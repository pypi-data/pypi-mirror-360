# blacklistQueries.yaml
blacklistQueries:
  create_blacklist_table: |
    CREATE TABLE
    IF NOT EXISTS blacklisted_tokens (
      token           TEXT PRIMARY KEY,
      blacklisted_on  TIMESTAMPTZ DEFAULT NOW()
    );
  select_blacklist_token: |
    SELECT 1
    FROM blacklisted_tokens
    WHERE token = %s;
  insert_blacklist_token: |
    INSERT
    INTO blacklisted_tokens (token)
    VALUES (%s)
    ON CONFLICT DO NOTHING;

# UploadsQueries.yaml
UploadsQueries:
  select_upload_items: |
    SELECT id, filename, filepath, uploader_id, shareable,
           download_count, download_limit, share_password, created_at
    FROM uploads
  insert_upload_items: |
    INSERT INTO uploads (
        filename, filepath, uploader_id, shareable, download_count, download_limit, share_password, created_at
    ) VALUES (%s, %s, %s, %s, %s, %s, %s, CURRENT_TIMESTAMP)
    RETURNING id
  select_upload_from_id: |
    SELECT * 
    FROM uploads 
    WHERE id = %s
  update_upload_share_link: |
    UPDATE uploads
    SET shareable      = %s,
        share_password = %s,
        download_limit = %s
    WHERE id = %s
  select_upload_from_filepath: |
    SELECT * 
    FROM uploads 
    WHERE filepath = %s

# userQueries.yaml
userQueries:
  select_user_by_username: |
    SELECT id,
           username,
           password_hash,
           is_admin
    FROM users
    WHERE username = %s
  insert_update_user: |
    INSERT INTO users (username, password_hash, is_admin)
    VALUES (%s, %s, %s)
    ON CONFLICT (username) DO UPDATE
      SET password_hash = EXCLUDED.password_hash,
          is_admin      = EXCLUDED.is_admin;
  select_existing_user: |
    SELECT
        username
    FROM users
    ORDER BY username ASC;

# tableQueries.yaml
tableQueries:
  create_users_table: |
    CREATE TABLE IF NOT EXISTS users (
      username      VARCHAR(255) PRIMARY KEY,
      password_hash TEXT           NOT NULL,
      is_admin      BOOLEAN        NOT NULL DEFAULT FALSE,
      created_at    TIMESTAMPTZ    DEFAULT NOW(),
      updated_at    TIMESTAMPTZ    DEFAULT NOW()
    );
  create_update_triggers: |
    CREATE OR REPLACE FUNCTION update_users_updated_at()
    RETURNS TRIGGER AS $$
    BEGIN
      NEW.updated_at := NOW();
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
  create_triggers: |
    DO $$
    BEGIN
      IF NOT EXISTS (
        SELECT 1 FROM pg_trigger WHERE tgname = 'users_updated_at_trigger'
      ) THEN
        CREATE TRIGGER users_updated_at_trigger
        BEFORE UPDATE ON users
        FOR EACH ROW
        EXECUTE PROCEDURE update_users_updated_at();
      END IF;
    END;
    $$;

# userIpQueries.yaml
userIpQueries:
  select_user_by_ip: |
    SELECT u.id,
           u.username,
           ui.first_seen,
           ui.last_seen,
           ui.hit_count
    FROM users u
    LEFT JOIN user_ips ui
        ON ui.user_id = u.id
    WHERE ui.ip_address = %s
  insert_user_ip: |
    INSERT INTO user_ips (user_id, ip_address)
    VALUES (%s, %s)
  update_user_ip: |
    UPDATE user_ips
    SET last_seen = %s,
        hit_count = hit_count + 1
    WHERE user_id = %s
    AND ip_address = %s
  select_user_ip: |
    SELECT 1
    FROM user_ips
    WHERE user_id = %s
    AND ip_address = %s
