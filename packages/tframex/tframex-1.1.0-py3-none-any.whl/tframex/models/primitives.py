from typing import Any, Dict, List, Literal, Optional

from pydantic import BaseModel, Field, field_validator


class FunctionCall(BaseModel):
    name: str
    arguments: str  # Should be a JSON string


class ToolCall(BaseModel):
    id: str  # Tool call ID, generated by the model
    type: Literal["function"] = "function"
    function: FunctionCall


class Message(BaseModel):
    role: Literal["system", "user", "assistant", "tool"]
    content: Optional[str] = None
    tool_calls: Optional[List[ToolCall]] = None
    tool_call_id: Optional[str] = None  # For role="tool", linking to a ToolCall id
    name: Optional[str] = (
        None  # For role="tool", the name of the function that was called
    )

    model_config = {
        "exclude_none": True,
        "extra": "ignore",  # Ignore extra fields during parsing if model adds them
    }


class MessageChunk(Message):
    """Represents a chunk of a message, typically used in streaming LLM responses."""

    pass  # Inherits fields, used for typing


class ToolParameterProperty(BaseModel):
    type: str  # e.g., "string", "number", "integer", "boolean", "array", "object"
    description: Optional[str] = None
    enum: Optional[List[Any]] = None
    # For array items or object properties, nested schema can be defined if needed


class ToolParameters(BaseModel):
    type: Literal["object"] = "object"
    properties: Dict[str, ToolParameterProperty] = Field(default_factory=dict)
    required: Optional[List[str]] = Field(default_factory=list)


class ToolDefinition(BaseModel):  # For OpenAI tool format
    type: Literal["function"] = "function"
    function: Dict[str, Any]  # name, description, parameters (ToolParameters schema)
