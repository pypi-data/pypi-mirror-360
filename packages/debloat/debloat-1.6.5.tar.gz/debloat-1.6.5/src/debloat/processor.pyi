import pefile
from _typeshed import Incomplete
from pefile import Structure as Structure
from typing import Callable, Optional, Tuple

PACKER: Incomplete

def readable_size(value: int) -> str: ...
def write_multiple_files(out_path: str, files: list, log_message: Callable[[str], None]) -> None: ...
def write_patched_file(out_path: str, pe: pefile.PE) -> Tuple[int, str]: ...
def handle_signature_abnormality(signature_address: int, signature_size: int, beginning_file_size: int) -> bool: ...
def check_and_extract_NSIS(possible_header: bytearray, data: bytearray) -> list: ...
def check_for_packer(possible_header: bytearray) -> int: ...
def find_last_section(pe: pefile.PE) -> Optional[pefile.SectionStructure]: ...
def get_signature_info(pe: pefile.PE) -> Tuple[int, int]: ...
def adjust_offsets(pe: pefile.PE, gap_offset: int, gap_size: int): ...
def refinery_strip(pe: pefile.PE, data: memoryview, block_size=...) -> int: ...
def refinery_trim_resources(pe: pefile.PE, pe_data: bytearray) -> int: ...
def remove_resources(pe: pefile.PE, pe_data: bytearray) -> Tuple[bytearray, int]: ...
def check_section_compression(pe: pefile.PE, pe_data: bytearray, end_of_real_data, log_message: Callable[[str], None]) -> Tuple[pefile.PE, int, str]: ...
def trim_junk(pe: pefile.PE, bloated_content: bytes, original_size_with_junk: int) -> int: ...
def process_pe(pe: pefile.PE, out_path: str, last_ditch_processing: bool, log_message: Callable[[str], None]) -> None: ...
