/*
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paul Govereau, Sean McLaughlin
*/

// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.

#include "stdc.h"
#include "region.h"
#include "cbor.h"
#include "serde_common.h"

bool Bool_List_ser(FILE *out, struct Bool_List *x) {
  u64 count = 0;
  for (struct Bool_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Bool_List *node = x; node; node = node->next)
    if (!cbor_encode_bool(out, node->b))
      return false;
  return true;
}

bool Nat_List_ser(FILE *out, struct Nat_List *x) {
  u64 count = 0;
  for (struct Nat_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Nat_List *node = x; node; node = node->next)
    if (!cbor_encode_uint(out, node->nat))
      return false;
  return true;
}

bool Int_List_ser(FILE *out, struct Int_List *x) {
  u64 count = 0;
  for (struct Int_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Int_List *node = x; node; node = node->next)
    if (!cbor_encode_int(out, node->i))
      return false;
  return true;
}

bool Float_List_ser(FILE *out, struct Float_List *x) {
  u64 count = 0;
  for (struct Float_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Float_List *node = x; node; node = node->next)
    if (!cbor_encode_float(out, node->f))
      return false;
  return true;
}

bool String_List_ser(FILE *out, struct String_List *x) {
  u64 count = 0;
  for (struct String_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct String_List *node = x; node; node = node->next)
    if (!String_ser(out, node->s))
      return false;
  return true;
}

bool Bool_Option_ser(FILE *out, bool x) {
  if (!x) {
    return cbor_encode_option(out, false);
  } else {
    return cbor_encode_option(out, true) && cbor_encode_bool(out, x);
  }
  return true;
}

bool Nat_Option_ser(FILE *out, u32 x) {
  if (!x) {
    return cbor_encode_option(out, false);
  } else {
    return cbor_encode_option(out, true) && cbor_encode_uint(out, x);
  }
  return true;
}

bool Int_Option_ser(FILE *out, i32 x) {
  if (!x) {
    return cbor_encode_option(out, false);
  } else {
    return cbor_encode_option(out, true) && cbor_encode_int(out, x);
  }
  return true;
}

bool Float_Option_ser(FILE *out, f32 x) {
  if (!x) {
    return cbor_encode_option(out, false);
  } else {
    return cbor_encode_option(out, true) && cbor_encode_float(out, x);
  }
  return true;
}

bool String_Option_ser(FILE *out, char *x) {
  if (!x) {
    return cbor_encode_option(out, false);
  } else {
    return cbor_encode_option(out, true) && String_ser(out, x);
  }
  return true;
}

bool Core_Pos_ser(FILE *out, struct Core_Pos *x) {
  if (!cbor_encode_tag(out, 100, 0, 4))
    return false;
  if (!cbor_encode_uint(out, x->line))
    return false;
  if (!cbor_encode_uint(out, x->column))
    return false;
  if (!Nat_Option_ser(out, x->lineEnd))
    return false;
  if (!Nat_Option_ser(out, x->columnEnd))
    return false;
  return true;
}

bool Bool_List_des(FILE *in, struct region *region, struct Bool_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Bool_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Bool_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Bool_des(in, region, &node->b))
      return false;
  }
  return true;
}

bool Nat_List_des(FILE *in, struct region *region, struct Nat_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Nat_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Nat_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Nat_des(in, region, &node->nat))
      return false;
  }
  return true;
}

bool Int_List_des(FILE *in, struct region *region, struct Int_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Int_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Int_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Int_des(in, region, &node->i))
      return false;
  }
  return true;
}

bool Float_List_des(FILE *in, struct region *region, struct Float_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Float_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Float_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Float_des(in, region, &node->f))
      return false;
  }
  return true;
}

bool String_List_des(FILE *in, struct region *region, struct String_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct String_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct String_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!String_des(in, region, &node->s))
      return false;
  }
  return true;
}

bool Bool_Option_des(FILE *in, struct region *region, bool *x) {
  bool isSome;
  if (!cbor_decode_option(in, &isSome))
    return false;
  if (!isSome)
    *x = 0;
  else
    return Bool_des(in, region, x);
  return true;
}

bool Nat_Option_des(FILE *in, struct region *region, u32 *x) {
  bool isSome;
  if (!cbor_decode_option(in, &isSome))
    return false;
  if (!isSome)
    *x = 0;
  else
    return Nat_des(in, region, x);
  return true;
}

bool Int_Option_des(FILE *in, struct region *region, i32 *x) {
  bool isSome;
  if (!cbor_decode_option(in, &isSome))
    return false;
  if (!isSome)
    *x = 0;
  else
    return Int_des(in, region, x);
  return true;
}

bool Float_Option_des(FILE *in, struct region *region, f32 *x) {
  bool isSome;
  if (!cbor_decode_option(in, &isSome))
    return false;
  if (!isSome)
    *x = 0;
  else
    return Float_des(in, region, x);
  return true;
}

bool String_Option_des(FILE *in, struct region *region, char **x) {
  bool isSome;
  if (!cbor_decode_option(in, &isSome))
    return false;
  if (!isSome)
    *x = 0;
  else
    return String_des(in, region, x);
  return true;
}

bool Core_Pos_des(FILE *in, struct region *region, struct Core_Pos **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 100 || c != 0 || l != 4)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Nat_des(in, region, &(*x)->line))
    return false;
  if (!Nat_des(in, region, &(*x)->column))
    return false;
  if (!Nat_Option_des(in, region, &(*x)->lineEnd))
    return false;
  if (!Nat_Option_des(in, region, &(*x)->columnEnd))
    return false;
  return true;
}
