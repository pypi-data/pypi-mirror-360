/*
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paul Govereau, Sean McLaughlin
*/

// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.

#include "stdc.h"
#include "region.h"
#include "cbor.h"
#include "serde_common.h"
#include "serde_python_core.h"

bool Python_Const_ser(FILE *out, struct Python_Const *x) {
  switch (x->tag) {
  case Python_Const_none:
    if (!cbor_encode_tag(out, 1, 0, 0))
      return false;
    break;
  case Python_Const_bool:
    if (!cbor_encode_tag(out, 1, 1, 1))
      return false;
    if (!cbor_encode_bool(out, x->b.value))
      return false;
    break;
  case Python_Const_int:
    if (!cbor_encode_tag(out, 1, 2, 1))
      return false;
    if (!cbor_encode_int(out, x->i.value))
      return false;
    break;
  case Python_Const_float:
    if (!cbor_encode_tag(out, 1, 3, 1))
      return false;
    if (!cbor_encode_float(out, x->f.value))
      return false;
    break;
  case Python_Const_string:
    if (!cbor_encode_tag(out, 1, 4, 1))
      return false;
    if (!String_ser(out, x->s.value))
      return false;
    break;
  case Python_Const_ellipsis:
    if (!cbor_encode_tag(out, 1, 5, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_Ctx_ser(FILE *out, enum Python_Ctx x) {
  switch (x) {
  case Python_Ctx_load:
    if (!cbor_encode_tag(out, 2, 0, 0))
      return false;
    break;
  case Python_Ctx_store:
    if (!cbor_encode_tag(out, 2, 1, 0))
      return false;
    break;
  case Python_Ctx_del:
    if (!cbor_encode_tag(out, 2, 2, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_BoolOp_ser(FILE *out, enum Python_BoolOp x) {
  switch (x) {
  case Python_BoolOp_land:
    if (!cbor_encode_tag(out, 3, 0, 0))
      return false;
    break;
  case Python_BoolOp_lor:
    if (!cbor_encode_tag(out, 3, 1, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_CmpOp_ser(FILE *out, enum Python_CmpOp x) {
  switch (x) {
  case Python_CmpOp_eq:
    if (!cbor_encode_tag(out, 4, 0, 0))
      return false;
    break;
  case Python_CmpOp_ne:
    if (!cbor_encode_tag(out, 4, 1, 0))
      return false;
    break;
  case Python_CmpOp_lt:
    if (!cbor_encode_tag(out, 4, 2, 0))
      return false;
    break;
  case Python_CmpOp_le:
    if (!cbor_encode_tag(out, 4, 3, 0))
      return false;
    break;
  case Python_CmpOp_gt:
    if (!cbor_encode_tag(out, 4, 4, 0))
      return false;
    break;
  case Python_CmpOp_ge:
    if (!cbor_encode_tag(out, 4, 5, 0))
      return false;
    break;
  case Python_CmpOp_is:
    if (!cbor_encode_tag(out, 4, 6, 0))
      return false;
    break;
  case Python_CmpOp_isNot:
    if (!cbor_encode_tag(out, 4, 7, 0))
      return false;
    break;
  case Python_CmpOp_isIn:
    if (!cbor_encode_tag(out, 4, 8, 0))
      return false;
    break;
  case Python_CmpOp_notIn:
    if (!cbor_encode_tag(out, 4, 9, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_UnaryOp_ser(FILE *out, enum Python_UnaryOp x) {
  switch (x) {
  case Python_UnaryOp_invert:
    if (!cbor_encode_tag(out, 5, 0, 0))
      return false;
    break;
  case Python_UnaryOp_not:
    if (!cbor_encode_tag(out, 5, 1, 0))
      return false;
    break;
  case Python_UnaryOp_uadd:
    if (!cbor_encode_tag(out, 5, 2, 0))
      return false;
    break;
  case Python_UnaryOp_usub:
    if (!cbor_encode_tag(out, 5, 3, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_BinOp_ser(FILE *out, enum Python_BinOp x) {
  switch (x) {
  case Python_BinOp_add:
    if (!cbor_encode_tag(out, 6, 0, 0))
      return false;
    break;
  case Python_BinOp_sub:
    if (!cbor_encode_tag(out, 6, 1, 0))
      return false;
    break;
  case Python_BinOp_mul:
    if (!cbor_encode_tag(out, 6, 2, 0))
      return false;
    break;
  case Python_BinOp_matmul:
    if (!cbor_encode_tag(out, 6, 3, 0))
      return false;
    break;
  case Python_BinOp_div:
    if (!cbor_encode_tag(out, 6, 4, 0))
      return false;
    break;
  case Python_BinOp_mod:
    if (!cbor_encode_tag(out, 6, 5, 0))
      return false;
    break;
  case Python_BinOp_pow:
    if (!cbor_encode_tag(out, 6, 6, 0))
      return false;
    break;
  case Python_BinOp_lshift:
    if (!cbor_encode_tag(out, 6, 7, 0))
      return false;
    break;
  case Python_BinOp_rshift:
    if (!cbor_encode_tag(out, 6, 8, 0))
      return false;
    break;
  case Python_BinOp_or:
    if (!cbor_encode_tag(out, 6, 9, 0))
      return false;
    break;
  case Python_BinOp_xor:
    if (!cbor_encode_tag(out, 6, 10, 0))
      return false;
    break;
  case Python_BinOp_and:
    if (!cbor_encode_tag(out, 6, 11, 0))
      return false;
    break;
  case Python_BinOp_floor:
    if (!cbor_encode_tag(out, 6, 12, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_Expr__ser(FILE *out, struct Python_Expr_ *x) {
  switch (x->tag) {
  case Python_Expr_const:
    if (!cbor_encode_tag(out, 8, 0, 1))
      return false;
    if (!Python_Const_ser(out, x->c.value))
      return false;
    break;
  case Python_Expr_tensor:
    if (!cbor_encode_tag(out, 8, 1, 2))
      return false;
    if (!Python_Expr_List_ser(out, x->tensor.shape))
      return false;
    if (!String_ser(out, x->tensor.dtype))
      return false;
    break;
  case Python_Expr_name:
    if (!cbor_encode_tag(out, 8, 2, 2))
      return false;
    if (!String_ser(out, x->name.id))
      return false;
    if (!Python_Ctx_ser(out, x->name.ctx))
      return false;
    break;
  case Python_Expr_attr:
    if (!cbor_encode_tag(out, 8, 3, 3))
      return false;
    if (!Python_Expr_ser(out, x->attr.value))
      return false;
    if (!String_ser(out, x->attr.id))
      return false;
    if (!Python_Ctx_ser(out, x->attr.ctx))
      return false;
    break;
  case Python_Expr_tuple:
    if (!cbor_encode_tag(out, 8, 4, 2))
      return false;
    if (!Python_Expr_List_ser(out, x->tuple.xs))
      return false;
    if (!Python_Ctx_ser(out, x->tuple.ctx))
      return false;
    break;
  case Python_Expr_list:
    if (!cbor_encode_tag(out, 8, 5, 2))
      return false;
    if (!Python_Expr_List_ser(out, x->list.xs))
      return false;
    if (!Python_Ctx_ser(out, x->list.ctx))
      return false;
    break;
  case Python_Expr_subscript:
    if (!cbor_encode_tag(out, 8, 6, 3))
      return false;
    if (!Python_Expr_ser(out, x->subscript.tensor))
      return false;
    if (!Python_Expr_ser(out, x->subscript.index))
      return false;
    if (!Python_Ctx_ser(out, x->subscript.ctx))
      return false;
    break;
  case Python_Expr_slice:
    if (!cbor_encode_tag(out, 8, 7, 3))
      return false;
    if (!Python_Expr_Option_ser(out, x->slice.l))
      return false;
    if (!Python_Expr_Option_ser(out, x->slice.u))
      return false;
    if (!Python_Expr_Option_ser(out, x->slice.step))
      return false;
    break;
  case Python_Expr_boolOp:
    if (!cbor_encode_tag(out, 8, 8, 2))
      return false;
    if (!Python_BoolOp_ser(out, x->boolOp.op))
      return false;
    if (!Python_Expr_List_ser(out, x->boolOp.values))
      return false;
    break;
  case Python_Expr_binOp:
    if (!cbor_encode_tag(out, 8, 9, 3))
      return false;
    if (!Python_BinOp_ser(out, x->binOp.op))
      return false;
    if (!Python_Expr_ser(out, x->binOp.left))
      return false;
    if (!Python_Expr_ser(out, x->binOp.right))
      return false;
    break;
  case Python_Expr_unaryOp:
    if (!cbor_encode_tag(out, 8, 10, 2))
      return false;
    if (!Python_UnaryOp_ser(out, x->unaryOp.op))
      return false;
    if (!Python_Expr_ser(out, x->unaryOp.operand))
      return false;
    break;
  case Python_Expr_compare:
    if (!cbor_encode_tag(out, 8, 11, 3))
      return false;
    if (!Python_Expr_ser(out, x->compare.left))
      return false;
    if (!Python_CmpOp_List_ser(out, x->compare.ops))
      return false;
    if (!Python_Expr_List_ser(out, x->compare.comparators))
      return false;
    break;
  case Python_Expr_ifExp:
    if (!cbor_encode_tag(out, 8, 12, 3))
      return false;
    if (!Python_Expr_ser(out, x->ifExp.test))
      return false;
    if (!Python_Expr_ser(out, x->ifExp.body))
      return false;
    if (!Python_Expr_ser(out, x->ifExp.orelse))
      return false;
    break;
  case Python_Expr_call:
    if (!cbor_encode_tag(out, 8, 13, 3))
      return false;
    if (!Python_Expr_ser(out, x->call.f))
      return false;
    if (!Python_Expr_List_ser(out, x->call.args))
      return false;
    if (!Python_Keyword_List_ser(out, x->call.keywords))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_Expr_ser(FILE *out, struct Python_Expr *x) {
  if (!cbor_encode_tag(out, 7, 0, 2))
    return false;
  if (!Python_Expr__ser(out, x->expr))
    return false;
  if (!Core_Pos_ser(out, x->pos))
    return false;
  return true;
}

bool Python_Keyword_ser(FILE *out, struct Python_Keyword *x) {
  if (!cbor_encode_tag(out, 9, 0, 3))
    return false;
  if (!String_ser(out, x->id))
    return false;
  if (!Python_Expr_ser(out, x->value))
    return false;
  if (!Core_Pos_ser(out, x->pos))
    return false;
  return true;
}

bool Python_Stmt__ser(FILE *out, struct Python_Stmt_ *x) {
  switch (x->tag) {
  case Python_Stmt_pass:
    if (!cbor_encode_tag(out, 11, 0, 0))
      return false;
    break;
  case Python_Stmt_expr:
    if (!cbor_encode_tag(out, 11, 1, 1))
      return false;
    if (!Python_Expr_ser(out, x->expr.e))
      return false;
    break;
  case Python_Stmt_assert:
    if (!cbor_encode_tag(out, 11, 2, 1))
      return false;
    if (!Python_Expr_ser(out, x->assert.e))
      return false;
    break;
  case Python_Stmt_ret:
    if (!cbor_encode_tag(out, 11, 3, 1))
      return false;
    if (!Python_Expr_ser(out, x->ret.e))
      return false;
    break;
  case Python_Stmt_assign:
    if (!cbor_encode_tag(out, 11, 4, 2))
      return false;
    if (!Python_Expr_List_ser(out, x->assign.xs))
      return false;
    if (!Python_Expr_ser(out, x->assign.e))
      return false;
    break;
  case Python_Stmt_augAssign:
    if (!cbor_encode_tag(out, 11, 5, 3))
      return false;
    if (!Python_Expr_ser(out, x->augAssign.x))
      return false;
    if (!Python_BinOp_ser(out, x->augAssign.op))
      return false;
    if (!Python_Expr_ser(out, x->augAssign.e))
      return false;
    break;
  case Python_Stmt_annAssign:
    if (!cbor_encode_tag(out, 11, 6, 3))
      return false;
    if (!Python_Expr_ser(out, x->annAssign.x))
      return false;
    if (!Python_Expr_ser(out, x->annAssign.annotation))
      return false;
    if (!Python_Expr_Option_ser(out, x->annAssign.value))
      return false;
    break;
  case Python_Stmt_ifStm:
    if (!cbor_encode_tag(out, 11, 7, 3))
      return false;
    if (!Python_Expr_ser(out, x->ifStm.e))
      return false;
    if (!Python_Stmt_List_ser(out, x->ifStm.thn))
      return false;
    if (!Python_Stmt_List_ser(out, x->ifStm.els))
      return false;
    break;
  case Python_Stmt_forLoop:
    if (!cbor_encode_tag(out, 11, 8, 4))
      return false;
    if (!Python_Expr_ser(out, x->forLoop.x))
      return false;
    if (!Python_Expr_ser(out, x->forLoop.iter))
      return false;
    if (!Python_Stmt_List_ser(out, x->forLoop.body))
      return false;
    if (!Python_Stmt_List_ser(out, x->forLoop.orelse))
      return false;
    break;
  case Python_Stmt_breakLoop:
    if (!cbor_encode_tag(out, 11, 9, 0))
      return false;
    break;
  case Python_Stmt_continueLoop:
    if (!cbor_encode_tag(out, 11, 10, 0))
      return false;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_Stmt_ser(FILE *out, struct Python_Stmt *x) {
  if (!cbor_encode_tag(out, 10, 0, 2))
    return false;
  if (!Python_Stmt__ser(out, x->stmt))
    return false;
  if (!Core_Pos_ser(out, x->pos))
    return false;
  return true;
}

bool Python_Args_ser(FILE *out, struct Python_Args *x) {
  if (!cbor_encode_tag(out, 12, 0, 7))
    return false;
  if (!String_List_ser(out, x->posonlyargs))
    return false;
  if (!String_List_ser(out, x->args))
    return false;
  if (!Python_Expr_List_ser(out, x->defaults))
    return false;
  if (!String_Option_ser(out, x->vararg))
    return false;
  if (!String_List_ser(out, x->kwonlyargs))
    return false;
  if (!Python_Keyword_List_ser(out, x->kw_defaults))
    return false;
  if (!String_Option_ser(out, x->kwarg))
    return false;
  return true;
}

bool Python_Fun_ser(FILE *out, struct Python_Fun *x) {
  if (!cbor_encode_tag(out, 13, 0, 5))
    return false;
  if (!String_ser(out, x->name))
    return false;
  if (!cbor_encode_uint(out, x->line))
    return false;
  if (!String_ser(out, x->source))
    return false;
  if (!Python_Args_ser(out, x->args))
    return false;
  if (!Python_Stmt_List_ser(out, x->body))
    return false;
  return true;
}

bool Python_Kernel_ser(FILE *out, struct Python_Kernel *x) {
  if (!cbor_encode_tag(out, 14, 0, 6))
    return false;
  if (!String_ser(out, x->entry))
    return false;
  if (!Python_Fun_List_ser(out, x->funcs))
    return false;
  if (!Python_Expr_List_ser(out, x->args))
    return false;
  if (!Python_Keyword_List_ser(out, x->kwargs))
    return false;
  if (!Python_Keyword_List_ser(out, x->globals))
    return false;
  if (!String_List_ser(out, x->undefinedSymbols))
    return false;
  return true;
}

bool Python_Expr_List_ser(FILE *out, struct Python_Expr_List *x) {
  u64 count = 0;
  for (struct Python_Expr_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Python_Expr_List *node = x; node; node = node->next)
    if (!Python_Expr_ser(out, node->expr))
      return false;
  return true;
}

bool Python_Expr_Option_ser(FILE *out, struct Python_Expr *x) {
  if (!x) {
    return cbor_encode_option(out, false);
  } else {
    return cbor_encode_option(out, true) && Python_Expr_ser(out, x);
  }
  return true;
}

bool Python_CmpOp_List_ser(FILE *out, struct Python_CmpOp_List *x) {
  u64 count = 0;
  for (struct Python_CmpOp_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Python_CmpOp_List *node = x; node; node = node->next)
    if (!Python_CmpOp_ser(out, node->cmpop))
      return false;
  return true;
}

bool Python_Keyword_List_ser(FILE *out, struct Python_Keyword_List *x) {
  u64 count = 0;
  for (struct Python_Keyword_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Python_Keyword_List *node = x; node; node = node->next)
    if (!Python_Keyword_ser(out, node->keyword))
      return false;
  return true;
}

bool Python_Stmt_List_ser(FILE *out, struct Python_Stmt_List *x) {
  u64 count = 0;
  for (struct Python_Stmt_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Python_Stmt_List *node = x; node; node = node->next)
    if (!Python_Stmt_ser(out, node->stmt))
      return false;
  return true;
}

bool Python_Fun_List_ser(FILE *out, struct Python_Fun_List *x) {
  u64 count = 0;
  for (struct Python_Fun_List *node = x; node; node = node->next)
    count++;
  if (!cbor_encode_array_start(out, count))
    return false;
  for (struct Python_Fun_List *node = x; node; node = node->next)
    if (!Python_Fun_ser(out, node->fun))
      return false;
  return true;
}

bool Python_Const_des(FILE *in, struct region *region,
                      struct Python_Const **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 1)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    (*x)->tag = Python_Const_none;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Bool_des(in, region, &(*x)->b.value))
      return false;
    (*x)->tag = Python_Const_bool;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Int_des(in, region, &(*x)->i.value))
      return false;
    (*x)->tag = Python_Const_int;
    break;
  case 3:
    if (l != 1)
      return false;
    if (!Float_des(in, region, &(*x)->f.value))
      return false;
    (*x)->tag = Python_Const_float;
    break;
  case 4:
    if (l != 1)
      return false;
    if (!String_des(in, region, &(*x)->s.value))
      return false;
    (*x)->tag = Python_Const_string;
    break;
  case 5:
    if (l != 0)
      return false;
    (*x)->tag = Python_Const_ellipsis;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_Ctx_des(FILE *in, struct region *region, enum Python_Ctx *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 2)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Python_Ctx_load;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Python_Ctx_store;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Python_Ctx_del;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_BoolOp_des(FILE *in, struct region *region, enum Python_BoolOp *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 3)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Python_BoolOp_land;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Python_BoolOp_lor;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_CmpOp_des(FILE *in, struct region *region, enum Python_CmpOp *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 4)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Python_CmpOp_eq;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Python_CmpOp_ne;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Python_CmpOp_lt;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Python_CmpOp_le;
    break;
  case 4:
    if (l != 0)
      return false;
    *x = Python_CmpOp_gt;
    break;
  case 5:
    if (l != 0)
      return false;
    *x = Python_CmpOp_ge;
    break;
  case 6:
    if (l != 0)
      return false;
    *x = Python_CmpOp_is;
    break;
  case 7:
    if (l != 0)
      return false;
    *x = Python_CmpOp_isNot;
    break;
  case 8:
    if (l != 0)
      return false;
    *x = Python_CmpOp_isIn;
    break;
  case 9:
    if (l != 0)
      return false;
    *x = Python_CmpOp_notIn;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_UnaryOp_des(FILE *in, struct region *region,
                        enum Python_UnaryOp *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 5)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Python_UnaryOp_invert;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Python_UnaryOp_not;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Python_UnaryOp_uadd;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Python_UnaryOp_usub;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_BinOp_des(FILE *in, struct region *region, enum Python_BinOp *x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 6)
    return false;
  (void)region;
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    *x = Python_BinOp_add;
    break;
  case 1:
    if (l != 0)
      return false;
    *x = Python_BinOp_sub;
    break;
  case 2:
    if (l != 0)
      return false;
    *x = Python_BinOp_mul;
    break;
  case 3:
    if (l != 0)
      return false;
    *x = Python_BinOp_matmul;
    break;
  case 4:
    if (l != 0)
      return false;
    *x = Python_BinOp_div;
    break;
  case 5:
    if (l != 0)
      return false;
    *x = Python_BinOp_mod;
    break;
  case 6:
    if (l != 0)
      return false;
    *x = Python_BinOp_pow;
    break;
  case 7:
    if (l != 0)
      return false;
    *x = Python_BinOp_lshift;
    break;
  case 8:
    if (l != 0)
      return false;
    *x = Python_BinOp_rshift;
    break;
  case 9:
    if (l != 0)
      return false;
    *x = Python_BinOp_or;
    break;
  case 10:
    if (l != 0)
      return false;
    *x = Python_BinOp_xor;
    break;
  case 11:
    if (l != 0)
      return false;
    *x = Python_BinOp_and;
    break;
  case 12:
    if (l != 0)
      return false;
    *x = Python_BinOp_floor;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_Expr__des(FILE *in, struct region *region,
                      struct Python_Expr_ **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 8)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 1)
      return false;
    if (!Python_Const_des(in, region, &(*x)->c.value))
      return false;
    (*x)->tag = Python_Expr_const;
    break;
  case 1:
    if (l != 2)
      return false;
    if (!Python_Expr_List_des(in, region, &(*x)->tensor.shape))
      return false;
    if (!String_des(in, region, &(*x)->tensor.dtype))
      return false;
    (*x)->tag = Python_Expr_tensor;
    break;
  case 2:
    if (l != 2)
      return false;
    if (!String_des(in, region, &(*x)->name.id))
      return false;
    if (!Python_Ctx_des(in, region, &(*x)->name.ctx))
      return false;
    (*x)->tag = Python_Expr_name;
    break;
  case 3:
    if (l != 3)
      return false;
    if (!Python_Expr_des(in, region, &(*x)->attr.value))
      return false;
    if (!String_des(in, region, &(*x)->attr.id))
      return false;
    if (!Python_Ctx_des(in, region, &(*x)->attr.ctx))
      return false;
    (*x)->tag = Python_Expr_attr;
    break;
  case 4:
    if (l != 2)
      return false;
    if (!Python_Expr_List_des(in, region, &(*x)->tuple.xs))
      return false;
    if (!Python_Ctx_des(in, region, &(*x)->tuple.ctx))
      return false;
    (*x)->tag = Python_Expr_tuple;
    break;
  case 5:
    if (l != 2)
      return false;
    if (!Python_Expr_List_des(in, region, &(*x)->list.xs))
      return false;
    if (!Python_Ctx_des(in, region, &(*x)->list.ctx))
      return false;
    (*x)->tag = Python_Expr_list;
    break;
  case 6:
    if (l != 3)
      return false;
    if (!Python_Expr_des(in, region, &(*x)->subscript.tensor))
      return false;
    if (!Python_Expr_des(in, region, &(*x)->subscript.index))
      return false;
    if (!Python_Ctx_des(in, region, &(*x)->subscript.ctx))
      return false;
    (*x)->tag = Python_Expr_subscript;
    break;
  case 7:
    if (l != 3)
      return false;
    if (!Python_Expr_Option_des(in, region, &(*x)->slice.l))
      return false;
    if (!Python_Expr_Option_des(in, region, &(*x)->slice.u))
      return false;
    if (!Python_Expr_Option_des(in, region, &(*x)->slice.step))
      return false;
    (*x)->tag = Python_Expr_slice;
    break;
  case 8:
    if (l != 2)
      return false;
    if (!Python_BoolOp_des(in, region, &(*x)->boolOp.op))
      return false;
    if (!Python_Expr_List_des(in, region, &(*x)->boolOp.values))
      return false;
    (*x)->tag = Python_Expr_boolOp;
    break;
  case 9:
    if (l != 3)
      return false;
    if (!Python_BinOp_des(in, region, &(*x)->binOp.op))
      return false;
    if (!Python_Expr_des(in, region, &(*x)->binOp.left))
      return false;
    if (!Python_Expr_des(in, region, &(*x)->binOp.right))
      return false;
    (*x)->tag = Python_Expr_binOp;
    break;
  case 10:
    if (l != 2)
      return false;
    if (!Python_UnaryOp_des(in, region, &(*x)->unaryOp.op))
      return false;
    if (!Python_Expr_des(in, region, &(*x)->unaryOp.operand))
      return false;
    (*x)->tag = Python_Expr_unaryOp;
    break;
  case 11:
    if (l != 3)
      return false;
    if (!Python_Expr_des(in, region, &(*x)->compare.left))
      return false;
    if (!Python_CmpOp_List_des(in, region, &(*x)->compare.ops))
      return false;
    if (!Python_Expr_List_des(in, region, &(*x)->compare.comparators))
      return false;
    (*x)->tag = Python_Expr_compare;
    break;
  case 12:
    if (l != 3)
      return false;
    if (!Python_Expr_des(in, region, &(*x)->ifExp.test))
      return false;
    if (!Python_Expr_des(in, region, &(*x)->ifExp.body))
      return false;
    if (!Python_Expr_des(in, region, &(*x)->ifExp.orelse))
      return false;
    (*x)->tag = Python_Expr_ifExp;
    break;
  case 13:
    if (l != 3)
      return false;
    if (!Python_Expr_des(in, region, &(*x)->call.f))
      return false;
    if (!Python_Expr_List_des(in, region, &(*x)->call.args))
      return false;
    if (!Python_Keyword_List_des(in, region, &(*x)->call.keywords))
      return false;
    (*x)->tag = Python_Expr_call;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_Expr_des(FILE *in, struct region *region, struct Python_Expr **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 7 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Python_Expr__des(in, region, &(*x)->expr))
    return false;
  if (!Core_Pos_des(in, region, &(*x)->pos))
    return false;
  return true;
}

bool Python_Keyword_des(FILE *in, struct region *region,
                        struct Python_Keyword **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 9 || c != 0 || l != 3)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!String_des(in, region, &(*x)->id))
    return false;
  if (!Python_Expr_des(in, region, &(*x)->value))
    return false;
  if (!Core_Pos_des(in, region, &(*x)->pos))
    return false;
  return true;
}

bool Python_Stmt__des(FILE *in, struct region *region,
                      struct Python_Stmt_ **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 11)
    return false;
  *x = region_alloc(region, sizeof(**x));
  switch (c) {
  case 0:
    if (l != 0)
      return false;
    (*x)->tag = Python_Stmt_pass;
    break;
  case 1:
    if (l != 1)
      return false;
    if (!Python_Expr_des(in, region, &(*x)->expr.e))
      return false;
    (*x)->tag = Python_Stmt_expr;
    break;
  case 2:
    if (l != 1)
      return false;
    if (!Python_Expr_des(in, region, &(*x)->assert.e))
      return false;
    (*x)->tag = Python_Stmt_assert;
    break;
  case 3:
    if (l != 1)
      return false;
    if (!Python_Expr_des(in, region, &(*x)->ret.e))
      return false;
    (*x)->tag = Python_Stmt_ret;
    break;
  case 4:
    if (l != 2)
      return false;
    if (!Python_Expr_List_des(in, region, &(*x)->assign.xs))
      return false;
    if (!Python_Expr_des(in, region, &(*x)->assign.e))
      return false;
    (*x)->tag = Python_Stmt_assign;
    break;
  case 5:
    if (l != 3)
      return false;
    if (!Python_Expr_des(in, region, &(*x)->augAssign.x))
      return false;
    if (!Python_BinOp_des(in, region, &(*x)->augAssign.op))
      return false;
    if (!Python_Expr_des(in, region, &(*x)->augAssign.e))
      return false;
    (*x)->tag = Python_Stmt_augAssign;
    break;
  case 6:
    if (l != 3)
      return false;
    if (!Python_Expr_des(in, region, &(*x)->annAssign.x))
      return false;
    if (!Python_Expr_des(in, region, &(*x)->annAssign.annotation))
      return false;
    if (!Python_Expr_Option_des(in, region, &(*x)->annAssign.value))
      return false;
    (*x)->tag = Python_Stmt_annAssign;
    break;
  case 7:
    if (l != 3)
      return false;
    if (!Python_Expr_des(in, region, &(*x)->ifStm.e))
      return false;
    if (!Python_Stmt_List_des(in, region, &(*x)->ifStm.thn))
      return false;
    if (!Python_Stmt_List_des(in, region, &(*x)->ifStm.els))
      return false;
    (*x)->tag = Python_Stmt_ifStm;
    break;
  case 8:
    if (l != 4)
      return false;
    if (!Python_Expr_des(in, region, &(*x)->forLoop.x))
      return false;
    if (!Python_Expr_des(in, region, &(*x)->forLoop.iter))
      return false;
    if (!Python_Stmt_List_des(in, region, &(*x)->forLoop.body))
      return false;
    if (!Python_Stmt_List_des(in, region, &(*x)->forLoop.orelse))
      return false;
    (*x)->tag = Python_Stmt_forLoop;
    break;
  case 9:
    if (l != 0)
      return false;
    (*x)->tag = Python_Stmt_breakLoop;
    break;
  case 10:
    if (l != 0)
      return false;
    (*x)->tag = Python_Stmt_continueLoop;
    break;
  default:
    return false;
  }
  return true;
}

bool Python_Stmt_des(FILE *in, struct region *region, struct Python_Stmt **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 10 || c != 0 || l != 2)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!Python_Stmt__des(in, region, &(*x)->stmt))
    return false;
  if (!Core_Pos_des(in, region, &(*x)->pos))
    return false;
  return true;
}

bool Python_Args_des(FILE *in, struct region *region, struct Python_Args **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 12 || c != 0 || l != 7)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!String_List_des(in, region, &(*x)->posonlyargs))
    return false;
  if (!String_List_des(in, region, &(*x)->args))
    return false;
  if (!Python_Expr_List_des(in, region, &(*x)->defaults))
    return false;
  if (!String_Option_des(in, region, &(*x)->vararg))
    return false;
  if (!String_List_des(in, region, &(*x)->kwonlyargs))
    return false;
  if (!Python_Keyword_List_des(in, region, &(*x)->kw_defaults))
    return false;
  if (!String_Option_des(in, region, &(*x)->kwarg))
    return false;
  return true;
}

bool Python_Fun_des(FILE *in, struct region *region, struct Python_Fun **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 13 || c != 0 || l != 5)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!String_des(in, region, &(*x)->name))
    return false;
  if (!Nat_des(in, region, &(*x)->line))
    return false;
  if (!String_des(in, region, &(*x)->source))
    return false;
  if (!Python_Args_des(in, region, &(*x)->args))
    return false;
  if (!Python_Stmt_List_des(in, region, &(*x)->body))
    return false;
  return true;
}

bool Python_Kernel_des(FILE *in, struct region *region,
                       struct Python_Kernel **x) {
  u8 t, c, l;
  if (!cbor_decode_tag(in, &t, &c, &l))
    return false;
  if (t != 14 || c != 0 || l != 6)
    return false;
  *x = region_alloc(region, sizeof(**x));
  if (!String_des(in, region, &(*x)->entry))
    return false;
  if (!Python_Fun_List_des(in, region, &(*x)->funcs))
    return false;
  if (!Python_Expr_List_des(in, region, &(*x)->args))
    return false;
  if (!Python_Keyword_List_des(in, region, &(*x)->kwargs))
    return false;
  if (!Python_Keyword_List_des(in, region, &(*x)->globals))
    return false;
  if (!String_List_des(in, region, &(*x)->undefinedSymbols))
    return false;
  return true;
}

bool Python_Expr_List_des(FILE *in, struct region *region,
                          struct Python_Expr_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Python_Expr_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Python_Expr_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Python_Expr_des(in, region, &node->expr))
      return false;
  }
  return true;
}

bool Python_Expr_Option_des(FILE *in, struct region *region,
                            struct Python_Expr **x) {
  bool isSome;
  if (!cbor_decode_option(in, &isSome))
    return false;
  if (!isSome)
    *x = 0;
  else
    return Python_Expr_des(in, region, x);
  return true;
}

bool Python_CmpOp_List_des(FILE *in, struct region *region,
                           struct Python_CmpOp_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Python_CmpOp_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Python_CmpOp_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Python_CmpOp_des(in, region, &node->cmpop))
      return false;
  }
  return true;
}

bool Python_Keyword_List_des(FILE *in, struct region *region,
                             struct Python_Keyword_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Python_Keyword_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Python_Keyword_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Python_Keyword_des(in, region, &node->keyword))
      return false;
  }
  return true;
}

bool Python_Stmt_List_des(FILE *in, struct region *region,
                          struct Python_Stmt_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Python_Stmt_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Python_Stmt_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Python_Stmt_des(in, region, &node->stmt))
      return false;
  }
  return true;
}

bool Python_Fun_List_des(FILE *in, struct region *region,
                         struct Python_Fun_List **x) {
  u64 count = 0;
  if (!cbor_decode_array_start(in, &count))
    return false;
  struct Python_Fun_List *current = *x = NULL;
  for (; count > 0; count--) {
    struct Python_Fun_List *node = region_alloc(region, sizeof(*node));
    node->next = NULL;
    if (!current) {
      *x = current = node;
    } else {
      current->next = node;
      current = node;
    }
    if (!Python_Fun_des(in, region, &node->fun))
      return false;
  }
  return true;
}
