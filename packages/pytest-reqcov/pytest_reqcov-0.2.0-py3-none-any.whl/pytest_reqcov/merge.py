#!/usr/bin/env python3
"""
Merge multiple output.csv files generated by pytest-reqcov plugin.

This script merges multiple CSV files and applies the AND operator for status:
- If all tests for a requirement/product are PASSED, the merged status is PASSED
- If any test for a requirement/product is FAILED, the merged status is FAILED
"""

import argparse
import csv
import sys
from collections import defaultdict
from pathlib import Path
from typing import Dict, List, Any


def load_csv_file(file_path: Path) -> List[Dict[str, str]]:
    """Load a CSV file and return its contents as a list of dictionaries."""
    rows = []
    try:
        with open(file_path, 'r', newline='', encoding='utf-8') as f:
            reader = csv.DictReader(f, delimiter=';')
            for row in reader:
                rows.append(row)
    except FileNotFoundError:
        print(f"Warning: File {file_path} not found, skipping.", file=sys.stderr)
    except Exception as e:
        print(f"Error reading {file_path}: {e}", file=sys.stderr)

    return rows


def merge_coverage_data(csv_files: List[Path]) -> Dict[str, Dict[str, Any]]:
    """
    Merge coverage data from multiple CSV files.

    Returns a dictionary where keys are "item|type" strings and values are
    dictionaries with merged data.
    """
    merged_data = defaultdict(lambda: {
        'item': '',
        'type': '',
        'status': 'NOT_TESTED',
        'tests': set()
    })

    for csv_file in csv_files:
        rows = load_csv_file(csv_file)

        for row in rows:
            item = row.get('item', '')
            item_type = row.get('type', '')
            status = row.get('status', 'NOT_TESTED')
            tests = row.get('tests', '')

            if not item or not item_type:
                continue

            key = f"{item}|{item_type}"

            # Initialize if first occurrence
            if not merged_data[key]['item']:
                merged_data[key]['item'] = item
                merged_data[key]['type'] = item_type

            # Add tests to the set
            if tests:
                merged_data[key]['tests'].add(tests)

            # Apply AND operator for status: if any test failed, overall status is FAILED
            if status == 'FAILED':
                merged_data[key]['status'] = 'FAILED'

            if status == 'PASSED' and merged_data[key]['status'] != 'FAILED':
                merged_data[key]['status'] = 'PASSED'

    return dict(merged_data)


def write_merged_csv(merged_data: Dict[str, Dict[str, Any]], output_file: Path):
    """Write the merged data to a CSV file."""
    with open(output_file, 'w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=['item', 'type', 'status', 'tests'], delimiter=';')
        writer.writeheader()

        # Sort by item name for consistent output
        sorted_items = sorted(merged_data.values(), key=lambda x: (x['type'], x['item']))

        for item_data in sorted_items:
            # Convert test set to comma-separated string
            tests_str = ','.join(sorted(item_data['tests']))
            writer.writerow({
                'item': item_data['item'],
                'type': item_data['type'],
                'status': item_data['status'],
                'tests': tests_str
            })


def main():
    """Main entry point for the merge script."""
    parser = argparse.ArgumentParser(
        description='Merge multiple pytest-reqcov output CSV files'
    )
    parser.add_argument(
        'input_files',
        nargs='+',
        type=Path,
        help='Input CSV files to merge'
    )
    parser.add_argument(
        '-o', '--output',
        type=Path,
        default=Path('merged_output.csv'),
        help='Output CSV file (default: merged_output.csv)'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Verbose output'
    )

    args = parser.parse_args()

    if args.verbose:
        print(f"Merging {len(args.input_files)} files:")
        for file_path in args.input_files:
            print(f"  - {file_path}")
        print(f"Output: {args.output}")

    # Merge the data
    merged_data = merge_coverage_data(args.input_files)

    if not merged_data:
        print("No data to merge. Exiting.", file=sys.stderr)
        sys.exit(1)

    # Write the merged output
    write_merged_csv(merged_data, args.output)

    if args.verbose:
        print(f"Merged data written to {args.output}")
        print(f"Total items: {len(merged_data)}")


if __name__ == '__main__':
    main()
