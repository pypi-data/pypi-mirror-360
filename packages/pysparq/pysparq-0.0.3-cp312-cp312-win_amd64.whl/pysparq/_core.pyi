"""
[Module sparq]
"""
from __future__ import annotations
import numpy
import pybind11_stubgen.typing_ext
import typing
__all__ = ['AddAssign_AnyInt_AnyInt', 'AddRegister', 'AddRegisterWithHadamard', 'Add_ConstUInt', 'Add_Mult_UInt_ConstUInt', 'Add_UInt_ConstUInt', 'Add_UInt_UInt', 'Add_UInt_UInt_InPlace', 'Assign', 'BaseOperator', 'Binary', 'Boolean', 'CheckDuplicateKey', 'CheckNan', 'CheckNormalization', 'ClearZero', 'CombineRegister', 'Compare_UInt_UInt', 'CondRot_General_Bool', 'CondRot_Rational_Bool', 'CustomArithmetic', 'Default', 'DenseMatrix_complex128', 'DenseMatrix_float64', 'DenseVector_complex128', 'DenseVector_float64', 'Detail', 'Div_Sqrt_Arccos_Int_Int', 'FlipBools', 'General', 'GetMid_UInt_UInt', 'GetRotateAngle_Int_Int', 'GlobalPhase_Int', 'Hadamard_Bool', 'Hadamard_Int', 'Hadamard_Int_Full', 'Hadamard_PartialQubit', 'Init_Unsafe', 'Less_UInt_UInt', 'ModuleInheritance_Test', 'ModuleInheritance_Test_SelfAdjoint', 'MoveBackRegister', 'Mult_UInt_ConstUInt', 'Normalize', 'PartialTrace', 'PartialTraceSelect', 'PartialTraceSelectRange', 'Phase_Bool', 'Pop', 'Prob', 'Push', 'QFT', 'QRAMCircuit_qutrit', 'QRAMLoad', 'QRAMLoadFast', 'RXgate_Bool', 'RYgate_Bool', 'RZgate_Bool', 'Rational', 'Reflection_Bool', 'RemoveRegister', 'Rot_Bool', 'Rot_GeneralStatePrep', 'Rot_GeneralUnitary', 'SXgate_Bool', 'SelfAdjointOperator', 'Sgate_Bool', 'ShiftLeft', 'ShiftRight', 'SignedInteger', 'SortByAmplitude', 'SortByKey', 'SortByKey2', 'SortExceptBit', 'SortExceptKey', 'SortExceptKeyHadamard', 'SortUnconditional', 'SparseMatrix', 'SparseState', 'SplitRegister', 'Sqrt_Div_Arccos_Int_Int', 'StateEqualExceptKey', 'StateEqualExceptQubits', 'StateHashExceptKey', 'StateHashExceptQubits', 'StateLessExceptKey', 'StateLessExceptQubits', 'StatePrint', 'StatePrintDisplay', 'StateStorage', 'StateStorageType', 'State_Prep_via_QRAM', 'Swap_Bool_Bool', 'Swap_General_General', 'System', 'TestRemovable', 'Tgate_Bool', 'U2gate_Bool', 'U3gate_Bool', 'UnsignedInteger', 'ViewNormalization', 'Walk_s_via_QRAM', 'Xgate_Bool', 'Ygate_Bool', 'ZeroConditionalPhaseFlip', 'Zgate_Bool', 'combine_systems', 'inverseQFT', 'merge_system', 'qda_classical2quantum', 'qda_solve', 'remove_system', 'split_systems', 'stateprep_unitary_build_schmidt']
M = typing.TypeVar("M", bound=int)
N = typing.TypeVar("N", bound=int)
class AddAssign_AnyInt_AnyInt(BaseOperator):
    @typing.overload
    def __init__(self, input_reg: str, output_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, input_reg: int, output_reg: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> AddAssign_AnyInt_AnyInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> AddAssign_AnyInt_AnyInt:
        ...
    def dag(self, state: SparseState) -> None:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class AddRegister:
    def __call__(self, arg0: SparseState) -> int:
        ...
    def __init__(self, name: str, type: StateStorageType, size: int) -> None:
        ...
class AddRegisterWithHadamard:
    def __call__(self, arg0: SparseState) -> int:
        ...
    def __init__(self, name: str, type: StateStorageType, size: int) -> None:
        ...
class Add_ConstUInt(BaseOperator):
    @typing.overload
    def __init__(self, input_reg: str, add: int) -> None:
        ...
    @typing.overload
    def __init__(self, input_reg: int, add: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Add_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Add_ConstUInt:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Add_Mult_UInt_ConstUInt(BaseOperator):
    @typing.overload
    def __init__(self, input_reg: str, multiplier: int, output_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, input_reg: int, multiplier: int, output_reg: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Add_Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Add_Mult_UInt_ConstUInt:
        ...
    def dag(self, state: SparseState) -> None:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Add_UInt_ConstUInt(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, input_reg: str, add: int, output_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, input_reg: int, add: int, output_reg: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Add_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Add_UInt_ConstUInt:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Add_UInt_UInt(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, input_reg1: str, input_reg2: str, output_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, input_id1: int, input_id2: int, output_id: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Add_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Add_UInt_UInt:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Add_UInt_UInt_InPlace(BaseOperator):
    @typing.overload
    def __init__(self, input_reg: str, output_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, input_reg: int, output_reg: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Add_UInt_UInt_InPlace:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Add_UInt_UInt_InPlace:
        ...
    def dag(self, state: SparseState) -> None:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Assign(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, src: str, dst: str) -> None:
        ...
    @typing.overload
    def __init__(self, src_id: int, dst_id: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Assign:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Assign:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Assign:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Assign:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Assign:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Assign:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Assign:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Assign:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Assign:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Assign:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Assign:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Assign:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Assign:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Assign:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Assign:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Assign:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class BaseOperator:
    def __call__(self, arg0: SparseState) -> None:
        ...
    def dag(self, arg0: SparseState) -> None:
        ...
class CheckDuplicateKey(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    def __init__(self) -> None:
        ...
class CheckNan(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    def __init__(self) -> None:
        ...
class CheckNormalization(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, threshold: float) -> None:
        ...
class ClearZero(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, epsilon: float) -> None:
        ...
class CombineRegister:
    def __call__(self, arg0: SparseState) -> int:
        ...
    def __init__(self, first: str, second: str) -> None:
        ...
class Compare_UInt_UInt(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, left_reg: str, right_reg: str, less_flag_reg: str, equal_flag_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, left_id: int, right_id: int, less_flag_id: int, equal_flag_id: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Compare_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Compare_UInt_UInt:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class CondRot_General_Bool(BaseOperator):
    @typing.overload
    def __init__(self, reg_in: str, reg_out: str, angle_function: typing.Callable) -> None:
        ...
    @typing.overload
    def __init__(self, reg_in: int, reg_out: int, angle_function: typing.Callable) -> None:
        ...
    def operate_alone_one(self, arg0: int, arg1: list[System]) -> None:
        ...
    def operate_alone_zero(self, arg0: int, arg1: list[System]) -> None:
        ...
    def operate_pair(self, arg0: int, arg1: int, arg2: list[System]) -> None:
        ...
class CondRot_Rational_Bool(BaseOperator):
    @typing.overload
    def __init__(self, arg0: str, arg1: str) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: int) -> None:
        ...
class CustomArithmetic(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    def __init__(self, input_registers: list, input_size: int, output_size: int, func: typing.Callable) -> None:
        ...
class DenseMatrix_complex128:
    def __init__(self, matrix: numpy.ndarray[numpy.complex128[M, N]]) -> None:
        ...
class DenseMatrix_float64:
    def __init__(self, matrix: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]) -> None:
        ...
class DenseVector_complex128:
    def __init__(self, vector: numpy.ndarray[numpy.complex128[M, 1]]) -> None:
        ...
class DenseVector_float64:
    def __init__(self, vector: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
class Div_Sqrt_Arccos_Int_Int(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, lhs_reg: str, rhs_reg: str, out_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, lhs_reg: int, rhs_reg: int, out_reg: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Div_Sqrt_Arccos_Int_Int:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class FlipBools(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> FlipBools:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> FlipBools:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class GetMid_UInt_UInt(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, left_reg: str, right_reg: str, mid_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, left_id: int, right_id: int, mid_id: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> GetMid_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> GetMid_UInt_UInt:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class GetRotateAngle_Int_Int(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, lhs_reg: str, rhs_reg: str, out_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, lhs_reg: int, rhs_reg: int, out_reg: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> GetRotateAngle_Int_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> GetRotateAngle_Int_Int:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class GlobalPhase_Int(BaseOperator):
    def __init__(self, phase: complex) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> GlobalPhase_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> GlobalPhase_Int:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Hadamard_Bool(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, reg_in: str) -> None:
        ...
    @typing.overload
    def __init__(self, reg_in: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Hadamard_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Hadamard_Bool:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Hadamard_Int(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, reg_in: str, n_digits: int) -> None:
        ...
    @typing.overload
    def __init__(self, reg_in: int, n_digits: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Hadamard_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Hadamard_Int:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Hadamard_Int_Full(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, reg_in: str) -> None:
        ...
    @typing.overload
    def __init__(self, reg_in: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Hadamard_Int_Full:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Hadamard_Int_Full:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Hadamard_PartialQubit(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, reg_in: str, qubit_positions: set) -> None:
        ...
    @typing.overload
    def __init__(self, reg_in: int, qubit_positions: set) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Hadamard_PartialQubit:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Hadamard_PartialQubit:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Init_Unsafe(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, reg: str, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, id: int, value: int) -> None:
        ...
class Less_UInt_UInt(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, left_reg: str, right_reg: str, less_flag_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, left_id: int, right_id: int, less_flag_id: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Less_UInt_UInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Less_UInt_UInt:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class ModuleInheritance_Test(BaseOperator):
    def __init__(self) -> None:
        ...
class ModuleInheritance_Test_SelfAdjoint(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    def __init__(self) -> None:
        ...
class MoveBackRegister:
    def __call__(self, arg0: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int) -> None:
        ...
class Mult_UInt_ConstUInt(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, input_reg: str, multiplier: int, output_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, input_id: int, multiplier: int, output_id: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Mult_UInt_ConstUInt:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Mult_UInt_ConstUInt:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Normalize(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    def __init__(self) -> None:
        ...
class PartialTrace:
    def __call__(self, state: SparseState) -> tuple[list[int], float]:
        ...
    @typing.overload
    def __init__(self, partial_trace_register_names: list[str]) -> None:
        ...
    @typing.overload
    def __init__(self, partial_trace_register_ids: list[int]) -> None:
        ...
    @typing.overload
    def __init__(self, single_register_name: str) -> None:
        ...
    @typing.overload
    def __init__(self, single_register_id: int) -> None:
        ...
class PartialTraceSelect:
    def __call__(self, state: SparseState) -> float:
        ...
    @typing.overload
    def __init__(self, name_value_map: dict[str, int]) -> None:
        ...
    @typing.overload
    def __init__(self, id_value_map: dict[int, int]) -> None:
        ...
    @typing.overload
    def __init__(self, reg_ids: list[int], select_values: list[int]) -> None:
        ...
    def get_projected_full(self, state: SparseState) -> tuple[list[complex], float]:
        ...
class PartialTraceSelectRange:
    def __call__(self, state: SparseState) -> float:
        ...
    @typing.overload
    def __init__(self, register_name: str, select_range: tuple[int, int]) -> None:
        ...
    @typing.overload
    def __init__(self, register_id: int, select_range: tuple[int, int]) -> None:
        ...
class Phase_Bool(BaseOperator):
    @typing.overload
    def __init__(self, reg: str, digit: int, lambda: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, digit: int, lambda: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg: str, lambda: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, lambda: float) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Phase_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Phase_Bool:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Pop(BaseOperator):
    @typing.overload
    def __init__(self, reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int) -> None:
        ...
class Push(BaseOperator):
    @typing.overload
    def __init__(self, reg: str, garbage: str) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, garbage: str) -> None:
        ...
class QFT(BaseOperator):
    @typing.overload
    def __init__(self, reg_name: str) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> QFT:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> QFT:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> QFT:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> QFT:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> QFT:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> QFT:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> QFT:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> QFT:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> QFT:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> QFT:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> QFT:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> QFT:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> QFT:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> QFT:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> QFT:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> QFT:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class QRAMCircuit_qutrit:
    @typing.overload
    def __init__(self, addr_size: int, data_size: int) -> None:
        ...
    @typing.overload
    def __init__(self, addr_size: int, data_size: int, memory: list[int]) -> None:
        ...
    @typing.overload
    def __init__(self, addr_size: int, data_size: int, memory: list[int]) -> None:
        ...
    @typing.overload
    def __init__(self, addr_size: int, data_size: int, memory: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.uint64]]) -> None:
        ...
class QRAMLoad(SelfAdjointOperator):
    version: typing.ClassVar[str] = ''
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, qram: QRAMCircuit_qutrit, addr_reg: str, data_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, qram: QRAMCircuit_qutrit, addr_reg_id: int, data_reg_id: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> QRAMLoad:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> QRAMLoad:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
    @property
    def qram_circuit(self) -> QRAMCircuit_qutrit:
        ...
class QRAMLoadFast(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, qram: QRAMCircuit_qutrit, addr_reg: str, data_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, qram: QRAMCircuit_qutrit, addr_reg_id: int, data_reg_id: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> QRAMLoadFast:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> QRAMLoadFast:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class RXgate_Bool(Rot_Bool):
    @typing.overload
    def __init__(self, reg: str, digit: int, theta: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, digit: int, theta: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg: str, theta: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, theta: float) -> None:
        ...
class RYgate_Bool(Rot_Bool):
    @typing.overload
    def __init__(self, reg: str, digit: int, theta: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, digit: int, theta: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg: str, theta: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, theta: float) -> None:
        ...
class RZgate_Bool(BaseOperator):
    @typing.overload
    def __init__(self, reg: str, digit: int, theta: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, digit: int, theta: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg: str, theta: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, theta: float) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> RZgate_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> RZgate_Bool:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Reflection_Bool(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, reg: str, inverse: bool = False) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, inverse: bool = False) -> None:
        ...
    @typing.overload
    def __init__(self, reg_ids: list[int], inverse: bool = False) -> None:
        ...
    @typing.overload
    def __init__(self, regs: list[str], inverse: bool = False) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Reflection_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Reflection_Bool:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class RemoveRegister:
    def __call__(self, arg0: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, name: str) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int) -> None:
        ...
class Rot_Bool(BaseOperator):
    @typing.overload
    def __init__(self, reg: str, digit: int, matrix: typing.Annotated[list[complex], pybind11_stubgen.typing_ext.FixedSize(4)]) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, digit: int, matrix: typing.Annotated[list[complex], pybind11_stubgen.typing_ext.FixedSize(4)]) -> None:
        ...
    @typing.overload
    def __init__(self, reg: str, matrix: typing.Annotated[list[complex], pybind11_stubgen.typing_ext.FixedSize(4)]) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, matrix: typing.Annotated[list[complex], pybind11_stubgen.typing_ext.FixedSize(4)]) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Rot_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Rot_Bool:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Rot_GeneralStatePrep(BaseOperator):
    @typing.overload
    def __init__(self, reg: str, state_vector: list[complex]) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, state_vector: list[complex]) -> None:
        ...
class Rot_GeneralUnitary(BaseOperator):
    @typing.overload
    def __init__(self, reg: str, unitary_matrix: DenseMatrix_complex128) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, unitary_matrix: DenseMatrix_complex128) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Rot_GeneralUnitary:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Rot_GeneralUnitary:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class SXgate_Bool(Rot_Bool):
    @typing.overload
    def __init__(self, reg: str, digit: int = 0) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, digit: int = 0) -> None:
        ...
class SelfAdjointOperator(BaseOperator):
    def __call__(self, arg0: SparseState) -> None:
        ...
    def dag(self, arg0: SparseState) -> None:
        ...
class Sgate_Bool(Phase_Bool):
    @typing.overload
    def __init__(self, reg: str, digit: int = 0) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, digit: int = 0) -> None:
        ...
class ShiftLeft(BaseOperator):
    @typing.overload
    def __init__(self, reg: str, shift_bits: int) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, shift_bits: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> ShiftLeft:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> ShiftLeft:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class ShiftRight(BaseOperator):
    @typing.overload
    def __init__(self, reg: str, shift_bits: int) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, shift_bits: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> ShiftRight:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> ShiftRight:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class SortByAmplitude(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    def __init__(self) -> None:
        ...
class SortByKey(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, key: str) -> None:
        ...
    @typing.overload
    def __init__(self, key_id: int) -> None:
        ...
class SortByKey2(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, key1: str, key2: str) -> None:
        ...
    @typing.overload
    def __init__(self, key1_id: int, key2_id: int) -> None:
        ...
class SortExceptBit(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, key: str, digit: int) -> None:
        ...
    @typing.overload
    def __init__(self, key_id: int, digit: int) -> None:
        ...
class SortExceptKey(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, key: str) -> None:
        ...
    @typing.overload
    def __init__(self, key_id: int) -> None:
        ...
class SortExceptKeyHadamard(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, key: str, qubit_ids: set[int]) -> None:
        ...
    @typing.overload
    def __init__(self, key_id: int, qubit_ids: set[int]) -> None:
        ...
class SortUnconditional(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    def __init__(self) -> None:
        ...
class SparseMatrix:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[float], arg1: list[int], arg2: int, arg3: int, arg4: int, arg5: bool) -> None:
        ...
class SparseState:
    def __init__(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def size(self) -> int:
        ...
    @property
    def basis_states(self) -> list[System]:
        ...
class SplitRegister:
    def __call__(self, arg0: SparseState) -> int:
        ...
    def __init__(self, first: str, second: str, size: int) -> None:
        ...
class Sqrt_Div_Arccos_Int_Int(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, lhs_reg: str, rhs_reg: str, out_reg: str) -> None:
        ...
    @typing.overload
    def __init__(self, lhs_reg: int, rhs_reg: int, out_reg: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Sqrt_Div_Arccos_Int_Int:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class StateEqualExceptKey:
    def __call__(self, arg0: System, arg1: System) -> int:
        ...
    def __init__(self, excluded_id: int) -> None:
        ...
class StateEqualExceptQubits:
    def __call__(self, arg0: System, arg1: System) -> int:
        ...
    def __init__(self, target_id: int, excluded_qubits: set[int]) -> None:
        ...
class StateHashExceptKey:
    def __call__(self, arg0: System) -> int:
        ...
    def __init__(self, excluded_id: int) -> None:
        ...
class StateHashExceptQubits:
    def __call__(self, arg0: System) -> int:
        ...
    def __init__(self, target_id: int, excluded_qubits: set[int]) -> None:
        ...
class StateLessExceptKey:
    def __call__(self, arg0: System, arg1: System) -> int:
        ...
    def __init__(self, excluded_id: int) -> None:
        ...
class StateLessExceptQubits:
    def __call__(self, arg0: System, arg1: System) -> int:
        ...
    def __init__(self, target_id: int, excluded_qubits: set[int]) -> None:
        ...
class StatePrint(SelfAdjointOperator):
    on: typing.ClassVar[bool] = True
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, disp: int = 0) -> None:
        ...
    @typing.overload
    def __init__(self, disp: int, precision: int) -> None:
        ...
    @typing.overload
    def __init__(self, disp: StatePrintDisplay) -> None:
        ...
class StatePrintDisplay:
    """
    Members:
    
      Default
    
      Detail
    
      Binary
    
      Prob
    """
    Binary: typing.ClassVar[StatePrintDisplay]  # value = <StatePrintDisplay.Binary: 2>
    Default: typing.ClassVar[StatePrintDisplay]  # value = <StatePrintDisplay.Default: 0>
    Detail: typing.ClassVar[StatePrintDisplay]  # value = <StatePrintDisplay.Detail: 1>
    Prob: typing.ClassVar[StatePrintDisplay]  # value = <StatePrintDisplay.Prob: 4>
    __members__: typing.ClassVar[dict[str, StatePrintDisplay]]  # value = {'Default': <StatePrintDisplay.Default: 0>, 'Detail': <StatePrintDisplay.Detail: 1>, 'Binary': <StatePrintDisplay.Binary: 2>, 'Prob': <StatePrintDisplay.Prob: 4>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class StateStorage:
    def __init__(self) -> None:
        ...
    @property
    def value(self) -> int:
        ...
class StateStorageType:
    """
    Members:
    
      General
    
      UnsignedInteger
    
      SignedInteger
    
      Boolean
    
      Rational
    """
    Boolean: typing.ClassVar[StateStorageType]  # value = <StateStorageType.Boolean: 3>
    General: typing.ClassVar[StateStorageType]  # value = <StateStorageType.General: 0>
    Rational: typing.ClassVar[StateStorageType]  # value = <StateStorageType.Rational: 4>
    SignedInteger: typing.ClassVar[StateStorageType]  # value = <StateStorageType.SignedInteger: 2>
    UnsignedInteger: typing.ClassVar[StateStorageType]  # value = <StateStorageType.UnsignedInteger: 1>
    __members__: typing.ClassVar[dict[str, StateStorageType]]  # value = {'General': <StateStorageType.General: 0>, 'UnsignedInteger': <StateStorageType.UnsignedInteger: 1>, 'SignedInteger': <StateStorageType.SignedInteger: 2>, 'Boolean': <StateStorageType.Boolean: 3>, 'Rational': <StateStorageType.Rational: 4>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class State_Prep_via_QRAM(BaseOperator):
    def __init__(self, qram: QRAMCircuit_qutrit, work_qubit: str, data_size: int, rational_size: int) -> None:
        ...
class Swap_Bool_Bool(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, reg1: str, digit1: int, reg2: str, digit2: int) -> None:
        ...
    @typing.overload
    def __init__(self, reg1_id: int, digit1: int, reg2_id: int, digit2: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Swap_Bool_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Swap_Bool_Bool:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Swap_General_General(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, reg1: str, reg2: str) -> None:
        ...
    @typing.overload
    def __init__(self, reg1_id: int, reg2_id: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Swap_General_General:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Swap_General_General:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class System:
    __hash__: typing.ClassVar[None] = None
    max_qubit_count: typing.ClassVar[int] = 0
    max_register_count: typing.ClassVar[int] = 0
    max_system_size: typing.ClassVar[int] = 0
    name_register_map: typing.ClassVar[list] = list()
    reusable_registers: typing.ClassVar[list] = list()
    temporal_registers: typing.ClassVar[list] = list()
    @staticmethod
    def add_register(arg0: str, arg1: StateStorageType, arg2: int) -> int:
        ...
    @staticmethod
    @typing.overload
    def add_register_synchronous(arg0: str, arg1: StateStorageType, arg2: int, arg3: SparseState) -> int:
        ...
    @staticmethod
    @typing.overload
    def add_register_synchronous(arg0: str, arg1: StateStorageType, arg2: int, arg3: list[System]) -> int:
        ...
    @staticmethod
    def clear() -> None:
        ...
    @staticmethod
    def get_activated_register_size() -> int:
        ...
    @staticmethod
    def get_id(arg0: str) -> int:
        ...
    @staticmethod
    def get_qubit_count() -> int:
        ...
    @staticmethod
    def get_register_info(arg0: str) -> tuple[str, StateStorageType, int, bool]:
        ...
    @staticmethod
    def name_of(arg0: int) -> str:
        ...
    @staticmethod
    @typing.overload
    def remove_register(arg0: int) -> None:
        ...
    @staticmethod
    @typing.overload
    def remove_register(arg0: str) -> None:
        ...
    @staticmethod
    @typing.overload
    def remove_register_synchronous(arg0: int, arg1: list[System]) -> None:
        ...
    @staticmethod
    @typing.overload
    def remove_register_synchronous(arg0: str, arg1: list[System]) -> None:
        ...
    @staticmethod
    @typing.overload
    def size_of(arg0: str) -> int:
        ...
    @staticmethod
    @typing.overload
    def size_of(arg0: int) -> int:
        ...
    @staticmethod
    @typing.overload
    def status_of(arg0: str) -> bool:
        ...
    @staticmethod
    @typing.overload
    def status_of(arg0: int) -> bool:
        ...
    @staticmethod
    @typing.overload
    def type_of(arg0: str) -> StateStorageType:
        ...
    @staticmethod
    @typing.overload
    def type_of(arg0: int) -> StateStorageType:
        ...
    @staticmethod
    def update_max_size(arg0: int) -> None:
        ...
    def __eq__(self, arg0: System) -> bool:
        ...
    def __init__(self) -> None:
        ...
    def __less__(self, arg0: System) -> bool:
        ...
    def __ne__(self, arg0: System) -> bool:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def get(self, arg0: int) -> StateStorage:
        ...
    @typing.overload
    def get(self, arg0: int) -> StateStorage:
        ...
    def get_as_uint64(self, arg0: int) -> int:
        ...
    @typing.overload
    def last_register(self) -> StateStorage:
        ...
    @typing.overload
    def last_register(self) -> StateStorage:
        ...
    @typing.overload
    def to_string(self) -> str:
        ...
    @typing.overload
    def to_string(self, arg0: int) -> str:
        ...
    @property
    def amplitude(self) -> complex:
        ...
    @property
    def registers(self) -> typing.Annotated[list[StateStorage], pybind11_stubgen.typing_ext.FixedSize(40)]:
        ...
class TestRemovable(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, register_name: str) -> None:
        ...
    @typing.overload
    def __init__(self, register_id: int) -> None:
        ...
class Tgate_Bool(Phase_Bool):
    @typing.overload
    def __init__(self, reg: str, digit: int = 0) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, digit: int = 0) -> None:
        ...
class U2gate_Bool(Rot_Bool):
    @typing.overload
    def __init__(self, reg: str, digit: int, phi: float, lambda: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, digit: int, phi: float, lambda: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg: str, phi: float, lambda: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, phi: float, lambda: float) -> None:
        ...
class U3gate_Bool(Rot_Bool):
    @typing.overload
    def __init__(self, reg: str, digit: int, theta: float, phi: float, lambda: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, digit: int, theta: float, phi: float, lambda: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg: str, theta: float, phi: float, lambda: float) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, theta: float, phi: float, lambda: float) -> None:
        ...
class ViewNormalization(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    def __init__(self) -> None:
        ...
class Walk_s_via_QRAM:
    def __call__(self, arg0: SparseState) -> None:
        ...
    def __init__(self, qram_A: QRAMCircuit_qutrit, qram_b: QRAMCircuit_qutrit, main_reg: str, anc_UA: str, anc_1: str, anc_2: str, anc_3: str, anc_4: str, s: float, kappa: float, p: float, data_size: int, rational_size: int) -> None:
        ...
    def dag(self, arg0: SparseState) -> None:
        ...
class Xgate_Bool(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, reg: str, digit: int) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, digit: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Xgate_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Xgate_Bool:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Ygate_Bool(BaseOperator):
    @typing.overload
    def __init__(self, reg: str, digit: int = 0) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, digit: int = 0) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> Ygate_Bool:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> Ygate_Bool:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class ZeroConditionalPhaseFlip(SelfAdjointOperator):
    def __call__(self, state: SparseState) -> None:
        ...
    @typing.overload
    def __init__(self, reg_ids: list[int]) -> None:
        ...
    @typing.overload
    def __init__(self, regs: list[str]) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> ZeroConditionalPhaseFlip:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> ZeroConditionalPhaseFlip:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
class Zgate_Bool(Phase_Bool):
    @typing.overload
    def __init__(self, reg: str, digit: int = 0) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int, digit: int = 0) -> None:
        ...
class inverseQFT(BaseOperator):
    @typing.overload
    def __init__(self, reg_name: str) -> None:
        ...
    @typing.overload
    def __init__(self, reg_id: int) -> None:
        ...
    def clear_control_all_ones(self) -> None:
        ...
    def clear_control_by_bit(self) -> None:
        ...
    def clear_control_by_value(self) -> None:
        ...
    def clear_control_nonzeros(self) -> None:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: str) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[str]) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, cond: int) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_all_ones(self, conds: list[int]) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: str, pos: int) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[str, int]]) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_bit(self, cond: int, pos: int) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_bit(self, conds: list[tuple[int, int]]) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: str) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[str]) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, cond: int) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_nonzeros(self, conds: list[int]) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: str, pos: int) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[str, int]]) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_value(self, cond: int, pos: int) -> inverseQFT:
        ...
    @typing.overload
    def conditioned_by_value(self, conds: list[tuple[int, int]]) -> inverseQFT:
        ...
    @property
    def condition_variable_all_ones(self) -> list[int]:
        ...
    @property
    def condition_variable_by_bit(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_by_value(self) -> list[tuple[int, int]]:
        ...
    @property
    def condition_variable_nonzeros(self) -> list[int]:
        ...
def combine_systems(to: SparseState, from: SparseState) -> None:
    ...
def merge_system(arg0: System, arg1: System) -> None:
    ...
def qda_classical2quantum(A: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]], b: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> tuple[numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]], numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]], typing.Callable[[numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]], numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]]]:
    ...
def qda_solve(A: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]], b: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]], kappa: float | None = None, p: float = 1.3, step_rate: float = 0.01) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
    ...
def remove_system(arg0: System) -> bool:
    ...
def split_systems(state: SparseState, condition_variable_nonzeros: list[int], condition_variable_all_ones: list[int], condition_variable_by_bit: list[tuple[int, int]], condition_variable_by_value: list[tuple[int, int]]) -> SparseState:
    ...
def stateprep_unitary_build_schmidt(state_vector: list[complex]) -> DenseMatrix_complex128:
    """
    Build unitary for state preparation
    """
Binary: StatePrintDisplay  # value = <StatePrintDisplay.Binary: 2>
Boolean: StateStorageType  # value = <StateStorageType.Boolean: 3>
Default: StatePrintDisplay  # value = <StatePrintDisplay.Default: 0>
Detail: StatePrintDisplay  # value = <StatePrintDisplay.Detail: 1>
General: StateStorageType  # value = <StateStorageType.General: 0>
Prob: StatePrintDisplay  # value = <StatePrintDisplay.Prob: 4>
Rational: StateStorageType  # value = <StateStorageType.Rational: 4>
SignedInteger: StateStorageType  # value = <StateStorageType.SignedInteger: 2>
UnsignedInteger: StateStorageType  # value = <StateStorageType.UnsignedInteger: 1>
