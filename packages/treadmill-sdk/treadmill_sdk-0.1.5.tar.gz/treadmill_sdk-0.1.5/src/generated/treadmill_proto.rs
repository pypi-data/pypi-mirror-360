// This file is @generated by prost-build.
/// Represents information about the treadmill device
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfo {
    /// Unique serial number of the device
    #[prost(string, tag = "1")]
    pub serial_number: ::prost::alloc::string::String,
    /// Firmware version of the device
    #[prost(string, tag = "2")]
    pub firmware_revision: ::prost::alloc::string::String,
}
/// APP发起OTA
/// 固件进入OTA模式后，开始请求文件
/// APP和固件交互传输升级包
/// 固件接收完成后,自动重启
/// 重启后，会擦写Flash
/// 操作Flash完成后，新固件运行，上报OTA完成状态。
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtaConfig {
    #[prost(enumeration = "ota_config::Cmd", tag = "1")]
    pub cmd: i32,
    #[prost(message, optional, tag = "2")]
    pub ota_data: ::core::option::Option<OtaData>,
    /// START 命令，带新固件信息
    #[prost(uint32, tag = "3")]
    pub file_size: u32,
    #[prost(string, tag = "4")]
    pub file_md5: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub file_sha256: ::prost::alloc::string::String,
}
/// Nested message and enum types in `OtaConfig`.
pub mod ota_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Cmd {
        None = 0,
        /// 前台传输MCU升级文件
        OtaStart = 1,
        /// 重启升级MCU
        OtaReboot = 2,
    }
    impl Cmd {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::OtaStart => "OTA_START",
                Self::OtaReboot => "OTA_REBOOT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "OTA_START" => Some(Self::OtaStart),
                "OTA_REBOOT" => Some(Self::OtaReboot),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OtaConfigResp {
    /// 如果没有错误，恢复空OtaConfigResp
    #[prost(enumeration = "ota_config_resp::State", tag = "1")]
    pub state: i32,
    /// 镜像的offset
    #[prost(uint32, tag = "2")]
    pub offset: u32,
}
/// Nested message and enum types in `OtaConfigResp`.
pub mod ota_config_resp {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        None = 0,
        /// entry为true，返回状态为Downloading
        Downloading = 1,
        /// 接收到最后一包数据，返回FINISHED
        DownloadFinished = 2,
        /// 如果收到reboot，返回该状态后，再重启
        Rebooting = 3,
        /// 重新运行会发送该状态
        Rebooted = 4,
        /// 设备端状态异常，终止本次OTA
        Abort = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Downloading => "DOWNLOADING",
                Self::DownloadFinished => "DOWNLOAD_FINISHED",
                Self::Rebooting => "REBOOTING",
                Self::Rebooted => "REBOOTED",
                Self::Abort => "ABORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "DOWNLOADING" => Some(Self::Downloading),
                "DOWNLOAD_FINISHED" => Some(Self::DownloadFinished),
                "REBOOTING" => Some(Self::Rebooting),
                "REBOOTED" => Some(Self::Rebooted),
                "ABORT" => Some(Self::Abort),
                _ => None,
            }
        }
    }
}
/// APP发送OTA文件数据
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtaData {
    #[prost(uint32, tag = "1")]
    pub offset: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// 结束标志
    #[prost(bool, tag = "3")]
    pub finished: bool,
}
/// 设备端主动上报的事件
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeviceEvent {
    EventUnspecified = 0,
    /// 硬件错误
    HardwareErr = 1,
    CalibrateImuOk = 2,
    CalibrateImuFail = 3,
}
impl DeviceEvent {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EventUnspecified => "EVENT_UNSPECIFIED",
            Self::HardwareErr => "HARDWARE_ERR",
            Self::CalibrateImuOk => "CALIBRATE_IMU_OK",
            Self::CalibrateImuFail => "CALIBRATE_IMU_FAIL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_UNSPECIFIED" => Some(Self::EventUnspecified),
            "HARDWARE_ERR" => Some(Self::HardwareErr),
            "CALIBRATE_IMU_OK" => Some(Self::CalibrateImuOk),
            "CALIBRATE_IMU_FAIL" => Some(Self::CalibrateImuFail),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImuSampleRate {
    ImuSrUnspecified = 0,
    /// IMU关闭采样
    ImuSrOff = 1,
    /// IMU订阅采样率25HZ
    ImuSr25 = 2,
    /// IMU订阅采样率50HZ
    ImuSr50 = 3,
    /// IMU订阅采样率100HZ
    ImuSr100 = 4,
    /// IMU订阅采样率90HZ
    ImuSr90 = 5,
    /// IMU订阅采样率200HZ
    ImuSr200 = 6,
    /// IMU订阅采样率400HZ
    ImuSr400 = 7,
}
impl ImuSampleRate {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ImuSrUnspecified => "IMU_SR_UNSPECIFIED",
            Self::ImuSrOff => "IMU_SR_OFF",
            Self::ImuSr25 => "IMU_SR_25",
            Self::ImuSr50 => "IMU_SR_50",
            Self::ImuSr100 => "IMU_SR_100",
            Self::ImuSr90 => "IMU_SR_90",
            Self::ImuSr200 => "IMU_SR_200",
            Self::ImuSr400 => "IMU_SR_400",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IMU_SR_UNSPECIFIED" => Some(Self::ImuSrUnspecified),
            "IMU_SR_OFF" => Some(Self::ImuSrOff),
            "IMU_SR_25" => Some(Self::ImuSr25),
            "IMU_SR_50" => Some(Self::ImuSr50),
            "IMU_SR_100" => Some(Self::ImuSr100),
            "IMU_SR_90" => Some(Self::ImuSr90),
            "IMU_SR_200" => Some(Self::ImuSr200),
            "IMU_SR_400" => Some(Self::ImuSr400),
            _ => None,
        }
    }
}
/// 通用传感器采样订阅
///
/// CommonSampleRate
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SamplingRate {
    /// 无采样
    None = 0,
    /// 关闭采样
    Off = 1,
    ///   25 Hz 采样率
    SamplingRate25 = 2,
    ///   50 Hz 采样率
    SamplingRate50 = 3,
    /// 100 Hz 采样率
    SamplingRate100 = 4,
    /// 200 Hz 采样率
    SamplingRate200 = 5,
    /// 270 Hz 采样率
    SamplingRate270 = 6,
}
impl SamplingRate {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SAMPLING_RATE_NONE",
            Self::Off => "SAMPLING_RATE_OFF",
            Self::SamplingRate25 => "SAMPLING_RATE_25",
            Self::SamplingRate50 => "SAMPLING_RATE_50",
            Self::SamplingRate100 => "SAMPLING_RATE_100",
            Self::SamplingRate200 => "SAMPLING_RATE_200",
            Self::SamplingRate270 => "SAMPLING_RATE_270",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SAMPLING_RATE_NONE" => Some(Self::None),
            "SAMPLING_RATE_OFF" => Some(Self::Off),
            "SAMPLING_RATE_25" => Some(Self::SamplingRate25),
            "SAMPLING_RATE_50" => Some(Self::SamplingRate50),
            "SAMPLING_RATE_100" => Some(Self::SamplingRate100),
            "SAMPLING_RATE_200" => Some(Self::SamplingRate200),
            "SAMPLING_RATE_270" => Some(Self::SamplingRate270),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConfigReqType {
    ReqNone = 0,
    /// 请求设备信息， 设备端上报：DeviceInfo
    GetDeviceInfo = 1,
    /// 设置设备信息
    SetDeviceInfo = 2,
    /// 读取所有sensor config
    GetSensorConfig = 4,
    /// 按默认配置一键订阅传感器数据
    StartDataStream = 6,
    /// 停止全部订阅数据流
    StopDataStream = 7,
    StartEvorun = 8,
    StopEvorun = 9,
    CalibrateImu = 10,
}
impl ConfigReqType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReqNone => "REQ_NONE",
            Self::GetDeviceInfo => "GET_DEVICE_INFO",
            Self::SetDeviceInfo => "SET_DEVICE_INFO",
            Self::GetSensorConfig => "GET_SENSOR_CONFIG",
            Self::StartDataStream => "START_DATA_STREAM",
            Self::StopDataStream => "STOP_DATA_STREAM",
            Self::StartEvorun => "START_EVORUN",
            Self::StopEvorun => "STOP_EVORUN",
            Self::CalibrateImu => "CALIBRATE_IMU",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REQ_NONE" => Some(Self::ReqNone),
            "GET_DEVICE_INFO" => Some(Self::GetDeviceInfo),
            "SET_DEVICE_INFO" => Some(Self::SetDeviceInfo),
            "GET_SENSOR_CONFIG" => Some(Self::GetSensorConfig),
            "START_DATA_STREAM" => Some(Self::StartDataStream),
            "STOP_DATA_STREAM" => Some(Self::StopDataStream),
            "START_EVORUN" => Some(Self::StartEvorun),
            "STOP_EVORUN" => Some(Self::StopEvorun),
            "CALIBRATE_IMU" => Some(Self::CalibrateImu),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TreadmillData {
    #[prost(uint32, tag = "1")]
    pub msg_id: u32,
    #[prost(enumeration = "treadmill_data::Status", tag = "2")]
    pub st: i32,
    #[prost(uint32, tag = "3")]
    pub target_speed: u32,
    #[prost(uint32, tag = "4")]
    pub real_speed: u32,
    #[prost(int32, tag = "5")]
    pub gradient: i32,
}
/// Nested message and enum types in `TreadmillData`.
pub mod treadmill_data {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        StInvalid = 0,
        StStop = 1,
        StRun = 2,
        StDecay = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::StInvalid => "ST_INVALID",
                Self::StStop => "ST_STOP",
                Self::StRun => "ST_RUN",
                Self::StDecay => "ST_DECAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ST_INVALID" => Some(Self::StInvalid),
                "ST_STOP" => Some(Self::StStop),
                "ST_RUN" => Some(Self::StRun),
                "ST_DECAY" => Some(Self::StDecay),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AmpsData {
    #[prost(enumeration = "ConfigRespError", tag = "1")]
    pub error: i32,
    #[prost(uint32, tag = "2")]
    pub seq_num: u32,
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub amps_value: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImuConfig {
    #[prost(enumeration = "imu_config::ImuMode", tag = "1")]
    pub imu_mode: i32,
    #[prost(enumeration = "ImuSampleRate", tag = "2")]
    pub imu_sr: i32,
}
/// Nested message and enum types in `ImuConfig`.
pub mod imu_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ImuMode {
        NotSet = 0,
        Acc = 1,
        Gyro = 2,
        AccGyro = 3,
        Euler = 4,
    }
    impl ImuMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NotSet => "NOT_SET",
                Self::Acc => "ACC",
                Self::Gyro => "GYRO",
                Self::AccGyro => "ACC_GYRO",
                Self::Euler => "EULER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOT_SET" => Some(Self::NotSet),
                "ACC" => Some(Self::Acc),
                "GYRO" => Some(Self::Gyro),
                "ACC_GYRO" => Some(Self::AccGyro),
                "EULER" => Some(Self::Euler),
                _ => None,
            }
        }
    }
}
/// flexible sensor configure
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FlexConfig {
    #[prost(enumeration = "SamplingRate", tag = "1")]
    pub sample_rate: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImuConfResp {
    #[prost(enumeration = "ConfigRespError", tag = "1")]
    pub error: i32,
    #[prost(message, optional, tag = "3")]
    pub config: ::core::option::Option<ImuConfig>,
    /// coefficient for calculating acceleration, eg. acc value on the X-axis = RAW_ADC_x * acc_coefficient
    #[prost(float, tag = "4")]
    pub acc_coefficient: f32,
    /// coefficient for calculating Gyroscope, eg. Gyro value on the X-axis = RAW_ADC_x * gyro_coefficient
    #[prost(float, tag = "5")]
    pub gyro_coefficient: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FlexConfResp {
    #[prost(enumeration = "ConfigRespError", tag = "1")]
    pub error: i32,
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<FlexConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImuData {
    #[prost(uint32, tag = "1")]
    pub seq_num: u32,
    /// 16-bit precision, sequence as x-y-z, little endian
    #[prost(bytes = "vec", tag = "4")]
    pub acc_raw_data: ::prost::alloc::vec::Vec<u8>,
    /// 16-bit precision, sequence as x-y-z, little endian
    #[prost(bytes = "vec", tag = "6")]
    pub gyro_raw_data: ::prost::alloc::vec::Vec<u8>,
    /// valid range is (-180, +180), sequence as yaw-pitch-roll
    #[prost(float, repeated, tag = "7")]
    pub eular_raw_data: ::prost::alloc::vec::Vec<f32>,
    /// sequence as x-y-z , unit(g)
    #[prost(float, repeated, tag = "9")]
    pub acc_correction_data: ::prost::alloc::vec::Vec<f32>,
    /// sequence as x-y-z , unit(dps)
    #[prost(float, repeated, tag = "10")]
    pub gyro_correction_data: ::prost::alloc::vec::Vec<f32>,
}
/// flexible sensor data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlexData {
    #[prost(enumeration = "ConfigRespError", tag = "1")]
    pub error: i32,
    #[prost(uint32, tag = "2")]
    pub seq_num: u32,
    /// 12 bytes for one group, <int16><little endian>, 6 channels in one group
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub channel_adc_value: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConfigRespError {
    ConfigErrSuccess = 0,
    /// 硬件错误
    ConfigErrHardware = 1,
    /// 参数错误
    ConfigErrParameter = 2,
    /// 未知错误
    ConfigErrUnknown = 3,
}
impl ConfigRespError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ConfigErrSuccess => "CONFIG_ERR_SUCCESS",
            Self::ConfigErrHardware => "CONFIG_ERR_HARDWARE",
            Self::ConfigErrParameter => "CONFIG_ERR_PARAMETER",
            Self::ConfigErrUnknown => "CONFIG_ERR_UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONFIG_ERR_SUCCESS" => Some(Self::ConfigErrSuccess),
            "CONFIG_ERR_HARDWARE" => Some(Self::ConfigErrHardware),
            "CONFIG_ERR_PARAMETER" => Some(Self::ConfigErrParameter),
            "CONFIG_ERR_UNKNOWN" => Some(Self::ConfigErrUnknown),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DebugInfo {
    #[prost(float, tag = "1")]
    pub current_range: f32,
    #[prost(float, tag = "2")]
    pub acc_range: f32,
    #[prost(float, tag = "3")]
    pub gyro_range: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GaitAnalysisResult {
    #[prost(uint32, tag = "1")]
    pub msg_id: u32,
    #[prost(uint32, tag = "2")]
    pub timestamp: u32,
    #[prost(enumeration = "gait_analysis_result::FootStrike", tag = "3")]
    pub foot: i32,
    #[prost(enumeration = "gait_analysis_result::GaitPattern", tag = "4")]
    pub pattern: i32,
    #[prost(uint32, tag = "5")]
    pub gait_duration: u32,
    #[prost(uint32, tag = "6")]
    pub sport_id: u32,
    #[prost(message, optional, tag = "7")]
    pub dbg_data: ::core::option::Option<DebugInfo>,
    #[prost(uint32, tag = "8")]
    pub sport_runtime: u32,
    #[prost(float, tag = "9")]
    pub step_load: f32,
    #[prost(enumeration = "AbnormalGait", tag = "10")]
    pub abnormal_gait: i32,
}
/// Nested message and enum types in `GaitAnalysisResult`.
pub mod gait_analysis_result {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FootStrike {
        Unspecified = 0,
        LeftFoot = 1,
        RightFoot = 2,
    }
    impl FootStrike {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FOOT_STRIKE_UNSPECIFIED",
                Self::LeftFoot => "LEFT_FOOT",
                Self::RightFoot => "RIGHT_FOOT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FOOT_STRIKE_UNSPECIFIED" => Some(Self::Unspecified),
                "LEFT_FOOT" => Some(Self::LeftFoot),
                "RIGHT_FOOT" => Some(Self::RightFoot),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GaitPattern {
        Unspecified = 0,
        Walk = 1,
        Run = 2,
    }
    impl GaitPattern {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "GAIT_PATTERN_UNSPECIFIED",
                Self::Walk => "WALK",
                Self::Run => "RUN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GAIT_PATTERN_UNSPECIFIED" => Some(Self::Unspecified),
                "WALK" => Some(Self::Walk),
                "RUN" => Some(Self::Run),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AbnormalGait {
    /// Default value per Protobuf convention
    Unspecified = 0,
    /// No load detected
    NoLoad = 1,
    /// Support phase detected
    HandrailSupported = 2,
    /// Unilateral dragging detected
    UnilateralDragging = 3,
}
impl AbnormalGait {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ABNORMAL_GAIT_UNSPECIFIED",
            Self::NoLoad => "NO_LOAD",
            Self::HandrailSupported => "HANDRAIL_SUPPORTED",
            Self::UnilateralDragging => "UNILATERAL_DRAGGING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ABNORMAL_GAIT_UNSPECIFIED" => Some(Self::Unspecified),
            "NO_LOAD" => Some(Self::NoLoad),
            "HANDRAIL_SUPPORTED" => Some(Self::HandrailSupported),
            "UNILATERAL_DRAGGING" => Some(Self::UnilateralDragging),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppSensor {
    #[prost(uint32, tag = "1")]
    pub msg_id: u32,
    #[prost(enumeration = "ConfigReqType", tag = "2")]
    pub msg_cmd: i32,
    #[prost(message, optional, tag = "5")]
    pub ota_cfg: ::core::option::Option<OtaConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SensorApp {
    #[prost(uint32, tag = "1")]
    pub msg_id: u32,
    #[prost(message, optional, tag = "2")]
    pub device_info: ::core::option::Option<DeviceInfo>,
    #[prost(enumeration = "DeviceEvent", tag = "3")]
    pub device_evt: i32,
    #[prost(message, optional, tag = "4")]
    pub ga_result: ::core::option::Option<GaitAnalysisResult>,
    #[prost(message, optional, tag = "5")]
    pub ota_resp: ::core::option::Option<OtaConfigResp>,
    #[prost(message, optional, tag = "6")]
    pub ota_data: ::core::option::Option<OtaData>,
    /// IMU & Mag Sensor
    #[prost(message, optional, tag = "10")]
    pub imu_data: ::core::option::Option<ImuData>,
    /// Imu configure response
    #[prost(message, optional, tag = "11")]
    pub imu_resp: ::core::option::Option<ImuConfResp>,
    #[prost(message, optional, tag = "22")]
    pub flex_data: ::core::option::Option<FlexData>,
    #[prost(message, optional, tag = "23")]
    pub flex_resp: ::core::option::Option<FlexConfResp>,
    #[prost(message, optional, tag = "24")]
    pub tm_data: ::core::option::Option<TreadmillData>,
    #[prost(message, optional, tag = "25")]
    pub amps_data: ::core::option::Option<AmpsData>,
}
