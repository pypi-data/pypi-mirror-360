use std::{path::Path, string};

use serde::{Deserialize, Serialize};
use serde_pickle::DeOptions;
use ndarray::prelude::*;

use crate::{
    acquisition::Params,
    error::{CalibrationError, MiscDataError},
    parsing::Sample,
    Event,
};

/// Holds the pedestals data generated by NaluDAQ.
///
/// This is used for correcting events for pedestals using types from [`crate::calibration`].
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct Pedestals {
    /// Indexed by [channel][window][sample]
    data: Vec<Vec<Vec<Sample>>>,
}

impl Pedestals {
    /// Create a new Pedestals object from the given g-zipped & pickled data.
    pub fn from_bytes(data: &[u8]) -> Result<Self, MiscDataError> {
        let decoder = flate2::read::GzDecoder::new(data);
        let pedestals: Option<Pedestals> =
            serde_pickle::from_reader(decoder, DeOptions::default())?;
        pedestals.ok_or(MiscDataError::InvalidMiscData)
    }

    /// Read pedestals from the disk.
    pub fn open(path: impl AsRef<Path>) -> Result<Self, MiscDataError> {
        let data = std::fs::read(path)?;
        Self::from_bytes(&data)
    }

    /// Export the pedestals as CSV to the given path.
    /// The CSV have a header: `window, sample, ch0, .., chN`.
    pub fn export_csv(&self, path: impl AsRef<Path>) -> Result<(), MiscDataError> {
        let mut writer = csv::Writer::from_path(path).unwrap();
        let channels = self.data.len();
        let mut header: Vec<String> = vec!["window".to_string(), "sample".to_string()];
        for i in 0..channels {
            let ch = format!(", ch{}", i);
            header.push(ch);
        };
        writer.write_record(header).unwrap();

        // let nray = ndarray::Array::from_vec(self.data.clone());
        // println!("nray: {:?}", nray.shape());
        let windows = self.data[0].len();
        let samples = self.data[0][0].len();
        let records = windows * samples;

        let mut a = Array::<f32, _>::zeros((channels, records));

        for (i, ch) in self.data.iter().enumerate() {
            for (j, window) in ch.iter().enumerate() {
                for (k, sample) in window.iter().enumerate() {
                    a[[i, j * samples + k]] = *sample as f32;
                }
            }
        }

        for i in 0..records {
            let mut record: Vec<String> = vec![format!("{}", i / samples), format!("{}", i % samples)];
            for j in 0..channels {
                record.push(format!("{}", a[[j, i]]));
            }
            writer.write_record(record).unwrap();
        }

        Ok(())
    }

    /// Correct the given event for pedestals.
    ///
    /// The given params must match the acquisition the event was taken from.
    pub fn correct(&self, event: &mut impl Event, params: &Params) -> Result<(), CalibrationError> {
        let samples = params.samples();
        let channels = params.channels();

        for chan in 0..channels {
            let window_labels = event
                .window_labels()
                .get(chan)
                .ok_or(CalibrationError::InvalidDataShape)?
                .clone();
            if window_labels.len() == 0 {
                continue;
            }
            let data = event
                .data_mut()
                .get_mut(chan)
                .ok_or(CalibrationError::InvalidDataShape)?;

            data.iter_mut().enumerate().try_for_each(|(i, sample)| {
                let window_label = *window_labels
                    .get(i / samples)
                    .ok_or(CalibrationError::InvalidDataShape)?;
                let pedestal_value = self
                    .data
                    .get(chan)
                    .ok_or(CalibrationError::InvalidDataShape)?
                    .get(window_label as usize)
                    .ok_or(CalibrationError::InvalidDataShape)?
                    .get(i % samples)
                    .ok_or(CalibrationError::InvalidDataShape)?;
                *sample = *sample - pedestal_value;

                Ok(())
            })?;
        }

        Ok(())
    }
}
