#!/usr/bin/env python3

import math
import os
import sys
from argparse import Namespace
from datetime import datetime, timezone
from pathlib import Path

from omakase_media_tools.file_log.logger import setup_ffmpeg_logger, ffmpeg_error

try:
    import ffmpeg
except ImportError:
    print("Error: ffmpeg package not found. Please install it separately.")
    print("For installation instructions, visit: https://https://ffmpeg.org")
    ffmpeg = None

ffmpeg_logger = setup_ffmpeg_logger("create_audio_metrics")


def seconds_to_timestamp(seconds):
    """Convert seconds to HH:MM:SS.milliseconds format."""
    return datetime.fromtimestamp(seconds, timezone.utc).strftime('%H:%M:%S.%f')[:-3]


def parse_ffmpeg_metrics_file(file_path):
    """
    Parse a text file generated by the ffmpeg ametadata filter.

    Samples are generated every 100ms. Each sample is represented by two lines:
        frame:0    pts:0       pts_time:0
        lavfi.r128.M=-120.691

    In this example:
        "pts_time" is the timestamp of the sample
        "lavfi.r128.M" is the name of the metric
        "-120.691" is the sample value
    """
    parsed_data = {}
    value4_sum = {}
    value4_count = {}
    try:
        with open(file_path, 'r') as file:
            lines = file.readlines()

        for i in range(0, len(lines), 2):
            line1 = lines[i].strip().split()
            line2 = lines[i + 1].strip().split('=')

            # Extract values
            value3 = int(float(line1[2].split(":")[-1]))  # Rounded down seconds
            value4 = float(line2[1])

            # Handle infinite and NaN values
            if not math.isfinite(value4):
                value4 = -120.0

            # Determine the 2-second interval start time
            interval_start = (value3 // 2) * 2

            # Initialize if not present
            if interval_start not in parsed_data:
                parsed_data[interval_start] = []
                value4_sum[interval_start] = 0
                value4_count[interval_start] = 0

            parsed_data[interval_start].append(value4)
            value4_sum[interval_start] += value4
            value4_count[interval_start] += 1
    except FileNotFoundError:
        print(f"Error: ffempeg metrics file not found at {file}")
    except Exception as e:
        print(f"An unexpected error occurred with ffempeg metrics file {file} :: {str(e)}")

    # Calculate averages
    for key in parsed_data.keys():
        if value4_count[key] != 0:
            average_value4 = value4_sum[key] / value4_count[key]
            parsed_data[key] = round(average_value4, 3) if math.isfinite(average_value4) else -120.0
        else:
            parsed_data[key] = 0  # No data for this interval

    return parsed_data


def create_vtt_file(input_file_path, output_file_path, omp_measurement='', omp_comment=''):
    """Create an OMP 1.0 VTT file from parsed data in temp file."""
    parsed_data = parse_ffmpeg_metrics_file(input_file_path)
    try:
        with open(output_file_path, 'w') as output_file:
            # Write the initial lines
            output_file.write("WEBVTT\n\n")

            # If creating an OMP VTT 1.0, write required header
            output_file.write("NOTE\n")
            output_file.write("Omakase Player Web VTT\n")
            output_file.write("V1.0\n\n")

            # Write the parsed data
            for key, value in parsed_data.items():
                start_timestamp = seconds_to_timestamp(key)
                end_timestamp = seconds_to_timestamp(key + 1.999)
                omp_decoration = ""
                omp_decoration += f":MEASUREMENT={omp_measurement}" if omp_measurement else ""
                omp_decoration += f":COMMENT={omp_comment}" if omp_comment else ""

                output_file.write(f"{start_timestamp} --> {end_timestamp}\n")
                output_file.write(f"{value:.3f}{omp_decoration}\n\n")
    except FileNotFoundError:
        print(f"Error: VTT output file not found at {output_file}")
    except Exception as e:
        print(f"An unexpected error occurred with VTT output file {output_file} :: {str(e)}")


def generate_audio_metrics(source_audio_file_path, vtt_directory='', samples_per_second=2):
    """
    For the source audio file, use ffmpeg to generate two OMP VTT 1.0 audio analysis VTT files
       EBU R128 metrics using the 'ebur128' audio metric filter
       RMS Level metrics using the 'astats' audio metric filter
    """
    if vtt_directory and not os.path.exists(vtt_directory):
        try:
            os.makedirs(vtt_directory)
        except PermissionError:
            print(f"Error: OMT does not have permissions to create directory {vtt_directory}")
            print("Change folder permissions or target folder and try again!")
            return
        except Exception as e:
            print(f"An unexpected error occurred creating directory {vtt_directory} :: {str(e)}")
            return
    # Generate EBU R128 metrics from ametadata filter and convert ffmpeg output to an OMP VTT 1.0 file
    generate_ebur128_metrics(source_audio_file_path, vtt_directory)

    # Generate RMS level metrics with the astats filter and convert ffmpeg output to an OMP VTT 1.0 file
    generate_rms_level_metrics(source_audio_file_path, vtt_directory)


def generate_ebur128_metrics(source_audio_file_path, vtt_directory=''):
    """
    Generate EBU R128 metrics with ffmpeg:
        ffmpeg  -hide_banner \
            -i $file \
            -map 0:a:0 \
            -filter_complex ebur128=metadata=1,ametadata=direct=1:key=lavfi.r128.M:print:file=$metrics_name \
            -f null -
    """

    # If ffmpeg is none, import above failed skip generation
    if ffmpeg is None:
        print("Error: ffmpeg package not available. Skipping EBU R128 metrics generation.")
        return
    try:
        ffmpeg_metrics_file_path = Path(source_audio_file_path).stem + '.tmp'
        stream = (
            ffmpeg
            .input(source_audio_file_path)
            .filter('ebur128', metadata=1)
            .filter('ametadata', direct=1, key='lavfi.r128.M', mode='print', file=ffmpeg_metrics_file_path)
            .output('-', format='null')
        )

        stdout, stderr = stream.run(capture_stdout=True, capture_stderr=True)
        ffmpeg_logger.info(f"FFmpeg output: {stdout.decode('utf-8')}")

        print("EBU R128 metrics generated successfully")

    except ffmpeg.Error as e:
        error_message = e.stderr.decode('utf-8') if e.stderr else str(e)
        ffmpeg_error(ffmpeg_logger, error_message)
    except Exception as e:
        err_msg = str(e)
        if "ffmpeg" in err_msg.lower():
            ffmpeg_error(ffmpeg_logger, err_msg)
            return
        print(f"An unexpected error occurred: {str(e)}", file=sys.stderr)

    # Convert the ffmpeg output to an OMP VTT 1.0 file
    create_vtt_file(
        ffmpeg_metrics_file_path,
        str(Path(vtt_directory) / f'{Path(source_audio_file_path).stem}_R128_2-SEC.vtt'),
        omp_measurement='lavfi.r128.M',
        omp_comment='2-sec avg'
    )

    # ffmpeg metrics file no longer needed
    try:
        os.remove(ffmpeg_metrics_file_path)
    except PermissionError:
        print(f"Error: OMT does not have permissions to remove ffmpeg metrics directory {ffmpeg_metrics_file_path}")
        print("Folder will remain in place and must be removed manually.")
    except Exception as e:
        print(f"An unexpected error occurred removing ffmpeg metrics directory {ffmpeg_metrics_file_path} :: {str(e)}")
        print("Folder will remain in place and must be removed manually.")


def generate_rms_level_metrics(source_audio_file_path, vtt_directory=''):
    """
    Generate RMS level metrics with ffmpeg
        ffmpeg  -hide_banner \
            -i $file \
            -map 0:a:0 \
            -filter_complex astats=metadata=1:reset=1:length=1,ametadata=direct=1:key=lavfi.astats.Overall.RMS_level:print:file=$metrics_name \
            -f null -
    """

    # If ffmpeg is none, import above failed skip generation
    if ffmpeg is None:
        print("Error: ffmpeg package not available. Skipping RMS level metrics generation.")
        return
    try:
        ffmpeg_metrics_file_path = Path(source_audio_file_path).stem + '.tmp'
        stream = (
            ffmpeg
            .input(source_audio_file_path)
            .filter('astats', metadata=1, reset=1, length=1)
            .filter('ametadata', direct=1, key='lavfi.astats.Overall.RMS_level', mode='print',
                    file=ffmpeg_metrics_file_path)
            .output('-', format='null')
        )

        stdout, stderr = stream.run(capture_stdout=True, capture_stderr=True)
        ffmpeg_logger.info(f"FFmpeg output: {stdout.decode('utf-8')}")

        print("RMS Level metrics generated successfully")

    except ffmpeg.Error as e:
        error_message = e.stderr.decode('utf-8') if e.stderr else str(e)
        ffmpeg_error(ffmpeg_logger, error_message)
    except Exception as e:
        err_msg = str(e)
        if "ffmpeg" in err_msg.lower():
            ffmpeg_error(ffmpeg_logger, err_msg)
            return
        print(f"An unexpected error occurred: {str(e)}", file=sys.stderr)

    # Convert the ffmpeg output to an OMP VTT 1.0 file
    create_vtt_file(
        ffmpeg_metrics_file_path,
        str(Path(vtt_directory) / f'{Path(source_audio_file_path).stem}_RMS_2-SEC.vtt'),
        omp_measurement='lavfi.astats.Overall.RMS_level',
        omp_comment='2-sec avg')

    # ffmpeg metrics file no longer needed
    try:
        os.remove(ffmpeg_metrics_file_path)
    except PermissionError:
        print(f"Error: OMT does not have permissions to remove ffmpeg metrics directory {ffmpeg_metrics_file_path}")
        print("Folder will remain in place and must be removed manually.")
    except Exception as e:
        print(f"An unexpected error occurred removing ffmpeg metrics directory {ffmpeg_metrics_file_path} :: {str(e)}")
        print("Folder will remain in place and must be removed manually.")


def setup_audio_metrics_args(subparsers):
    audio_metrics_parser = subparsers.add_parser('audio-metrics', aliases=['a'], help='create audio metrics track')

    audio_metrics_parser.add_argument("-v", "--verbose", help="enable verbose output", action="store_true")
    audio_metrics_parser.add_argument("-i", "--input", help="input media file or directory", required=True)
    audio_metrics_parser.add_argument("-o", "--output", help="output directory", required=True)
    audio_metrics_parser.set_defaults(func=create_audio_metrics)


def create_audio_metrics(args: Namespace):
    """
    omt.py --audio-metrics -i <input file or directory> -o <output_dir>
    """
    if args.verbose:
        print(f"creating audio metrics: input \'{args.input}\' | output: \'{args.output}\'")

    if os.path.isfile(args.input):
        generate_audio_metrics(args.input, args.output)
    elif os.path.isdir(args.input):
        for entry in os.scandir(args.input):
            if entry.name.endswith('.wav') | entry.name.endswith('.aac') | entry.name.endswith('.mp4'):
                generate_audio_metrics(entry.path, args.output)
    else:
        print(f"Input {args.input} is not a valid file or directory.")
        return
