Metadata-Version: 2.4
Name: bitfieldrw
Version: 0.1.1
Summary: A Python library for reading and writing bit fields with type annotations
Project-URL: Homepage, https://github.com/DawnMagnet/bitfieldrw
Project-URL: Documentation, https://github.com/DawnMagnet/bitfieldrw#readme
Project-URL: Repository, https://github.com/DawnMagnet/bitfieldrw.git
Project-URL: Bug Tracker, https://github.com/DawnMagnet/bitfieldrw/issues
Author-email: DawnMagnet <dawnmagnet@example.com>
Maintainer-email: DawnMagnet <dawnmagnet@example.com>
License-Expression: MIT
License-File: LICENSE
Keywords: binary,bitfield,embedded,networking,protocol,serialization,struct
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Topic :: Software Development :: Embedded Systems
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: System :: Networking
Classifier: Typing :: Typed
Requires-Python: >=3.8
Provides-Extra: dev
Requires-Dist: black; extra == 'dev'
Requires-Dist: build; extra == 'dev'
Requires-Dist: mypy; extra == 'dev'
Requires-Dist: ruff; extra == 'dev'
Requires-Dist: twine; extra == 'dev'
Description-Content-Type: text/markdown

# BitFieldRW

[![PyPI version](https://badge.fury.io/py/bitfieldrw.svg)](https://badge.fury.io/py/bitfieldrw)
[![Python Support](https://img.shields.io/pypi/pyversions/bitfieldrw.svg)](https://pypi.org/project/bitfieldrw/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

ä¸€ä¸ªå¼ºå¤§ä¸”æ˜“äºä½¿ç”¨çš„ Python ä½å­—æ®µè¯»å†™åº“ï¼Œæ”¯æŒç±»å‹æ³¨è§£å’Œå¤§ç«¯åºä½å¸ƒå±€ã€‚

## ç‰¹æ€§

- ğŸš€ **ç±»å‹å®‰å…¨**: ä½¿ç”¨ Python ç±»å‹æ³¨è§£å®šä¹‰ä½å­—æ®µç»“æ„
- ğŸ“¦ **å¤šç§æ•°æ®ç±»å‹**: æ”¯æŒæœ‰ç¬¦å·/æ— ç¬¦å·æ•´æ•°ã€æµ®ç‚¹æ•°
- ğŸ”§ **åµŒå¥—ç»“æ„**: æ”¯æŒä½å­—æ®µç»“æ„çš„åµŒå¥—
- ğŸ”„ **å­—èŠ‚åºæ”¯æŒ**: æ”¯æŒå¤§ç«¯åºå’Œå°ç«¯åº
- âœ… **å®Œæ•´æµ‹è¯•**: åŒ…å«å…¨é¢çš„æµ‹è¯•ç”¨ä¾‹
- ğŸ“ **æ¸…æ™° API**: ç›´è§‚æ˜“æ‡‚çš„æ¥å£è®¾è®¡

## å®‰è£…

```bash
pip install bitfieldrw
```

## å¿«é€Ÿå¼€å§‹

### åŸºæœ¬ç”¨æ³•

```python
from bitfieldrw import bitfield, BitFieldMixin, Uint, Int, Float

@bitfield
class NetworkPacket(BitFieldMixin):
    version: Uint[4]      # 4ä½ç‰ˆæœ¬å·
    header_len: Uint[4]   # 4ä½å¤´é•¿åº¦
    type_of_service: Uint[8]  # 8ä½æœåŠ¡ç±»å‹
    total_length: Uint[16]    # 16ä½æ€»é•¿åº¦

# åˆ›å»ºå®ä¾‹
packet = NetworkPacket()
packet.version = 4
packet.header_len = 5
packet.type_of_service = 0
packet.total_length = 1500

# è½¬æ¢ä¸ºå­—èŠ‚
data = packet.to_bytes()  # é»˜è®¤å¤§ç«¯åº
print(f"Packed bytes: {data.hex()}")

# ä»å­—èŠ‚åŠ è½½
new_packet = NetworkPacket()
new_packet.from_bytes(data)
print(f"Version: {new_packet.version}")
print(f"Total length: {new_packet.total_length}")
```

### æ”¯æŒçš„æ•°æ®ç±»å‹

```python
@bitfield
class DataTypes(BitFieldMixin):
    unsigned_int: Uint[8]     # æ— ç¬¦å·æ•´æ•° (0-255)
    signed_int: Int[8]        # æœ‰ç¬¦å·æ•´æ•° (-128 åˆ° 127)
    float_val: Float[32]      # 32ä½æµ®ç‚¹æ•°

data = DataTypes()
data.unsigned_int = 255
data.signed_int = -50
data.float_val = 3.14159
```

### åµŒå¥—ç»“æ„

```python
@bitfield
class Header(BitFieldMixin):
    magic: Uint[16]
    version: Uint[8]

@bitfield
class Message(BitFieldMixin):
    header: Header           # åµŒå¥—çš„ä½å­—æ®µç»“æ„
    payload_length: Uint[16]
    flags: Uint[8]

msg = Message()
msg.header.magic = 0xABCD
msg.header.version = 1
msg.payload_length = 1024
msg.flags = 0x80
```

### å­—èŠ‚åºæ”¯æŒ

```python
# å¤§ç«¯åº (é»˜è®¤)
big_endian_data = packet.to_bytes(byteorder="big")

# å°ç«¯åº
little_endian_data = packet.to_bytes(byteorder="little")

# ä»å­—èŠ‚åŠ è½½æ—¶æŒ‡å®šå­—èŠ‚åº
packet.from_bytes(data, byteorder="little")
```

### ä¸åŸå§‹æ•´æ•°äº’è½¬

```python
# è½¬æ¢ä¸ºæ•´æ•°
raw_value = packet.to_int()

# ä»æ•´æ•°åŠ è½½
packet.from_int(0x12345678)
```

## API å‚è€ƒ

### æ•°æ®ç±»å‹

- `Uint[n]`: n ä½æ— ç¬¦å·æ•´æ•°
- `Int[n]`: n ä½æœ‰ç¬¦å·æ•´æ•°ï¼ˆäºŒè¿›åˆ¶è¡¥ç ï¼‰
- `Float[32]`: 32 ä½ IEEE 754 æµ®ç‚¹æ•°

### ä¸»è¦æ–¹æ³•

- `to_bytes(byteorder="big")`: è½¬æ¢ä¸ºå­—èŠ‚ä¸²
- `from_bytes(data, byteorder="big")`: ä»å­—èŠ‚ä¸²åŠ è½½
- `to_int()`: è½¬æ¢ä¸ºåŸå§‹æ•´æ•°
- `from_int(value)`: ä»æ•´æ•°åŠ è½½
- `get_bit_length()`: è·å–æ€»ä½é•¿åº¦
- `get_byte_length()`: è·å–å­—èŠ‚é•¿åº¦ï¼ˆå‘ä¸Šå–æ•´ï¼‰

## ä½å¸ƒå±€

BitFieldRW ä½¿ç”¨å¤§ç«¯åºä½å¸ƒå±€ï¼Œå­—æ®µæŒ‰ç…§å®šä¹‰é¡ºåºä»é«˜ä½åˆ°ä½ä½æ’åˆ—ï¼š

```python
@bitfield
class Example(BitFieldMixin):
    field_a: Uint[4]  # ä½ 15-12
    field_b: Uint[8]  # ä½ 11-4
    field_c: Uint[4]  # ä½ 3-0
```

## åº”ç”¨åœºæ™¯

- ğŸ“¡ **ç½‘ç»œåè®®**: è§£æå’Œæ„é€ ç½‘ç»œæ•°æ®åŒ…
- ğŸ’¾ **æ–‡ä»¶æ ¼å¼**: å¤„ç†äºŒè¿›åˆ¶æ–‡ä»¶æ ¼å¼
- ğŸ”§ **ç¡¬ä»¶æ¥å£**: ä¸åµŒå…¥å¼è®¾å¤‡é€šä¿¡
- ğŸ® **æ¸¸æˆå¼€å‘**: å¤„ç†ç´§å‡‘çš„æ•°æ®ç»“æ„
- ğŸ“Š **æ•°æ®å‹ç¼©**: é«˜æ•ˆå­˜å‚¨æ ‡å¿—ä½å’Œå°æ•´æ•°

## å¼€å‘

### GitHub Actions å·¥ä½œæµ

é¡¹ç›®ä½¿ç”¨ GitHub Actions è¿›è¡ŒæŒç»­é›†æˆå’Œè‡ªåŠ¨å‘å¸ƒï¼š

- **æµ‹è¯•**: åœ¨å¤šä¸ª Python ç‰ˆæœ¬ (3.8-3.13) ä¸Šè¿è¡Œæµ‹è¯•
- **ä»£ç è´¨é‡**: ä½¿ç”¨ ruffã€mypy å’Œ black è¿›è¡Œä»£ç æ£€æŸ¥
- **è‡ªåŠ¨å‘å¸ƒ**:
  - æ¨é€åˆ° `main` æˆ– `develop` åˆ†æ”¯æ—¶è‡ªåŠ¨å‘å¸ƒåˆ° TestPyPI
  - åˆ›å»º GitHub Release æ—¶è‡ªåŠ¨å‘å¸ƒåˆ°æ­£å¼ PyPI

### æœ¬åœ°å¼€å‘

ä½¿ç”¨ `uv` è¿›è¡Œä¾èµ–ç®¡ç†ï¼š

```bash
# å®‰è£…ä¾èµ–
uv sync --dev

# è¿è¡Œæµ‹è¯•
uv run python -m unittest discover tests -v

# ä»£ç æ£€æŸ¥
uv run ruff check .
uv run mypy bitfieldrw

# æ ¼å¼åŒ–ä»£ç 
uv run black .

# æ„å»ºåŒ…
uv build
```

## è®¸å¯è¯

MIT License - è¯¦è§ [LICENSE](LICENSE) æ–‡ä»¶ã€‚

## è´¡çŒ®

æ¬¢è¿æäº¤ issue å’Œ pull requestï¼

## æ›´æ–°æ—¥å¿—

### 0.1.0

- åˆå§‹ç‰ˆæœ¬å‘å¸ƒ
- æ”¯æŒåŸºæœ¬ä½å­—æ®µæ“ä½œ
- æ”¯æŒåµŒå¥—ç»“æ„
- å®Œæ•´çš„æµ‹è¯•è¦†ç›–
