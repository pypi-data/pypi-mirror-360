from __future__ import annotations

import datetime
from types import TracebackType
from typing import Any

from wrapt import ObjectProxy

from coredis import PureToken
from coredis.client import Client, RedisCluster
from coredis.commands.script import Script
from coredis.typing import (
    AnyStr,
    Generic,
    KeyT,
    Literal,
    Mapping,
    Parameters,
    StringT,
    ValueT,
)

# TODO: remove this once mypy can disambiguate class method names
#  from builtin types. ``set`` is a redis commands with
#  an associated method that clashes with the set[] type.
_Set = set

class Pipeline(ObjectProxy, Generic[AnyStr]):  # type: ignore
    scripts: set[Script[AnyStr]]
    @classmethod
    def proxy(
        cls,
        client: "Client[AnyStr]",
        transaction: "bool | None",
        watches: "Parameters[KeyT] | None" = ...,
        timeout: "float | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def watch(self, *keys: "KeyT") -> bool: ...
    async def unwatch(self) -> bool: ...
    def multi(self) -> None: ...
    async def execute(self, raise_on_error: "bool" = ...) -> tuple[Any, ...]: ...
    async def __aenter__(self) -> "Pipeline[AnyStr]": ...
    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None: ...
    async def copy(
        self,
        source: "KeyT",
        destination: "KeyT",
        db: "int | None" = ...,
        replace: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def delete(self, keys: "Parameters[KeyT]") -> Pipeline[AnyStr]: ...
    async def dump(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def exists(self, keys: "Parameters[KeyT]") -> Pipeline[AnyStr]: ...
    async def expire(
        self,
        key: "KeyT",
        seconds: "int | datetime.timedelta",
        condition: "Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def expireat(
        self,
        key: "KeyT",
        unix_time_seconds: "int | datetime.datetime",
        condition: "Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def expiretime(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def keys(self, pattern: "StringT" = ...) -> Pipeline[AnyStr]: ...
    async def migrate(
        self,
        host: "StringT",
        port: "int",
        destination_db: "int",
        timeout: "int",
        *keys: "KeyT",
        copy: "bool | None" = ...,
        replace: "bool | None" = ...,
        auth: "StringT | None" = ...,
        username: "StringT | None" = ...,
        password: "StringT | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def move(self, key: "KeyT", db: "int") -> Pipeline[AnyStr]: ...
    async def object_encoding(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def object_freq(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def object_idletime(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def object_refcount(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def persist(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def pexpire(
        self,
        key: "KeyT",
        milliseconds: "int | datetime.timedelta",
        condition: "Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def pexpireat(
        self,
        key: "KeyT",
        unix_time_milliseconds: "int | datetime.datetime",
        condition: "Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def pexpiretime(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def pttl(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def randomkey(self) -> Pipeline[AnyStr]: ...
    async def rename(self, key: "KeyT", newkey: "KeyT") -> Pipeline[AnyStr]: ...
    async def renamenx(self, key: "KeyT", newkey: "KeyT") -> Pipeline[AnyStr]: ...
    async def restore(
        self,
        key: "KeyT",
        ttl: "int | datetime.timedelta | datetime.datetime",
        serialized_value: "bytes",
        replace: "bool | None" = ...,
        absttl: "bool | None" = ...,
        idletime: "int | datetime.timedelta | None" = ...,
        freq: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def scan(
        self,
        cursor: "int | None" = ...,
        match: "StringT | None" = ...,
        count: "int | None" = ...,
        type_: "StringT | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def sort(
        self,
        key: "KeyT",
        gets: "Parameters[KeyT] | None" = ...,
        by: "StringT | None" = ...,
        offset: "int | None" = ...,
        count: "int | None" = ...,
        order: "Literal[PureToken.ASC, PureToken.DESC] | None" = ...,
        alpha: "bool | None" = ...,
        store: "KeyT | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def sort_ro(
        self,
        key: "KeyT",
        gets: "Parameters[KeyT] | None" = ...,
        by: "StringT | None" = ...,
        offset: "int | None" = ...,
        count: "int | None" = ...,
        order: "Literal[PureToken.ASC, PureToken.DESC] | None" = ...,
        alpha: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def touch(self, keys: "Parameters[KeyT]") -> Pipeline[AnyStr]: ...
    async def ttl(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def type(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def unlink(self, keys: "Parameters[KeyT]") -> Pipeline[AnyStr]: ...
    async def wait(self, numreplicas: "int", timeout: "int") -> Pipeline[AnyStr]: ...
    async def waitaof(
        self, numlocal: "int", numreplicas: "int", timeout: "int"
    ) -> Pipeline[AnyStr]: ...
    async def append(self, key: "KeyT", value: "ValueT") -> Pipeline[AnyStr]: ...
    async def decr(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def decrby(self, key: "KeyT", decrement: "int") -> Pipeline[AnyStr]: ...
    async def get(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def getdel(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def getex(
        self,
        key: "KeyT",
        ex: "int | datetime.timedelta | None" = ...,
        px: "int | datetime.timedelta | None" = ...,
        exat: "int | datetime.datetime | None" = ...,
        pxat: "int | datetime.datetime | None" = ...,
        persist: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def getrange(self, key: "KeyT", start: "int", end: "int") -> Pipeline[AnyStr]: ...
    async def getset(self, key: "KeyT", value: "ValueT") -> Pipeline[AnyStr]: ...
    async def incr(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def incrby(self, key: "KeyT", increment: "int") -> Pipeline[AnyStr]: ...
    async def incrbyfloat(self, key: "KeyT", increment: "int | float") -> Pipeline[AnyStr]: ...
    async def lcs(
        self,
        key1: "KeyT",
        key2: "KeyT",
        len_: "bool | None" = ...,
        idx: "bool | None" = ...,
        minmatchlen: "int | None" = ...,
        withmatchlen: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def mget(self, keys: "Parameters[KeyT]") -> Pipeline[AnyStr]: ...
    async def mset(self, key_values: "Mapping[KeyT, ValueT]") -> Pipeline[AnyStr]: ...
    async def msetnx(self, key_values: "Mapping[KeyT, ValueT]") -> Pipeline[AnyStr]: ...
    async def psetex(
        self, key: "KeyT", milliseconds: "int | datetime.timedelta", value: "ValueT"
    ) -> Pipeline[AnyStr]: ...
    async def set(
        self,
        key: "KeyT",
        value: "ValueT",
        condition: "Literal[PureToken.NX, PureToken.XX] | None" = ...,
        get: "bool | None" = ...,
        ex: "int | datetime.timedelta | None" = ...,
        px: "int | datetime.timedelta | None" = ...,
        exat: "int | datetime.datetime | None" = ...,
        pxat: "int | datetime.datetime | None" = ...,
        keepttl: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def setex(
        self, key: "KeyT", value: "ValueT", seconds: "int | datetime.timedelta"
    ) -> Pipeline[AnyStr]: ...
    async def setnx(self, key: "KeyT", value: "ValueT") -> Pipeline[AnyStr]: ...
    async def setrange(self, key: "KeyT", offset: "int", value: "ValueT") -> Pipeline[AnyStr]: ...
    async def strlen(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def substr(self, key: "KeyT", start: "int", end: "int") -> Pipeline[AnyStr]: ...
    async def bitcount(
        self,
        key: "KeyT",
        start: "int | None" = ...,
        end: "int | None" = ...,
        index_unit: "Literal[PureToken.BIT, PureToken.BYTE] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def bitop(
        self, keys: "Parameters[KeyT]", operation: "StringT", destkey: "KeyT"
    ) -> Pipeline[AnyStr]: ...
    async def bitpos(
        self,
        key: "KeyT",
        bit: "int",
        start: "int | None" = ...,
        end: "int | None" = ...,
        index_unit: "Literal[PureToken.BIT, PureToken.BYTE] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def getbit(self, key: "KeyT", offset: "int") -> Pipeline[AnyStr]: ...
    async def setbit(self, key: "KeyT", offset: "int", value: "int") -> Pipeline[AnyStr]: ...
    async def hdel(self, key: "KeyT", fields: "Parameters[StringT]") -> Pipeline[AnyStr]: ...
    async def hexists(self, key: "KeyT", field: "StringT") -> Pipeline[AnyStr]: ...
    async def hexpire(
        self,
        key: "KeyT",
        seconds: "int | datetime.timedelta",
        fields: "Parameters[StringT]",
        condition: "Literal[PureToken.GT, PureToken.LT, PureToken.NX, PureToken.XX] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def hexpireat(
        self,
        key: "KeyT",
        unix_time_seconds: "int | datetime.datetime",
        fields: "Parameters[StringT]",
        condition: "Literal[PureToken.GT, PureToken.LT, PureToken.NX, PureToken.XX] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def hexpiretime(self, key: "KeyT", fields: "Parameters[StringT]") -> Pipeline[AnyStr]: ...
    async def hget(self, key: "KeyT", field: "StringT") -> Pipeline[AnyStr]: ...
    async def hgetall(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def hincrby(
        self, key: "KeyT", field: "StringT", increment: "int"
    ) -> Pipeline[AnyStr]: ...
    async def hincrbyfloat(
        self, key: "KeyT", field: "StringT", increment: "int | float"
    ) -> Pipeline[AnyStr]: ...
    async def hkeys(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def hlen(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def hmget(self, key: "KeyT", fields: "Parameters[StringT]") -> Pipeline[AnyStr]: ...
    async def hmset(
        self, key: "KeyT", field_values: "Mapping[StringT, ValueT]"
    ) -> Pipeline[AnyStr]: ...
    async def hpersist(self, key: "KeyT", fields: "Parameters[StringT]") -> Pipeline[AnyStr]: ...
    async def hpexpire(
        self,
        key: "KeyT",
        milliseconds: "int | datetime.timedelta",
        fields: "Parameters[StringT]",
        condition: "Literal[PureToken.GT, PureToken.LT, PureToken.NX, PureToken.XX] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def hpexpireat(
        self,
        key: "KeyT",
        unix_time_milliseconds: "int | datetime.datetime",
        fields: "Parameters[StringT]",
        condition: "Literal[PureToken.GT, PureToken.LT, PureToken.NX, PureToken.XX] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def hpexpiretime(
        self, key: "KeyT", fields: "Parameters[StringT]"
    ) -> Pipeline[AnyStr]: ...
    async def hpttl(self, key: "KeyT", fields: "Parameters[StringT]") -> Pipeline[AnyStr]: ...
    async def hrandfield(
        self, key: "KeyT", count: "int | None" = ..., withvalues: "bool | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def hscan(
        self,
        key: "KeyT",
        cursor: "int | None" = ...,
        match: "StringT | None" = ...,
        count: "int | None" = ...,
        novalues: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def hset(
        self, key: "KeyT", field_values: "Mapping[StringT, ValueT]"
    ) -> Pipeline[AnyStr]: ...
    async def hsetnx(self, key: "KeyT", field: "StringT", value: "ValueT") -> Pipeline[AnyStr]: ...
    async def hstrlen(self, key: "KeyT", field: "StringT") -> Pipeline[AnyStr]: ...
    async def httl(self, key: "KeyT", fields: "Parameters[StringT]") -> Pipeline[AnyStr]: ...
    async def hvals(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def blmove(
        self,
        source: "KeyT",
        destination: "KeyT",
        wherefrom: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        whereto: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        timeout: "int | float",
    ) -> Pipeline[AnyStr]: ...
    async def blmpop(
        self,
        keys: "Parameters[KeyT]",
        timeout: "int | float",
        where: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        count: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def blpop(self, keys: "Parameters[KeyT]", timeout: "int | float") -> Pipeline[AnyStr]: ...
    async def brpop(self, keys: "Parameters[KeyT]", timeout: "int | float") -> Pipeline[AnyStr]: ...
    async def brpoplpush(
        self, source: "KeyT", destination: "KeyT", timeout: "int | float"
    ) -> Pipeline[AnyStr]: ...
    async def lindex(self, key: "KeyT", index: "int") -> Pipeline[AnyStr]: ...
    async def linsert(
        self,
        key: "KeyT",
        where: "Literal[PureToken.AFTER, PureToken.BEFORE]",
        pivot: "ValueT",
        element: "ValueT",
    ) -> Pipeline[AnyStr]: ...
    async def llen(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def lmove(
        self,
        source: "KeyT",
        destination: "KeyT",
        wherefrom: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        whereto: "Literal[PureToken.LEFT, PureToken.RIGHT]",
    ) -> Pipeline[AnyStr]: ...
    async def lmpop(
        self,
        keys: "Parameters[KeyT]",
        where: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        count: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def lpop(self, key: "KeyT", count: "int | None" = ...) -> Pipeline[AnyStr]: ...
    async def lpos(
        self,
        key: "KeyT",
        element: "ValueT",
        rank: "int | None" = ...,
        count: "int | None" = ...,
        maxlen: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def lpush(self, key: "KeyT", elements: "Parameters[ValueT]") -> Pipeline[AnyStr]: ...
    async def lpushx(self, key: "KeyT", elements: "Parameters[ValueT]") -> Pipeline[AnyStr]: ...
    async def lrange(self, key: "KeyT", start: "int", stop: "int") -> Pipeline[AnyStr]: ...
    async def lrem(self, key: "KeyT", count: "int", element: "ValueT") -> Pipeline[AnyStr]: ...
    async def lset(self, key: "KeyT", index: "int", element: "ValueT") -> Pipeline[AnyStr]: ...
    async def ltrim(self, key: "KeyT", start: "int", stop: "int") -> Pipeline[AnyStr]: ...
    async def rpop(self, key: "KeyT", count: "int | None" = ...) -> Pipeline[AnyStr]: ...
    async def rpoplpush(self, source: "KeyT", destination: "KeyT") -> Pipeline[AnyStr]: ...
    async def rpush(self, key: "KeyT", elements: "Parameters[ValueT]") -> Pipeline[AnyStr]: ...
    async def rpushx(self, key: "KeyT", elements: "Parameters[ValueT]") -> Pipeline[AnyStr]: ...
    async def sadd(self, key: "KeyT", members: "Parameters[ValueT]") -> Pipeline[AnyStr]: ...
    async def scard(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def sdiff(self, keys: "Parameters[KeyT]") -> Pipeline[AnyStr]: ...
    async def sdiffstore(
        self, keys: "Parameters[KeyT]", destination: "KeyT"
    ) -> Pipeline[AnyStr]: ...
    async def sinter(self, keys: "Parameters[KeyT]") -> Pipeline[AnyStr]: ...
    async def sintercard(
        self, keys: "Parameters[KeyT]", limit: "int | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def sinterstore(
        self, keys: "Parameters[KeyT]", destination: "KeyT"
    ) -> Pipeline[AnyStr]: ...
    async def sismember(self, key: "KeyT", member: "ValueT") -> Pipeline[AnyStr]: ...
    async def smembers(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def smismember(self, key: "KeyT", members: "Parameters[ValueT]") -> Pipeline[AnyStr]: ...
    async def smove(
        self, source: "KeyT", destination: "KeyT", member: "ValueT"
    ) -> Pipeline[AnyStr]: ...
    async def spop(self, key: "KeyT", count: "int | None" = ...) -> Pipeline[AnyStr]: ...
    async def srandmember(self, key: "KeyT", count: "int | None" = ...) -> Pipeline[AnyStr]: ...
    async def srem(self, key: "KeyT", members: "Parameters[ValueT]") -> Pipeline[AnyStr]: ...
    async def sscan(
        self,
        key: "KeyT",
        cursor: "int | None" = ...,
        match: "StringT | None" = ...,
        count: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def sunion(self, keys: "Parameters[KeyT]") -> Pipeline[AnyStr]: ...
    async def sunionstore(
        self, keys: "Parameters[KeyT]", destination: "KeyT"
    ) -> Pipeline[AnyStr]: ...
    async def bzmpop(
        self,
        keys: "Parameters[KeyT]",
        timeout: "int | float",
        where: "Literal[PureToken.MAX, PureToken.MIN]",
        count: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def bzpopmax(
        self, keys: "Parameters[KeyT]", timeout: "int | float"
    ) -> Pipeline[AnyStr]: ...
    async def bzpopmin(
        self, keys: "Parameters[KeyT]", timeout: "int | float"
    ) -> Pipeline[AnyStr]: ...
    async def zadd(
        self,
        key: "KeyT",
        member_scores: "Mapping[StringT, int | float]",
        condition: "Literal[PureToken.NX, PureToken.XX] | None" = ...,
        comparison: "Literal[PureToken.GT, PureToken.LT] | None" = ...,
        change: "bool | None" = ...,
        increment: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def zcard(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def zcount(self, key: "KeyT", min_: "ValueT", max_: "ValueT") -> Pipeline[AnyStr]: ...
    async def zdiff(
        self, keys: "Parameters[KeyT]", withscores: "bool | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def zdiffstore(
        self, keys: "Parameters[KeyT]", destination: "KeyT"
    ) -> Pipeline[AnyStr]: ...
    async def zincrby(
        self, key: "KeyT", member: "ValueT", increment: "int"
    ) -> Pipeline[AnyStr]: ...
    async def zinter(
        self,
        keys: "Parameters[KeyT]",
        weights: "Parameters[int] | None" = ...,
        aggregate: "Literal[PureToken.MAX, PureToken.MIN, PureToken.SUM] | None" = ...,
        withscores: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def zintercard(
        self, keys: "Parameters[KeyT]", limit: "int | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def zinterstore(
        self,
        keys: "Parameters[KeyT]",
        destination: "KeyT",
        weights: "Parameters[int] | None" = ...,
        aggregate: "Literal[PureToken.MAX, PureToken.MIN, PureToken.SUM] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def zlexcount(self, key: "KeyT", min_: "ValueT", max_: "ValueT") -> Pipeline[AnyStr]: ...
    async def zmpop(
        self,
        keys: "Parameters[KeyT]",
        where: "Literal[PureToken.MAX, PureToken.MIN]",
        count: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def zmscore(self, key: "KeyT", members: "Parameters[ValueT]") -> Pipeline[AnyStr]: ...
    async def zpopmax(self, key: "KeyT", count: "int | None" = ...) -> Pipeline[AnyStr]: ...
    async def zpopmin(self, key: "KeyT", count: "int | None" = ...) -> Pipeline[AnyStr]: ...
    async def zrandmember(
        self, key: "KeyT", count: "int | None" = ..., withscores: "bool | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def zrange(
        self,
        key: "KeyT",
        min_: "int | ValueT",
        max_: "int | ValueT",
        sortby: "Literal[PureToken.BYSCORE, PureToken.BYLEX] | None" = ...,
        rev: "bool | None" = ...,
        offset: "int | None" = ...,
        count: "int | None" = ...,
        withscores: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def zrangebylex(
        self,
        key: "KeyT",
        min_: "ValueT",
        max_: "ValueT",
        offset: "int | None" = ...,
        count: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def zrangebyscore(
        self,
        key: "KeyT",
        min_: "int | float",
        max_: "int | float",
        withscores: "bool | None" = ...,
        offset: "int | None" = ...,
        count: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def zrangestore(
        self,
        dst: "KeyT",
        src: "KeyT",
        min_: "int | ValueT",
        max_: "int | ValueT",
        sortby: "Literal[PureToken.BYSCORE, PureToken.BYLEX] | None" = ...,
        rev: "bool | None" = ...,
        offset: "int | None" = ...,
        count: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def zrank(
        self, key: "KeyT", member: "ValueT", withscore: "bool | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def zrem(self, key: "KeyT", members: "Parameters[ValueT]") -> Pipeline[AnyStr]: ...
    async def zremrangebylex(
        self, key: "KeyT", min_: "ValueT", max_: "ValueT"
    ) -> Pipeline[AnyStr]: ...
    async def zremrangebyrank(self, key: "KeyT", start: "int", stop: "int") -> Pipeline[AnyStr]: ...
    async def zremrangebyscore(
        self, key: "KeyT", min_: "int | float", max_: "int | float"
    ) -> Pipeline[AnyStr]: ...
    async def zrevrange(
        self, key: "KeyT", start: "int", stop: "int", withscores: "bool | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def zrevrangebylex(
        self,
        key: "KeyT",
        max_: "ValueT",
        min_: "ValueT",
        offset: "int | None" = ...,
        count: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def zrevrangebyscore(
        self,
        key: "KeyT",
        max_: "int | float",
        min_: "int | float",
        withscores: "bool | None" = ...,
        offset: "int | None" = ...,
        count: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def zrevrank(
        self, key: "KeyT", member: "ValueT", withscore: "bool | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def zscan(
        self,
        key: "KeyT",
        cursor: "int | None" = ...,
        match: "StringT | None" = ...,
        count: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def zscore(self, key: "KeyT", member: "ValueT") -> Pipeline[AnyStr]: ...
    async def zunion(
        self,
        keys: "Parameters[KeyT]",
        weights: "Parameters[int] | None" = ...,
        aggregate: "Literal[PureToken.SUM, PureToken.MIN, PureToken.MAX] | None" = ...,
        withscores: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def zunionstore(
        self,
        keys: "Parameters[KeyT]",
        destination: "KeyT",
        weights: "Parameters[int] | None" = ...,
        aggregate: "Literal[PureToken.SUM, PureToken.MIN, PureToken.MAX] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def pfadd(self, key: "KeyT", *elements: "ValueT") -> Pipeline[AnyStr]: ...
    async def pfcount(self, keys: "Parameters[KeyT]") -> Pipeline[AnyStr]: ...
    async def pfmerge(
        self, destkey: "KeyT", sourcekeys: "Parameters[KeyT]"
    ) -> Pipeline[AnyStr]: ...
    async def geoadd(
        self,
        key: "KeyT",
        longitude_latitude_members: "Parameters[tuple[int | float, int | float, ValueT]]",
        condition: "Literal[PureToken.NX, PureToken.XX] | None" = ...,
        change: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def geodist(
        self,
        key: "KeyT",
        member1: "StringT",
        member2: "StringT",
        unit: "Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def geohash(self, key: "KeyT", members: "Parameters[ValueT]") -> Pipeline[AnyStr]: ...
    async def geopos(self, key: "KeyT", members: "Parameters[ValueT]") -> Pipeline[AnyStr]: ...
    async def georadius(
        self,
        key: "KeyT",
        longitude: "int | float",
        latitude: "int | float",
        radius: "int | float",
        unit: "Literal[PureToken.FT, PureToken.KM, PureToken.M, PureToken.MI]",
        withcoord: "bool | None" = ...,
        withdist: "bool | None" = ...,
        withhash: "bool | None" = ...,
        count: "int | None" = ...,
        any_: "bool | None" = ...,
        order: "Literal[PureToken.ASC, PureToken.DESC] | None" = ...,
        store: "KeyT | None" = ...,
        storedist: "KeyT | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def georadiusbymember(
        self,
        key: "KeyT",
        member: "ValueT",
        radius: "int | float",
        unit: "Literal[PureToken.FT, PureToken.KM, PureToken.M, PureToken.MI]",
        withcoord: "bool | None" = ...,
        withdist: "bool | None" = ...,
        withhash: "bool | None" = ...,
        count: "int | None" = ...,
        any_: "bool | None" = ...,
        order: "Literal[PureToken.ASC, PureToken.DESC] | None" = ...,
        store: "KeyT | None" = ...,
        storedist: "KeyT | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def geosearch(
        self,
        key: "KeyT",
        member: "ValueT | None" = ...,
        longitude: "int | float | None" = ...,
        latitude: "int | float | None" = ...,
        radius: "int | float | None" = ...,
        circle_unit: "None | Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]" = ...,
        width: "int | float | None" = ...,
        height: "int | float | None" = ...,
        box_unit: "Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI] | None" = ...,
        order: "Literal[PureToken.ASC, PureToken.DESC] | None" = ...,
        count: "int | None" = ...,
        any_: "bool | None" = ...,
        withcoord: "bool | None" = ...,
        withdist: "bool | None" = ...,
        withhash: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def geosearchstore(
        self,
        destination: "KeyT",
        source: "KeyT",
        member: "ValueT | None" = ...,
        longitude: "int | float | None" = ...,
        latitude: "int | float | None" = ...,
        radius: "int | float | None" = ...,
        circle_unit: "None | Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]" = ...,
        width: "int | float | None" = ...,
        height: "int | float | None" = ...,
        box_unit: "Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI] | None" = ...,
        order: "Literal[PureToken.ASC, PureToken.DESC] | None" = ...,
        count: "int | None" = ...,
        any_: "bool | None" = ...,
        storedist: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def xack(
        self, key: "KeyT", group: "StringT", identifiers: "Parameters[ValueT]"
    ) -> Pipeline[AnyStr]: ...
    async def xadd(
        self,
        key: "KeyT",
        field_values: "Mapping[StringT, ValueT]",
        identifier: "ValueT | None" = ...,
        nomkstream: "bool | None" = ...,
        trim_strategy: "Literal[PureToken.MAXLEN, PureToken.MINID] | None" = ...,
        threshold: "int | None" = ...,
        trim_operator: "Literal[PureToken.EQUAL, PureToken.APPROXIMATELY] | None" = ...,
        limit: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def xautoclaim(
        self,
        key: "KeyT",
        group: "StringT",
        consumer: "StringT",
        min_idle_time: "int | datetime.timedelta",
        start: "ValueT",
        count: "int | None" = ...,
        justid: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def xclaim(
        self,
        key: "KeyT",
        group: "StringT",
        consumer: "StringT",
        min_idle_time: "int | datetime.timedelta",
        identifiers: "Parameters[ValueT]",
        idle: "int | datetime.timedelta | None" = ...,
        time: "int | datetime.datetime | None" = ...,
        retrycount: "int | None" = ...,
        force: "bool | None" = ...,
        justid: "bool | None" = ...,
        lastid: "ValueT | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def xdel(self, key: "KeyT", identifiers: "Parameters[ValueT]") -> Pipeline[AnyStr]: ...
    async def xgroup_create(
        self,
        key: "KeyT",
        groupname: "StringT",
        identifier: "ValueT | None" = ...,
        mkstream: "bool | None" = ...,
        entriesread: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def xgroup_createconsumer(
        self, key: "KeyT", groupname: "StringT", consumername: "StringT"
    ) -> Pipeline[AnyStr]: ...
    async def xgroup_delconsumer(
        self, key: "KeyT", groupname: "StringT", consumername: "StringT"
    ) -> Pipeline[AnyStr]: ...
    async def xgroup_destroy(self, key: "KeyT", groupname: "StringT") -> Pipeline[AnyStr]: ...
    async def xgroup_setid(
        self,
        key: "KeyT",
        groupname: "StringT",
        identifier: "ValueT | None" = ...,
        entriesread: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def xinfo_consumers(self, key: "KeyT", groupname: "StringT") -> Pipeline[AnyStr]: ...
    async def xinfo_groups(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def xinfo_stream(
        self, key: "KeyT", full: "bool | None" = ..., count: "int | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def xlen(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def xpending(
        self,
        key: "KeyT",
        group: "StringT",
        start: "ValueT | None" = ...,
        end: "ValueT | None" = ...,
        count: "int | None" = ...,
        idle: "int | None" = ...,
        consumer: "StringT | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def xrange(
        self,
        key: "KeyT",
        start: "ValueT | None" = ...,
        end: "ValueT | None" = ...,
        count: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def xread(
        self,
        streams: "Mapping[ValueT, ValueT]",
        count: "int | None" = ...,
        block: "int | datetime.timedelta | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def xreadgroup(
        self,
        group: "StringT",
        consumer: "StringT",
        streams: "Mapping[ValueT, ValueT]",
        count: "int | None" = ...,
        block: "int | datetime.timedelta | None" = ...,
        noack: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def xrevrange(
        self,
        key: "KeyT",
        end: "ValueT | None" = ...,
        start: "ValueT | None" = ...,
        count: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def xtrim(
        self,
        key: "KeyT",
        trim_strategy: "Literal[PureToken.MAXLEN, PureToken.MINID]",
        threshold: "int",
        trim_operator: "Literal[PureToken.EQUAL, PureToken.APPROXIMATELY] | None" = ...,
        limit: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def eval(
        self,
        script: "StringT",
        keys: "Parameters[KeyT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def evalsha(
        self,
        sha1: "StringT",
        keys: "Parameters[KeyT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def evalsha_ro(
        self,
        sha1: "StringT",
        keys: "Parameters[KeyT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def eval_ro(
        self,
        script: "StringT",
        keys: "Parameters[KeyT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def fcall(
        self,
        function: "StringT",
        keys: "Parameters[KeyT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def fcall_ro(
        self,
        function: "StringT",
        keys: "Parameters[KeyT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def function_delete(self, library_name: "StringT") -> Pipeline[AnyStr]: ...
    async def function_dump(self) -> Pipeline[AnyStr]: ...
    async def function_flush(
        self, async_: "Literal[PureToken.ASYNC, PureToken.SYNC] | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def function_kill(self) -> Pipeline[AnyStr]: ...
    async def function_list(
        self, libraryname: "StringT | None" = ..., withcode: "bool | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def function_load(
        self, function_code: "StringT", replace: "bool | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def function_restore(
        self,
        serialized_value: "bytes",
        policy: "Literal[PureToken.FLUSH, PureToken.APPEND, PureToken.REPLACE] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def function_stats(self) -> Pipeline[AnyStr]: ...
    async def script_debug(
        self, mode: "Literal[PureToken.NO, PureToken.SYNC, PureToken.YES]"
    ) -> Pipeline[AnyStr]: ...
    async def script_exists(self, sha1s: "Parameters[StringT]") -> Pipeline[AnyStr]: ...
    async def script_flush(
        self, sync_type: "Literal[PureToken.ASYNC, PureToken.SYNC] | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def script_kill(self) -> Pipeline[AnyStr]: ...
    async def script_load(self, script: "StringT") -> Pipeline[AnyStr]: ...
    async def publish(self, channel: "StringT", message: "ValueT") -> Pipeline[AnyStr]: ...
    async def pubsub_channels(self, pattern: "StringT | None" = ...) -> Pipeline[AnyStr]: ...
    async def pubsub_numpat(self) -> Pipeline[AnyStr]: ...
    async def pubsub_numsub(self, *channels: "StringT") -> Pipeline[AnyStr]: ...
    async def pubsub_shardchannels(self, pattern: "StringT | None" = ...) -> Pipeline[AnyStr]: ...
    async def pubsub_shardnumsub(self, *channels: "StringT") -> Pipeline[AnyStr]: ...
    async def spublish(self, channel: "StringT", message: "ValueT") -> Pipeline[AnyStr]: ...
    async def acl_cat(self, categoryname: "StringT | None" = ...) -> Pipeline[AnyStr]: ...
    async def acl_deluser(self, usernames: "Parameters[StringT]") -> Pipeline[AnyStr]: ...
    async def acl_dryrun(
        self, username: "StringT", command: "StringT", *args: "ValueT"
    ) -> Pipeline[AnyStr]: ...
    async def acl_genpass(self, bits: "int | None" = ...) -> Pipeline[AnyStr]: ...
    async def acl_getuser(self, username: "StringT") -> Pipeline[AnyStr]: ...
    async def acl_list(self) -> Pipeline[AnyStr]: ...
    async def acl_load(self) -> Pipeline[AnyStr]: ...
    async def acl_log(
        self, count: "int | None" = ..., reset: "bool | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def acl_save(self) -> Pipeline[AnyStr]: ...
    async def acl_setuser(self, username: "StringT", *rules: "StringT") -> Pipeline[AnyStr]: ...
    async def acl_users(self) -> Pipeline[AnyStr]: ...
    async def acl_whoami(self) -> Pipeline[AnyStr]: ...
    async def bgrewriteaof(self) -> Pipeline[AnyStr]: ...
    async def bgsave(self, schedule: "bool | None" = ...) -> Pipeline[AnyStr]: ...
    async def command(self) -> Pipeline[AnyStr]: ...
    async def command_count(self) -> Pipeline[AnyStr]: ...
    async def command_docs(self, *command_names: "StringT") -> Pipeline[AnyStr]: ...
    async def command_getkeys(
        self, command: "StringT", arguments: "Parameters[ValueT]"
    ) -> Pipeline[AnyStr]: ...
    async def command_getkeysandflags(
        self, command: "StringT", arguments: "Parameters[ValueT]"
    ) -> Pipeline[AnyStr]: ...
    async def command_info(self, *command_names: "StringT") -> Pipeline[AnyStr]: ...
    async def command_list(
        self,
        module: "StringT | None" = ...,
        aclcat: "StringT | None" = ...,
        pattern: "StringT | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def config_get(self, parameters: "Parameters[StringT]") -> Pipeline[AnyStr]: ...
    async def config_resetstat(self) -> Pipeline[AnyStr]: ...
    async def config_rewrite(self) -> Pipeline[AnyStr]: ...
    async def config_set(
        self, parameter_values: "Mapping[StringT, ValueT]"
    ) -> Pipeline[AnyStr]: ...
    async def dbsize(self) -> Pipeline[AnyStr]: ...
    async def failover(
        self,
        host: "StringT | None" = ...,
        port: "int | None" = ...,
        force: "bool | None" = ...,
        abort: "bool | None" = ...,
        timeout: "int | datetime.timedelta | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def flushall(
        self, async_: "Literal[PureToken.ASYNC, PureToken.SYNC] | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def flushdb(
        self, async_: "Literal[PureToken.ASYNC, PureToken.SYNC] | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def info(self, *sections: "StringT") -> Pipeline[AnyStr]: ...
    async def lastsave(self) -> Pipeline[AnyStr]: ...
    async def latency_doctor(self) -> Pipeline[AnyStr]: ...
    async def latency_graph(self, event: "StringT") -> Pipeline[AnyStr]: ...
    async def latency_histogram(self, *commands: "StringT") -> Pipeline[AnyStr]: ...
    async def latency_history(self, event: "StringT") -> Pipeline[AnyStr]: ...
    async def latency_latest(self) -> Pipeline[AnyStr]: ...
    async def latency_reset(self, *events: "StringT") -> Pipeline[AnyStr]: ...
    async def lolwut(self, version: "int | None" = ...) -> Pipeline[AnyStr]: ...
    async def memory_doctor(self) -> Pipeline[AnyStr]: ...
    async def memory_malloc_stats(self) -> Pipeline[AnyStr]: ...
    async def memory_purge(self) -> Pipeline[AnyStr]: ...
    async def memory_stats(self) -> Pipeline[AnyStr]: ...
    async def memory_usage(self, key: "KeyT", samples: "int | None" = ...) -> Pipeline[AnyStr]: ...
    async def module_list(self) -> Pipeline[AnyStr]: ...
    async def module_load(
        self, path: "StringT", *args: "str | bytes | int | float"
    ) -> Pipeline[AnyStr]: ...
    async def module_loadex(
        self,
        path: "StringT",
        configs: "dict[StringT, ValueT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def module_unload(self, name: "StringT") -> Pipeline[AnyStr]: ...
    async def replicaof(
        self, host: "StringT | None" = ..., port: "int | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def role(self) -> Pipeline[AnyStr]: ...
    async def save(self) -> Pipeline[AnyStr]: ...
    async def shutdown(
        self,
        nosave_save: "Literal[PureToken.NOSAVE, PureToken.SAVE] | None" = ...,
        now: "bool | None" = ...,
        force: "bool | None" = ...,
        abort: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def slaveof(
        self, host: "StringT | None" = ..., port: "int | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def slowlog_get(self, count: "int | None" = ...) -> Pipeline[AnyStr]: ...
    async def slowlog_len(self) -> Pipeline[AnyStr]: ...
    async def slowlog_reset(self) -> Pipeline[AnyStr]: ...
    async def swapdb(self, index1: "int", index2: "int") -> Pipeline[AnyStr]: ...
    async def time(self) -> Pipeline[AnyStr]: ...
    async def auth(
        self, password: "StringT", username: "StringT | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def client_caching(
        self, mode: "Literal[PureToken.NO, PureToken.YES]"
    ) -> Pipeline[AnyStr]: ...
    async def client_getname(self) -> Pipeline[AnyStr]: ...
    async def client_getredir(self) -> Pipeline[AnyStr]: ...
    async def client_id(self) -> Pipeline[AnyStr]: ...
    async def client_info(self) -> Pipeline[AnyStr]: ...
    async def client_kill(
        self,
        ip_port: "StringT | None" = ...,
        identifier: "int | None" = ...,
        type_: "None | Literal[PureToken.NORMAL, PureToken.MASTER, PureToken.SLAVE, PureToken.REPLICA, PureToken.PUBSUB]" = ...,
        user: "StringT | None" = ...,
        addr: "StringT | None" = ...,
        laddr: "StringT | None" = ...,
        skipme: "bool | None" = ...,
        maxage: "int | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def client_list(
        self,
        type_: "None | Literal[PureToken.MASTER, PureToken.NORMAL, PureToken.PUBSUB, PureToken.REPLICA]" = ...,
        identifiers: "Parameters[int] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def client_no_evict(
        self, enabled: "Literal[PureToken.ON, PureToken.OFF]"
    ) -> Pipeline[AnyStr]: ...
    async def client_no_touch(
        self, enabled: "Literal[PureToken.OFF, PureToken.ON]"
    ) -> Pipeline[AnyStr]: ...
    async def client_pause(
        self, timeout: "int", mode: "Literal[PureToken.WRITE, PureToken.ALL] | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def client_reply(
        self, mode: "Literal[PureToken.OFF, PureToken.ON, PureToken.SKIP]"
    ) -> Pipeline[AnyStr]: ...
    async def client_setinfo(
        self, lib_name: "StringT | None" = ..., lib_ver: "StringT | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def client_setname(self, connection_name: "StringT") -> Pipeline[AnyStr]: ...
    async def client_tracking(
        self,
        status: "Literal[PureToken.OFF, PureToken.ON]",
        *prefixes: "StringT",
        redirect: "int | None" = ...,
        bcast: "bool | None" = ...,
        optin: "bool | None" = ...,
        optout: "bool | None" = ...,
        noloop: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def client_trackinginfo(self) -> Pipeline[AnyStr]: ...
    async def client_unblock(
        self,
        client_id: "int",
        timeout_error: "Literal[PureToken.TIMEOUT, PureToken.ERROR] | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def client_unpause(self) -> Pipeline[AnyStr]: ...
    async def echo(self, message: "StringT") -> Pipeline[AnyStr]: ...
    async def hello(
        self,
        protover: "int | None" = ...,
        username: "StringT | None" = ...,
        password: "StringT | None" = ...,
        setname: "StringT | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def ping(self, message: "StringT | None" = ...) -> Pipeline[AnyStr]: ...
    async def quit(self) -> Pipeline[AnyStr]: ...
    async def reset(self) -> Pipeline[AnyStr]: ...
    async def select(self, index: "int") -> Pipeline[AnyStr]: ...
    async def asking(self) -> Pipeline[AnyStr]: ...
    async def cluster_addslots(self, slots: "Parameters[int]") -> Pipeline[AnyStr]: ...
    async def cluster_addslotsrange(
        self, slots: "Parameters[tuple[int, int]]"
    ) -> Pipeline[AnyStr]: ...
    async def cluster_bumpepoch(self) -> Pipeline[AnyStr]: ...
    async def cluster_count_failure_reports(self, node_id: "StringT") -> Pipeline[AnyStr]: ...
    async def cluster_countkeysinslot(self, slot: "int") -> Pipeline[AnyStr]: ...
    async def cluster_delslots(self, slots: "Parameters[int]") -> Pipeline[AnyStr]: ...
    async def cluster_delslotsrange(
        self, slots: "Parameters[tuple[int, int]]"
    ) -> Pipeline[AnyStr]: ...
    async def cluster_failover(
        self, options: "Literal[PureToken.FORCE, PureToken.TAKEOVER] | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def cluster_flushslots(self) -> Pipeline[AnyStr]: ...
    async def cluster_forget(self, node_id: "StringT") -> Pipeline[AnyStr]: ...
    async def cluster_getkeysinslot(self, slot: "int", count: "int") -> Pipeline[AnyStr]: ...
    async def cluster_info(self) -> Pipeline[AnyStr]: ...
    async def cluster_keyslot(self, key: "KeyT") -> Pipeline[AnyStr]: ...
    async def cluster_links(self) -> Pipeline[AnyStr]: ...
    async def cluster_meet(
        self, ip: "StringT", port: "int", cluster_bus_port: "int | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def cluster_myid(self) -> Pipeline[AnyStr]: ...
    async def cluster_nodes(self) -> Pipeline[AnyStr]: ...
    async def cluster_replicas(self, node_id: "StringT") -> Pipeline[AnyStr]: ...
    async def cluster_replicate(self, node_id: "StringT") -> Pipeline[AnyStr]: ...
    async def cluster_reset(
        self, hard_soft: "Literal[PureToken.HARD, PureToken.SOFT] | None" = ...
    ) -> Pipeline[AnyStr]: ...
    async def cluster_saveconfig(self) -> Pipeline[AnyStr]: ...
    async def cluster_set_config_epoch(self, config_epoch: "int") -> Pipeline[AnyStr]: ...
    async def cluster_setslot(
        self,
        slot: "int",
        importing: "StringT | None" = ...,
        migrating: "StringT | None" = ...,
        node: "StringT | None" = ...,
        stable: "bool | None" = ...,
    ) -> Pipeline[AnyStr]: ...
    async def cluster_shards(self) -> Pipeline[AnyStr]: ...
    async def cluster_slaves(self, node_id: "StringT") -> Pipeline[AnyStr]: ...
    async def cluster_slots(self) -> Pipeline[AnyStr]: ...
    async def readonly(self) -> Pipeline[AnyStr]: ...
    async def readwrite(self) -> Pipeline[AnyStr]: ...

class ClusterPipeline(ObjectProxy, Generic[AnyStr]):  # type: ignore
    @classmethod
    def proxy(
        cls,
        client: "RedisCluster[AnyStr]",
        transaction: "bool | None" = ...,
        watches: "Parameters[KeyT] | None" = ...,
        timeout: "float | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def watch(self, *keys: "KeyT") -> bool: ...
    async def unwatch(self) -> bool: ...
    def multi(self) -> None: ...
    async def execute(self, raise_on_error: "bool" = ...) -> tuple[object, ...]: ...
    async def __aenter__(self) -> "ClusterPipeline[AnyStr]": ...
    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None: ...
    async def copy(
        self,
        source: "KeyT",
        destination: "KeyT",
        db: "int | None" = ...,
        replace: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def delete(self, keys: "Parameters[KeyT]") -> ClusterPipeline[AnyStr]: ...
    async def dump(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def exists(self, keys: "Parameters[KeyT]") -> ClusterPipeline[AnyStr]: ...
    async def expire(
        self,
        key: "KeyT",
        seconds: "int | datetime.timedelta",
        condition: "Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def expireat(
        self,
        key: "KeyT",
        unix_time_seconds: "int | datetime.datetime",
        condition: "Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def expiretime(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def keys(self, pattern: "StringT" = ...) -> ClusterPipeline[AnyStr]: ...
    async def migrate(
        self,
        host: "StringT",
        port: "int",
        destination_db: "int",
        timeout: "int",
        *keys: "KeyT",
        copy: "bool | None" = ...,
        replace: "bool | None" = ...,
        auth: "StringT | None" = ...,
        username: "StringT | None" = ...,
        password: "StringT | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def move(self, key: "KeyT", db: "int") -> ClusterPipeline[AnyStr]: ...
    async def object_encoding(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def object_freq(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def object_idletime(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def object_refcount(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def persist(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def pexpire(
        self,
        key: "KeyT",
        milliseconds: "int | datetime.timedelta",
        condition: "Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def pexpireat(
        self,
        key: "KeyT",
        unix_time_milliseconds: "int | datetime.datetime",
        condition: "Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def pexpiretime(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def pttl(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def randomkey(self) -> ClusterPipeline[AnyStr]: ...
    async def rename(self, key: "KeyT", newkey: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def renamenx(self, key: "KeyT", newkey: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def restore(
        self,
        key: "KeyT",
        ttl: "int | datetime.timedelta | datetime.datetime",
        serialized_value: "bytes",
        replace: "bool | None" = ...,
        absttl: "bool | None" = ...,
        idletime: "int | datetime.timedelta | None" = ...,
        freq: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def scan(
        self,
        cursor: "int | None" = ...,
        match: "StringT | None" = ...,
        count: "int | None" = ...,
        type_: "StringT | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def sort(
        self,
        key: "KeyT",
        gets: "Parameters[KeyT] | None" = ...,
        by: "StringT | None" = ...,
        offset: "int | None" = ...,
        count: "int | None" = ...,
        order: "Literal[PureToken.ASC, PureToken.DESC] | None" = ...,
        alpha: "bool | None" = ...,
        store: "KeyT | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def sort_ro(
        self,
        key: "KeyT",
        gets: "Parameters[KeyT] | None" = ...,
        by: "StringT | None" = ...,
        offset: "int | None" = ...,
        count: "int | None" = ...,
        order: "Literal[PureToken.ASC, PureToken.DESC] | None" = ...,
        alpha: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def touch(self, keys: "Parameters[KeyT]") -> ClusterPipeline[AnyStr]: ...
    async def ttl(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def type(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def unlink(self, keys: "Parameters[KeyT]") -> ClusterPipeline[AnyStr]: ...
    async def wait(self, numreplicas: "int", timeout: "int") -> ClusterPipeline[AnyStr]: ...
    async def waitaof(
        self, numlocal: "int", numreplicas: "int", timeout: "int"
    ) -> ClusterPipeline[AnyStr]: ...
    async def append(self, key: "KeyT", value: "ValueT") -> ClusterPipeline[AnyStr]: ...
    async def decr(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def decrby(self, key: "KeyT", decrement: "int") -> ClusterPipeline[AnyStr]: ...
    async def get(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def getdel(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def getex(
        self,
        key: "KeyT",
        ex: "int | datetime.timedelta | None" = ...,
        px: "int | datetime.timedelta | None" = ...,
        exat: "int | datetime.datetime | None" = ...,
        pxat: "int | datetime.datetime | None" = ...,
        persist: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def getrange(self, key: "KeyT", start: "int", end: "int") -> ClusterPipeline[AnyStr]: ...
    async def getset(self, key: "KeyT", value: "ValueT") -> ClusterPipeline[AnyStr]: ...
    async def incr(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def incrby(self, key: "KeyT", increment: "int") -> ClusterPipeline[AnyStr]: ...
    async def incrbyfloat(
        self, key: "KeyT", increment: "int | float"
    ) -> ClusterPipeline[AnyStr]: ...
    async def lcs(
        self,
        key1: "KeyT",
        key2: "KeyT",
        len_: "bool | None" = ...,
        idx: "bool | None" = ...,
        minmatchlen: "int | None" = ...,
        withmatchlen: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def mget(self, keys: "Parameters[KeyT]") -> ClusterPipeline[AnyStr]: ...
    async def mset(self, key_values: "Mapping[KeyT, ValueT]") -> ClusterPipeline[AnyStr]: ...
    async def msetnx(self, key_values: "Mapping[KeyT, ValueT]") -> ClusterPipeline[AnyStr]: ...
    async def psetex(
        self, key: "KeyT", milliseconds: "int | datetime.timedelta", value: "ValueT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def set(
        self,
        key: "KeyT",
        value: "ValueT",
        condition: "Literal[PureToken.NX, PureToken.XX] | None" = ...,
        get: "bool | None" = ...,
        ex: "int | datetime.timedelta | None" = ...,
        px: "int | datetime.timedelta | None" = ...,
        exat: "int | datetime.datetime | None" = ...,
        pxat: "int | datetime.datetime | None" = ...,
        keepttl: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def setex(
        self, key: "KeyT", value: "ValueT", seconds: "int | datetime.timedelta"
    ) -> ClusterPipeline[AnyStr]: ...
    async def setnx(self, key: "KeyT", value: "ValueT") -> ClusterPipeline[AnyStr]: ...
    async def setrange(
        self, key: "KeyT", offset: "int", value: "ValueT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def strlen(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def substr(self, key: "KeyT", start: "int", end: "int") -> ClusterPipeline[AnyStr]: ...
    async def bitcount(
        self,
        key: "KeyT",
        start: "int | None" = ...,
        end: "int | None" = ...,
        index_unit: "Literal[PureToken.BIT, PureToken.BYTE] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def bitop(
        self, keys: "Parameters[KeyT]", operation: "StringT", destkey: "KeyT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def bitpos(
        self,
        key: "KeyT",
        bit: "int",
        start: "int | None" = ...,
        end: "int | None" = ...,
        index_unit: "Literal[PureToken.BIT, PureToken.BYTE] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def getbit(self, key: "KeyT", offset: "int") -> ClusterPipeline[AnyStr]: ...
    async def setbit(self, key: "KeyT", offset: "int", value: "int") -> ClusterPipeline[AnyStr]: ...
    async def hdel(self, key: "KeyT", fields: "Parameters[StringT]") -> ClusterPipeline[AnyStr]: ...
    async def hexists(self, key: "KeyT", field: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def hexpire(
        self,
        key: "KeyT",
        seconds: "int | datetime.timedelta",
        fields: "Parameters[StringT]",
        condition: "Literal[PureToken.GT, PureToken.LT, PureToken.NX, PureToken.XX] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def hexpireat(
        self,
        key: "KeyT",
        unix_time_seconds: "int | datetime.datetime",
        fields: "Parameters[StringT]",
        condition: "Literal[PureToken.GT, PureToken.LT, PureToken.NX, PureToken.XX] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def hexpiretime(
        self, key: "KeyT", fields: "Parameters[StringT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def hget(self, key: "KeyT", field: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def hgetall(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def hincrby(
        self, key: "KeyT", field: "StringT", increment: "int"
    ) -> ClusterPipeline[AnyStr]: ...
    async def hincrbyfloat(
        self, key: "KeyT", field: "StringT", increment: "int | float"
    ) -> ClusterPipeline[AnyStr]: ...
    async def hkeys(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def hlen(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def hmget(
        self, key: "KeyT", fields: "Parameters[StringT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def hmset(
        self, key: "KeyT", field_values: "Mapping[StringT, ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def hpersist(
        self, key: "KeyT", fields: "Parameters[StringT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def hpexpire(
        self,
        key: "KeyT",
        milliseconds: "int | datetime.timedelta",
        fields: "Parameters[StringT]",
        condition: "Literal[PureToken.GT, PureToken.LT, PureToken.NX, PureToken.XX] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def hpexpireat(
        self,
        key: "KeyT",
        unix_time_milliseconds: "int | datetime.datetime",
        fields: "Parameters[StringT]",
        condition: "Literal[PureToken.GT, PureToken.LT, PureToken.NX, PureToken.XX] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def hpexpiretime(
        self, key: "KeyT", fields: "Parameters[StringT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def hpttl(
        self, key: "KeyT", fields: "Parameters[StringT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def hrandfield(
        self, key: "KeyT", count: "int | None" = ..., withvalues: "bool | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def hscan(
        self,
        key: "KeyT",
        cursor: "int | None" = ...,
        match: "StringT | None" = ...,
        count: "int | None" = ...,
        novalues: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def hset(
        self, key: "KeyT", field_values: "Mapping[StringT, ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def hsetnx(
        self, key: "KeyT", field: "StringT", value: "ValueT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def hstrlen(self, key: "KeyT", field: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def httl(self, key: "KeyT", fields: "Parameters[StringT]") -> ClusterPipeline[AnyStr]: ...
    async def hvals(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def blmove(
        self,
        source: "KeyT",
        destination: "KeyT",
        wherefrom: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        whereto: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        timeout: "int | float",
    ) -> ClusterPipeline[AnyStr]: ...
    async def blmpop(
        self,
        keys: "Parameters[KeyT]",
        timeout: "int | float",
        where: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        count: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def blpop(
        self, keys: "Parameters[KeyT]", timeout: "int | float"
    ) -> ClusterPipeline[AnyStr]: ...
    async def brpop(
        self, keys: "Parameters[KeyT]", timeout: "int | float"
    ) -> ClusterPipeline[AnyStr]: ...
    async def brpoplpush(
        self, source: "KeyT", destination: "KeyT", timeout: "int | float"
    ) -> ClusterPipeline[AnyStr]: ...
    async def lindex(self, key: "KeyT", index: "int") -> ClusterPipeline[AnyStr]: ...
    async def linsert(
        self,
        key: "KeyT",
        where: "Literal[PureToken.AFTER, PureToken.BEFORE]",
        pivot: "ValueT",
        element: "ValueT",
    ) -> ClusterPipeline[AnyStr]: ...
    async def llen(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def lmove(
        self,
        source: "KeyT",
        destination: "KeyT",
        wherefrom: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        whereto: "Literal[PureToken.LEFT, PureToken.RIGHT]",
    ) -> ClusterPipeline[AnyStr]: ...
    async def lmpop(
        self,
        keys: "Parameters[KeyT]",
        where: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        count: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def lpop(self, key: "KeyT", count: "int | None" = ...) -> ClusterPipeline[AnyStr]: ...
    async def lpos(
        self,
        key: "KeyT",
        element: "ValueT",
        rank: "int | None" = ...,
        count: "int | None" = ...,
        maxlen: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def lpush(
        self, key: "KeyT", elements: "Parameters[ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def lpushx(
        self, key: "KeyT", elements: "Parameters[ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def lrange(self, key: "KeyT", start: "int", stop: "int") -> ClusterPipeline[AnyStr]: ...
    async def lrem(
        self, key: "KeyT", count: "int", element: "ValueT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def lset(
        self, key: "KeyT", index: "int", element: "ValueT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def ltrim(self, key: "KeyT", start: "int", stop: "int") -> ClusterPipeline[AnyStr]: ...
    async def rpop(self, key: "KeyT", count: "int | None" = ...) -> ClusterPipeline[AnyStr]: ...
    async def rpoplpush(self, source: "KeyT", destination: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def rpush(
        self, key: "KeyT", elements: "Parameters[ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def rpushx(
        self, key: "KeyT", elements: "Parameters[ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def sadd(self, key: "KeyT", members: "Parameters[ValueT]") -> ClusterPipeline[AnyStr]: ...
    async def scard(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def sdiff(self, keys: "Parameters[KeyT]") -> ClusterPipeline[AnyStr]: ...
    async def sdiffstore(
        self, keys: "Parameters[KeyT]", destination: "KeyT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def sinter(self, keys: "Parameters[KeyT]") -> ClusterPipeline[AnyStr]: ...
    async def sintercard(
        self, keys: "Parameters[KeyT]", limit: "int | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def sinterstore(
        self, keys: "Parameters[KeyT]", destination: "KeyT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def sismember(self, key: "KeyT", member: "ValueT") -> ClusterPipeline[AnyStr]: ...
    async def smembers(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def smismember(
        self, key: "KeyT", members: "Parameters[ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def smove(
        self, source: "KeyT", destination: "KeyT", member: "ValueT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def spop(self, key: "KeyT", count: "int | None" = ...) -> ClusterPipeline[AnyStr]: ...
    async def srandmember(
        self, key: "KeyT", count: "int | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def srem(self, key: "KeyT", members: "Parameters[ValueT]") -> ClusterPipeline[AnyStr]: ...
    async def sscan(
        self,
        key: "KeyT",
        cursor: "int | None" = ...,
        match: "StringT | None" = ...,
        count: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def sunion(self, keys: "Parameters[KeyT]") -> ClusterPipeline[AnyStr]: ...
    async def sunionstore(
        self, keys: "Parameters[KeyT]", destination: "KeyT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def bzmpop(
        self,
        keys: "Parameters[KeyT]",
        timeout: "int | float",
        where: "Literal[PureToken.MAX, PureToken.MIN]",
        count: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def bzpopmax(
        self, keys: "Parameters[KeyT]", timeout: "int | float"
    ) -> ClusterPipeline[AnyStr]: ...
    async def bzpopmin(
        self, keys: "Parameters[KeyT]", timeout: "int | float"
    ) -> ClusterPipeline[AnyStr]: ...
    async def zadd(
        self,
        key: "KeyT",
        member_scores: "Mapping[StringT, int | float]",
        condition: "Literal[PureToken.NX, PureToken.XX] | None" = ...,
        comparison: "Literal[PureToken.GT, PureToken.LT] | None" = ...,
        change: "bool | None" = ...,
        increment: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def zcard(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def zcount(
        self, key: "KeyT", min_: "ValueT", max_: "ValueT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def zdiff(
        self, keys: "Parameters[KeyT]", withscores: "bool | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def zdiffstore(
        self, keys: "Parameters[KeyT]", destination: "KeyT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def zincrby(
        self, key: "KeyT", member: "ValueT", increment: "int"
    ) -> ClusterPipeline[AnyStr]: ...
    async def zinter(
        self,
        keys: "Parameters[KeyT]",
        weights: "Parameters[int] | None" = ...,
        aggregate: "Literal[PureToken.MAX, PureToken.MIN, PureToken.SUM] | None" = ...,
        withscores: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def zintercard(
        self, keys: "Parameters[KeyT]", limit: "int | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def zinterstore(
        self,
        keys: "Parameters[KeyT]",
        destination: "KeyT",
        weights: "Parameters[int] | None" = ...,
        aggregate: "Literal[PureToken.MAX, PureToken.MIN, PureToken.SUM] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def zlexcount(
        self, key: "KeyT", min_: "ValueT", max_: "ValueT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def zmpop(
        self,
        keys: "Parameters[KeyT]",
        where: "Literal[PureToken.MAX, PureToken.MIN]",
        count: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def zmscore(
        self, key: "KeyT", members: "Parameters[ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def zpopmax(self, key: "KeyT", count: "int | None" = ...) -> ClusterPipeline[AnyStr]: ...
    async def zpopmin(self, key: "KeyT", count: "int | None" = ...) -> ClusterPipeline[AnyStr]: ...
    async def zrandmember(
        self, key: "KeyT", count: "int | None" = ..., withscores: "bool | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def zrange(
        self,
        key: "KeyT",
        min_: "int | ValueT",
        max_: "int | ValueT",
        sortby: "Literal[PureToken.BYSCORE, PureToken.BYLEX] | None" = ...,
        rev: "bool | None" = ...,
        offset: "int | None" = ...,
        count: "int | None" = ...,
        withscores: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def zrangebylex(
        self,
        key: "KeyT",
        min_: "ValueT",
        max_: "ValueT",
        offset: "int | None" = ...,
        count: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def zrangebyscore(
        self,
        key: "KeyT",
        min_: "int | float",
        max_: "int | float",
        withscores: "bool | None" = ...,
        offset: "int | None" = ...,
        count: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def zrangestore(
        self,
        dst: "KeyT",
        src: "KeyT",
        min_: "int | ValueT",
        max_: "int | ValueT",
        sortby: "Literal[PureToken.BYSCORE, PureToken.BYLEX] | None" = ...,
        rev: "bool | None" = ...,
        offset: "int | None" = ...,
        count: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def zrank(
        self, key: "KeyT", member: "ValueT", withscore: "bool | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def zrem(self, key: "KeyT", members: "Parameters[ValueT]") -> ClusterPipeline[AnyStr]: ...
    async def zremrangebylex(
        self, key: "KeyT", min_: "ValueT", max_: "ValueT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def zremrangebyrank(
        self, key: "KeyT", start: "int", stop: "int"
    ) -> ClusterPipeline[AnyStr]: ...
    async def zremrangebyscore(
        self, key: "KeyT", min_: "int | float", max_: "int | float"
    ) -> ClusterPipeline[AnyStr]: ...
    async def zrevrange(
        self, key: "KeyT", start: "int", stop: "int", withscores: "bool | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def zrevrangebylex(
        self,
        key: "KeyT",
        max_: "ValueT",
        min_: "ValueT",
        offset: "int | None" = ...,
        count: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def zrevrangebyscore(
        self,
        key: "KeyT",
        max_: "int | float",
        min_: "int | float",
        withscores: "bool | None" = ...,
        offset: "int | None" = ...,
        count: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def zrevrank(
        self, key: "KeyT", member: "ValueT", withscore: "bool | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def zscan(
        self,
        key: "KeyT",
        cursor: "int | None" = ...,
        match: "StringT | None" = ...,
        count: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def zscore(self, key: "KeyT", member: "ValueT") -> ClusterPipeline[AnyStr]: ...
    async def zunion(
        self,
        keys: "Parameters[KeyT]",
        weights: "Parameters[int] | None" = ...,
        aggregate: "Literal[PureToken.SUM, PureToken.MIN, PureToken.MAX] | None" = ...,
        withscores: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def zunionstore(
        self,
        keys: "Parameters[KeyT]",
        destination: "KeyT",
        weights: "Parameters[int] | None" = ...,
        aggregate: "Literal[PureToken.SUM, PureToken.MIN, PureToken.MAX] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def pfadd(self, key: "KeyT", *elements: "ValueT") -> ClusterPipeline[AnyStr]: ...
    async def pfcount(self, keys: "Parameters[KeyT]") -> ClusterPipeline[AnyStr]: ...
    async def pfmerge(
        self, destkey: "KeyT", sourcekeys: "Parameters[KeyT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def geoadd(
        self,
        key: "KeyT",
        longitude_latitude_members: "Parameters[tuple[int | float, int | float, ValueT]]",
        condition: "Literal[PureToken.NX, PureToken.XX] | None" = ...,
        change: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def geodist(
        self,
        key: "KeyT",
        member1: "StringT",
        member2: "StringT",
        unit: "Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def geohash(
        self, key: "KeyT", members: "Parameters[ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def geopos(
        self, key: "KeyT", members: "Parameters[ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def georadius(
        self,
        key: "KeyT",
        longitude: "int | float",
        latitude: "int | float",
        radius: "int | float",
        unit: "Literal[PureToken.FT, PureToken.KM, PureToken.M, PureToken.MI]",
        withcoord: "bool | None" = ...,
        withdist: "bool | None" = ...,
        withhash: "bool | None" = ...,
        count: "int | None" = ...,
        any_: "bool | None" = ...,
        order: "Literal[PureToken.ASC, PureToken.DESC] | None" = ...,
        store: "KeyT | None" = ...,
        storedist: "KeyT | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def georadiusbymember(
        self,
        key: "KeyT",
        member: "ValueT",
        radius: "int | float",
        unit: "Literal[PureToken.FT, PureToken.KM, PureToken.M, PureToken.MI]",
        withcoord: "bool | None" = ...,
        withdist: "bool | None" = ...,
        withhash: "bool | None" = ...,
        count: "int | None" = ...,
        any_: "bool | None" = ...,
        order: "Literal[PureToken.ASC, PureToken.DESC] | None" = ...,
        store: "KeyT | None" = ...,
        storedist: "KeyT | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def geosearch(
        self,
        key: "KeyT",
        member: "ValueT | None" = ...,
        longitude: "int | float | None" = ...,
        latitude: "int | float | None" = ...,
        radius: "int | float | None" = ...,
        circle_unit: "None | Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]" = ...,
        width: "int | float | None" = ...,
        height: "int | float | None" = ...,
        box_unit: "Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI] | None" = ...,
        order: "Literal[PureToken.ASC, PureToken.DESC] | None" = ...,
        count: "int | None" = ...,
        any_: "bool | None" = ...,
        withcoord: "bool | None" = ...,
        withdist: "bool | None" = ...,
        withhash: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def geosearchstore(
        self,
        destination: "KeyT",
        source: "KeyT",
        member: "ValueT | None" = ...,
        longitude: "int | float | None" = ...,
        latitude: "int | float | None" = ...,
        radius: "int | float | None" = ...,
        circle_unit: "None | Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]" = ...,
        width: "int | float | None" = ...,
        height: "int | float | None" = ...,
        box_unit: "Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI] | None" = ...,
        order: "Literal[PureToken.ASC, PureToken.DESC] | None" = ...,
        count: "int | None" = ...,
        any_: "bool | None" = ...,
        storedist: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def xack(
        self, key: "KeyT", group: "StringT", identifiers: "Parameters[ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def xadd(
        self,
        key: "KeyT",
        field_values: "Mapping[StringT, ValueT]",
        identifier: "ValueT | None" = ...,
        nomkstream: "bool | None" = ...,
        trim_strategy: "Literal[PureToken.MAXLEN, PureToken.MINID] | None" = ...,
        threshold: "int | None" = ...,
        trim_operator: "Literal[PureToken.EQUAL, PureToken.APPROXIMATELY] | None" = ...,
        limit: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def xautoclaim(
        self,
        key: "KeyT",
        group: "StringT",
        consumer: "StringT",
        min_idle_time: "int | datetime.timedelta",
        start: "ValueT",
        count: "int | None" = ...,
        justid: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def xclaim(
        self,
        key: "KeyT",
        group: "StringT",
        consumer: "StringT",
        min_idle_time: "int | datetime.timedelta",
        identifiers: "Parameters[ValueT]",
        idle: "int | datetime.timedelta | None" = ...,
        time: "int | datetime.datetime | None" = ...,
        retrycount: "int | None" = ...,
        force: "bool | None" = ...,
        justid: "bool | None" = ...,
        lastid: "ValueT | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def xdel(
        self, key: "KeyT", identifiers: "Parameters[ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def xgroup_create(
        self,
        key: "KeyT",
        groupname: "StringT",
        identifier: "ValueT | None" = ...,
        mkstream: "bool | None" = ...,
        entriesread: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def xgroup_createconsumer(
        self, key: "KeyT", groupname: "StringT", consumername: "StringT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def xgroup_delconsumer(
        self, key: "KeyT", groupname: "StringT", consumername: "StringT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def xgroup_destroy(
        self, key: "KeyT", groupname: "StringT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def xgroup_setid(
        self,
        key: "KeyT",
        groupname: "StringT",
        identifier: "ValueT | None" = ...,
        entriesread: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def xinfo_consumers(
        self, key: "KeyT", groupname: "StringT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def xinfo_groups(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def xinfo_stream(
        self, key: "KeyT", full: "bool | None" = ..., count: "int | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def xlen(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def xpending(
        self,
        key: "KeyT",
        group: "StringT",
        start: "ValueT | None" = ...,
        end: "ValueT | None" = ...,
        count: "int | None" = ...,
        idle: "int | None" = ...,
        consumer: "StringT | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def xrange(
        self,
        key: "KeyT",
        start: "ValueT | None" = ...,
        end: "ValueT | None" = ...,
        count: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def xread(
        self,
        streams: "Mapping[ValueT, ValueT]",
        count: "int | None" = ...,
        block: "int | datetime.timedelta | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def xreadgroup(
        self,
        group: "StringT",
        consumer: "StringT",
        streams: "Mapping[ValueT, ValueT]",
        count: "int | None" = ...,
        block: "int | datetime.timedelta | None" = ...,
        noack: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def xrevrange(
        self,
        key: "KeyT",
        end: "ValueT | None" = ...,
        start: "ValueT | None" = ...,
        count: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def xtrim(
        self,
        key: "KeyT",
        trim_strategy: "Literal[PureToken.MAXLEN, PureToken.MINID]",
        threshold: "int",
        trim_operator: "Literal[PureToken.EQUAL, PureToken.APPROXIMATELY] | None" = ...,
        limit: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def eval(
        self,
        script: "StringT",
        keys: "Parameters[KeyT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def evalsha(
        self,
        sha1: "StringT",
        keys: "Parameters[KeyT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def evalsha_ro(
        self,
        sha1: "StringT",
        keys: "Parameters[KeyT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def eval_ro(
        self,
        script: "StringT",
        keys: "Parameters[KeyT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def fcall(
        self,
        function: "StringT",
        keys: "Parameters[KeyT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def fcall_ro(
        self,
        function: "StringT",
        keys: "Parameters[KeyT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def function_delete(self, library_name: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def function_dump(self) -> ClusterPipeline[AnyStr]: ...
    async def function_flush(
        self, async_: "Literal[PureToken.ASYNC, PureToken.SYNC] | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def function_kill(self) -> ClusterPipeline[AnyStr]: ...
    async def function_list(
        self, libraryname: "StringT | None" = ..., withcode: "bool | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def function_load(
        self, function_code: "StringT", replace: "bool | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def function_restore(
        self,
        serialized_value: "bytes",
        policy: "Literal[PureToken.FLUSH, PureToken.APPEND, PureToken.REPLACE] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def function_stats(self) -> ClusterPipeline[AnyStr]: ...
    async def script_debug(
        self, mode: "Literal[PureToken.NO, PureToken.SYNC, PureToken.YES]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def script_exists(self, sha1s: "Parameters[StringT]") -> ClusterPipeline[AnyStr]: ...
    async def script_flush(
        self, sync_type: "Literal[PureToken.ASYNC, PureToken.SYNC] | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def script_kill(self) -> ClusterPipeline[AnyStr]: ...
    async def script_load(self, script: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def publish(self, channel: "StringT", message: "ValueT") -> ClusterPipeline[AnyStr]: ...
    async def pubsub_channels(self, pattern: "StringT | None" = ...) -> ClusterPipeline[AnyStr]: ...
    async def pubsub_numpat(self) -> ClusterPipeline[AnyStr]: ...
    async def pubsub_numsub(self, *channels: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def pubsub_shardchannels(
        self, pattern: "StringT | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def pubsub_shardnumsub(self, *channels: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def spublish(self, channel: "StringT", message: "ValueT") -> ClusterPipeline[AnyStr]: ...
    async def acl_cat(self, categoryname: "StringT | None" = ...) -> ClusterPipeline[AnyStr]: ...
    async def acl_deluser(self, usernames: "Parameters[StringT]") -> ClusterPipeline[AnyStr]: ...
    async def acl_dryrun(
        self, username: "StringT", command: "StringT", *args: "ValueT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def acl_genpass(self, bits: "int | None" = ...) -> ClusterPipeline[AnyStr]: ...
    async def acl_getuser(self, username: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def acl_list(self) -> ClusterPipeline[AnyStr]: ...
    async def acl_load(self) -> ClusterPipeline[AnyStr]: ...
    async def acl_log(
        self, count: "int | None" = ..., reset: "bool | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def acl_save(self) -> ClusterPipeline[AnyStr]: ...
    async def acl_setuser(
        self, username: "StringT", *rules: "StringT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def acl_users(self) -> ClusterPipeline[AnyStr]: ...
    async def acl_whoami(self) -> ClusterPipeline[AnyStr]: ...
    async def bgrewriteaof(self) -> ClusterPipeline[AnyStr]: ...
    async def bgsave(self, schedule: "bool | None" = ...) -> ClusterPipeline[AnyStr]: ...
    async def command(self) -> ClusterPipeline[AnyStr]: ...
    async def command_count(self) -> ClusterPipeline[AnyStr]: ...
    async def command_docs(self, *command_names: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def command_getkeys(
        self, command: "StringT", arguments: "Parameters[ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def command_getkeysandflags(
        self, command: "StringT", arguments: "Parameters[ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def command_info(self, *command_names: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def command_list(
        self,
        module: "StringT | None" = ...,
        aclcat: "StringT | None" = ...,
        pattern: "StringT | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def config_get(self, parameters: "Parameters[StringT]") -> ClusterPipeline[AnyStr]: ...
    async def config_resetstat(self) -> ClusterPipeline[AnyStr]: ...
    async def config_rewrite(self) -> ClusterPipeline[AnyStr]: ...
    async def config_set(
        self, parameter_values: "Mapping[StringT, ValueT]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def dbsize(self) -> ClusterPipeline[AnyStr]: ...
    async def failover(
        self,
        host: "StringT | None" = ...,
        port: "int | None" = ...,
        force: "bool | None" = ...,
        abort: "bool | None" = ...,
        timeout: "int | datetime.timedelta | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def flushall(
        self, async_: "Literal[PureToken.ASYNC, PureToken.SYNC] | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def flushdb(
        self, async_: "Literal[PureToken.ASYNC, PureToken.SYNC] | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def info(self, *sections: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def lastsave(self) -> ClusterPipeline[AnyStr]: ...
    async def latency_doctor(self) -> ClusterPipeline[AnyStr]: ...
    async def latency_graph(self, event: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def latency_histogram(self, *commands: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def latency_history(self, event: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def latency_latest(self) -> ClusterPipeline[AnyStr]: ...
    async def latency_reset(self, *events: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def lolwut(self, version: "int | None" = ...) -> ClusterPipeline[AnyStr]: ...
    async def memory_doctor(self) -> ClusterPipeline[AnyStr]: ...
    async def memory_malloc_stats(self) -> ClusterPipeline[AnyStr]: ...
    async def memory_purge(self) -> ClusterPipeline[AnyStr]: ...
    async def memory_stats(self) -> ClusterPipeline[AnyStr]: ...
    async def memory_usage(
        self, key: "KeyT", samples: "int | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def module_list(self) -> ClusterPipeline[AnyStr]: ...
    async def module_load(
        self, path: "StringT", *args: "str | bytes | int | float"
    ) -> ClusterPipeline[AnyStr]: ...
    async def module_loadex(
        self,
        path: "StringT",
        configs: "dict[StringT, ValueT] | None" = ...,
        args: "Parameters[ValueT] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def module_unload(self, name: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def replicaof(
        self, host: "StringT | None" = ..., port: "int | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def role(self) -> ClusterPipeline[AnyStr]: ...
    async def save(self) -> ClusterPipeline[AnyStr]: ...
    async def shutdown(
        self,
        nosave_save: "Literal[PureToken.NOSAVE, PureToken.SAVE] | None" = ...,
        now: "bool | None" = ...,
        force: "bool | None" = ...,
        abort: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def slaveof(
        self, host: "StringT | None" = ..., port: "int | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def slowlog_get(self, count: "int | None" = ...) -> ClusterPipeline[AnyStr]: ...
    async def slowlog_len(self) -> ClusterPipeline[AnyStr]: ...
    async def slowlog_reset(self) -> ClusterPipeline[AnyStr]: ...
    async def swapdb(self, index1: "int", index2: "int") -> ClusterPipeline[AnyStr]: ...
    async def time(self) -> ClusterPipeline[AnyStr]: ...
    async def auth(
        self, password: "StringT", username: "StringT | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def client_caching(
        self, mode: "Literal[PureToken.NO, PureToken.YES]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def client_getname(self) -> ClusterPipeline[AnyStr]: ...
    async def client_getredir(self) -> ClusterPipeline[AnyStr]: ...
    async def client_id(self) -> ClusterPipeline[AnyStr]: ...
    async def client_info(self) -> ClusterPipeline[AnyStr]: ...
    async def client_kill(
        self,
        ip_port: "StringT | None" = ...,
        identifier: "int | None" = ...,
        type_: "None | Literal[PureToken.NORMAL, PureToken.MASTER, PureToken.SLAVE, PureToken.REPLICA, PureToken.PUBSUB]" = ...,
        user: "StringT | None" = ...,
        addr: "StringT | None" = ...,
        laddr: "StringT | None" = ...,
        skipme: "bool | None" = ...,
        maxage: "int | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def client_list(
        self,
        type_: "None | Literal[PureToken.MASTER, PureToken.NORMAL, PureToken.PUBSUB, PureToken.REPLICA]" = ...,
        identifiers: "Parameters[int] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def client_no_evict(
        self, enabled: "Literal[PureToken.ON, PureToken.OFF]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def client_no_touch(
        self, enabled: "Literal[PureToken.OFF, PureToken.ON]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def client_pause(
        self, timeout: "int", mode: "Literal[PureToken.WRITE, PureToken.ALL] | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def client_reply(
        self, mode: "Literal[PureToken.OFF, PureToken.ON, PureToken.SKIP]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def client_setinfo(
        self, lib_name: "StringT | None" = ..., lib_ver: "StringT | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def client_setname(self, connection_name: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def client_tracking(
        self,
        status: "Literal[PureToken.OFF, PureToken.ON]",
        *prefixes: "StringT",
        redirect: "int | None" = ...,
        bcast: "bool | None" = ...,
        optin: "bool | None" = ...,
        optout: "bool | None" = ...,
        noloop: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def client_trackinginfo(self) -> ClusterPipeline[AnyStr]: ...
    async def client_unblock(
        self,
        client_id: "int",
        timeout_error: "Literal[PureToken.TIMEOUT, PureToken.ERROR] | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def client_unpause(self) -> ClusterPipeline[AnyStr]: ...
    async def echo(self, message: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def hello(
        self,
        protover: "int | None" = ...,
        username: "StringT | None" = ...,
        password: "StringT | None" = ...,
        setname: "StringT | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def ping(self, message: "StringT | None" = ...) -> ClusterPipeline[AnyStr]: ...
    async def quit(self) -> ClusterPipeline[AnyStr]: ...
    async def reset(self) -> ClusterPipeline[AnyStr]: ...
    async def select(self, index: "int") -> ClusterPipeline[AnyStr]: ...
    async def asking(self) -> ClusterPipeline[AnyStr]: ...
    async def cluster_addslots(self, slots: "Parameters[int]") -> ClusterPipeline[AnyStr]: ...
    async def cluster_addslotsrange(
        self, slots: "Parameters[tuple[int, int]]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def cluster_bumpepoch(self) -> ClusterPipeline[AnyStr]: ...
    async def cluster_count_failure_reports(
        self, node_id: "StringT"
    ) -> ClusterPipeline[AnyStr]: ...
    async def cluster_countkeysinslot(self, slot: "int") -> ClusterPipeline[AnyStr]: ...
    async def cluster_delslots(self, slots: "Parameters[int]") -> ClusterPipeline[AnyStr]: ...
    async def cluster_delslotsrange(
        self, slots: "Parameters[tuple[int, int]]"
    ) -> ClusterPipeline[AnyStr]: ...
    async def cluster_failover(
        self, options: "Literal[PureToken.FORCE, PureToken.TAKEOVER] | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def cluster_flushslots(self) -> ClusterPipeline[AnyStr]: ...
    async def cluster_forget(self, node_id: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def cluster_getkeysinslot(self, slot: "int", count: "int") -> ClusterPipeline[AnyStr]: ...
    async def cluster_info(self) -> ClusterPipeline[AnyStr]: ...
    async def cluster_keyslot(self, key: "KeyT") -> ClusterPipeline[AnyStr]: ...
    async def cluster_links(self) -> ClusterPipeline[AnyStr]: ...
    async def cluster_meet(
        self, ip: "StringT", port: "int", cluster_bus_port: "int | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def cluster_myid(self) -> ClusterPipeline[AnyStr]: ...
    async def cluster_nodes(self) -> ClusterPipeline[AnyStr]: ...
    async def cluster_replicas(self, node_id: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def cluster_replicate(self, node_id: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def cluster_reset(
        self, hard_soft: "Literal[PureToken.HARD, PureToken.SOFT] | None" = ...
    ) -> ClusterPipeline[AnyStr]: ...
    async def cluster_saveconfig(self) -> ClusterPipeline[AnyStr]: ...
    async def cluster_set_config_epoch(self, config_epoch: "int") -> ClusterPipeline[AnyStr]: ...
    async def cluster_setslot(
        self,
        slot: "int",
        importing: "StringT | None" = ...,
        migrating: "StringT | None" = ...,
        node: "StringT | None" = ...,
        stable: "bool | None" = ...,
    ) -> ClusterPipeline[AnyStr]: ...
    async def cluster_shards(self) -> ClusterPipeline[AnyStr]: ...
    async def cluster_slaves(self, node_id: "StringT") -> ClusterPipeline[AnyStr]: ...
    async def cluster_slots(self) -> ClusterPipeline[AnyStr]: ...
    async def readonly(self) -> ClusterPipeline[AnyStr]: ...
    async def readwrite(self) -> ClusterPipeline[AnyStr]: ...
