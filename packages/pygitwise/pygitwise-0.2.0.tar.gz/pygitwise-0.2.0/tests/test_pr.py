from unittest.mock import MagicMock, patch, call
import pytest
import subprocess  # For mocking gh CLI calls
import os

from gitwise.features.pr import (
    PrFeature,
    _clean_pr_body,
    _validate_branch_name,
    _get_pr_commits,
    _generate_pr_title,
    _generate_pr_description_llm,  # For direct test
    _get_repository_info,  # For direct test
)
from gitwise.features.pr_enhancements import (
    get_pr_labels,
    get_changed_files,
    generate_checklist,
    enhance_pr_description,
    DEFAULT_COMMIT_TYPE_LABELS,
    FILE_PATTERN_CHECKLISTS,
)
from gitwise.core.git_manager import GitManager
from gitwise.prompts import PROMPT_PR_DESCRIPTION


@pytest.fixture
def mock_git_manager_pr():  # Renamed to avoid conflict if used in same test session as other features
    """Fixture to mock GitManager for PR tests."""
    with patch(
        "gitwise.features.pr.GitManager", spec=GitManager
    ) as mock_gm_constructor:  # Mock constructor
        mock_gm_instance = mock_gm_constructor.return_value
        mock_gm_instance.get_current_branch.return_value = "feature/test-pr"
        mock_gm_instance.get_default_remote_branch_name.return_value = "main"
        mock_gm_instance.get_merge_base.return_value = (
            "abcdef123456"  # Mock merge base hash
        )
        mock_gm_instance.get_commits_between.return_value = [
            {
                "hash": "c1",
                "message": "feat: implement amazing feature",
                "author": "dev1",
            },
            {"hash": "c2", "message": "fix: solve critical bug", "author": "dev2"},
        ]
        mock_gm_instance.has_uncommitted_changes.return_value = (
            False  # Default to no uncommitted changes
        )
        mock_gm_instance._run_git_command.return_value = MagicMock(
            stdout="remote.origin.url git@github.com:user/repo.git", returncode=0
        )
        yield mock_gm_instance


@pytest.fixture
def mock_pr_dependencies():  # Mocks for PrFeature execution
    with patch("gitwise.features.pr.load_config", MagicMock(return_value={})), patch(
        "gitwise.features.pr.get_llm_backend", MagicMock(return_value="ollama")
    ), patch(
        "gitwise.features.pr.typer.confirm"
    ) as mock_confirm, patch(
        "gitwise.features.pr.typer.prompt"
    ) as mock_prompt, patch(
        "gitwise.features.pr.subprocess.run"
    ) as mock_subprocess_run, patch(
        "gitwise.features.pr.get_llm_response"
    ) as mock_get_llm, patch(
        "gitwise.features.pr_enhancements.get_changed_files"
    ) as mock_get_changed_files_enhancements, patch(
        "gitwise.features.pr.get_pr_labels"
    ) as mock_get_pr_labels_feature, patch(
        "gitwise.features.pr.enhance_pr_description"
    ) as mock_enhance_pr_desc_feature:

        # Define a side effect function for subprocess.run to handle different calls
        def subprocess_side_effect(*args, **kwargs):
            cmd = args[0]
            
            # Check if this is a git branch check call
            if len(cmd) >= 2 and cmd[0] == "git" and "rev-parse" in cmd:
                return MagicMock(returncode=0, stdout="feature/test-branch", stderr="")
            
            # For gh pr list (checking for existing PRs)
            if len(cmd) >= 3 and cmd[0] == "gh" and cmd[1] == "pr" and cmd[2] == "list":
                return MagicMock(returncode=0, stdout="[]", stderr="")
            
            # For gh pr create call
            if len(cmd) >= 3 and cmd[0] == "gh" and cmd[1] == "pr" and cmd[2] == "create":
                return MagicMock(returncode=0, stdout="https://github.com/user/repo/pull/123", stderr="")
            
            # For editor when editing PR description
            if len(cmd) == 2 and (cmd[0] == "vi" or cmd[0] == os.environ.get("EDITOR", "vi")):
                return MagicMock(returncode=0, stdout="", stderr="")
            
            # Default fallback
            return MagicMock(returncode=0, stdout="", stderr="")
        
        # Set up the side effect for subprocess.run
        mock_subprocess_run.side_effect = subprocess_side_effect
        
        mock_get_llm.return_value = "This is a great PR body generated by AI."
        mock_get_changed_files_enhancements.return_value = ["src/main.py", "README.md"]
        mock_get_pr_labels_feature.return_value = ["enhancement", "bug"]
        mock_enhance_pr_desc_feature.side_effect = (
            lambda commits, desc, use_labels, use_checklist, skip_gen, base: (
                desc + "\n## Checklist\n- [ ] Item",
                ["enhancement", "bug"],
            )
        )

        yield {
            "confirm": mock_confirm,
            "prompt": mock_prompt,
            "subprocess_run": mock_subprocess_run,
            "get_llm": mock_get_llm,
            "get_changed_files_enhancements": mock_get_changed_files_enhancements,
            "get_pr_labels_feature": mock_get_pr_labels_feature,
            "enhance_pr_desc_feature": mock_enhance_pr_desc_feature,
        }


@pytest.fixture
def sample_commits_pr():
    return [
        {"hash": "c1", "message": "feat: implement amazing feature", "author": "dev1"},
        {"hash": "c2", "message": "fix: solve critical bug", "author": "dev2"},
    ]


# Tests for helper functions in pr.py


def test_clean_pr_body():
    raw = "Here is the PR body:\n\n## Summary\nThis is a summary.\n\n## Contributors\nThanks to everyone!"
    cleaned = _clean_pr_body(raw)
    assert "Here is the PR body:" not in cleaned
    assert "## Summary" in cleaned
    assert "Contributors" not in cleaned
    assert _clean_pr_body("Just the body.") == "Just the body."


def test_validate_branch_name():
    assert _validate_branch_name("feature/new-feature")
    assert _validate_branch_name("fix/bug-fix-123")
    assert not _validate_branch_name("main")
    assert not _validate_branch_name(
        "feature/NewFeatureWithCaps"
    )  # No caps allowed by regex
    assert not _validate_branch_name("feature-no-slash")


def test_get_pr_commits(mock_git_manager_pr, sample_commits_pr):
    mock_git_manager_pr.get_commits_between.return_value = sample_commits_pr
    commits = _get_pr_commits(mock_git_manager_pr, "origin/main")
    assert commits == sample_commits_pr
    mock_git_manager_pr.get_merge_base.assert_called_once_with("origin/main", "HEAD")
    mock_git_manager_pr.get_commits_between.assert_called_once_with(
        "abcdef123456", "HEAD"
    )


def test_generate_pr_title(sample_commits_pr):
    title = _generate_pr_title(sample_commits_pr)
    assert title == "feat: implement amazing feature (+1 more commits)"
    title_single = _generate_pr_title([sample_commits_pr[0]])
    assert title_single == "feat: implement amazing feature"


def test_generate_pr_description_llm(sample_commits_pr):
    # Patch both get_llm_response and ContextFeature to avoid branch checking issues
    with patch("gitwise.features.pr.get_llm_response") as mock_llm_resp, \
         patch("gitwise.features.pr.ContextFeature") as MockContextFeature:
        # Setup the context feature mock
        mock_context_instance = MagicMock()
        mock_context_instance.get_context_for_ai_prompt.return_value = ""
        mock_context_instance.parse_branch_context.return_value = None
        MockContextFeature.return_value = mock_context_instance
        
        # Setup the LLM response
        mock_llm_resp.return_value = "AI Generated Description"
        
        # Call the function we're testing - no need to use skip_context
        # since we're properly mocking the ContextFeature
        desc = _generate_pr_description_llm(sample_commits_pr, "url", "repo_name")
        
        # Verify the result
        assert desc == "AI Generated Description"
        
        # Verify prompt contents
        expected_prompt_content = (
            "- feat: implement amazing feature\n- fix: solve critical bug"
        )
        called_prompt = mock_llm_resp.call_args[0][0]
        assert expected_prompt_content in called_prompt
        assert (
            PROMPT_PR_DESCRIPTION.split("{{commits}}")[0] in called_prompt
        )  # Check if base prompt is used


def test_get_repository_info_from_pr_module(mock_git_manager_pr):  # Renamed test
    mock_git_manager_pr._run_git_command.return_value = MagicMock(
        stdout="git@github.com:testuser/testrepo.git", returncode=0
    )
    info = _get_repository_info(mock_git_manager_pr)
    assert info["url"] == "git@github.com:testuser/testrepo.git"
    assert info["name"] == "testuser/testrepo"


# Tests for PrFeature.execute_pr


def test_pr_feature_execute_pr_basic_flow(
    mock_git_manager_pr, mock_pr_dependencies, sample_commits_pr
):
    mock_git_manager_pr.get_commits_between.return_value = sample_commits_pr
    mock_pr_dependencies["confirm"].return_value = True  # Confirm PR creation
    mock_pr_dependencies["prompt"].return_value = 1  # "Yes" to create PR

    feature = PrFeature()
    result = feature.execute_pr(use_labels=False, use_checklist=False)
    assert result is True

    mock_pr_dependencies["get_llm"].assert_called_once()
    
    # Find the gh pr create call in the subprocess calls
    gh_create_call_found = False
    for call_args in mock_pr_dependencies["subprocess_run"].call_args_list:
        args = call_args[0][0]
        if len(args) >= 3 and args[0] == "gh" and args[1] == "pr" and args[2] == "create":
            gh_create_call_found = True
            # Check expected arguments in the gh pr create call
            assert "--title" in args
            assert "feat: implement amazing feature (+1 more commits)" in str(args)
            assert "--body" in args
            assert "This is a great PR body generated by AI." in str(args)
            assert "--base" in args
            assert "main" in str(args)  # Default base
            assert "--label" not in args  # Labels not used
            break
    
    assert gh_create_call_found, "gh pr create command not found in subprocess calls"


def test_pr_feature_execute_pr_with_labels_and_checklist(
    mock_git_manager_pr, mock_pr_dependencies, sample_commits_pr
):
    mock_git_manager_pr.get_commits_between.return_value = sample_commits_pr
    mock_pr_dependencies["confirm"].return_value = True
    mock_pr_dependencies["prompt"].return_value = 1  # Yes, create PR

    feature = PrFeature()
    # For this test, we rely on the mocked get_pr_labels_feature and enhance_pr_desc_feature
    # from mock_pr_dependencies fixture to return expected labels and modified body.
    result = feature.execute_pr(use_labels=True, use_checklist=True, base="develop")
    assert result is True

    mock_pr_dependencies["get_pr_labels_feature"].assert_called_once_with(
        sample_commits_pr
    )
    mock_pr_dependencies["enhance_pr_desc_feature"].assert_called_once()

    # Find the gh pr create call in the subprocess calls
    gh_create_call_found = False
    for call_args in mock_pr_dependencies["subprocess_run"].call_args_list:
        args = call_args[0][0]
        if len(args) >= 3 and args[0] == "gh" and args[1] == "pr" and args[2] == "create":
            gh_create_call_found = True
            # Check expected arguments in the gh pr create call
            assert "--label" in args
            assert "enhancement" in str(args)
            assert "bug" in str(args)
            assert "## Checklist" in str(args)
            assert "develop" in str(args)  # Custom base
            break
    
    assert gh_create_call_found, "gh pr create command with labels not found in subprocess calls"


def test_pr_feature_edit_description(
    mock_git_manager_pr, mock_pr_dependencies, sample_commits_pr
):
    mock_git_manager_pr.get_commits_between.return_value = sample_commits_pr
    edited_body_content = "User has edited this PR body."

    # User choices: Edit description, then proceed with edited desc
    mock_pr_dependencies["prompt"].side_effect = [
        2,
        1,
    ]  # Edit description, then Yes to create with new desc
    mock_pr_dependencies["confirm"].return_value = (
        True  # Confirm using edited description
    )

    with patch(
        "gitwise.features.pr.tempfile.NamedTemporaryFile"
    ) as mock_tempfile, patch("builtins.open") as mock_builtin_open_editor:

        mock_tf = MagicMock()
        mock_tf.name = "/tmp/pr_body.md"
        mock_tempfile.return_value.__enter__.return_value = mock_tf

        # Simulate reading the edited file content
        mock_file_read = MagicMock()
        mock_file_read.read.return_value = edited_body_content
        mock_builtin_open_editor.return_value.__enter__.return_value = mock_file_read

        feature = PrFeature()
        result = feature.execute_pr(use_labels=False, use_checklist=False)
        assert result is True

        # Verify editor call
        editor_call_found = False
        for call_args in mock_pr_dependencies["subprocess_run"].call_args_list:
            args = call_args[0][0]
            if len(args) == 2 and args[0] in ["vi", os.environ.get("EDITOR", "vi")] and args[1] == mock_tf.name:
                editor_call_found = True
                break
        assert editor_call_found, "Editor call not found for editing PR description"

        # Verify PR creation
        gh_create_call_found = False
        for call_args in mock_pr_dependencies["subprocess_run"].call_args_list:
            args = call_args[0][0]
            if len(args) >= 3 and args[0] == "gh" and args[1] == "pr" and args[2] == "create":
                for arg in args:
                    if edited_body_content in str(arg):
                        gh_create_call_found = True
                        break
                if gh_create_call_found:
                    break
        assert gh_create_call_found, "GitHub PR create call with edited content not found"


# Tests for pr_enhancements.py functions


@patch(
    "gitwise.features.pr_enhancements.git_manager", spec=GitManager
)  # Mock the module-level git_manager
def test_enh_get_changed_files(mock_gm_enhancements):
    mock_gm_enhancements.get_default_remote_branch_name.return_value = "main"
    mock_gm_enhancements.get_current_branch.return_value = "feature/xyz"
    mock_gm_enhancements._run_git_command.return_value = MagicMock(
        stdout="file1.py\nfile2.md", returncode=0
    )

    files = get_changed_files(base_branch="origin/main")
    assert files == ["file1.py", "file2.md"]
    mock_gm_enhancements._run_git_command.assert_called_once_with(
        ["diff", "--name-only", "origin/main..feature/xyz"], check=True
    )


def test_enh_get_pr_labels(sample_commits_pr):
    with patch("gitwise.features.pr_enhancements.load_custom_labels", return_value={}):
        labels = get_pr_labels(sample_commits_pr)
        assert "enhancement" in labels
        assert "bug" in labels


def test_enh_generate_checklist():
    files = ["src/main.py", "README.md", "config/settings.json"]
    checklist_str = generate_checklist(files, skip_general=False)
    assert "- [ ] Added/updated docstrings" in checklist_str  # From .py
    assert "- [ ] Checked for broken links" in checklist_str  # From .md
    assert "- [ ] Validated JSON format" in checklist_str  # From .json
    assert "- [ ] All tests pass" in checklist_str  # General item

    checklist_str_skip_general = generate_checklist(files, skip_general=True)
    assert "- [ ] All tests pass" not in checklist_str_skip_general


def test_enh_enhance_pr_description(sample_commits_pr):
    initial_desc = "Initial PR description."
    with patch(
        "gitwise.features.pr_enhancements.get_pr_labels"
    ) as mock_get_labels, patch(
        "gitwise.features.pr_enhancements.get_changed_files"
    ) as mock_get_files, patch(
        "gitwise.features.pr_enhancements.generate_checklist"
    ) as mock_gen_checklist:

        mock_get_labels.return_value = ["enhancement"]
        mock_get_files.return_value = ["script.py"]
        mock_gen_checklist.return_value = "- [ ] A python specific task"

        desc, labels = enhance_pr_description(
            sample_commits_pr, initial_desc, use_labels=True, use_checklist=True
        )

        assert labels == ["enhancement"]
        assert initial_desc in desc
        assert "## Checklist" in desc
        assert "- [ ] A python specific task" in desc
