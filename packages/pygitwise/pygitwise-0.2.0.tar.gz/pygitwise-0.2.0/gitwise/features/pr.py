"""Pull request creation feature for GitWise."""

# Test comment for PR flow

import subprocess
import re
from typing import List, Dict, Optional, Tuple

from gitwise.features.context import ContextFeature
from gitwise.llm.router import get_llm_response
from ..prompts import PROMPT_PR_DESCRIPTION
from .pr_enhancements import enhance_pr_description, get_pr_labels
from rich.console import Console
from ..ui import components
import os
import tempfile
import typer
from gitwise.config import get_llm_backend, load_config, ConfigError
from ..core.git_manager import GitManager  # New import

console = Console()


def _clean_pr_body(raw_body: str) -> str:
    """Programmatically cleans the PR body generated by LLM.
    Removes common preamble and unwanted sections like 'Contributors'.
    """
    cleaned_body = raw_body.strip()

    lines = cleaned_body.split("\n")
    start_index = 0
    for i, line in enumerate(lines):
        if line.startswith(("##", "# ", "###", "- ", "* ", "**Summary")):
            start_index = i
            break
        if (
            i < 3
            and not line.startswith("##")
            and not line.startswith("# ")
            and not line.startswith("###")
            and "Summary of Changes" not in line
            and "Key Enhancements" not in line
            and "Key Features" not in line
        ):
            continue
        else:
            if i == 0:  # No preamble found
                start_index = 0
            else:
                start_index = i  # Content started
            break

    if start_index > 0 and start_index < len(lines):
        cleaned_body = "\n".join(lines[start_index:])

    # Remove "Contributors" or "Acknowledgements" sections
    section_patterns_to_remove = [
        r"(^|\n)##?\s*(?:🙏\s*)?(?:Contributors|Acknowledgements|Special Thanks|Next Steps)\s*($|\n).*?(?=(^|\n)##?\s|\Z)"
    ]
    for pattern in section_patterns_to_remove:
        cleaned_body = re.sub(
            pattern, "", cleaned_body, flags=re.IGNORECASE | re.MULTILINE | re.DOTALL
        ).strip()

    return cleaned_body.strip()


def _validate_branch_name(branch: str) -> bool:
    """Validate branch name against naming conventions."""
    # Protected branches
    protected = {"main", "master", "develop"}
    if branch in protected:
        return False

    # Branch name pattern
    pattern = r"^(feature|fix|docs|chore|refactor|test|style|perf|ci|build|revert)/[a-z0-9-]+$"
    return bool(re.match(pattern, branch))


def _get_pr_commits(git_m: GitManager, base_branch: str) -> List[Dict]:
    """Return commits unique to the current branch (not yet merged into base_branch)."""
    try:
        merge_base = git_m.get_merge_base(base_branch, "HEAD")
        if not merge_base:
            components.show_error(f"Could not determine merge base with {base_branch}.")
            return []

        log_range = f"{merge_base}..HEAD"
        components.console.print(
            f"[dim]Analyzing commits in range: {log_range} (Base: '{base_branch}', Merge base: '{merge_base}')[/dim]"
        )
        return git_m.get_commits_between(merge_base, "HEAD")
    except Exception as e:
        components.show_error(f"Failed to get commits for PR: {str(e)}")
        return []


def _generate_pr_title(commits: List[Dict]) -> str:
    """Generate a PR title from a list of commits."""
    if not commits:
        return ""
    first_commit = commits[0]
    title = first_commit["message"].split("\n")[0]
    if len(commits) > 1:
        title = f"{title} (+{len(commits)-1} more commits)"
    return title


def _generate_pr_description_llm(
    commits: List[Dict], repo_url: str, repo_name: str, guidance: str = ""
) -> str:
    """Generate a PR description using LLM prompt with context from ContextFeature."""
    # Get context for the current branch
    context_feature = ContextFeature()
    # First try to parse branch name for context if we don't have it already
    context_feature.parse_branch_context()
    # Then get context as a formatted string for the prompt
    context_string = context_feature.get_context_for_ai_prompt()
    
    # Show visual indication that context is being used
    if context_string:
        # Trim long contexts for display
        display_context = context_string
        if len(display_context) > 100:
            display_context = display_context[:97] + "..."
        components.show_section("Context Used for PR Description")
        components.console.print(f"[dim cyan]{display_context}[/dim cyan]")
        
        # Add context to guidance
        if guidance:
            guidance = f"{context_string} {guidance}"
        else:
            guidance = context_string
    
    # Get information about changed files across all commits
    git_m = GitManager()
    changed_files = set()
    
    # First try to get files from the commits
    for commit in commits:
        if 'files' in commit:
            changed_files.update(commit['files'])
    
    # If that doesn't work, get files from current PR changes
    if not changed_files:
        current_branch = git_m.get_current_branch()
        default_branch = git_m.get_default_remote_branch_name()
        if current_branch and default_branch:
            try:
                files_output = git_m._run_git_command(
                    ["diff", "--name-only", f"origin/{default_branch}...{current_branch}"], 
                    check=False
                )
                if files_output.returncode == 0:
                    changed_files.update(files_output.stdout.strip().split('\n'))
            except:
                pass  # Silently fail if we can't get the file list
    
    # Add file information to guidance
    if changed_files:
        file_info = "\nFiles changed in this PR:\n"
        for file_path in sorted(changed_files):
            if not file_path:  # Skip empty entries
                continue
                
            # Determine file type
            file_type = "Documentation" if file_path.endswith(('.md', '.rst', '.txt')) else "Code"
            if "test" in file_path.lower():
                file_type = "Test"
            elif "docs/" in file_path.lower():
                file_type = "Documentation"
            
            file_info += f"- {file_path} ({file_type})\n"
        
        # Add file information to guidance
        if guidance:
            guidance = f"{guidance}\n\n{file_info}"
        else:
            guidance = file_info
    
    # Remove author names to avoid LLM confusion (was causing "payas module" hallucinations)
    formatted_commits = "\n".join(
        [f"- {commit['message']}" for commit in commits]
    )
    prompt = PROMPT_PR_DESCRIPTION.replace("{{commits}}", formatted_commits).replace(
        "{{guidance}}", guidance
    )
    llm_output = get_llm_response(prompt)
    return llm_output.strip()


def _create_gh_pr(
    title: str,
    body: str,
    base: str,
    current_branch: str,
    labels: List[str],
    draft: bool = False,
) -> None:
    """Internal function to create a pull request using the gh CLI."""
    components.show_section("Creating Pull Request via gh CLI")
    with components.show_spinner("Running `gh pr create`..."):
        try:
            # This subprocess call is for `gh` (GitHub CLI), not `git`.
            # It should remain a direct subprocess call unless we abstract `gh` interactions later.
            pr_list_cmd = [
                "gh",
                "pr",
                "list",
                "--head",
                current_branch,
                "--base",
                base,
                "--state",
                "open",
                "--json",
                "url",
            ]
            pr_list_result = subprocess.run(pr_list_cmd, capture_output=True, text=True)
            if pr_list_result.returncode == 0 and pr_list_result.stdout.strip():
                import json  # Import here as it's only needed for this block

                pr_list_data = json.loads(pr_list_result.stdout)
                if pr_list_data:
                    pr_url = pr_list_data[0].get("url")
                    components.show_success(
                        f"A pull request for this branch already exists: {pr_url}"
                    )
                    return

            cmd = [
                "gh",
                "pr",
                "create",
                "--title",
                title,
                "--body",
                body,
                "--base",
                base,
            ]
            if draft:
                cmd.append("--draft")
            for label in labels:
                cmd.extend(["--label", label])

            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                components.show_success("Pull request created successfully by gh CLI.")
                components.console.print(result.stdout)
            else:
                components.show_error("Failed to create pull request using gh CLI.")
                error_details = (
                    f"`gh pr create` exited with code {result.returncode}.\n"
                )
                if result.stderr:
                    error_details += f"\nStderr:\n{result.stderr}"
                if result.stdout:
                    error_details += f"\nStdout:\n{result.stdout}"
                components.console.print(error_details)
        except FileNotFoundError as fnf_error:
            if "gh" in str(fnf_error):
                components.show_error(
                    "GitHub CLI (gh) not found. Please install it to create PRs."
                )
                components.console.print(
                    "\n[dim]You can install it from: https://cli.github.com/[/dim]"
                )
            elif "git" in str(fnf_error):
                components.show_error(
                    "Git command not found. Please ensure Git is installed."
                )
            else:
                components.show_error(f"A required command was not found: {fnf_error}")
        except (
            subprocess.CalledProcessError
        ) as cpe_error:  # Catch errors from the git rev-parse call
            components.show_error(
                f"Failed to get current branch for PR creation: {cpe_error}"
            )
        except Exception as e:
            components.show_error(
                f"An unexpected error occurred during PR creation: {str(e)}"
            )


def _get_repository_info(git_m: GitManager) -> Dict[str, str]:
    """Get repository information.
    Returns:
        Dictionary with repository information.
    """
    info = {}
    try:
        config_get_result = git_m._run_git_command(
            ["config", "--get", "remote.origin.url"], check=False
        )
        info["url"] = (
            config_get_result.stdout.strip()
            if config_get_result.returncode == 0
            else ""
        )
    except RuntimeError as e:
        components.show_warning(f"Could not get remote.origin.url: {e}")
        info["url"] = ""

    if info["url"]:
        match = re.search(r"[:/]([^/]+/[^/]+?)(?:\.git)?$", info["url"])
        if match:
            info["name"] = match.group(1)
        else:
            info["name"] = "repository"
    else:
        info["name"] = "repository"
    return info


def _print_pr_commit_hashes(git_m: GitManager, base_branch: str) -> None:
    commits = _get_pr_commits(git_m, base_branch)
    components.show_section(f"[Debug] Commits for PR are (base: {base_branch})")
    for c in commits:
        components.console.print(
            f"[bold cyan]{c['hash'][:7]}[/bold cyan] {c['message']}"
        )


def _backend_display_name(backend_str: str) -> str:
    """Get backend display name with provider detection for online mode."""
    if backend_str == "online":
        try:
            from gitwise.llm.providers import detect_provider_from_config
            from gitwise.config import load_config
            
            config = load_config()
            provider = detect_provider_from_config(config)
            
            if provider == "google":
                return "Online (Google Gemini)"
            elif provider == "openai":
                return "Online (OpenAI)"
            elif provider == "anthropic":
                return "Online (Anthropic Claude)"
            elif provider == "openrouter":
                return "Online (OpenRouter)"
            else:
                return "Online (Cloud provider)"
        except:
            return "Online (Cloud provider)"
    else:
        return {
            "ollama": "Ollama (local server)",
        }.get(backend_str, backend_str)


class PrFeature:
    def __init__(self):
        self.git_manager = GitManager()

    def execute_pr(
        self,
        use_labels: bool = False,
        use_checklist: bool = False,
        skip_general_checklist: bool = False,
        title: Optional[str] = None,
        base: Optional[str] = None,
        draft: bool = False,
        skip_prompts: bool = False,
        auto_confirm: bool = False,
    ) -> bool:
        """Create a pull request with AI-generated description.
        Orchestrates commit collection, title/description generation, and PR creation.
        Returns True if PR was created or already exists, False otherwise.
        """
        try:
            # Config check
            try:
                load_config()
            except ConfigError as e:
                from ..cli.init import init_command  # Moved import here

                components.show_error(str(e))
                if auto_confirm or typer.confirm(
                    "Would you like to run 'gitwise init' now?", default=True
                ):
                    init_command()  # Assumes init_command is imported from ..cli.init
                return False

            # Handle uncommitted changes
            if self.git_manager.has_uncommitted_changes():
                components.show_warning(
                    "You have uncommitted changes (staged or unstaged). These will not be included in the PR unless you commit them."
                )
                if auto_confirm or typer.confirm(
                    "Would you like to stage and commit all changes before creating the PR?",
                    default=True,
                ):
                    with components.show_spinner("Staging all changes..."):
                        if not self.git_manager.stage_all():
                            components.show_error(
                                "Failed to stage all changes. Aborting PR creation."
                            )
                            return False
                    components.show_section("Commit All Changes Before PR")
                    commit_message = ("chore: auto-commit before PR creation" if auto_confirm else 
                                     typer.prompt(
                                         "Enter a commit message for all staged changes",
                                         default="chore: auto-commit before PR creation",
                                     ))
                    with components.show_spinner("Committing changes..."):
                        if not self.git_manager.create_commit(commit_message):
                            components.show_error(
                                "Failed to commit changes. Aborting PR creation."
                            )
                            return False
                        else:
                            components.show_success("All changes committed.")

                    if auto_confirm or typer.confirm(
                        "Would you like to update the changelog for the changes just committed?",
                        default=True,
                    ):
                        from gitwise.features.changelog import (
                            ChangelogFeature,
                        )  # Import the class

                        with components.show_spinner("Updating changelog..."):
                            ChangelogFeature().execute_changelog(
                                auto_update=True
                            )  # Call the method
                            if self.git_manager.stage_files(["CHANGELOG.md"]):
                                changelog_commit_msg = (
                                    "docs: update changelog for PR changes"
                                )
                                if self.git_manager.create_commit(changelog_commit_msg):
                                    components.show_success(
                                        "Changelog updated and committed."
                                    )
                                else:
                                    components.show_warning(
                                        f"Failed to commit changelog."
                                    )
                            else:
                                components.show_warning(
                                    "Failed to stage CHANGELOG.md after update."
                                )
                else:
                    components.show_warning(
                        "PR creation cancelled due to uncommitted changes."
                    )
                    return False

            backend = get_llm_backend()
            components.show_section(
                f"[AI] LLM Backend: {_backend_display_name(backend)}"
            )


            current_branch = self.git_manager.get_current_branch()
            if not current_branch:
                components.show_error("Not on any branch")
                return False

            default_remote_name = "origin"
            base_branch_for_analysis, base_branch_for_gh = (
                self._determine_base_branches(base, default_remote_name)
            )
            if not base_branch_for_analysis:
                return False

            components.show_section("Analyzing Changes")
            with components.show_spinner("Checking for commits..."):
                commits = _get_pr_commits(self.git_manager, base_branch_for_analysis)
                if not commits:
                    components.show_warning("No commits to create PR for")
                    return False

            pr_generated_title = title or _generate_pr_title(commits)

            self._display_commits(commits)

            components.show_section("Generating PR Description")
            repo_info = _get_repository_info(self.git_manager)
            pr_body = self._generate_and_clean_pr_body(
                commits, repo_info["url"], repo_info["name"], skip_prompts, auto_confirm
            )
            if pr_body is None:
                return False

            final_labels = []
            if use_labels:
                with components.show_spinner("Generating labels..."):
                    final_labels = get_pr_labels(
                        commits
                    )  # Module level helper from pr_enhancements

            if use_checklist:
                with components.show_spinner("Generating checklist..."):
                    # enhance_pr_description is from pr_enhancements and takes git_manager implicitly via its own get_changed_files if needed
                    pr_body, _ = enhance_pr_description(
                        commits,
                        pr_body,
                        False,
                        True,
                        skip_general_checklist,
                        base_branch_for_analysis,
                    )

            self._display_pr_preview(pr_generated_title, final_labels, pr_body)

            if skip_prompts:
                _create_gh_pr(
                    pr_generated_title,
                    pr_body,
                    base_branch_for_gh,
                    current_branch,
                    final_labels,
                    draft,
                )
                return True  # Assuming _create_gh_pr handles its own success/failure output and PR existence check
            else:
                user_choice = self._prompt_for_pr_creation()
                if user_choice.lower() == "no":
                    components.show_warning("PR creation cancelled")
                    return False

                if user_choice.lower() == "edit description":
                    edited_pr_body = self._edit_pr_body(pr_body)
                    if edited_pr_body is None:
                        return False
                    pr_body = edited_pr_body
                    self._display_pr_preview(
                        pr_generated_title,
                        final_labels,
                        pr_body,
                        "Edited PR Description",
                    )
                    if not typer.confirm(
                        "Proceed with PR creation using the edited description?",
                        default=True,
                    ):
                        components.show_warning("PR creation cancelled after edit.")
                        return False

                _create_gh_pr(
                    pr_generated_title,
                    pr_body,
                    base_branch_for_gh,
                    current_branch,
                    final_labels,
                    draft,
                )
                return True  # Assuming _create_gh_pr handles its own success/failure output and PR existence check

        except Exception as e:
            components.show_error(
                f"An unexpected error occurred in PR command: {str(e)}"
            )
            import traceback

            components.console.print(f"[dim]{traceback.format_exc()}[/dim]")
            return False

    # --- Private helper methods for PrFeature ---
    def _determine_base_branches(
        self, base_input: Optional[str], remote_name: str
    ) -> Tuple[Optional[str], Optional[str]]:
        if base_input:
            analysis_base = (
                base_input if "/" in base_input else f"{remote_name}/{base_input}"
            )
            gh_base = base_input.split(f"{remote_name}/", 1)[-1]
            return analysis_base, gh_base
        else:
            simple_default_branch = self.git_manager.get_default_remote_branch_name(
                remote_name
            )
            if not simple_default_branch:
                components.show_error(
                    f"Could not determine default remote branch for '{remote_name}'."
                )
                return None, None
            return f"{remote_name}/{simple_default_branch}", simple_default_branch

    def _display_commits(self, commits: List[Dict]):
        components.show_section("Commits to Include in PR")
        for commit in commits:
            components.console.print(
                f"[bold cyan]{commit['hash'][:7]}[/bold cyan] {commit['message']}"
            )

    def _generate_and_clean_pr_body(
        self, commits: List[Dict], repo_url: str, repo_name: str, skip_prompts: bool, auto_confirm: bool
    ) -> Optional[str]:
        """Generate a PR body using LLM and clean it for use in PR."""
        try:
            with components.show_spinner("Generating PR description..."):
                # Generate PR description using the LLM
                pr_body = _generate_pr_description_llm(
                    commits, repo_url, repo_name
                )
            if not pr_body:
                # Fallback if LLM fails
                components.show_warning("Could not generate PR description using LLM.")
                components.console.print(
                    "Using basic description derived from commits instead."
                )
                pr_body = self._generate_fallback_description(commits)
        except Exception as e:
            components.show_error(f"Could not generate PR description: {str(e)}")
            return None
        
        # Clean any unwanted text from PR body
        pr_body = _clean_pr_body(pr_body)
        return pr_body

    def _display_pr_preview(
        self,
        title: str,
        labels: List[str],
        body: str,
        section_title: str = "Suggested PR Description",
    ):
        components.show_section(section_title)
        components.console.print(f"[bold]Title:[/bold] {title}")
        if labels:
            components.console.print(f"[bold]Labels:[/bold] {', '.join(labels)}")
        components.console.print(f"[bold]Body:[/bold]\n{body}")

    def _prompt_for_pr_creation(self) -> str:
        components.show_prompt(
            "Create this pull request?",
            options=["Yes", "Edit description", "No"],
            default="Yes",
        )
        choice_num = typer.prompt("Select an option", type=int, default=1)
        return {1: "yes", 2: "edit description", 3: "no"}.get(choice_num, "no")

    def _edit_pr_body(self, current_body: str) -> Optional[str]:
        with tempfile.NamedTemporaryFile(
            suffix=".md", delete=False, mode="w+", encoding="utf-8"
        ) as tf:
            tf.write(current_body)
            tf.flush()
        editor = os.environ.get("EDITOR", "vi")
        try:
            subprocess.run([editor, tf.name], check=True)
            with open(tf.name, "r", encoding="utf-8") as f_read:
                edited_body = f_read.read().strip()
            return edited_body
        except FileNotFoundError:
            components.show_error(
                f"Editor '{editor}' not found. Please set EDITOR env var."
            )
            return typer.prompt(
                "PR Body (editor not found)", default=current_body, multi_line_ok=True
            )
        except subprocess.CalledProcessError:
            components.show_warning("Editor closed without changes or with an error.")
            return typer.prompt(
                "PR Body (editor error)", default=current_body, multi_line_ok=True
            )
        finally:
            if os.path.exists(tf.name):
                os.unlink(tf.name)

    def _generate_fallback_description(self, commits: List[Dict]) -> str:
        """Generate a basic PR description from commits when LLM fails."""
        lines = ["## Summary", ""]
        
        # Add a basic summary line
        if commits:
            lines.append(f"This PR contains {len(commits)} commit(s).")
            lines.append("")
        
        # Add commit list
        lines.append("## Commits")
        lines.append("")
        for commit in commits:
            lines.append(f"* {commit['message']}")
        
        return "\n".join(lines)
