"""
Generated node classes from TOML configuration.
This file is auto-generated. Do not edit manually.
"""

from typing import Any, Dict, List, Optional, Union, Protocol, runtime_checkable
from .node import Node, NodeOutputs


@Node.register_node_type("append_files")
class AppendFilesNode(Node):
    """
    Append files together in successive fashion

    ## Inputs
    ### Common Inputs
        file_type: The type of file to append.
        selected_files: The number of files to be appended. Files will be appended in successive fashion (e.g., file-1 first, then file-2, etc.).

    ## Outputs
    ### Common Outputs
        file: A file with all the files appended together.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file_type",
            "helper_text": "The type of file to append.",
            "value": "PDF",
            "type": "enum<string>",
        },
        {
            "field": "selected_files",
            "helper_text": "The number of files to be appended. Files will be appended in successive fashion (e.g., file-1 first, then file-2, etc.).",
            "value": [""],
            "type": "vec<file>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file", "helper_text": "A file with all the files appended together."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        file_type: str = "PDF",
        selected_files: List[str] = [""],
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="append_files",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_type is not None:
            self.inputs["file_type"] = file_type
        if selected_files is not None:
            self.inputs["selected_files"] = selected_files

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def file(self) -> str:
        """
        A file with all the files appended together.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file")

    @classmethod
    def from_dict(cls, data: dict) -> "AppendFilesNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("sticky_note")
class StickyNoteNode(Node):
    """


    ## Inputs
    ### Common Inputs
        text: The text input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "text",
            "helper_text": "The text input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="sticky_note",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "StickyNoteNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("custom_group")
class CustomGroupNode(Node):
    """


    ## Inputs
        None

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = []

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="custom_group",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "CustomGroupNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("transformation")
class TransformationNode(Node):
    """
    A transformation node that applies a specific transformation to the input data.

    ## Inputs
    ### Common Inputs
        transformation: The ID of the transformation to be used
    ### [transformations._id.<A>]
        [<A>.inputs]: The [<A>.inputs] input

    ## Outputs
    ### [transformations._id.<A>]
        [<A>.outputs]: The [<A>.outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "transformation",
            "helper_text": "The ID of the transformation to be used",
            "value": {"object_id": "", "object_type": 14},
            "type": "transformation",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "[transformations._id.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["transformation"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        transformation: Any = {"object_id": "", "object_type": 14},
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["transformation"] = transformation

        super().__init__(
            node_type="transformation",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if transformation is not None:
            self.inputs["transformation"] = transformation

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "TransformationNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("chat_file_reader")
class ChatFileReaderNode(Node):
    """
    Allows for document upload within chatbots (often connected to the LLM node).

    ## Inputs
    ### Common Inputs
        chunk_overlap: The number of tokens of overlap between chunks (1 token = 4 characters)
        chunk_size: The number of tokens per chunk (1 token = 4 characters)
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
        max_docs_per_query: Sets the maximum number of chunks to retrieve for each query
        retrieval_unit: Return the most relevant Chunks (text content) or Documents (will return the document metadata)

    ## Outputs
    ### Common Outputs
        documents: The uploaded file (in the chat interface) is processed into text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_overlap",
            "helper_text": "The number of tokens of overlap between chunks (1 token = 4 characters)",
            "value": 200,
            "type": "int32",
        },
        {
            "field": "chunk_size",
            "helper_text": "The number of tokens per chunk (1 token = 4 characters)",
            "value": 1000,
            "type": "int32",
        },
        {
            "field": "file_parser",
            "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
            "value": "default",
            "type": "enum<string>",
        },
        {
            "field": "max_docs_per_query",
            "helper_text": "Sets the maximum number of chunks to retrieve for each query",
            "value": 10,
            "type": "int32",
        },
        {
            "field": "retrieval_unit",
            "helper_text": "Return the most relevant Chunks (text content) or Documents (will return the document metadata)",
            "value": "chunks",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "documents",
            "helper_text": "The uploaded file (in the chat interface) is processed into text",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_overlap: int = 200,
        chunk_size: int = 1000,
        file_parser: str = "default",
        max_docs_per_query: int = 10,
        retrieval_unit: str = "chunks",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="chat_file_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_parser is not None:
            self.inputs["file_parser"] = file_parser
        if max_docs_per_query is not None:
            self.inputs["max_docs_per_query"] = max_docs_per_query
        if retrieval_unit is not None:
            self.inputs["retrieval_unit"] = retrieval_unit
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def documents(self) -> List[str]:
        """
        The uploaded file (in the chat interface) is processed into text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("documents")

    @classmethod
    def from_dict(cls, data: dict) -> "ChatFileReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("pipeline")
class PipelineNode(Node):
    """
    Pipeline

    ## Inputs
    ### Common Inputs
        pipeline: The ID of the pipeline to be used
    ### [pipelines._id.<A>]
        [<A>.inputs]: The [<A>.inputs] input

    ## Outputs
    ### [pipelines._id.<A>]
        [<A>.outputs]: The [<A>.outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "pipeline",
            "helper_text": "The ID of the pipeline to be used",
            "value": {"object_type": 0, "object_id": ""},
            "type": "pipeline",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "[pipelines._id.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["pipeline"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        pipeline: Any = {"object_type": 0, "object_id": ""},
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["pipeline"] = pipeline

        super().__init__(
            node_type="pipeline",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if pipeline is not None:
            self.inputs["pipeline"] = pipeline

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "PipelineNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("agent")
class AgentNode(Node):
    """
    Agent

    ## Inputs
    ### Common Inputs
        agent_id: The agent_id input
    ### [agents._id.<A>]
        [<A>.inputs]: The [<A>.inputs] input

    ## Outputs
    ### [agents._id.<A>]
        [<A>.outputs]: The [<A>.outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "agent_id",
            "helper_text": "The agent_id input",
            "value": "",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "[agents._id.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["agent_id"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        agent_id: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["agent_id"] = agent_id

        super().__init__(
            node_type="agent",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if agent_id is not None:
            self.inputs["agent_id"] = agent_id

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "AgentNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("chat_memory")
class ChatMemoryNode(Node):
    """
    Give connected nodes access to conversation history.

    ## Inputs
    ### Common Inputs
        memory_type: The type of memory to use
        memory_window: The number of tokens to store in memory

    ## Outputs
    ### Common Outputs
        memory: The conversation history in the format of the selected type
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "memory_type",
            "helper_text": "The type of memory to use",
            "value": "Token Buffer",
            "type": "string",
        },
        {
            "field": "memory_window",
            "helper_text": "The number of tokens to store in memory",
            "value": 2048,
            "type": "int32",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "memory",
            "helper_text": "The conversation history in the format of the selected type",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "Vector Database": {
            "inputs": [
                {"field": "memory_window", "type": "int32", "value": 20},
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Vector Database",
                    "helper_text": "Stores all previous messages in a Vector Database. Will return most similar messages based on the user message",
                },
            ],
            "outputs": [],
        },
        "Message Buffer": {
            "inputs": [
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Message Buffer",
                    "helper_text": "Returns a set number of previous consecutive messages",
                },
                {"field": "memory_window", "type": "int32", "value": 10},
            ],
            "outputs": [],
        },
        "Token Buffer": {
            "inputs": [
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Token Buffer",
                    "helper_text": "Returns a set number of previous consecutive messages until adding an additional message would cause the total history size to be larger than the Max Tokens",
                },
                {"field": "memory_window", "type": "int32", "value": 2048},
            ],
            "outputs": [],
        },
        "Full - Formatted": {
            "inputs": [
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Full - Formatted",
                    "helper_text": "Returns all previous chat history",
                }
            ],
            "outputs": [],
        },
        "Full - Raw": {
            "inputs": [
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Full - Raw",
                    "helper_text": 'Returns a Python list with elements in the following format: {"type": type, "message": message}',
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["memory_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        memory_type: str = "Token Buffer",
        memory_window: int = 2048,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["memory_type"] = memory_type

        super().__init__(
            node_type="chat_memory",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if memory_type is not None:
            self.inputs["memory_type"] = memory_type
        if memory_window is not None:
            self.inputs["memory_window"] = memory_window

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def memory(self) -> str:
        """
        The conversation history in the format of the selected type


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("memory")

    @classmethod
    def from_dict(cls, data: dict) -> "ChatMemoryNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("llm")
class LlmNode(Node):
    """
    LLM

    ## Inputs
    ### Common Inputs
        enable_moderation: Whether to enable moderation
        enable_pii_address: Whether to enable PII address
        enable_pii_cc: Whether to enable PII cc
        enable_pii_email: Whether to enable PII email
        enable_pii_name: Whether to enable PII name
        enable_pii_phone: Whether to enable PII phone
        enable_pii_ssn: Whether to enable PII ssn
        max_tokens: The maximum amount of input + output tokens the model will take in and generate per run (1 token = 4 characters). Note: different models have different token limits and the workflow will error if the max token is reached.
        model: Select the LLM model to be used
        prompt: The data that is sent to the LLM. Add data from other nodes with double curly braces e.g., {{input_0.text}}
        provider: Select the LLM provider to be used
        retry_on_failure: Enable retrying when the node execution fails
        safe_context_token_window: If enabled, the context window will be reduced to fit the model's maximum context window.
        show_confidence: Whether to show the confidence score of the response
        show_sources: Whether to show the sources used to generate the response
        stream: Whether to stream the response
        system: The system prompt to be used
        temperature: The “creativity” of the response - increase the temperature for more creative responses.
        thinking_token_limit: The maximum number of tokens the model can use for thinking
        top_p: The “randomness” of the output - higher Top P values increase the randomness
    ### When use_personal_api_key = True
        api_key: Your personal API key
    ### When provider = 'custom'
        api_key: Your personal API key
        base_url: The base URL of the custom LLM provider
        finetuned_model: Use your finetuned model for response generation. Make sure to select the matching base model from the dropdown.
        use_personal_api_key: Whether to use a personal API key
    ### When show_sources = True
        citation_metadata: The metadata of the sources used to generate the response
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'azure' and use_personal_api_key = True
        deployment_id: The deployment ID for the Azure OpenAI model. This is required when using Azure OpenAI services.
        endpoint: The Azure OpenAI endpoint URL (e.g., https://your-resource-name.openai.azure.com)
    ### When provider = 'openai' and use_personal_api_key = True
        finetuned_model: Use your finetuned model for response generation. Make sure to select the matching base model from the dropdown.
    ### When provider = 'openai'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'anthropic'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'google'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'cohere'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'together'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'bedrock'
        json_response: Whether to return the response as a JSON object
    ### When provider = 'azure'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When json_response = True
        json_schema: The schema of the JSON response
    ### When retry_on_failure = True
        max_retries: The maximum number of retries
        retry_interval_ms: The interval between retries in milliseconds
    ### When provider = 'perplexity'
        use_personal_api_key: Whether to use a personal API key

    ## Outputs
    ### Common Outputs
        credits_used: The number of credits used
        input_tokens: The number of input tokens
        output_tokens: The number of output tokens
        tokens_used: The number of tokens used
    ### When stream = True
        response: The response as a stream of text
    ### When stream = False
        response: The response as a single string
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "enable_moderation",
            "helper_text": "Whether to enable moderation",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_address",
            "helper_text": "Whether to enable PII address",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_cc",
            "helper_text": "Whether to enable PII cc",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_email",
            "helper_text": "Whether to enable PII email",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_name",
            "helper_text": "Whether to enable PII name",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_phone",
            "helper_text": "Whether to enable PII phone",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_ssn",
            "helper_text": "Whether to enable PII ssn",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The maximum amount of input + output tokens the model will take in and generate per run (1 token = 4 characters). Note: different models have different token limits and the workflow will error if the max token is reached.",
            "value": 128000,
            "type": "int64",
        },
        {
            "field": "model",
            "helper_text": "Select the LLM model to be used",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The data that is sent to the LLM. Add data from other nodes with double curly braces e.g., {{input_0.text}}",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "Select the LLM provider to be used",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "retry_on_failure",
            "helper_text": "Enable retrying when the node execution fails",
            "value": False,
            "type": "bool",
        },
        {
            "field": "safe_context_token_window",
            "helper_text": "If enabled, the context window will be reduced to fit the model's maximum context window.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "show_confidence",
            "helper_text": "Whether to show the confidence score of the response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "show_sources",
            "helper_text": "Whether to show the sources used to generate the response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "stream",
            "helper_text": "Whether to stream the response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "system",
            "helper_text": "The system prompt to be used",
            "value": "",
            "type": "string",
        },
        {
            "field": "temperature",
            "helper_text": "The “creativity” of the response - increase the temperature for more creative responses.",
            "value": 0.5,
            "type": "float",
        },
        {
            "field": "thinking_token_limit",
            "helper_text": "The maximum number of tokens the model can use for thinking",
            "value": 0,
            "type": "int64",
        },
        {
            "field": "top_p",
            "helper_text": "The “randomness” of the output - higher Top P values increase the randomness",
            "value": 0.5,
            "type": "float",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "credits_used", "helper_text": "The number of credits used"},
        {"field": "input_tokens", "helper_text": "The number of input tokens"},
        {"field": "output_tokens", "helper_text": "The number of output tokens"},
        {"field": "tokens_used", "helper_text": "The number of tokens used"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**true**(*)**(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "response",
                    "type": "stream<string>",
                    "helper_text": "The response as a stream of text",
                }
            ],
        },
        "(*)**false**(*)**(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "helper_text": "The response as a single string",
                }
            ],
        },
        "(*)**(*)**true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Your personal API key",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_schema",
                    "type": "string",
                    "value": "",
                    "helper_text": "The schema of the JSON response",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**(*)**true**(*)": {
            "inputs": [
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "value": [],
                    "helper_text": "The metadata of the sources used to generate the response",
                },
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**(*)**(*)**true": {
            "inputs": [
                {
                    "field": "max_retries",
                    "type": "int32",
                    "value": 1,
                    "helper_text": "The maximum number of retries",
                },
                {
                    "field": "retry_interval_ms",
                    "type": "int32",
                    "value": 1000,
                    "helper_text": "The interval between retries in milliseconds",
                },
            ],
            "outputs": [],
        },
        "custom**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "base_url",
                    "type": "string",
                    "value": "",
                    "helper_text": "The base URL of the custom LLM provider",
                },
                {
                    "field": "model",
                    "type": "string",
                    "value": "",
                    "helper_text": "The model to be used",
                },
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Your API key",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Whether to use a personal API key",
                },
                {
                    "field": "finetuned_model",
                    "type": "string",
                    "value": "",
                    "helper_text": "Use your finetuned model for response generation. Make sure to select the matching base model from the dropdown.",
                },
            ],
            "outputs": [],
            "title": "Custom",
        },
        "openai**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
            ],
            "outputs": [],
            "title": "OpenAI",
        },
        "openai**(*)**true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "finetuned_model",
                    "type": "string",
                    "value": "",
                    "helper_text": "Use your finetuned model for response generation. Make sure to select the matching base model from the dropdown.",
                }
            ],
            "outputs": [],
        },
        "anthropic**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
            ],
            "outputs": [],
            "title": "Anthropic",
        },
        "perplexity**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                }
            ],
            "outputs": [],
            "title": "Perplexity",
        },
        "google**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
            ],
            "outputs": [],
            "title": "Google",
        },
        "cohere**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
            ],
            "outputs": [],
            "title": "Cohere",
        },
        "together**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
            ],
            "outputs": [],
            "title": "Open Source",
        },
        "bedrock**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                }
            ],
            "outputs": [],
            "title": "Bedrock",
        },
        "azure**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
            ],
            "outputs": [],
            "title": "Azure",
        },
        "azure**(*)**true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "endpoint",
                    "type": "string",
                    "value": "",
                    "helper_text": "The Azure OpenAI endpoint URL (e.g., https://your-resource-name.openai.azure.com)",
                },
                {
                    "field": "deployment_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The deployment ID for the Azure OpenAI model. This is required when using Azure OpenAI services.",
                },
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = [
        "provider",
        "stream",
        "use_personal_api_key",
        "json_response",
        "show_sources",
        "retry_on_failure",
    ]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        provider: str = "openai",
        stream: bool = False,
        use_personal_api_key: bool = False,
        json_response: bool = False,
        show_sources: bool = False,
        retry_on_failure: bool = False,
        api_key: str = "",
        base_url: str = "",
        citation_metadata: List[str] = [],
        deployment_id: str = "",
        enable_moderation: bool = False,
        enable_pii_address: bool = False,
        enable_pii_cc: bool = False,
        enable_pii_email: bool = False,
        enable_pii_name: bool = False,
        enable_pii_phone: bool = False,
        enable_pii_ssn: bool = False,
        endpoint: str = "",
        finetuned_model: str = "",
        json_schema: str = "",
        max_retries: int = 1,
        max_tokens: int = 128000,
        model: str = "gpt-4o",
        prompt: str = "",
        retry_interval_ms: int = 1000,
        safe_context_token_window: bool = False,
        show_confidence: bool = False,
        system: str = "",
        temperature: Any = 0.5,
        thinking_token_limit: int = 0,
        top_p: Any = 0.5,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["provider"] = provider
        params["stream"] = stream
        params["use_personal_api_key"] = use_personal_api_key
        params["json_response"] = json_response
        params["show_sources"] = show_sources
        params["retry_on_failure"] = retry_on_failure

        super().__init__(
            node_type="llm",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if system is not None:
            self.inputs["system"] = system
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if stream is not None:
            self.inputs["stream"] = stream
        if show_sources is not None:
            self.inputs["show_sources"] = show_sources
        if show_confidence is not None:
            self.inputs["show_confidence"] = show_confidence
        if enable_moderation is not None:
            self.inputs["enable_moderation"] = enable_moderation
        if enable_pii_name is not None:
            self.inputs["enable_pii_name"] = enable_pii_name
        if enable_pii_email is not None:
            self.inputs["enable_pii_email"] = enable_pii_email
        if enable_pii_phone is not None:
            self.inputs["enable_pii_phone"] = enable_pii_phone
        if enable_pii_ssn is not None:
            self.inputs["enable_pii_ssn"] = enable_pii_ssn
        if enable_pii_address is not None:
            self.inputs["enable_pii_address"] = enable_pii_address
        if enable_pii_cc is not None:
            self.inputs["enable_pii_cc"] = enable_pii_cc
        if thinking_token_limit is not None:
            self.inputs["thinking_token_limit"] = thinking_token_limit
        if safe_context_token_window is not None:
            self.inputs["safe_context_token_window"] = safe_context_token_window
        if retry_on_failure is not None:
            self.inputs["retry_on_failure"] = retry_on_failure
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if json_schema is not None:
            self.inputs["json_schema"] = json_schema
        if citation_metadata is not None:
            self.inputs["citation_metadata"] = citation_metadata
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if max_retries is not None:
            self.inputs["max_retries"] = max_retries
        if retry_interval_ms is not None:
            self.inputs["retry_interval_ms"] = retry_interval_ms
        if base_url is not None:
            self.inputs["base_url"] = base_url
        if finetuned_model is not None:
            self.inputs["finetuned_model"] = finetuned_model
        if endpoint is not None:
            self.inputs["endpoint"] = endpoint
        if deployment_id is not None:
            self.inputs["deployment_id"] = deployment_id

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def credits_used(self) -> Any:
        """
        The number of credits used


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("credits_used")

    @property
    def input_tokens(self) -> int:
        """
        The number of input tokens


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("input_tokens")

    @property
    def output_tokens(self) -> int:
        """
        The number of output tokens


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output_tokens")

    @property
    def response(self) -> Any:
        """
        The response as a stream of text

        Different behavior based on configuration:
          - The response as a stream of text (When stream = True)
          - The response as a single string (When stream = False)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @property
    def tokens_used(self) -> int:
        """
        The number of tokens used


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tokens_used")

    @classmethod
    def from_dict(cls, data: dict) -> "LlmNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("input")
class InputNode(Node):
    """
    Pass data of different types into your workflow.

    ## Inputs
    ### Common Inputs
        description: The description of the input
        input_type: Raw Text
        use_default_value: Set default value to be used if no value is provided
    ### When input_type = 'string' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'file' and use_default_value = True
        default_value: The default value to be used if no value is provided
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
    ### When input_type = 'audio' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'image' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'knowledge_base' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'pipeline' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'vec<file>' and use_default_value = True
        default_value: The default value to be used if no value is provided
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
    ### When input_type = 'int32' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'bool' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'timestamp' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'vec<string>' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'file' and use_default_value = False
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
    ### When input_type = 'vec<file>' and use_default_value = False
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.

    ## Outputs
    ### When input_type = 'audio' and use_default_value = False
        audio: The audio that was passed in
    ### When input_type = 'audio' and use_default_value = True
        audio: The audio that was passed in
    ### When input_type = 'file' and use_default_value = False
        file: The file that was passed in
        processed_text: The processed text of the file.
    ### When input_type = 'file' and use_default_value = True
        file: The file that was passed in
        processed_text: The processed text of the file.
    ### When input_type = 'vec<file>' and use_default_value = False
        files: The files that were passed in
        processed_texts: The processed text of the files
    ### When input_type = 'vec<file>' and use_default_value = True
        files: The files that were passed in
        processed_texts: The processed text of the files
    ### When input_type = 'image' and use_default_value = False
        image: The image that was passed in
    ### When input_type = 'image' and use_default_value = True
        image: The image that was passed in
    ### When input_type = 'knowledge_base' and use_default_value = False
        knowledge_base: The Knowledge Base that was passed in
    ### When input_type = 'knowledge_base' and use_default_value = True
        knowledge_base: The Knowledge Base that was passed in
    ### When input_type = 'pipeline' and use_default_value = False
        pipeline: The pipeline output
    ### When input_type = 'pipeline' and use_default_value = True
        pipeline: The pipeline output
    ### When input_type = 'string' and use_default_value = False
        text: The text that was passed in
    ### When input_type = 'string' and use_default_value = True
        text: The text that was passed in
    ### When input_type = 'int32' and use_default_value = False
        value: The integer that was passed in
    ### When input_type = 'int32' and use_default_value = True
        value: The integer that was passed in
    ### When input_type = 'bool' and use_default_value = False
        value: The boolean that was passed in
    ### When input_type = 'bool' and use_default_value = True
        value: The boolean that was passed in
    ### When input_type = 'timestamp' and use_default_value = False
        value: The timestamp that was passed in
    ### When input_type = 'timestamp' and use_default_value = True
        value: The timestamp that was passed in
    ### When input_type = 'vec<string>' and use_default_value = False
        value: The list of strings that was passed in
    ### When input_type = 'vec<string>' and use_default_value = True
        value: The list of strings that was passed in
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "description",
            "helper_text": "The description of the input",
            "value": "",
            "type": "string",
        },
        {
            "field": "input_type",
            "helper_text": "Raw Text",
            "value": "string",
            "type": "enum<string>",
        },
        {
            "field": "use_default_value",
            "helper_text": "Set default value to be used if no value is provided",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "string**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "string",
                    "helper_text": "Raw Text",
                }
            ],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The text that was passed in",
                }
            ],
        },
        "string**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "string",
                    "helper_text": "Raw Text",
                },
                {
                    "field": "default_value",
                    "type": "string",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The text that was passed in",
                }
            ],
        },
        "file**false": {
            "inputs": [
                {
                    "field": "file_parser",
                    "type": "enum<string>",
                    "value": "default",
                    "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
                },
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "file",
                    "helper_text": "File of any type: PDF, Word, MP3, JPEG, etc.",
                },
            ],
            "outputs": [
                {
                    "field": "processed_text",
                    "type": "string",
                    "helper_text": "The processed text of the file.",
                },
                {
                    "field": "file",
                    "type": "file",
                    "helper_text": "The file that was passed in",
                },
            ],
        },
        "file**true": {
            "inputs": [
                {
                    "field": "file_parser",
                    "type": "enum<string>",
                    "value": "default",
                    "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
                },
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "file",
                    "helper_text": "File of any type: PDF, Word, MP3, JPEG, etc.",
                },
                {
                    "field": "default_value",
                    "type": "file",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "processed_text",
                    "type": "string",
                    "helper_text": "The processed text of the file.",
                },
                {
                    "field": "file",
                    "type": "file",
                    "helper_text": "The file that was passed in",
                },
            ],
        },
        "audio**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "audio",
                    "helper_text": "Allows you to record audio through the VectorShift platform. To convert the audio to text, connect the input node to a Speech to Text node",
                }
            ],
            "outputs": [
                {
                    "field": "audio",
                    "type": "audio",
                    "helper_text": "The audio that was passed in",
                }
            ],
        },
        "audio**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "audio",
                    "helper_text": "Allows you to record audio through the VectorShift platform. To convert the audio to text, connect the input node to a Speech to Text node",
                },
                {
                    "field": "default_value",
                    "type": "audio",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "audio",
                    "type": "audio",
                    "helper_text": "The audio that was passed in",
                }
            ],
        },
        "image**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "image",
                    "helper_text": "Image of any type: JPEG, PNG, etc.",
                }
            ],
            "outputs": [
                {
                    "field": "image",
                    "type": "image",
                    "helper_text": "The image that was passed in",
                }
            ],
        },
        "image**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "image",
                    "helper_text": "Image of any type: JPEG, PNG, etc.",
                },
                {
                    "field": "default_value",
                    "type": "image",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "image",
                    "type": "image",
                    "helper_text": "The image that was passed in",
                }
            ],
        },
        "knowledge_base**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "knowledge_base",
                    "helper_text": "Allows you to pass a Knowledge Base as an input",
                }
            ],
            "outputs": [
                {
                    "field": "knowledge_base",
                    "type": "knowledge_base",
                    "helper_text": "The Knowledge Base that was passed in",
                }
            ],
        },
        "knowledge_base**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "knowledge_base",
                    "helper_text": "Allows you to pass a Knowledge Base as an input",
                },
                {
                    "field": "default_value",
                    "type": "knowledge_base",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "knowledge_base",
                    "type": "knowledge_base",
                    "helper_text": "The Knowledge Base that was passed in",
                }
            ],
        },
        "pipeline**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "pipeline",
                    "helper_text": "Allows you to pass a Pipeline as an input",
                }
            ],
            "outputs": [{"field": "pipeline", "type": "pipeline"}],
        },
        "pipeline**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "pipeline",
                    "helper_text": "Allows you to pass a Pipeline as an input",
                },
                {
                    "field": "default_value",
                    "type": "pipeline",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [{"field": "pipeline", "type": "pipeline"}],
        },
        "vec<file>**false": {
            "inputs": [
                {
                    "field": "file_parser",
                    "type": "enum<string>",
                    "value": "default",
                    "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
                },
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "vec<file>",
                    "helper_text": "Allows you to pass a list of files as an input",
                },
            ],
            "outputs": [
                {
                    "field": "processed_texts",
                    "type": "vec<string>",
                    "helper_text": "The processed text of the files",
                },
                {
                    "field": "files",
                    "type": "vec<file>",
                    "helper_text": "The files that were passed in",
                },
            ],
        },
        "vec<file>**true": {
            "inputs": [
                {
                    "field": "file_parser",
                    "type": "enum<string>",
                    "value": "default",
                    "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
                },
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "vec<file>",
                    "helper_text": "Allows you to pass a list of files as an input",
                },
                {
                    "field": "default_value",
                    "type": "vec<file>",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "processed_texts",
                    "type": "vec<string>",
                    "helper_text": "The processed text of the files",
                },
                {
                    "field": "files",
                    "type": "vec<file>",
                    "helper_text": "The files that were passed in",
                },
            ],
        },
        "int32**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "int32",
                    "helper_text": "Allows you to pass an integer as an input",
                }
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "int32",
                    "helper_text": "The integer that was passed in",
                }
            ],
        },
        "int32**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "int32",
                    "helper_text": "Allows you to pass an integer as an input",
                },
                {
                    "field": "default_value",
                    "type": "int32",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "int32",
                    "helper_text": "The integer that was passed in",
                }
            ],
        },
        "bool**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "bool",
                    "helper_text": "Allows you to pass a boolean as an input",
                }
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "bool",
                    "helper_text": "The boolean that was passed in",
                }
            ],
        },
        "bool**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "bool",
                    "helper_text": "Allows you to pass a boolean as an input",
                },
                {
                    "field": "default_value",
                    "type": "bool",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "bool",
                    "helper_text": "The boolean that was passed in",
                }
            ],
        },
        "timestamp**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "timestamp",
                    "helper_text": "Allows you to pass a timestamp as an input",
                }
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "timestamp",
                    "helper_text": "The timestamp that was passed in",
                }
            ],
        },
        "timestamp**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "timestamp",
                    "helper_text": "Allows you to pass a timestamp as an input",
                },
                {
                    "field": "default_value",
                    "type": "timestamp",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "timestamp",
                    "helper_text": "The timestamp that was passed in",
                }
            ],
        },
        "vec<string>**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "vec<string>",
                    "helper_text": "Allows you to pass a list of strings as an input",
                }
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "vec<string>",
                    "helper_text": "The list of strings that was passed in",
                }
            ],
        },
        "vec<string>**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "vec<string>",
                    "helper_text": "Allows you to pass a list of strings as an input",
                },
                {
                    "field": "default_value",
                    "type": "vec<string>",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "vec<string>",
                    "helper_text": "The list of strings that was passed in",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["input_type", "use_default_value"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        input_type: str = "string",
        use_default_value: bool = False,
        default_value: Optional[str] = None,
        description: str = "",
        file_parser: str = "default",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["input_type"] = input_type
        params["use_default_value"] = use_default_value

        super().__init__(
            node_type="input",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if input_type is not None:
            self.inputs["input_type"] = input_type
        if description is not None:
            self.inputs["description"] = description
        if use_default_value is not None:
            self.inputs["use_default_value"] = use_default_value
        if default_value is not None:
            self.inputs["default_value"] = default_value
        if file_parser is not None:
            self.inputs["file_parser"] = file_parser

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def audio(self) -> Any:
        """
        The audio that was passed in

        Available: When input_type = 'audio' and use_default_value = False, When input_type = 'audio' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("audio")

    @property
    def file(self) -> str:
        """
        The file that was passed in

        Available: When input_type = 'file' and use_default_value = False, When input_type = 'file' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file")

    @property
    def files(self) -> List[str]:
        """
        The files that were passed in

        Available: When input_type = 'vec<file>' and use_default_value = False, When input_type = 'vec<file>' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("files")

    @property
    def image(self) -> Any:
        """
        The image that was passed in

        Available: When input_type = 'image' and use_default_value = False, When input_type = 'image' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("image")

    @property
    def knowledge_base(self) -> Any:
        """
        The Knowledge Base that was passed in

        Available: When input_type = 'knowledge_base' and use_default_value = False, When input_type = 'knowledge_base' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("knowledge_base")

    @property
    def pipeline(self) -> Any:
        """
        The pipeline output

        Available: When input_type = 'pipeline' and use_default_value = False, When input_type = 'pipeline' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pipeline")

    @property
    def processed_text(self) -> str:
        """
        The processed text of the file.

        Available: When input_type = 'file' and use_default_value = False, When input_type = 'file' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_text")

    @property
    def processed_texts(self) -> List[str]:
        """
        The processed text of the files

        Available: When input_type = 'vec<file>' and use_default_value = False, When input_type = 'vec<file>' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_texts")

    @property
    def text(self) -> str:
        """
        The text that was passed in

        Available: When input_type = 'string' and use_default_value = False, When input_type = 'string' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @property
    def value(self) -> int:
        """
        The integer that was passed in

        Different behavior based on configuration:
          - The integer that was passed in (When input_type = 'int32' and use_default_value = False, When input_type = 'int32' and use_default_value = True)
          - The boolean that was passed in (When input_type = 'bool' and use_default_value = False, When input_type = 'bool' and use_default_value = True)
          - The timestamp that was passed in (When input_type = 'timestamp' and use_default_value = False, When input_type = 'timestamp' and use_default_value = True)
          - The list of strings that was passed in (When input_type = 'vec<string>' and use_default_value = False, When input_type = 'vec<string>' and use_default_value = True)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("value")

    @classmethod
    def from_dict(cls, data: dict) -> "InputNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("output")
class OutputNode(Node):
    """
    Output data of different types from your workflow.

    ## Inputs
    ### Common Inputs
        description: The description of the output
        output_type: The output_type input
    ### string
        value: The value input
    ### file
        value: The value input
    ### audio
        value: The value input
    ### json
        value: The value input
    ### image
        value: The value input
    ### stream<string>
        value: The value input
    ### vec<file>
        value: The value input
    ### int32
        value: The value input
    ### float
        value: The value input
    ### bool
        value: The value input
    ### timestamp
        value: The value input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "description",
            "helper_text": "The description of the output",
            "value": "",
            "type": "string",
        },
        {
            "field": "output_type",
            "helper_text": "The output_type input",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "string": {
            "inputs": [
                {"field": "value", "type": "string", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "string",
                    "helper_text": "Output raw text",
                },
            ],
            "outputs": [],
        },
        "file": {
            "inputs": [
                {"field": "value", "type": "file", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "file",
                    "helper_text": "Output file of any type: PDF, Word, Excel, CSV, MP3, JPEG, etc.",
                },
            ],
            "outputs": [],
        },
        "audio": {
            "inputs": [
                {"field": "value", "type": "audio", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "audio",
                    "helper_text": "Output raw audio. Output can be generated with the text to speech node",
                },
            ],
            "outputs": [],
        },
        "json": {
            "inputs": [
                {"field": "value", "type": "string", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "json",
                    "helper_text": "Output JSON (e.g., LLMs can output JSON - input the schema by selecting “JSON Output” in the gear of the LLM)",
                },
            ],
            "outputs": [],
        },
        "image": {
            "inputs": [
                {"field": "value", "type": "image", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "image",
                    "helper_text": "Output Image(s) (images are of file type PNG)",
                },
            ],
            "outputs": [],
        },
        "stream<string>": {
            "inputs": [
                {"field": "value", "type": "stream<string>", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "stream<string>",
                    "helper_text": "Output as a stream of raw text",
                },
            ],
            "outputs": [],
            "banner_text": 'Ensure to check "Stream Response" in gear of the LLM',
        },
        "vec<file>": {
            "inputs": [
                {"field": "value", "type": "vec<file>", "value": []},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "vec<file>",
                    "helper_text": "Output a list of files",
                },
            ],
            "outputs": [],
        },
        "int32": {
            "inputs": [
                {"field": "value", "type": "int32", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "int32",
                    "helper_text": "Output an integer",
                },
            ],
            "outputs": [],
        },
        "float": {
            "inputs": [
                {"field": "value", "type": "float", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "float",
                    "helper_text": "Output a float",
                },
            ],
            "outputs": [],
        },
        "bool": {
            "inputs": [
                {"field": "value", "type": "bool", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "bool",
                    "helper_text": "Output a boolean",
                },
            ],
            "outputs": [],
        },
        "timestamp": {
            "inputs": [
                {"field": "value", "type": "timestamp", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "timestamp",
                    "helper_text": "Output a timestamp",
                },
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["output_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        output_type: str = "string",
        description: str = "",
        value: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["output_type"] = output_type

        super().__init__(
            node_type="output",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if output_type is not None:
            self.inputs["output_type"] = output_type
        if description is not None:
            self.inputs["description"] = description
        if value is not None:
            self.inputs["value"] = value

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "OutputNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("categorizer")
class CategorizerNode(Node):
    """
    Categorize text using AI into custom-defined buckets

    ## Inputs
    ### Common Inputs
        additional_context: Provide any additional context or instructions
        fields: The fields to be categorized
        justification: Include the AI’s justification for its score
        max_tokens: The maximum number of tokens to generate
        model: The specific model for categorization
        provider: The model provider
        temperature: The temperature of the model
        text: The text that will be categorized
        top_p: The top-p value

    ## Outputs
    ### Common Outputs
        category: The category of the input text
        credits_used: The number of credits used
        input_tokens: The number of input tokens
        output_tokens: The number of output tokens
        tokens_used: The number of tokens used
    ### When justification = True
        justification: The AI justification
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "additional_context",
            "helper_text": "Provide any additional context or instructions",
            "value": "",
            "type": "string",
        },
        {
            "field": "fields",
            "helper_text": "The fields to be categorized",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "justification",
            "helper_text": "Include the AI’s justification for its score",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The maximum number of tokens to generate",
            "value": 2048,
            "type": "int64",
        },
        {
            "field": "model",
            "helper_text": "The specific model for categorization",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature of the model",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "text",
            "helper_text": "The text that will be categorized",
            "value": "",
            "type": "string",
        },
        {
            "field": "top_p",
            "helper_text": "The top-p value",
            "value": 1.0,
            "type": "float",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "category", "helper_text": "The category of the input text"},
        {"field": "credits_used", "helper_text": "The number of credits used"},
        {"field": "input_tokens", "helper_text": "The number of input tokens"},
        {"field": "output_tokens", "helper_text": "The number of output tokens"},
        {"field": "tokens_used", "helper_text": "The number of tokens used"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [],
            "outputs": [
                {
                    "field": "justification",
                    "type": "string",
                    "helper_text": "The AI justification",
                }
            ],
        },
        "false": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["justification"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        justification: bool = False,
        additional_context: str = "",
        fields: List[Any] = [],
        max_tokens: int = 2048,
        model: str = "gpt-4o",
        provider: str = "openai",
        temperature: Any = 0.7,
        text: str = "",
        top_p: Any = 1.0,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["justification"] = justification

        super().__init__(
            node_type="categorizer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if justification is not None:
            self.inputs["justification"] = justification
        if fields is not None:
            self.inputs["fields"] = fields
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if text is not None:
            self.inputs["text"] = text
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if top_p is not None:
            self.inputs["top_p"] = top_p

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def category(self) -> str:
        """
        The category of the input text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("category")

    @property
    def credits_used(self) -> Any:
        """
        The number of credits used


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("credits_used")

    @property
    def input_tokens(self) -> int:
        """
        The number of input tokens


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("input_tokens")

    @property
    def justification(self) -> str:
        """
        The AI justification

        Available: When justification = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("justification")

    @property
    def output_tokens(self) -> int:
        """
        The number of output tokens


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output_tokens")

    @property
    def tokens_used(self) -> int:
        """
        The number of tokens used


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tokens_used")

    @classmethod
    def from_dict(cls, data: dict) -> "CategorizerNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("extract_data")
class ExtractDataNode(Node):
    """
    Extract key pieces of information or a list of information from a input text.

    ## Inputs
    ### Common Inputs
        additional_context: Provide any additional context or instructions
        fields: The fields input
        model: The specific model for data extraction
        processed_outputs: The processed_outputs input
        provider: The model provider
        text: The text that data will be extracted from

    ## Outputs
    ### Common Outputs
        [processed_outputs]: The [processed_outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "additional_context",
            "helper_text": "Provide any additional context or instructions",
            "value": "",
            "type": "string",
        },
        {
            "field": "fields",
            "helper_text": "The fields input",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "model",
            "helper_text": "The specific model for data extraction",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "processed_outputs",
            "helper_text": "The processed_outputs input",
            "value": {},
            "type": "map<string, string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text that data will be extracted from",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "[processed_outputs]",
            "helper_text": "The [processed_outputs] output",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        additional_context: str = "",
        fields: List[Any] = [],
        model: str = "gpt-4o",
        processed_outputs: Dict[str, str] = {},
        provider: str = "openai",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="extract_data",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if fields is not None:
            self.inputs["fields"] = fields
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if text is not None:
            self.inputs["text"] = text
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "ExtractDataNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("data_collector")
class DataCollectorNode(Node):
    """
    Allows a chatbot to collect information by asking the user to provide specific pieces of information (e.g., name, email, etc.).

    ## Inputs
    ### Common Inputs
        auto_generate: If checked, the node will output questions in successive order until all fields are successfully collected. If unchecked, the node will output the data that is collected (often passed to an LLM with a prompt to ask successive questions to the user, along with specific instructions after all fields are collected) - e.g., {'Field1': 'Collected_Data', 'Field2': 'Collected_Data'}
        data_collector_node_id: The ID of the data collector node
        fields: The fields to be collected
        prompt: Specific instructions of how the LLM should collect the information
        query: The query to be analysed for data collection (passed to the LLM)
    ### When auto_generate = True
        llm: The model provider
        model: The specific model for question generation

    ## Outputs
    ### When auto_generate = False
        collected_data: The data that is collected
    ### When auto_generate = True
        question: The question to be asked to the user
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "auto_generate",
            "helper_text": "If checked, the node will output questions in successive order until all fields are successfully collected. If unchecked, the node will output the data that is collected (often passed to an LLM with a prompt to ask successive questions to the user, along with specific instructions after all fields are collected) - e.g., {'Field1': 'Collected_Data', 'Field2': 'Collected_Data'}",
            "value": True,
            "type": "bool",
        },
        {
            "field": "data_collector_node_id",
            "helper_text": "The ID of the data collector node",
            "value": "",
            "type": "string",
        },
        {
            "field": "fields",
            "helper_text": "The fields to be collected",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "prompt",
            "helper_text": "Specific instructions of how the LLM should collect the information",
            "value": "",
            "type": "string",
        },
        {
            "field": "query",
            "helper_text": "The query to be analysed for data collection (passed to the LLM)",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "llm",
                    "type": "enum<string>",
                    "value": "openai",
                    "helper_text": "The model provider",
                },
                {
                    "field": "model",
                    "type": "enum<string>",
                    "value": "gpt-4-1106-preview",
                    "helper_text": "The specific model for question generation",
                },
            ],
            "outputs": [
                {
                    "field": "question",
                    "type": "string",
                    "helper_text": "The question to be asked to the user",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "collected_data",
                    "type": "string",
                    "helper_text": "The data that is collected",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["auto_generate"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        auto_generate: bool = True,
        data_collector_node_id: str = "",
        fields: List[Any] = [],
        llm: str = "openai",
        model: str = "gpt-4-1106-preview",
        prompt: str = "",
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["auto_generate"] = auto_generate

        super().__init__(
            node_type="data_collector",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if auto_generate is not None:
            self.inputs["auto_generate"] = auto_generate
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if fields is not None:
            self.inputs["fields"] = fields
        if data_collector_node_id is not None:
            self.inputs["data_collector_node_id"] = data_collector_node_id
        if query is not None:
            self.inputs["query"] = query
        if llm is not None:
            self.inputs["llm"] = llm
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def collected_data(self) -> str:
        """
        The data that is collected

        Available: When auto_generate = False


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("collected_data")

    @property
    def question(self) -> str:
        """
        The question to be asked to the user

        Available: When auto_generate = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("question")

    @classmethod
    def from_dict(cls, data: dict) -> "DataCollectorNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("scorer")
class ScorerNode(Node):
    """
    Score text using AI based on a set of criteria.

    ## Inputs
    ### Common Inputs
        additional_context: Provide any additional context or instructions
        criteria: The criteria that the text will be scored
        justification: Include the AI’s justification for its score
        model: The specific model for scoring
        provider: The model provider
        text: The text that will be scored

    ## Outputs
    ### Common Outputs
        score: The score of the text based on the criteria
    ### When justification = True
        justification: The AI justification
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "additional_context",
            "helper_text": "Provide any additional context or instructions",
            "value": "",
            "type": "string",
        },
        {
            "field": "criteria",
            "helper_text": "The criteria that the text will be scored",
            "value": "",
            "type": "string",
        },
        {
            "field": "justification",
            "helper_text": "Include the AI’s justification for its score",
            "value": False,
            "type": "bool",
        },
        {
            "field": "model",
            "helper_text": "The specific model for scoring",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text that will be scored",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "score", "helper_text": "The score of the text based on the criteria"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [],
            "outputs": [
                {
                    "field": "justification",
                    "type": "string",
                    "helper_text": "The AI justification",
                }
            ],
        },
        "false": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["justification"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        justification: bool = False,
        additional_context: str = "",
        criteria: str = "",
        model: str = "gpt-4o",
        provider: str = "openai",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["justification"] = justification

        super().__init__(
            node_type="scorer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if justification is not None:
            self.inputs["justification"] = justification
        if text is not None:
            self.inputs["text"] = text
        if criteria is not None:
            self.inputs["criteria"] = criteria
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def justification(self) -> str:
        """
        The AI justification

        Available: When justification = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("justification")

    @property
    def score(self) -> Any:
        """
        The score of the text based on the criteria


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("score")

    @classmethod
    def from_dict(cls, data: dict) -> "ScorerNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("speech_to_text")
class SpeechToTextNode(Node):
    """


    ## Inputs
    ### Common Inputs
        audio: The audio input
        model: The model input
    ### Deepgram
        submodel: The submodel input
        tier: The tier input

    ## Outputs
    ### Common Outputs
        text: The text output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "audio",
            "helper_text": "The audio input",
            "value": "",
            "type": "audio",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "OpenAI Whisper",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "text", "helper_text": "The text output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "OpenAI Whisper": {"inputs": [], "outputs": []},
        "Deepgram": {
            "inputs": [
                {"field": "submodel", "type": "enum<string>", "value": "nova-2"},
                {"field": "tier", "type": "enum<string>", "value": "general"},
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["model"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        model: str = "OpenAI Whisper",
        audio: Any = None,
        submodel: str = "nova-2",
        tier: str = "general",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["model"] = model

        super().__init__(
            node_type="speech_to_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if model is not None:
            self.inputs["model"] = model
        if audio is not None:
            self.inputs["audio"] = audio
        if submodel is not None:
            self.inputs["submodel"] = submodel
        if tier is not None:
            self.inputs["tier"] = tier

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def text(self) -> str:
        """
        The text output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @classmethod
    def from_dict(cls, data: dict) -> "SpeechToTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("file_save")
class FileSaveNode(Node):
    """
    Save a file on the VectorShift platform (under the 'Files' tab).

    ## Inputs
    ### Common Inputs
        files: The files to be saved
        name: The name of the file

    ## Outputs
    ### Common Outputs
        file_name: The name of the file saved
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "files",
            "helper_text": "The files to be saved",
            "value": [""],
            "type": "vec<file>",
        },
        {
            "field": "name",
            "helper_text": "The name of the file",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file_name", "helper_text": "The name of the file saved"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        files: List[str] = [""],
        name: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="file_save",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if name is not None:
            self.inputs["name"] = name
        if files is not None:
            self.inputs["files"] = files

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def file_name(self) -> List[str]:
        """
        The name of the file saved


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_name")

    @classmethod
    def from_dict(cls, data: dict) -> "FileSaveNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("image_gen")
class ImageGenNode(Node):
    """


    ## Inputs
    ### Common Inputs
        aspect_ratio: The aspect_ratio input
        image_count: The image_count input
        model: The model input
        prompt: The prompt input
        provider: The provider input
        size: The size input

    ## Outputs
    ### Common Outputs
        images: The images output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "aspect_ratio",
            "helper_text": "The aspect_ratio input",
            "value": "1:1",
            "type": "enum<string>",
        },
        {
            "field": "image_count",
            "helper_text": "The image_count input",
            "value": "1",
            "type": "string",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "gpt-4-1106-preview",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The prompt input",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "The provider input",
            "value": "llmOpenAI",
            "type": "enum<string>",
        },
        {
            "field": "size",
            "helper_text": "The size input",
            "value": "512x512",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "images", "helper_text": "The images output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        aspect_ratio: str = "1:1",
        image_count: str = "1",
        model: str = "gpt-4-1106-preview",
        prompt: str = "",
        provider: str = "llmOpenAI",
        size: str = "512x512",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="image_gen",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if size is not None:
            self.inputs["size"] = size
        if aspect_ratio is not None:
            self.inputs["aspect_ratio"] = aspect_ratio
        if image_count is not None:
            self.inputs["image_count"] = image_count

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def images(self) -> List[Any]:
        """
        The images output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("images")

    @classmethod
    def from_dict(cls, data: dict) -> "ImageGenNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("file")
class FileNode(Node):
    """
    Load a static file into the workflow as a raw File or process it into Text.

    ## Inputs
    ### Common Inputs
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
        selected_option: Select an existing file from the VectorShift platform
    ### upload
        file: The file that was passed in
    ### name
        file_name: The name of the file from the VectorShift platform (for files on the File tab)

    ## Outputs
    ### Common Outputs
        file: The file that was passed in
        processed_text: The processed text of the file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file_parser",
            "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
            "value": "default",
            "type": "enum<string>",
        },
        {
            "field": "selected_option",
            "helper_text": "Select an existing file from the VectorShift platform",
            "value": "upload",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file", "helper_text": "The file that was passed in"},
        {"field": "processed_text", "helper_text": "The processed text of the file"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "upload": {
            "inputs": [
                {
                    "field": "file",
                    "type": "file",
                    "helper_text": "The file that was passed in",
                }
            ],
            "outputs": [],
        },
        "name": {
            "inputs": [
                {
                    "field": "file_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "The name of the file from the VectorShift platform (for files on the File tab)",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["selected_option"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        selected_option: str = "upload",
        file: Optional[str] = None,
        file_name: str = "",
        file_parser: str = "default",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["selected_option"] = selected_option

        super().__init__(
            node_type="file",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_parser is not None:
            self.inputs["file_parser"] = file_parser
        if selected_option is not None:
            self.inputs["selected_option"] = selected_option
        if file is not None:
            self.inputs["file"] = file
        if file_name is not None:
            self.inputs["file_name"] = file_name

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def file(self) -> str:
        """
        The file that was passed in


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file")

    @property
    def processed_text(self) -> str:
        """
        The processed text of the file


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_text")

    @classmethod
    def from_dict(cls, data: dict) -> "FileNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("get_list_item")
class GetListItemNode(Node):
    """
    Get a value from a list given an index. The first item in the list is index 0.

    ## Inputs
    ### Common Inputs
        index: The index of the item to retrieve
        type: The type of the list
    ### <T>
        list: The list to retrieve the item from

    ## Outputs
    ### <T>
        output: The item retrieved from the list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "index",
            "helper_text": "The index of the item to retrieve",
            "value": 0,
            "type": "int32",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The list to retrieve the item from",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "<T>",
                    "helper_text": "The item retrieved from the list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        index: int = 0,
        list: List[Any] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="get_list_item",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if index is not None:
            self.inputs["index"] = index
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "GetListItemNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("llm_open_ai_vision")
class LlmOpenAiVisionNode(Node):
    """


    ## Inputs
    ### Common Inputs
        image: The image input
        json_response: The json_response input
        max_tokens: The max_tokens input
        model: The model input
        prompt: The prompt input
        provider: The provider input
        stream: The stream input
        system: The system input
        temperature: The temperature input
        top_p: The top_p input
        use_personal_api_key: The use_personal_api_key input
    ### When use_personal_api_key = True
        api_key: The api_key input
    ### When json_response = True
        json_schema: The json_schema input

    ## Outputs
    ### Common Outputs
        response: The response output
        tokens_used: The tokens_used output
    ### When stream = True
        response_deltas: The response_deltas output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "image",
            "helper_text": "The image input",
            "value": None,
            "type": "image",
        },
        {
            "field": "json_response",
            "helper_text": "The json_response input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The max_tokens input",
            "value": 128000,
            "type": "int32",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "gpt-4-vision-preview",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The prompt input",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "The provider input",
            "value": "openAiImageToText",
            "type": "enum<string>",
        },
        {
            "field": "stream",
            "helper_text": "The stream input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "system",
            "helper_text": "The system input",
            "value": "",
            "type": "string",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature input",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "top_p",
            "helper_text": "The top_p input",
            "value": 0.9,
            "type": "float",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "The use_personal_api_key input",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "response", "helper_text": "The response output"},
        {"field": "tokens_used", "helper_text": "The tokens_used output"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**true**(*)**(*)": {
            "inputs": [],
            "outputs": [{"field": "response_deltas", "type": "Stream<string>"}],
        },
        "(*)**false**(*)**(*)": {"inputs": [], "outputs": []},
        "(*)**(*)**true**(*)": {
            "inputs": [{"field": "api_key", "type": "string", "value": ""}],
            "outputs": [],
        },
        "(*)**(*)**false**(*)": {"inputs": [], "outputs": []},
        "(*)**(*)**(*)**true": {
            "inputs": [{"field": "json_schema", "type": "string", "value": ""}],
            "outputs": [],
        },
        "(*)**(*)**(*)**false": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["provider", "stream", "use_personal_api_key", "json_response"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        provider: str = "openAiImageToText",
        stream: bool = False,
        use_personal_api_key: bool = False,
        json_response: bool = False,
        api_key: str = "",
        image: Optional[Any] = None,
        json_schema: str = "",
        max_tokens: int = 128000,
        model: str = "gpt-4-vision-preview",
        prompt: str = "",
        system: str = "",
        temperature: Any = 0.7,
        top_p: Any = 0.9,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["provider"] = provider
        params["stream"] = stream
        params["use_personal_api_key"] = use_personal_api_key
        params["json_response"] = json_response

        super().__init__(
            node_type="llm_open_ai_vision",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if system is not None:
            self.inputs["system"] = system
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if stream is not None:
            self.inputs["stream"] = stream
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if image is not None:
            self.inputs["image"] = image
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if json_schema is not None:
            self.inputs["json_schema"] = json_schema

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def response(self) -> str:
        """
        The response output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @property
    def tokens_used(self) -> int:
        """
        The tokens_used output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tokens_used")

    @classmethod
    def from_dict(cls, data: dict) -> "LlmOpenAiVisionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("llm_google_vision")
class LlmGoogleVisionNode(Node):
    """


    ## Inputs
    ### Common Inputs
        api_key: The api_key input
        image: The image input
        json_response: The json_response input
        max_tokens: The max_tokens input
        model: The model input
        prompt: The prompt input
        provider: The provider input
        stream: The stream input
        temperature: The temperature input
        top_p: The top_p input

    ## Outputs
    ### Common Outputs
        response: The response output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "api_key",
            "helper_text": "The api_key input",
            "value": "",
            "type": "string",
        },
        {
            "field": "image",
            "helper_text": "The image input",
            "value": None,
            "type": "image",
        },
        {
            "field": "json_response",
            "helper_text": "The json_response input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The max_tokens input",
            "value": 32760,
            "type": "int32",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "gemini-pro-vision",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The prompt input",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "The provider input",
            "value": "googleImageToText",
            "type": "enum<string>",
        },
        {
            "field": "stream",
            "helper_text": "The stream input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature input",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "top_p",
            "helper_text": "The top_p input",
            "value": 0.9,
            "type": "float",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "response", "helper_text": "The response output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        api_key: str = "",
        image: Optional[Any] = None,
        json_response: bool = False,
        max_tokens: int = 32760,
        model: str = "gemini-pro-vision",
        prompt: str = "",
        provider: str = "googleImageToText",
        stream: bool = False,
        temperature: Any = 0.7,
        top_p: Any = 0.9,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="llm_google_vision",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if stream is not None:
            self.inputs["stream"] = stream
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if image is not None:
            self.inputs["image"] = image

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def response(self) -> str:
        """
        The response output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @classmethod
    def from_dict(cls, data: dict) -> "LlmGoogleVisionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("split_text")
class SplitTextNode(Node):
    """
    Takes input text and separate it into a List of texts based on the delimiter.

    ## Inputs
    ### Common Inputs
        delimiter: The delimiter to split the text on
        text: The text to split
    ### character(s)
        character: The character(s) to split the text on

    ## Outputs
    ### Common Outputs
        processed_text: The text split into a list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "delimiter",
            "helper_text": "The delimiter to split the text on",
            "value": "space",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to split",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "processed_text", "helper_text": "The text split into a list"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "character(s)": {
            "inputs": [
                {
                    "field": "character",
                    "type": "string",
                    "value": "",
                    "helper_text": "The character(s) to split the text on",
                }
            ],
            "outputs": [],
        },
        "space": {"inputs": [], "outputs": []},
        "newline": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["delimiter"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        delimiter: str = "space",
        character: str = "",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["delimiter"] = delimiter

        super().__init__(
            node_type="split_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if delimiter is not None:
            self.inputs["delimiter"] = delimiter
        if text is not None:
            self.inputs["text"] = text
        if character is not None:
            self.inputs["character"] = character

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def processed_text(self) -> List[str]:
        """
        The text split into a list


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_text")

    @classmethod
    def from_dict(cls, data: dict) -> "SplitTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("summarizer")
class SummarizerNode(Node):
    """
    Summarize text with AI

    ## Inputs
    ### Common Inputs
        model: The specific model for summarization
        provider: The model provider
        text: The text to be summarized

    ## Outputs
    ### Common Outputs
        summary: The summary of the text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "model",
            "helper_text": "The specific model for summarization",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to be summarized",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "summary", "helper_text": "The summary of the text"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        model: str = "gpt-4o",
        provider: str = "openai",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="summarizer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def summary(self) -> str:
        """
        The summary of the text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("summary")

    @classmethod
    def from_dict(cls, data: dict) -> "SummarizerNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("text")
class TextNode(Node):
    """
    Accepts Text from upstream nodes and allows you to write additional text / concatenate different texts to pass to downstream nodes.

    ## Inputs
    ### Common Inputs
        text: The text to be processed

    ## Outputs
    ### Common Outputs
        text: The text from the node
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "text",
            "helper_text": "The text to be processed",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "text", "helper_text": "The text from the node"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def text(self) -> str:
        """
        The text from the node


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @classmethod
    def from_dict(cls, data: dict) -> "TextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("text_to_file")
class TextToFileNode(Node):
    """
    Convert data from type Text to type File

    ## Inputs
    ### Common Inputs
        file_type: The type of file to convert the text to.
        text: The text for conversion.

    ## Outputs
    ### Common Outputs
        file: The text as converted to a file.
        file_type: The type of file that was converted the text to.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file_type",
            "helper_text": "The type of file to convert the text to.",
            "value": "PDF",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text for conversion.",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file", "helper_text": "The text as converted to a file."},
        {
            "field": "file_type",
            "helper_text": "The type of file that was converted the text to.",
        },
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        file_type: str = "PDF",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="text_to_file",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_type is not None:
            self.inputs["file_type"] = file_type
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def file(self) -> str:
        """
        The text as converted to a file.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file")

    @property
    def file_type(self) -> str:
        """
        The type of file that was converted the text to.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_type")

    @classmethod
    def from_dict(cls, data: dict) -> "TextToFileNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("time")
class TimeNode(Node):
    """
    Outputs the current time (often connected to LLM node)

    ## Inputs
    ### Common Inputs
        delta_time_unit: The unit of the delta
        delta_value: The value of the delta
        is_positive: If the time should be positive
        is_positive_delta: If the time should be positive
        output_format: The format of the output time
        time_node_zone: The timezone of the time node

    ## Outputs
    ### Common Outputs
        processed_time: The time from the node
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "delta_time_unit",
            "helper_text": "The unit of the delta",
            "value": "Seconds",
            "type": "enum<string>",
        },
        {
            "field": "delta_value",
            "helper_text": "The value of the delta",
            "value": 0,
            "type": "int32",
        },
        {
            "field": "is_positive",
            "helper_text": "If the time should be positive",
            "value": "+",
            "type": "enum<string>",
        },
        {
            "field": "is_positive_delta",
            "helper_text": "If the time should be positive",
            "value": True,
            "type": "bool",
        },
        {
            "field": "output_format",
            "helper_text": "The format of the output time",
            "value": "DD/MM/YYYY",
            "type": "enum<string>",
        },
        {
            "field": "time_node_zone",
            "helper_text": "The timezone of the time node",
            "value": "America/New_York",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "processed_time", "helper_text": "The time from the node"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        delta_time_unit: str = "Seconds",
        delta_value: int = 0,
        is_positive: str = "+",
        is_positive_delta: bool = True,
        output_format: str = "DD/MM/YYYY",
        time_node_zone: str = "America/New_York",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="time",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if is_positive is not None:
            self.inputs["is_positive"] = is_positive
        if is_positive_delta is not None:
            self.inputs["is_positive_delta"] = is_positive_delta
        if delta_value is not None:
            self.inputs["delta_value"] = delta_value
        if delta_time_unit is not None:
            self.inputs["delta_time_unit"] = delta_time_unit
        if output_format is not None:
            self.inputs["output_format"] = output_format
        if time_node_zone is not None:
            self.inputs["time_node_zone"] = time_node_zone

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def processed_time(self) -> str:
        """
        The time from the node


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_time")

    @classmethod
    def from_dict(cls, data: dict) -> "TimeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("translator")
class TranslatorNode(Node):
    """
    Translate text from one language to another

    ## Inputs
    ### Common Inputs
        model: The specific model for translation
        provider: The model provider
        source_language: The language of the input text
        target_language: The language to translate to
        text: The text to be translated

    ## Outputs
    ### Common Outputs
        translation: The translation of the text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "model",
            "helper_text": "The specific model for translation",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "source_language",
            "helper_text": "The language of the input text",
            "value": "Detect Language",
            "type": "enum<string>",
        },
        {
            "field": "target_language",
            "helper_text": "The language to translate to",
            "value": "English",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to be translated",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "translation", "helper_text": "The translation of the text"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        model: str = "gpt-4o",
        provider: str = "openai",
        source_language: str = "Detect Language",
        target_language: str = "English",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="translator",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if source_language is not None:
            self.inputs["source_language"] = source_language
        if target_language is not None:
            self.inputs["target_language"] = target_language

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def translation(self) -> str:
        """
        The translation of the text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("translation")

    @classmethod
    def from_dict(cls, data: dict) -> "TranslatorNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("tts_eleven_labs")
class TtsElevenLabsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        api_key: The api_key input
        model: The model input
        text: The text input
        voice: The voice input

    ## Outputs
    ### Common Outputs
        audio: The audio output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "api_key",
            "helper_text": "The api_key input",
            "value": "",
            "type": "string",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "eleven_multilingual_v2",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text input",
            "value": "",
            "type": "string",
        },
        {
            "field": "voice",
            "helper_text": "The voice input",
            "value": "shimmer",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "audio", "helper_text": "The audio output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        api_key: str = "",
        model: str = "eleven_multilingual_v2",
        text: str = "",
        voice: str = "shimmer",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="tts_eleven_labs",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if model is not None:
            self.inputs["model"] = model
        if voice is not None:
            self.inputs["voice"] = voice
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def audio(self) -> Any:
        """
        The audio output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("audio")

    @classmethod
    def from_dict(cls, data: dict) -> "TtsElevenLabsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("tts_open_ai")
class TtsOpenAiNode(Node):
    """


    ## Inputs
    ### Common Inputs
        model: The model input
        text: The text input
        use_personal_api_key: The use_personal_api_key input
        voice: The voice input
    ### When use_personal_api_key = True
        api_key: The api_key input

    ## Outputs
    ### Common Outputs
        audio: The audio output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "tts-1",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text input",
            "value": "",
            "type": "string",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "The use_personal_api_key input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "voice",
            "helper_text": "The voice input",
            "value": "alloy",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "audio", "helper_text": "The audio output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false": {"inputs": [], "outputs": []},
        "true": {
            "inputs": [{"field": "api_key", "type": "string", "value": ""}],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        api_key: str = "",
        model: str = "tts-1",
        text: str = "",
        voice: str = "alloy",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key

        super().__init__(
            node_type="tts_open_ai",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if model is not None:
            self.inputs["model"] = model
        if voice is not None:
            self.inputs["voice"] = voice
        if text is not None:
            self.inputs["text"] = text
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def audio(self) -> Any:
        """
        The audio output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("audio")

    @classmethod
    def from_dict(cls, data: dict) -> "TtsOpenAiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_audio_operations")
class AiAudioOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="ai_audio_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "AiAudioOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_text_to_speech")
class AiTextToSpeechNode(Node):
    """
    Generate Audio from text using AI

    ## Inputs
    ### Common Inputs
        model: Select the text-to-speech model
        provider: Select the model provider.
        text: The text for conversion.
        use_personal_api_key: Use your personal API key
        voice: Select the voice
    ### When use_personal_api_key = True
        api_key: Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run

    ## Outputs
    ### Common Outputs
        audio: The Text as converted to Audio.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "model",
            "helper_text": "Select the text-to-speech model",
            "value": "tts-1",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "Select the model provider.",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text for conversion.",
            "value": "",
            "type": "string",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "Use your personal API key",
            "value": False,
            "type": "bool",
        },
        {
            "field": "voice",
            "helper_text": "Select the voice",
            "value": "alloy",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "audio", "helper_text": "The Text as converted to Audio."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)": {"inputs": [], "outputs": []},
        "true**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run",
                }
            ],
            "outputs": [],
        },
        "(*)**openai": {"inputs": [], "outputs": [], "title": "OpenAI Text to Speech"},
        "(*)**eleven_labs": {
            "inputs": [],
            "outputs": [],
            "title": "Eleven Labs Text to Speech",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "provider"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        provider: str = "openai",
        api_key: str = "",
        model: str = "tts-1",
        text: str = "",
        voice: str = "alloy",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["provider"] = provider

        super().__init__(
            node_type="ai_text_to_speech",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if voice is not None:
            self.inputs["voice"] = voice
        if text is not None:
            self.inputs["text"] = text
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def audio(self) -> Any:
        """
        The Text as converted to Audio.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("audio")

    @classmethod
    def from_dict(cls, data: dict) -> "AiTextToSpeechNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_speech_to_text")
class AiSpeechToTextNode(Node):
    """
    Generate Text from Audio using AI

    ## Inputs
    ### Common Inputs
        audio: The audio for conversion
        model: Select the speech-to-text model
        provider: Select the model provider.
        use_personal_api_key: Use your personal API key
    ### When use_personal_api_key = True
        api_key: The api_key input
    ### When provider = 'deepgram'
        tier: Select the tier

    ## Outputs
    ### Common Outputs
        text: The Text from the Audio.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "audio",
            "helper_text": "The audio for conversion",
            "value": "",
            "type": "audio",
        },
        {
            "field": "model",
            "helper_text": "Select the speech-to-text model",
            "value": "whisper-1",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "Select the model provider.",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "Use your personal API key",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "text", "helper_text": "The Text from the Audio."}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**openai": {"inputs": [], "outputs": [], "title": "OpenAI Speech to Text"},
        "(*)**deepgram": {
            "inputs": [
                {
                    "field": "tier",
                    "type": "enum<string>",
                    "value": "general",
                    "helper_text": "Select the tier",
                }
            ],
            "outputs": [],
            "title": "Deepgram Speech to Text",
        },
        "false**(*)": {"inputs": [], "outputs": []},
        "true**(*)": {
            "inputs": [{"field": "api_key", "type": "string", "value": ""}],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "provider"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        provider: str = "openai",
        api_key: str = "",
        audio: Any = None,
        model: str = "whisper-1",
        tier: str = "general",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["provider"] = provider

        super().__init__(
            node_type="ai_speech_to_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if audio is not None:
            self.inputs["audio"] = audio
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if tier is not None:
            self.inputs["tier"] = tier
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def text(self) -> str:
        """
        The Text from the Audio.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @classmethod
    def from_dict(cls, data: dict) -> "AiSpeechToTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_image_operations")
class AiImageOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="ai_image_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "AiImageOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_image_to_text")
class AiImageToTextNode(Node):
    """
    Generate Text from Image using AI

    ## Inputs
    ### Common Inputs
        image: The image for conversion
        json_response: Return the response as a JSON object
        max_tokens: The maximum number of tokens to generate
        model: Select the image-to-text model
        prompt: The data that is sent to the LLM. Add data from other nodes with double curly braces, e.g., {{input1}}
        provider: Select the model provider.
        stream: Stream the response
        system: Tell the AI model how you would like it to respond. Be as specific as possible. For example, you can instruct the model on what tone to respond in or how to respond given the information you provide
        temperature: The temperature of the model
        top_p: The top-p value
        use_personal_api_key: Use your personal API key
    ### When use_personal_api_key = True
        api_key: Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run
    ### When json_response = True
        json_schema: The JSON schema to use for the response

    ## Outputs
    ### Common Outputs
        tokens_used: The number of tokens used
    ### When stream = False
        text: The Text from the Image.
    ### When stream = True
        text: Stream of text generated from the Image.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "image",
            "helper_text": "The image for conversion",
            "value": None,
            "type": "image",
        },
        {
            "field": "json_response",
            "helper_text": "Return the response as a JSON object",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The maximum number of tokens to generate",
            "value": 128000,
            "type": "int64",
        },
        {
            "field": "model",
            "helper_text": "Select the image-to-text model",
            "value": "chatgpt-4o-latest",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The data that is sent to the LLM. Add data from other nodes with double curly braces, e.g., {{input1}}",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "Select the model provider.",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "stream",
            "helper_text": "Stream the response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "system",
            "helper_text": "Tell the AI model how you would like it to respond. Be as specific as possible. For example, you can instruct the model on what tone to respond in or how to respond given the information you provide",
            "value": "",
            "type": "string",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature of the model",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "top_p",
            "helper_text": "The top-p value",
            "value": 0.9,
            "type": "float",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "Use your personal API key",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "tokens_used", "helper_text": "The number of tokens used"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)**(*)**(*)": {"inputs": [], "outputs": []},
        "true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run",
                }
            ],
            "outputs": [],
        },
        "(*)**false**(*)**(*)": {"inputs": [], "outputs": []},
        "(*)**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_schema",
                    "type": "string",
                    "value": "",
                    "helper_text": "The JSON schema to use for the response",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**false**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The Text from the Image.",
                }
            ],
        },
        "(*)**(*)**true**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "text",
                    "type": "stream<string>",
                    "helper_text": "Stream of text generated from the Image.",
                }
            ],
        },
        "(*)**(*)**(*)**openai": {
            "inputs": [],
            "outputs": [],
            "title": "OpenAI Image to Text",
        },
        "(*)**(*)**(*)**anthropic": {
            "inputs": [],
            "outputs": [],
            "title": "Anthropic Image to Text",
        },
        "(*)**(*)**(*)**google": {
            "inputs": [],
            "outputs": [],
            "title": "Google Image to Text",
        },
        "(*)**(*)**(*)**xai": {
            "inputs": [],
            "outputs": [],
            "title": "XAI Image to Text",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "json_response", "stream", "provider"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        json_response: bool = False,
        stream: bool = False,
        provider: str = "openai",
        api_key: str = "",
        image: Optional[Any] = None,
        json_schema: str = "",
        max_tokens: int = 128000,
        model: str = "chatgpt-4o-latest",
        prompt: str = "",
        system: str = "",
        temperature: Any = 0.7,
        top_p: Any = 0.9,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["json_response"] = json_response
        params["stream"] = stream
        params["provider"] = provider

        super().__init__(
            node_type="ai_image_to_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if system is not None:
            self.inputs["system"] = system
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if image is not None:
            self.inputs["image"] = image
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if stream is not None:
            self.inputs["stream"] = stream
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if json_schema is not None:
            self.inputs["json_schema"] = json_schema

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def text(self) -> str:
        """
        The Text from the Image.

        Different behavior based on configuration:
          - The Text from the Image. (When stream = False)
          - Stream of text generated from the Image. (When stream = True)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @property
    def tokens_used(self) -> int:
        """
        The number of tokens used


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tokens_used")

    @classmethod
    def from_dict(cls, data: dict) -> "AiImageToTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_text_to_image")
class AiTextToImageNode(Node):
    """
    Generate Image from Text using AI

    ## Inputs
    ### Common Inputs
        aspect_ratio: Select the aspect ratio.
        model: Select the text-to-image model
        prompt: Tell the AI model how you would like it to respond. Be as specific as possible. For example, you can instruct the model to use bright colors.
        provider: Select the model provider.
        size: Select the size.
        use_personal_api_key: Use your personal API key
    ### When use_personal_api_key = True
        api_key: Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run

    ## Outputs
    ### Common Outputs
        image: The Image(s) generated from the Text.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "aspect_ratio",
            "helper_text": "Select the aspect ratio.",
            "value": "1:1",
            "type": "enum<string>",
        },
        {
            "field": "model",
            "helper_text": "Select the text-to-image model",
            "value": "dall-e-2",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "Tell the AI model how you would like it to respond. Be as specific as possible. For example, you can instruct the model to use bright colors.",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "Select the model provider.",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "size",
            "helper_text": "Select the size.",
            "value": "512x512",
            "type": "enum<string>",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "Use your personal API key",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "image", "helper_text": "The Image(s) generated from the Text."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)": {"inputs": [], "outputs": []},
        "true**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run",
                }
            ],
            "outputs": [],
        },
        "(*)**openai": {"inputs": [], "outputs": [], "title": "OpenAI Text to Image"},
        "(*)**stabilityai": {
            "inputs": [],
            "outputs": [],
            "title": "Stability AI Text to Image",
        },
        "(*)**flux": {"inputs": [], "outputs": [], "title": "Flux Text to Image"},
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "provider"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        provider: str = "openai",
        api_key: str = "",
        aspect_ratio: str = "1:1",
        model: str = "dall-e-2",
        prompt: str = "",
        size: str = "512x512",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["provider"] = provider

        super().__init__(
            node_type="ai_text_to_image",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if size is not None:
            self.inputs["size"] = size
        if aspect_ratio is not None:
            self.inputs["aspect_ratio"] = aspect_ratio
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def image(self) -> Any:
        """
        The Image(s) generated from the Text.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("image")

    @classmethod
    def from_dict(cls, data: dict) -> "AiTextToImageNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("llm_anthropic_vision")
class LlmAnthropicVisionNode(Node):
    """


    ## Inputs
    ### Common Inputs
        image: The image input
        json_response: The json_response input
        max_tokens: The max_tokens input
        model: The model input
        prompt: The prompt input
        system: The system input
        temperature: The temperature input
        top_p: The top_p input
        use_personal_api_key: The use_personal_api_key input
    ### When use_personal_api_key = True
        api_key: The api_key input
    ### When json_response = True
        json_schema: The json_schema input

    ## Outputs
    ### Common Outputs
        response: The response output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "image",
            "helper_text": "The image input",
            "value": None,
            "type": "image",
        },
        {
            "field": "json_response",
            "helper_text": "The json_response input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The max_tokens input",
            "value": 200000,
            "type": "int32",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "claude-3-haiku-20240307",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The prompt input",
            "value": "",
            "type": "string",
        },
        {
            "field": "system",
            "helper_text": "The system input",
            "value": "",
            "type": "string",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature input",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "top_p",
            "helper_text": "The top_p input",
            "value": 0.9,
            "type": "float",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "The use_personal_api_key input",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "response", "helper_text": "The response output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)": {"inputs": [], "outputs": []},
        "true**(*)": {
            "inputs": [{"field": "api_key", "type": "string", "value": ""}],
            "outputs": [],
        },
        "(*)**false": {"inputs": [], "outputs": []},
        "(*)**true": {
            "inputs": [{"field": "json_schema", "type": "string", "value": ""}],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "json_response"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        json_response: bool = False,
        api_key: str = "",
        image: Optional[Any] = None,
        json_schema: str = "",
        max_tokens: int = 200000,
        model: str = "claude-3-haiku-20240307",
        prompt: str = "",
        system: str = "",
        temperature: Any = 0.7,
        top_p: Any = 0.9,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["json_response"] = json_response

        super().__init__(
            node_type="llm_anthropic_vision",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if system is not None:
            self.inputs["system"] = system
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if image is not None:
            self.inputs["image"] = image
        if model is not None:
            self.inputs["model"] = model
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if json_schema is not None:
            self.inputs["json_schema"] = json_schema

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def response(self) -> str:
        """
        The response output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @classmethod
    def from_dict(cls, data: dict) -> "LlmAnthropicVisionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("semantic_search")
class SemanticSearchNode(Node):
    """
    Generate a temporary vector database at run-time and retrieve the most relevant pieces from the documents based on the query.

    ## Inputs
    ### Common Inputs
        alpha: The alpha value for the retrieval
        analyze_documents: To analyze document contents and enrich them when parsing
        answer_multiple_questions: Extract separate questions from the query and retrieve content separately for each question to improve search performance
        do_advanced_qa: Use additional LLM calls to analyze each document to improve answer correctness
        do_nl_metadata_query: Do a natural language metadata query
        documents: The text for semantic search. Note: you may add multiple upstream nodes to this field.
        enable_context: Additional context passed to advanced search and query analysis
        enable_document_db_filter: Filter the documents returned from the knowledge base
        enable_filter: Filter the content returned from the knowledge base
        expand_query: Expand query to improve semantic search
        expand_query_terms: Expand query terms to improve semantic search
        format_context_for_llm: Format the context for the LLM
        is_hybrid: Whether to create a hybrid knowledge base
        max_docs_per_query: The maximum number of relevant chunks to be returned
        model: The model to use for the embedding
        query: The query will be used to search documents for relevant pieces semantically.
        rerank_documents: Refine the initial ranking of returned chunks based on relevancy
        retrieval_unit: The unit of retrieval
        score_cutoff: The score cutoff
        segmentation_method: The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.
        show_intermediate_steps: Show intermediate steps
        splitter_method: Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.
        transform_query: Transform the query for better semantic search
    ### When do_advanced_qa = True
        advanced_search_mode: The mode to use for the advanced search
        qa_model_name: The model to use for the QA
    ### When enable_context = True
        context: Additional context to pass to the query analysis and qa steps
    ### When enable_document_db_filter = True
        document_db_filter: Filter the documents returned from the knowledge base
    ### When enable_filter = True
        filter: Filter the content returned from the knowledge base
    ### When rerank_documents = True
        rerank_model: Refine the initial ranking of returned chunks based on relevancy

    ## Outputs
    ### When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = False
        chunks: Semantically similar chunks retrieved from the knowledge base
    ### When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True
        chunks: Semantically similar chunks retrieved from the knowledge base
        formatted_text: Knowledge base outputs formatted for input to a LLM
    ### When do_advanced_qa = True
        citation_metadata: Citation metadata for semantic search outputs, used for showing sources in LLM responses
        response: The response from the semantic search
    ### When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = False
        documents: Semantically similar documents retrieved from the knowledge base
    ### When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True
        documents: Semantically similar documents retrieved from the knowledge base
        formatted_text: Knowledge base outputs formatted for input to a LLM
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "alpha",
            "helper_text": "The alpha value for the retrieval",
            "value": 0.5,
            "type": "float",
        },
        {
            "field": "analyze_documents",
            "helper_text": "To analyze document contents and enrich them when parsing",
            "value": False,
            "type": "bool",
        },
        {
            "field": "answer_multiple_questions",
            "helper_text": "Extract separate questions from the query and retrieve content separately for each question to improve search performance",
            "value": False,
            "type": "bool",
        },
        {
            "field": "do_advanced_qa",
            "helper_text": "Use additional LLM calls to analyze each document to improve answer correctness",
            "value": False,
            "type": "bool",
        },
        {
            "field": "do_nl_metadata_query",
            "helper_text": "Do a natural language metadata query",
            "value": False,
            "type": "bool",
        },
        {
            "field": "documents",
            "helper_text": "The text for semantic search. Note: you may add multiple upstream nodes to this field.",
            "value": [],
            "type": "string",
        },
        {
            "field": "enable_context",
            "helper_text": "Additional context passed to advanced search and query analysis",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_document_db_filter",
            "helper_text": "Filter the documents returned from the knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_filter",
            "helper_text": "Filter the content returned from the knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "expand_query",
            "helper_text": "Expand query to improve semantic search",
            "value": False,
            "type": "bool",
        },
        {
            "field": "expand_query_terms",
            "helper_text": "Expand query terms to improve semantic search",
            "value": False,
            "type": "bool",
        },
        {
            "field": "format_context_for_llm",
            "helper_text": "Format the context for the LLM",
            "value": False,
            "type": "bool",
        },
        {
            "field": "is_hybrid",
            "helper_text": "Whether to create a hybrid knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_docs_per_query",
            "helper_text": "The maximum number of relevant chunks to be returned",
            "value": 5,
            "type": "int32",
        },
        {
            "field": "model",
            "helper_text": "The model to use for the embedding",
            "value": "openai/text-embedding-3-small",
            "type": "enum<string>",
        },
        {
            "field": "query",
            "helper_text": "The query will be used to search documents for relevant pieces semantically.",
            "value": "",
            "type": "string",
        },
        {
            "field": "rerank_documents",
            "helper_text": "Refine the initial ranking of returned chunks based on relevancy",
            "value": False,
            "type": "bool",
        },
        {
            "field": "retrieval_unit",
            "helper_text": "The unit of retrieval",
            "value": "chunks",
            "type": "enum<string>",
        },
        {
            "field": "score_cutoff",
            "helper_text": "The score cutoff",
            "value": 0,
            "type": "float",
        },
        {
            "field": "segmentation_method",
            "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
            "value": "words",
            "type": "enum<string>",
        },
        {
            "field": "show_intermediate_steps",
            "helper_text": "Show intermediate steps",
            "value": False,
            "type": "bool",
        },
        {
            "field": "splitter_method",
            "helper_text": "Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.",
            "value": "markdown",
            "type": "enum<string>",
        },
        {
            "field": "transform_query",
            "helper_text": "Transform the query for better semantic search",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**(*)**(*)**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "qa_model_name",
                    "type": "enum<string>",
                    "value": "gpt-4o-mini",
                    "helper_text": "The model to use for the QA",
                },
                {
                    "field": "advanced_search_mode",
                    "type": "enum<string>",
                    "value": "accurate",
                    "helper_text": "The mode to use for the advanced search",
                },
            ],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "helper_text": "The response from the semantic search",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for semantic search outputs, used for showing sources in LLM responses",
                },
            ],
        },
        "(*)**true**(*)**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter the content returned from the knowledge base",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**true**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "rerank_model",
                    "type": "enum<string>",
                    "value": "cohere/rerank-english-v3.0",
                    "helper_text": "Refine the initial ranking of returned chunks based on relevancy",
                }
            ],
            "outputs": [],
        },
        "false**(*)**(*)**documents**(*)**false**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "documents",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar documents retrieved from the knowledge base",
                }
            ],
        },
        "false**(*)**(*)**chunks**(*)**false**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "chunks",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar chunks retrieved from the knowledge base",
                }
            ],
        },
        "false**(*)**(*)**documents**(*)**true**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "documents",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar documents retrieved from the knowledge base",
                },
                {
                    "field": "formatted_text",
                    "type": "string",
                    "helper_text": "Knowledge base outputs formatted for input to a LLM",
                },
            ],
        },
        "false**(*)**(*)**chunks**(*)**true**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "chunks",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar chunks retrieved from the knowledge base",
                },
                {
                    "field": "formatted_text",
                    "type": "string",
                    "helper_text": "Knowledge base outputs formatted for input to a LLM",
                },
            ],
        },
        "(*)**(*)**(*)**(*)**true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "context",
                    "type": "string",
                    "value": "",
                    "helper_text": "Additional context to pass to the query analysis and qa steps",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**(*)**(*)**(*)**true**(*)": {
            "inputs": [
                {
                    "field": "document_db_filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter the documents returned from the knowledge base",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**(*)**(*)**(*)**(*)**(dynamic)": {
            "inputs": [
                {
                    "field": "segmentation_method",
                    "type": "enum<string>",
                    "value": "words",
                    "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = [
        "do_advanced_qa",
        "enable_filter",
        "rerank_documents",
        "retrieval_unit",
        "enable_context",
        "format_context_for_llm",
        "enable_document_db_filter",
        "splitter_method",
    ]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        do_advanced_qa: bool = False,
        enable_filter: bool = False,
        rerank_documents: bool = False,
        retrieval_unit: str = "chunks",
        enable_context: bool = False,
        format_context_for_llm: bool = False,
        enable_document_db_filter: bool = False,
        splitter_method: str = "markdown",
        advanced_search_mode: str = "accurate",
        alpha: Any = 0.5,
        analyze_documents: bool = False,
        answer_multiple_questions: bool = False,
        context: str = "",
        do_nl_metadata_query: bool = False,
        document_db_filter: str = "",
        documents: str = "[]",
        expand_query: bool = False,
        expand_query_terms: bool = False,
        filter: str = "",
        is_hybrid: bool = False,
        max_docs_per_query: int = 5,
        model: str = "openai/text-embedding-3-small",
        qa_model_name: str = "gpt-4o-mini",
        query: str = "",
        rerank_model: str = "cohere/rerank-english-v3.0",
        score_cutoff: Any = 0,
        segmentation_method: str = "words",
        show_intermediate_steps: bool = False,
        transform_query: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["do_advanced_qa"] = do_advanced_qa
        params["enable_filter"] = enable_filter
        params["rerank_documents"] = rerank_documents
        params["retrieval_unit"] = retrieval_unit
        params["enable_context"] = enable_context
        params["format_context_for_llm"] = format_context_for_llm
        params["enable_document_db_filter"] = enable_document_db_filter
        params["splitter_method"] = splitter_method

        super().__init__(
            node_type="semantic_search",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if model is not None:
            self.inputs["model"] = model
        if query is not None:
            self.inputs["query"] = query
        if max_docs_per_query is not None:
            self.inputs["max_docs_per_query"] = max_docs_per_query
        if rerank_documents is not None:
            self.inputs["rerank_documents"] = rerank_documents
        if documents is not None:
            self.inputs["documents"] = documents
        if enable_filter is not None:
            self.inputs["enable_filter"] = enable_filter
        if do_nl_metadata_query is not None:
            self.inputs["do_nl_metadata_query"] = do_nl_metadata_query
        if retrieval_unit is not None:
            self.inputs["retrieval_unit"] = retrieval_unit
        if alpha is not None:
            self.inputs["alpha"] = alpha
        if transform_query is not None:
            self.inputs["transform_query"] = transform_query
        if answer_multiple_questions is not None:
            self.inputs["answer_multiple_questions"] = answer_multiple_questions
        if expand_query is not None:
            self.inputs["expand_query"] = expand_query
        if expand_query_terms is not None:
            self.inputs["expand_query_terms"] = expand_query_terms
        if do_advanced_qa is not None:
            self.inputs["do_advanced_qa"] = do_advanced_qa
        if show_intermediate_steps is not None:
            self.inputs["show_intermediate_steps"] = show_intermediate_steps
        if score_cutoff is not None:
            self.inputs["score_cutoff"] = score_cutoff
        if enable_context is not None:
            self.inputs["enable_context"] = enable_context
        if format_context_for_llm is not None:
            self.inputs["format_context_for_llm"] = format_context_for_llm
        if enable_document_db_filter is not None:
            self.inputs["enable_document_db_filter"] = enable_document_db_filter
        if analyze_documents is not None:
            self.inputs["analyze_documents"] = analyze_documents
        if is_hybrid is not None:
            self.inputs["is_hybrid"] = is_hybrid
        if splitter_method is not None:
            self.inputs["splitter_method"] = splitter_method
        if segmentation_method is not None:
            self.inputs["segmentation_method"] = segmentation_method
        if qa_model_name is not None:
            self.inputs["qa_model_name"] = qa_model_name
        if advanced_search_mode is not None:
            self.inputs["advanced_search_mode"] = advanced_search_mode
        if filter is not None:
            self.inputs["filter"] = filter
        if rerank_model is not None:
            self.inputs["rerank_model"] = rerank_model
        if context is not None:
            self.inputs["context"] = context
        if document_db_filter is not None:
            self.inputs["document_db_filter"] = document_db_filter

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def chunks(self) -> List[str]:
        """
        Semantically similar chunks retrieved from the knowledge base

        Available: When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = False, When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("chunks")

    @property
    def citation_metadata(self) -> List[str]:
        """
        Citation metadata for semantic search outputs, used for showing sources in LLM responses

        Available: When do_advanced_qa = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("citation_metadata")

    @property
    def documents(self) -> List[str]:
        """
        Semantically similar documents retrieved from the knowledge base

        Available: When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = False, When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("documents")

    @property
    def formatted_text(self) -> str:
        """
        Knowledge base outputs formatted for input to a LLM

        Available: When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True, When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("formatted_text")

    @property
    def response(self) -> str:
        """
        The response from the semantic search

        Available: When do_advanced_qa = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @classmethod
    def from_dict(cls, data: dict) -> "SemanticSearchNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base")
class KnowledgeBaseNode(Node):
    """
    Semantically query a knowledge base that can contain files, scraped URLs, and data from synced integrations (e.g., Google Drive).

    ## Inputs
    ### Common Inputs
        alpha: The alpha value for the retrieval
        answer_multiple_questions: Extract separate questions from the query and retrieve content separately for each question to improve search performance
        do_advanced_qa: Use additional LLM calls to analyze each document to improve answer correctness
        do_nl_metadata_query: Do a natural language metadata query
        enable_context: Enable context
        enable_document_db_filter: Enable the document DB filter
        enable_filter: Filter the content returned from the knowledge base
        expand_query: Expand query to improve semantic search
        expand_query_terms: Expand query terms to improve semantic search
        format_context_for_llm: Format the context for the LLM
        knowledge_base: Select an existing knowledge base
        query: The query will be used to search documents for relevant pieces semantically.
        rerank_documents: Rerank the documents returned from the knowledge base
        retrieval_unit: The unit of retrieval
        score_cutoff: The score cutoff
        top_k: The number of relevant chunks to be returned
        transform_query: Transform the query for better semantic search
    ### When do_advanced_qa = True
        advanced_search_mode: The mode to use for the advanced search
        qa_model_name: The model to use for the QA
    ### When enable_context = True
        context: Additional context to pass to the query analysis and qa steps
    ### When enable_document_db_filter = True
        document_db_filter: Filter the documents returned from the knowledge base
    ### When enable_filter = True
        filter: Filter the content returned from the knowledge base
    ### When rerank_documents = True
        num_chunks_to_rerank: The number of chunks to rerank
        rerank_model: Refine the initial ranking of returned chunks based on relevancy

    ## Outputs
    ### When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = False
        chunks: Semantically similar chunks retrieved from the knowledge base.
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
    ### When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True
        chunks: Semantically similar chunks retrieved from the knowledge base.
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        formatted_text: Knowledge base outputs formatted for input to a LLM
    ### When do_advanced_qa = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        response: The response from the knowledge base
    ### When enable_filter = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
    ### When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = False
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        documents: The documents returned from the knowledge base
    ### When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        documents: Semantically similar documents retrieved from the knowledge base.
        formatted_text: Knowledge base outputs formatted for input to a LLM
    ### When enable_context = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
    ### When enable_document_db_filter = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "alpha",
            "helper_text": "The alpha value for the retrieval",
            "value": 0.5,
            "type": "float",
        },
        {
            "field": "answer_multiple_questions",
            "helper_text": "Extract separate questions from the query and retrieve content separately for each question to improve search performance",
            "value": False,
            "type": "bool",
        },
        {
            "field": "do_advanced_qa",
            "helper_text": "Use additional LLM calls to analyze each document to improve answer correctness",
            "value": False,
            "type": "bool",
        },
        {
            "field": "do_nl_metadata_query",
            "helper_text": "Do a natural language metadata query",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_context",
            "helper_text": "Enable context",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_document_db_filter",
            "helper_text": "Enable the document DB filter",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_filter",
            "helper_text": "Filter the content returned from the knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "expand_query",
            "helper_text": "Expand query to improve semantic search",
            "value": False,
            "type": "bool",
        },
        {
            "field": "expand_query_terms",
            "helper_text": "Expand query terms to improve semantic search",
            "value": False,
            "type": "bool",
        },
        {
            "field": "format_context_for_llm",
            "helper_text": "Format the context for the LLM",
            "value": True,
            "type": "bool",
        },
        {
            "field": "knowledge_base",
            "helper_text": "Select an existing knowledge base",
            "value": {"object_type": 1, "object_id": ""},
            "type": "knowledge_base",
        },
        {
            "field": "query",
            "helper_text": "The query will be used to search documents for relevant pieces semantically.",
            "value": "",
            "type": "string",
        },
        {
            "field": "rerank_documents",
            "helper_text": "Rerank the documents returned from the knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "retrieval_unit",
            "helper_text": "The unit of retrieval",
            "value": "chunks",
            "type": "enum<string>",
        },
        {
            "field": "score_cutoff",
            "helper_text": "The score cutoff",
            "value": 0,
            "type": "float",
        },
        {
            "field": "top_k",
            "helper_text": "The number of relevant chunks to be returned",
            "value": 10,
            "type": "int32",
        },
        {
            "field": "transform_query",
            "helper_text": "Transform the query for better semantic search",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**(*)**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "qa_model_name",
                    "label": "QA Model Name",
                    "type": "string",
                    "value": "gpt-4o-mini",
                    "helper_text": "The model to use for the QA",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "qa_models",
                    },
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "advanced_search_mode",
                    "label": "Advanced Search Mode",
                    "type": "string",
                    "value": "accurate",
                    "helper_text": "The mode to use for the advanced search",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Fast", "value": "fast"},
                            {"label": "Accurate", "value": "accurate"},
                        ],
                    },
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "helper_text": "The response from the knowledge base",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
            ],
        },
        "(*)**true**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "filter",
                    "label": "Filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter the content returned from the knowledge base",
                }
            ],
            "outputs": [
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                }
            ],
        },
        "(*)**(*)**true**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "rerank_model",
                    "label": "Rerank Model",
                    "type": "string",
                    "value": "cohere/rerank-english-v3.0",
                    "helper_text": "Refine the initial ranking of returned chunks based on relevancy",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "rerank_models",
                    },
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "num_chunks_to_rerank",
                    "label": "Num Chunks to Rerank",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The number of chunks to rerank",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
        },
        "false**(*)**(*)**documents**(*)**false**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "documents",
                    "type": "vec<string>",
                    "helper_text": "The documents returned from the knowledge base",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
            ],
        },
        "false**(*)**(*)**chunks**(*)**false**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "chunks",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar chunks retrieved from the knowledge base.",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
            ],
        },
        "false**(*)**(*)**documents**(*)**true**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "documents",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar documents retrieved from the knowledge base.",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
                {
                    "field": "formatted_text",
                    "type": "string",
                    "helper_text": "Knowledge base outputs formatted for input to a LLM",
                },
            ],
        },
        "false**(*)**(*)**chunks**(*)**true**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "chunks",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar chunks retrieved from the knowledge base.",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
                {
                    "field": "formatted_text",
                    "type": "string",
                    "helper_text": "Knowledge base outputs formatted for input to a LLM",
                },
            ],
        },
        "(*)**(*)**(*)**(*)**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "context",
                    "label": "Context",
                    "type": "string",
                    "value": "",
                    "helper_text": "Additional context to pass to the query analysis and qa steps",
                }
            ],
            "outputs": [
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                }
            ],
        },
        "(*)**(*)**(*)**(*)**(*)**(*)**true": {
            "inputs": [
                {
                    "field": "document_db_filter",
                    "label": "Document DB Filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter the documents returned from the knowledge base",
                }
            ],
            "outputs": [
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = [
        "do_advanced_qa",
        "enable_filter",
        "rerank_documents",
        "retrieval_unit",
        "enable_context",
        "format_context_for_llm",
        "enable_document_db_filter",
    ]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        do_advanced_qa: bool = False,
        enable_filter: bool = False,
        rerank_documents: bool = False,
        retrieval_unit: str = "chunks",
        enable_context: bool = False,
        format_context_for_llm: bool = True,
        enable_document_db_filter: bool = False,
        advanced_search_mode: str = "accurate",
        alpha: Any = 0.5,
        answer_multiple_questions: bool = False,
        context: str = "",
        do_nl_metadata_query: bool = False,
        document_db_filter: str = "",
        expand_query: bool = False,
        expand_query_terms: bool = False,
        filter: str = "",
        knowledge_base: Any = {"object_type": 1, "object_id": ""},
        num_chunks_to_rerank: int = 10,
        qa_model_name: str = "gpt-4o-mini",
        query: str = "",
        rerank_model: str = "cohere/rerank-english-v3.0",
        score_cutoff: Any = 0,
        top_k: int = 10,
        transform_query: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["do_advanced_qa"] = do_advanced_qa
        params["enable_filter"] = enable_filter
        params["rerank_documents"] = rerank_documents
        params["retrieval_unit"] = retrieval_unit
        params["enable_context"] = enable_context
        params["format_context_for_llm"] = format_context_for_llm
        params["enable_document_db_filter"] = enable_document_db_filter

        super().__init__(
            node_type="knowledge_base",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if knowledge_base is not None:
            self.inputs["knowledge_base"] = knowledge_base
        if query is not None:
            self.inputs["query"] = query
        if top_k is not None:
            self.inputs["top_k"] = top_k
        if enable_filter is not None:
            self.inputs["enable_filter"] = enable_filter
        if rerank_documents is not None:
            self.inputs["rerank_documents"] = rerank_documents
        if do_nl_metadata_query is not None:
            self.inputs["do_nl_metadata_query"] = do_nl_metadata_query
        if retrieval_unit is not None:
            self.inputs["retrieval_unit"] = retrieval_unit
        if alpha is not None:
            self.inputs["alpha"] = alpha
        if transform_query is not None:
            self.inputs["transform_query"] = transform_query
        if answer_multiple_questions is not None:
            self.inputs["answer_multiple_questions"] = answer_multiple_questions
        if expand_query is not None:
            self.inputs["expand_query"] = expand_query
        if expand_query_terms is not None:
            self.inputs["expand_query_terms"] = expand_query_terms
        if do_advanced_qa is not None:
            self.inputs["do_advanced_qa"] = do_advanced_qa
        if score_cutoff is not None:
            self.inputs["score_cutoff"] = score_cutoff
        if enable_context is not None:
            self.inputs["enable_context"] = enable_context
        if format_context_for_llm is not None:
            self.inputs["format_context_for_llm"] = format_context_for_llm
        if enable_document_db_filter is not None:
            self.inputs["enable_document_db_filter"] = enable_document_db_filter
        if qa_model_name is not None:
            self.inputs["qa_model_name"] = qa_model_name
        if advanced_search_mode is not None:
            self.inputs["advanced_search_mode"] = advanced_search_mode
        if filter is not None:
            self.inputs["filter"] = filter
        if rerank_model is not None:
            self.inputs["rerank_model"] = rerank_model
        if num_chunks_to_rerank is not None:
            self.inputs["num_chunks_to_rerank"] = num_chunks_to_rerank
        if context is not None:
            self.inputs["context"] = context
        if document_db_filter is not None:
            self.inputs["document_db_filter"] = document_db_filter

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def chunks(self) -> List[str]:
        """
        Semantically similar chunks retrieved from the knowledge base.

        Available: When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = False, When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("chunks")

    @property
    def citation_metadata(self) -> List[str]:
        """
        Citation metadata for knowledge base outputs, used for showing sources in LLM responses

        Available: When do_advanced_qa = True, When enable_filter = True, When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = False, When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = False, When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True, When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True, When enable_context = True, When enable_document_db_filter = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("citation_metadata")

    @property
    def documents(self) -> List[str]:
        """
        The documents returned from the knowledge base

        Different behavior based on configuration:
          - The documents returned from the knowledge base (When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = False)
          - Semantically similar documents retrieved from the knowledge base. (When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("documents")

    @property
    def formatted_text(self) -> str:
        """
        Knowledge base outputs formatted for input to a LLM

        Available: When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True, When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("formatted_text")

    @property
    def response(self) -> str:
        """
        The response from the knowledge base

        Available: When do_advanced_qa = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base_loader")
class KnowledgeBaseLoaderNode(Node):
    """
    Load data into an existing knowledge base.

    ## Inputs
    ### Common Inputs
        document_type: Scrape sub-pages of the provided link
        knowledge_base: The knowledge base to load data into
        rescrape_frequency: The frequency to rescrape the URL
    ### File
        documents: The file to be added to the selected knowledge base. Note: to convert text to file, use the Text to File node
    ### Recursive URL
        load_sitemap: Load URLs to crawl from a sitemap. If the URL is a sitemap, it will be used directly. If the URL is not a sitemap, the sitemap will be fetched automatically.
        max_depth: The maximum depth of the URL to crawl
        max_recursive_urls: The maximum number of recursive URLs to scrape
        same_domain_only: Whether to only crawl links from the same domain
        url: The raw URL link (e.g., https://vectorshift.ai/)
    ### URL
        max_recursive_urls: The maximum number of recursive URLs to scrape
        url: The raw URL link (e.g., https://vectorshift.ai/)

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "document_type",
            "helper_text": "Scrape sub-pages of the provided link",
            "value": "File",
            "type": "enum<string>",
        },
        {
            "field": "knowledge_base",
            "helper_text": "The knowledge base to load data into",
            "value": {},
            "type": "knowledge_base",
        },
        {
            "field": "rescrape_frequency",
            "helper_text": "The frequency to rescrape the URL",
            "value": "Never",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "URL": {
            "inputs": [
                {
                    "field": "max_recursive_urls",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The maximum number of recursive URLs to scrape",
                },
                {
                    "field": "url",
                    "type": "string",
                    "value": "",
                    "helper_text": "The raw URL link (e.g., https://vectorshift.ai/)",
                },
            ],
            "outputs": [],
        },
        "File": {
            "inputs": [
                {
                    "field": "documents",
                    "type": "vec<file>",
                    "value": [""],
                    "helper_text": "The file to be added to the selected knowledge base. Note: to convert text to file, use the Text to File node",
                }
            ],
            "outputs": [],
        },
        "Recursive URL": {
            "inputs": [
                {
                    "field": "max_recursive_urls",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The maximum number of recursive URLs to scrape",
                    "label": "Max urls to crawl (max 800)",
                },
                {
                    "field": "url",
                    "type": "string",
                    "value": "",
                    "helper_text": "The raw URL link (e.g., https://vectorshift.ai/)",
                },
                {
                    "field": "max_depth",
                    "type": "int32",
                    "value": 5,
                    "helper_text": "The maximum depth of the URL to crawl",
                    "label": "Max depth to crawl",
                },
                {
                    "field": "same_domain_only",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to only crawl links from the same domain",
                    "label": "Same domain only",
                },
                {
                    "field": "load_sitemap",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Load URLs to crawl from a sitemap. If the URL is a sitemap, it will be used directly. If the URL is not a sitemap, the sitemap will be fetched automatically.",
                    "label": "Load sitemap",
                },
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["document_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        document_type: str = "File",
        documents: List[str] = [""],
        knowledge_base: Any = {},
        load_sitemap: bool = False,
        max_depth: int = 5,
        max_recursive_urls: int = 10,
        rescrape_frequency: str = "Never",
        same_domain_only: bool = False,
        url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["document_type"] = document_type

        super().__init__(
            node_type="knowledge_base_loader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if knowledge_base is not None:
            self.inputs["knowledge_base"] = knowledge_base
        if document_type is not None:
            self.inputs["document_type"] = document_type
        if rescrape_frequency is not None:
            self.inputs["rescrape_frequency"] = rescrape_frequency
        if max_recursive_urls is not None:
            self.inputs["max_recursive_urls"] = max_recursive_urls
        if url is not None:
            self.inputs["url"] = url
        if documents is not None:
            self.inputs["documents"] = documents
        if max_depth is not None:
            self.inputs["max_depth"] = max_depth
        if same_domain_only is not None:
            self.inputs["same_domain_only"] = same_domain_only
        if load_sitemap is not None:
            self.inputs["load_sitemap"] = load_sitemap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseLoaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("map")
class MapNode(Node):
    """


    ## Inputs
    ### Common Inputs
        function: The function input
        inputs: The inputs input

    ## Outputs
    ### Common Outputs
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "function",
            "helper_text": "The function input",
            "value": "",
            "type": "string",
        },
        {
            "field": "inputs",
            "helper_text": "The inputs input",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The output output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        function: str = "",
        inputs: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="map",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if inputs is not None:
            self.inputs["inputs"] = inputs
        if function is not None:
            self.inputs["function"] = function

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The output output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "MapNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("merge")
class MergeNode(Node):
    """
    Recombine paths created by a condition node. Note: if you are not using a condition node, you shouldn’t use a merge node

    ## Inputs
    ### Common Inputs
        function: The function to apply to the input fields
        type: The expected type of the input and output fields
    ### When function = 'first' and type = '<T>'
        fields: The fields input
    ### When function = 'join' and type = '<T>'
        fields: The fields input

    ## Outputs
    ### When function = 'first' and type = '<T>'
        output: The Text from the path based on the condition node
    ### When function = 'join' and type = '<T>'
        output: The Text from the path based on the condition node
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "function",
            "helper_text": "The function to apply to the input fields",
            "value": "first",
            "type": "enum<string>",
        },
        {
            "field": "type",
            "helper_text": "The expected type of the input and output fields",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "first**<T>": {
            "inputs": [
                {"field": "fields", "type": "vec<<T>>", "value": [""]},
                {
                    "field": "function",
                    "type": "enum<string>",
                    "value": "first",
                    "helper_text": "The function to apply to the input fields",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "<T>",
                    "helper_text": "The Text from the path based on the condition node",
                }
            ],
        },
        "join**<T>": {
            "inputs": [
                {"field": "fields", "type": "vec<<T>>", "value": [""]},
                {
                    "field": "function",
                    "type": "enum<string>",
                    "value": "join",
                    "helper_text": "The function to apply to the output fields",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The Text from the path based on the condition node",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["function", "type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        function: str = "first",
        type: str = "string",
        fields: List[Any] = [""],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["function"] = function
        params["type"] = type

        super().__init__(
            node_type="merge",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if function is not None:
            self.inputs["function"] = function
        if fields is not None:
            self.inputs["fields"] = fields

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "MergeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("condition")
class ConditionNode(Node):
    """
    Specify a series of conditions and execute different paths based on the value of the conditions.

    ## Inputs
    ### Common Inputs
        conditions: The conditions input
        outputs: The outputs input

    ## Outputs
    ### Common Outputs
        [outputs]: The [outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "conditions",
            "helper_text": "The conditions input",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "outputs",
            "helper_text": "The outputs input",
            "value": {},
            "type": "map<string, string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "[outputs]", "helper_text": "The [outputs] output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        conditions: List[Any] = [],
        outputs: Dict[str, str] = {},
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="condition",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if conditions is not None:
            self.inputs["conditions"] = conditions
        if outputs is not None:
            self.inputs["outputs"] = outputs

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "ConditionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("nl_to_sql")
class NlToSqlNode(Node):
    """
    Convert natural language queries to SQL queries.

    ## Inputs
    ### Common Inputs
        db_dialect: The database dialect to use
        model: The model to use for the conversion
        schema: The schema of the database
        text: The natural language query to convert to SQL

    ## Outputs
    ### Common Outputs
        sql_query: The SQL query generated from the natural language query
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "db_dialect",
            "helper_text": "The database dialect to use",
            "value": "PostgreSQL",
            "type": "enum<string>",
        },
        {
            "field": "model",
            "helper_text": "The model to use for the conversion",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "schema",
            "helper_text": "The schema of the database",
            "value": "",
            "type": "string",
        },
        {
            "field": "text",
            "helper_text": "The natural language query to convert to SQL",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "sql_query",
            "helper_text": "The SQL query generated from the natural language query",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        db_dialect: str = "PostgreSQL",
        model: str = "gpt-4o",
        schema: str = "",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="nl_to_sql",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if db_dialect is not None:
            self.inputs["db_dialect"] = db_dialect
        if schema is not None:
            self.inputs["schema"] = schema
        if text is not None:
            self.inputs["text"] = text
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def sql_query(self) -> str:
        """
        The SQL query generated from the natural language query


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("sql_query")

    @classmethod
    def from_dict(cls, data: dict) -> "NlToSqlNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("read_json_values")
class ReadJsonValuesNode(Node):
    """
    Read values from a JSON object based on a provided key(s).

    ## Inputs
    ### Common Inputs
        json_string: The JSON you want to read from
        keys: Define the name(s) of the JSON keys from the JSON that you want to read
        processed_outputs: The processed_outputs input

    ## Outputs
    ### Common Outputs
        [processed_outputs]: The [processed_outputs] output
        json_values: The JSON Value
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "json_string",
            "helper_text": "The JSON you want to read from",
            "value": "",
            "type": "string",
        },
        {
            "field": "keys",
            "helper_text": "Define the name(s) of the JSON keys from the JSON that you want to read",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "processed_outputs",
            "helper_text": "The processed_outputs input",
            "value": {},
            "type": "map<string, string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "[processed_outputs]",
            "helper_text": "The [processed_outputs] output",
        },
        {"field": "json_values", "helper_text": "The JSON Value"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        json_string: str = "",
        keys: List[Any] = [],
        processed_outputs: Dict[str, str] = {},
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="read_json_values",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if json_string is not None:
            self.inputs["json_string"] = json_string
        if keys is not None:
            self.inputs["keys"] = keys
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def json_values(self) -> str:
        """
        The JSON Value


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("json_values")

    @classmethod
    def from_dict(cls, data: dict) -> "ReadJsonValuesNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("write_json_value")
class WriteJsonValueNode(Node):
    """
    Update a specific value in a JSON.

    ## Inputs
    ### Common Inputs
        fields: The fields input
        selected: Whether to update the JSON value or create a new JSON
    ### old
        json_string: The JSON to update

    ## Outputs
    ### Common Outputs
        updated_json: The updated JSON
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "fields",
            "helper_text": "The fields input",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "selected",
            "helper_text": "Whether to update the JSON value or create a new JSON",
            "value": "new",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "updated_json", "helper_text": "The updated JSON"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "old": {
            "inputs": [
                {
                    "field": "json_string",
                    "type": "string",
                    "value": "",
                    "helper_text": "The JSON to update",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["selected"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        selected: str = "new",
        fields: List[Any] = [],
        json_string: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["selected"] = selected

        super().__init__(
            node_type="write_json_value",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if selected is not None:
            self.inputs["selected"] = selected
        if fields is not None:
            self.inputs["fields"] = fields
        if json_string is not None:
            self.inputs["json_string"] = json_string

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def updated_json(self) -> str:
        """
        The updated JSON


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated_json")

    @classmethod
    def from_dict(cls, data: dict) -> "WriteJsonValueNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("api")
class ApiNode(Node):
    """
    Make an API request to a given URL.

    ## Inputs
    ### Common Inputs
        files: Files to include in the API request
        headers: Headers to include in the API request
        is_raw_json: Whether to return the raw JSON response from the API
        method: Choose the API Method desired (GET, POST, PUT, DELETE, PATCH)
        query_params: Query parameters to include in the API request
        url: Target URL for the API Request
    ### When is_raw_json = False
        body_params: The body parameters to include in the API request
    ### When is_raw_json = True
        raw_json: The raw JSON request to the API

    ## Outputs
    ### Common Outputs
        output: The response from the API
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "files",
            "helper_text": "Files to include in the API request",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "headers",
            "helper_text": "Headers to include in the API request",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "is_raw_json",
            "helper_text": "Whether to return the raw JSON response from the API",
            "value": False,
            "type": "bool",
        },
        {
            "field": "method",
            "helper_text": "Choose the API Method desired (GET, POST, PUT, DELETE, PATCH)",
            "value": "GET",
            "type": "enum<string>",
        },
        {
            "field": "query_params",
            "helper_text": "Query parameters to include in the API request",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "url",
            "helper_text": "Target URL for the API Request",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The response from the API"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "raw_json",
                    "type": "string",
                    "value": "",
                    "helper_text": "The raw JSON request to the API",
                    "label": "Raw JSON",
                    "order": 7,
                }
            ],
            "outputs": [],
        },
        "false": {
            "inputs": [
                {
                    "field": "body_params",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                    "helper_text": "The body parameters to include in the API request",
                    "label": "Body Parameters",
                    "component": {"type": "table"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["is_raw_json"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        is_raw_json: bool = False,
        body_params: List[Any] = [],
        files: List[Any] = [],
        headers: List[Any] = [],
        method: str = "GET",
        query_params: List[Any] = [],
        raw_json: str = "",
        url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["is_raw_json"] = is_raw_json

        super().__init__(
            node_type="api",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if method is not None:
            self.inputs["method"] = method
        if url is not None:
            self.inputs["url"] = url
        if headers is not None:
            self.inputs["headers"] = headers
        if query_params is not None:
            self.inputs["query_params"] = query_params
        if files is not None:
            self.inputs["files"] = files
        if is_raw_json is not None:
            self.inputs["is_raw_json"] = is_raw_json
        if raw_json is not None:
            self.inputs["raw_json"] = raw_json
        if body_params is not None:
            self.inputs["body_params"] = body_params

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The response from the API


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "ApiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("url_loader")
class UrlLoaderNode(Node):
    """
    Scrape content from a URL.

    ## Inputs
    ### Common Inputs
        provider: The provider to use for the URL loader
        url: The URL to load
    ### When provider = 'modal' and use_actions = True
        actions: The browser actions to perform on the URL
    ### When provider = 'modal'
        ai_enhance_content: Whether to enhance the content
        recursive: Whether to recursively load the URL
        use_actions: Perform browser actions to interact with the input website
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'apify'
        api_key: The API key to use
        recursive: Whether to recursively load the URL
    ### When provider = 'jina' and use_personal_api_key = True
        api_key: The API key to use
    ### When provider = 'modal' and use_personal_api_key = True
        apify_key: The API key to use
    ### When provider = 'modal' and recursive = True
        load_sitemap: Load URLs to crawl from a sitemap. If the URL is a sitemap, it will be used directly. If the URL is not a sitemap, the sitemap will be fetched automatically.
        url_limit: The maximum number of URLs to load
    ### When provider = 'apify' and recursive = True
        url_limit: The maximum number of URLs to load
    ### When provider = 'jina'
        use_personal_api_key: Whether to use a personal API key

    ## Outputs
    ### Common Outputs
        content: The content of the URL
        links: The sub-links present on the webpage of the provided URL
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "provider",
            "helper_text": "The provider to use for the URL loader",
            "value": "modal",
            "type": "enum<string>",
        },
        {
            "field": "url",
            "helper_text": "The URL to load",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "content", "helper_text": "The content of the URL"},
        {
            "field": "links",
            "helper_text": "The sub-links present on the webpage of the provided URL",
        },
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "jina**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "label": "Use personal API key",
                    "component": {"type": "bool"},
                }
            ],
            "outputs": [],
            "inputs_sort_order": ["provider", "url", "use_personal_api_key", "api_key"],
        },
        "apify**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "recursive",
                    "type": "bool",
                    "value": False,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "helper_text": "Whether to recursively load the URL",
                    "label": "Recursive",
                    "component": {"type": "bool"},
                },
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "The API key to use",
                    "label": "API key",
                    "component": {"type": "password"},
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "inputs_sort_order": [
                "provider",
                "url",
                "recursive",
                "url_limit",
                "api_key",
            ],
        },
        "modal**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "recursive",
                    "type": "bool",
                    "value": False,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "helper_text": "Whether to recursively load the URL",
                    "label": "Recursive",
                    "component": {"type": "bool"},
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "label": "Use personal API key",
                    "component": {"type": "bool"},
                },
                {
                    "field": "ai_enhance_content",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to enhance the content",
                    "label": "AI enhance content",
                    "component": {"type": "bool"},
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "is_advanced_setting": True,
                },
                {
                    "field": "use_actions",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Perform browser actions to interact with the input website",
                    "label": "Use browser actions",
                    "component": {"type": "bool"},
                    "banner_text": "This feature is only supported for the default provider and with recursive disabled",
                    "agent_field_type": "dynamic",
                    "is_hidden_in_agent": True,
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "inputs_sort_order": [
                "provider",
                "url",
                "use_actions",
                "actions",
                "recursive",
                "url_limit",
                "load_sitemap",
                "use_personal_api_key",
                "apify_key",
                "ai_enhance_content",
            ],
        },
        "modal**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "apify_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "The API key to use",
                    "label": "API key",
                    "component": {"type": "password"},
                    "agent_field_type": "static",
                    "disable_conversion": True,
                }
            ],
            "outputs": [],
        },
        "modal**(*)**true**(*)": {
            "inputs": [
                {
                    "field": "actions",
                    "type": "vec<any>",
                    "value": [],
                    "helper_text": "The browser actions to perform on the URL",
                    "label": "Actions",
                    "agent_field_type": "dynamic",
                    "is_hidden_in_agent": True,
                    "disable_conversion": True,
                }
            ],
            "outputs": [],
        },
        "modal**(*)**(*)**true": {
            "inputs": [
                {
                    "field": "url_limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The maximum number of URLs to load",
                    "label": "URL limit",
                    "component": {"type": "int32"},
                },
                {
                    "field": "load_sitemap",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Load URLs to crawl from a sitemap. If the URL is a sitemap, it will be used directly. If the URL is not a sitemap, the sitemap will be fetched automatically.",
                    "label": "Load sitemap",
                    "component": {"type": "bool"},
                    "agent_field_type": "dynamic",
                },
            ],
            "outputs": [],
        },
        "jina**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "The API key to use",
                    "label": "API key",
                    "component": {"type": "password"},
                    "agent_field_type": "static",
                    "disable_conversion": True,
                }
            ],
            "outputs": [],
        },
        "apify**(*)**(*)**true": {
            "inputs": [
                {
                    "field": "url_limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The maximum number of URLs to load",
                    "label": "URL limit",
                    "component": {"type": "int32"},
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["provider", "use_personal_api_key", "use_actions", "recursive"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        provider: str = "modal",
        use_personal_api_key: bool = False,
        use_actions: bool = False,
        recursive: bool = False,
        actions: List[Any] = [],
        ai_enhance_content: bool = False,
        api_key: str = "",
        apify_key: str = "",
        load_sitemap: bool = False,
        url: str = "",
        url_limit: int = 10,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["provider"] = provider
        params["use_personal_api_key"] = use_personal_api_key
        params["use_actions"] = use_actions
        params["recursive"] = recursive

        super().__init__(
            node_type="url_loader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if url is not None:
            self.inputs["url"] = url
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if recursive is not None:
            self.inputs["recursive"] = recursive
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if ai_enhance_content is not None:
            self.inputs["ai_enhance_content"] = ai_enhance_content
        if use_actions is not None:
            self.inputs["use_actions"] = use_actions
        if apify_key is not None:
            self.inputs["apify_key"] = apify_key
        if actions is not None:
            self.inputs["actions"] = actions
        if url_limit is not None:
            self.inputs["url_limit"] = url_limit
        if load_sitemap is not None:
            self.inputs["load_sitemap"] = load_sitemap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def content(self) -> str:
        """
        The content of the URL


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("content")

    @property
    def links(self) -> List[str]:
        """
        The sub-links present on the webpage of the provided URL


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("links")

    @classmethod
    def from_dict(cls, data: dict) -> "UrlLoaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("wikipedia")
class WikipediaNode(Node):
    """
    Query Wikipedia to return relevant articles

    ## Inputs
    ### Common Inputs
        chunk_text: Whether to chunk the text
        query: The Wikipedia query
    ### When chunk_text = True
        chunk_overlap: The overlap of the chunks
        chunk_size: The size of the chunks to create

    ## Outputs
    ### When chunk_text = True
        output: List of raw text from the Wikipedia article
    ### When chunk_text = False
        output: The raw text from the Wikipedia article
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_text",
            "helper_text": "Whether to chunk the text",
            "value": False,
            "type": "bool",
        },
        {
            "field": "query",
            "helper_text": "The Wikipedia query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "chunk_size",
                    "type": "int32",
                    "value": 512,
                    "helper_text": "The size of the chunks to create",
                    "label": "Chunk Size",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "int32",
                        "slider": True,
                        "min": 1,
                        "max": 4096,
                        "step": 1,
                    },
                },
                {
                    "field": "chunk_overlap",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The overlap of the chunks",
                    "label": "Chunk Overlap",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "int32",
                        "slider": True,
                        "min": 0,
                        "max": 4095,
                        "step": 1,
                    },
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<string>",
                    "helper_text": "List of raw text from the Wikipedia article",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "The raw text from the Wikipedia article",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["chunk_text"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_text: bool = False,
        chunk_overlap: int = 0,
        chunk_size: int = 512,
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["chunk_text"] = chunk_text

        super().__init__(
            node_type="wikipedia",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if chunk_text is not None:
            self.inputs["chunk_text"] = chunk_text
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[str]:
        """
        List of raw text from the Wikipedia article

        Different behavior based on configuration:
          - List of raw text from the Wikipedia article (When chunk_text = True)
          - The raw text from the Wikipedia article (When chunk_text = False)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "WikipediaNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("youtube")
class YoutubeNode(Node):
    """
    Get the transcript of a youtube video.

    ## Inputs
    ### Common Inputs
        chunk_text: Whether to chunk the text
        url: The YouTube URL to get the transcript of
    ### When chunk_text = True
        chunk_overlap: The overlap of the chunks
        chunk_size: The size of the chunks to create

    ## Outputs
    ### When chunk_text = True
        output: List of raw text from the YouTube transcript
    ### When chunk_text = False
        output: The raw text from the YouTube transcript
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_text",
            "helper_text": "Whether to chunk the text",
            "value": False,
            "type": "bool",
        },
        {
            "field": "url",
            "helper_text": "The YouTube URL to get the transcript of",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "chunk_size",
                    "type": "int32",
                    "value": 512,
                    "helper_text": "The size of the chunks to create",
                    "label": "Chunk Size",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "int32",
                        "slider": True,
                        "min": 1,
                        "max": 4096,
                        "step": 1,
                    },
                },
                {
                    "field": "chunk_overlap",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The overlap of the chunks",
                    "label": "Chunk Overlap",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "int32",
                        "slider": True,
                        "min": 0,
                        "max": 4095,
                        "step": 1,
                    },
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<string>",
                    "helper_text": "List of raw text from the YouTube transcript",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "The raw text from the YouTube transcript",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["chunk_text"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_text: bool = False,
        chunk_overlap: int = 0,
        chunk_size: int = 512,
        url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["chunk_text"] = chunk_text

        super().__init__(
            node_type="youtube",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if url is not None:
            self.inputs["url"] = url
        if chunk_text is not None:
            self.inputs["chunk_text"] = chunk_text
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[str]:
        """
        List of raw text from the YouTube transcript

        Different behavior based on configuration:
          - List of raw text from the YouTube transcript (When chunk_text = True)
          - The raw text from the YouTube transcript (When chunk_text = False)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "YoutubeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("arxiv")
class ArxivNode(Node):
    """
    Query ARXIV to return relevant articles

    ## Inputs
    ### Common Inputs
        chunk_text: Whether to chunk the text
        query: The ARXIV query
    ### When chunk_text = True
        chunk_overlap: The overlap of the chunks
        chunk_size: The size of the chunks to create

    ## Outputs
    ### When chunk_text = True
        output: List of raw text from the ARXIV article
    ### When chunk_text = False
        output: The raw text from the ARXIV article
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_text",
            "helper_text": "Whether to chunk the text",
            "value": False,
            "type": "bool",
        },
        {
            "field": "query",
            "helper_text": "The ARXIV query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "chunk_size",
                    "type": "int32",
                    "value": 512,
                    "helper_text": "The size of the chunks to create",
                    "label": "Chunk Size",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "int32",
                        "slider": True,
                        "min": 1,
                        "max": 4096,
                        "step": 1,
                    },
                },
                {
                    "field": "chunk_overlap",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The overlap of the chunks",
                    "label": "Chunk Overlap",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "int32",
                        "slider": True,
                        "min": 0,
                        "max": 4095,
                        "step": 1,
                    },
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<string>",
                    "helper_text": "List of raw text from the ARXIV article",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "The raw text from the ARXIV article",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["chunk_text"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_text: bool = False,
        chunk_overlap: int = 0,
        chunk_size: int = 512,
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["chunk_text"] = chunk_text

        super().__init__(
            node_type="arxiv",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if chunk_text is not None:
            self.inputs["chunk_text"] = chunk_text
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[str]:
        """
        List of raw text from the ARXIV article

        Different behavior based on configuration:
          - List of raw text from the ARXIV article (When chunk_text = True)
          - The raw text from the ARXIV article (When chunk_text = False)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "ArxivNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("serp_api")
class SerpApiNode(Node):
    """
    Query the SERPAPI Google search API

    ## Inputs
    ### Common Inputs
        api_key: SERP API key
        query: The web search query

    ## Outputs
    ### Common Outputs
        output: Results of the SERP query
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "api_key",
            "helper_text": "SERP API key",
            "value": "",
            "type": "string",
        },
        {
            "field": "query",
            "helper_text": "The web search query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "Results of the SERP query"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        api_key: str = "",
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="serp_api",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[str]:
        """
        Results of the SERP query


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "SerpApiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("you_dot_com")
class YouDotComNode(Node):
    """
    Query the You.com search API

    ## Inputs
    ### Common Inputs
        api_key: You.com API key
        loader_type: Select the loader type: General or News
        query: The search query

    ## Outputs
    ### Common Outputs
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "api_key",
            "helper_text": "You.com API key",
            "value": "",
            "type": "string",
        },
        {
            "field": "loader_type",
            "helper_text": "Select the loader type: General or News",
            "value": "YOU_DOT_COM",
            "type": "enum<string>",
        },
        {
            "field": "query",
            "helper_text": "The search query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The output output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "YOU_DOT_COM": {"inputs": [], "outputs": [], "title": "You.com Web Search"},
        "YOU_DOT_COM_NEWS": {
            "inputs": [],
            "outputs": [],
            "title": "You.com Search News",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["loader_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        loader_type: str = "YOU_DOT_COM",
        api_key: str = "",
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["loader_type"] = loader_type

        super().__init__(
            node_type="you_dot_com",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if loader_type is not None:
            self.inputs["loader_type"] = loader_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The output output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "YouDotComNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("exa_ai")
class ExaAiNode(Node):
    """
    Query the Exa search API

    ## Inputs
    ### Common Inputs
        loader_type: Select the loader type: General, Companies, or Research Papers
        query: The search query

    ## Outputs
    ### Common Outputs
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "loader_type",
            "helper_text": "Select the loader type: General, Companies, or Research Papers",
            "value": "EXA_AI_SEARCH",
            "type": "enum<string>",
        },
        {
            "field": "query",
            "helper_text": "The search query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The output output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "EXA_AI_SEARCH": {"inputs": [], "outputs": [], "title": "Exa AI Web Search"},
        "EXA_AI_SEARCH_COMPANIES": {
            "inputs": [],
            "outputs": [],
            "title": "Exa AI Companies",
        },
        "EXA_AI_SEARCH_RESEARCH_PAPERS": {
            "inputs": [],
            "outputs": [],
            "title": "Exa AI Research Papers",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["loader_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        loader_type: str = "EXA_AI_SEARCH",
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["loader_type"] = loader_type

        super().__init__(
            node_type="exa_ai",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if loader_type is not None:
            self.inputs["loader_type"] = loader_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[str]:
        """
        The output output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "ExaAiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("google_search")
class GoogleSearchNode(Node):
    """
    Query the Google Search search API

    ## Inputs
    ### Common Inputs
        location: The location of the search
        num_results: The number of results to return
        query: The Google search query
        search_type: Select the search type: Web, Image, Hotels, Events, or News

    ## Outputs
    ### Common Outputs
        snippets: The snippets of the Google search results
        urls: The URLs of the Google search results
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "location",
            "helper_text": "The location of the search",
            "value": "us",
            "type": "string",
        },
        {
            "field": "num_results",
            "helper_text": "The number of results to return",
            "value": 10,
            "type": "int32",
        },
        {
            "field": "query",
            "helper_text": "The Google search query",
            "value": "",
            "type": "string",
        },
        {
            "field": "search_type",
            "helper_text": "Select the search type: Web, Image, Hotels, Events, or News",
            "value": "web",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "snippets",
            "helper_text": "The snippets of the Google search results",
        },
        {"field": "urls", "helper_text": "The URLs of the Google search results"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        location: str = "us",
        num_results: int = 10,
        query: str = "",
        search_type: str = "web",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="google_search",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if num_results is not None:
            self.inputs["num_results"] = num_results
        if search_type is not None:
            self.inputs["search_type"] = search_type
        if location is not None:
            self.inputs["location"] = location

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def snippets(self) -> List[str]:
        """
        The snippets of the Google search results


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("snippets")

    @property
    def urls(self) -> List[str]:
        """
        The URLs of the Google search results


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("urls")

    @classmethod
    def from_dict(cls, data: dict) -> "GoogleSearchNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("google_alert_rss_reader")
class GoogleAlertRssReaderNode(Node):
    """
    Read the contents from a Google Alert RSS feed

    ## Inputs
    ### Common Inputs
        feed_link: The link of the Google Alert RSS feed you want to read
        timeframe: The publish dates of the items in the feed to read

    ## Outputs
    ### Common Outputs
        dates: The publish dates of the Google Alert RSS feed items
        links: The links of the Google Alert RSS feed items
        snippets: The snippets of the Google Alert RSS feed items
        titles: The titles of the Google Alert RSS feed items
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "feed_link",
            "helper_text": "The link of the Google Alert RSS feed you want to read",
            "value": "",
            "type": "string",
        },
        {
            "field": "timeframe",
            "helper_text": "The publish dates of the items in the feed to read",
            "value": "all",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "dates",
            "helper_text": "The publish dates of the Google Alert RSS feed items",
        },
        {
            "field": "links",
            "helper_text": "The links of the Google Alert RSS feed items",
        },
        {
            "field": "snippets",
            "helper_text": "The snippets of the Google Alert RSS feed items",
        },
        {
            "field": "titles",
            "helper_text": "The titles of the Google Alert RSS feed items",
        },
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        feed_link: str = "",
        timeframe: str = "all",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="google_alert_rss_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if feed_link is not None:
            self.inputs["feed_link"] = feed_link
        if timeframe is not None:
            self.inputs["timeframe"] = timeframe

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def dates(self) -> List[str]:
        """
        The publish dates of the Google Alert RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("dates")

    @property
    def links(self) -> List[str]:
        """
        The links of the Google Alert RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("links")

    @property
    def snippets(self) -> List[str]:
        """
        The snippets of the Google Alert RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("snippets")

    @property
    def titles(self) -> List[str]:
        """
        The titles of the Google Alert RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("titles")

    @classmethod
    def from_dict(cls, data: dict) -> "GoogleAlertRssReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("rss_feed_reader")
class RssFeedReaderNode(Node):
    """
    Read the contents from an RSS feed

    ## Inputs
    ### Common Inputs
        entries: The number of entries you want to fetch
        timeframe: The publish dates of the items in the feed to read
        url: The link of the RSS feed you want to read

    ## Outputs
    ### Common Outputs
        authors: The authors of the RSS feed items
        contents: The contents of the RSS feed items
        links: The links of the RSS feed items
        published_dates: The publish dates of the RSS feed items
        summaries: The summaries of the RSS feed items
        titles: The titles of the RSS feed items
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "entries",
            "helper_text": "The number of entries you want to fetch",
            "value": 10,
            "type": "int32",
        },
        {
            "field": "timeframe",
            "helper_text": "The publish dates of the items in the feed to read",
            "value": "all",
            "type": "enum<string>",
        },
        {
            "field": "url",
            "helper_text": "The link of the RSS feed you want to read",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "authors", "helper_text": "The authors of the RSS feed items"},
        {"field": "contents", "helper_text": "The contents of the RSS feed items"},
        {"field": "links", "helper_text": "The links of the RSS feed items"},
        {
            "field": "published_dates",
            "helper_text": "The publish dates of the RSS feed items",
        },
        {"field": "summaries", "helper_text": "The summaries of the RSS feed items"},
        {"field": "titles", "helper_text": "The titles of the RSS feed items"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        entries: int = 10,
        timeframe: str = "all",
        url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="rss_feed_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if url is not None:
            self.inputs["url"] = url
        if timeframe is not None:
            self.inputs["timeframe"] = timeframe
        if entries is not None:
            self.inputs["entries"] = entries

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def authors(self) -> List[str]:
        """
        The authors of the RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("authors")

    @property
    def contents(self) -> List[str]:
        """
        The contents of the RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("contents")

    @property
    def links(self) -> List[str]:
        """
        The links of the RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("links")

    @property
    def published_dates(self) -> List[str]:
        """
        The publish dates of the RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("published_dates")

    @property
    def summaries(self) -> List[str]:
        """
        The summaries of the RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("summaries")

    @property
    def titles(self) -> List[str]:
        """
        The titles of the RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("titles")

    @classmethod
    def from_dict(cls, data: dict) -> "RssFeedReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("csv_query")
class CsvQueryNode(Node):
    """
    Utilizes an LLM agent to query CSV(s). Delimeter for the CSV must be commas.

    ## Inputs
    ### Common Inputs
        csv: The CSV to be queried (file must be a CSV). Note: Ensure connecting node is of type File not text
        query: The question you want to be answered by the CSV
        stream: Whether to stream the results of the query

    ## Outputs
    ### Common Outputs
        output: The answer to the Query based on the CSV
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "csv",
            "helper_text": "The CSV to be queried (file must be a CSV). Note: Ensure connecting node is of type File not text",
            "value": None,
            "type": "file",
        },
        {
            "field": "query",
            "helper_text": "The question you want to be answered by the CSV",
            "value": "",
            "type": "string",
        },
        {
            "field": "stream",
            "helper_text": "Whether to stream the results of the query",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "The answer to the Query based on the CSV"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        csv: Optional[str] = None,
        query: str = "",
        stream: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="csv_query",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if csv is not None:
            self.inputs["csv"] = csv
        if query is not None:
            self.inputs["query"] = query
        if stream is not None:
            self.inputs["stream"] = stream

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The answer to the Query based on the CSV


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "CsvQueryNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("csv_reader")
class CsvReaderNode(Node):
    """
    Read the contents from a CSV file and output a list of the data for each column.

    ## Inputs
    ### Common Inputs
        columns: Define the name(s) of the columns that you want to read
        file_type: The type of file to read.
        processed_outputs: The processed_outputs input
        selected_file: The file to read.
    ### EXCEL
        sheet: The sheet input
        sheets: The sheets input

    ## Outputs
    ### Common Outputs
        [processed_outputs]: The [processed_outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "columns",
            "helper_text": "Define the name(s) of the columns that you want to read",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "file_type",
            "helper_text": "The type of file to read.",
            "value": "CSV",
            "type": "enum<string>",
        },
        {
            "field": "processed_outputs",
            "helper_text": "The processed_outputs input",
            "value": {},
            "type": "map<string, string>",
        },
        {
            "field": "selected_file",
            "helper_text": "The file to read.",
            "value": None,
            "type": "file",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "[processed_outputs]",
            "helper_text": "The [processed_outputs] output",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "CSV": {"inputs": [], "outputs": []},
        "EXCEL": {
            "inputs": [
                {"field": "sheet", "type": "enum<string>"},
                {"field": "sheets", "type": "vec<string>", "value": []},
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["file_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        file_type: str = "CSV",
        columns: List[Any] = [],
        processed_outputs: Dict[str, str] = {},
        selected_file: Optional[str] = None,
        sheet: Optional[str] = None,
        sheets: List[str] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["file_type"] = file_type

        super().__init__(
            node_type="csv_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_type is not None:
            self.inputs["file_type"] = file_type
        if selected_file is not None:
            self.inputs["selected_file"] = selected_file
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs
        if columns is not None:
            self.inputs["columns"] = columns
        if sheet is not None:
            self.inputs["sheet"] = sheet
        if sheets is not None:
            self.inputs["sheets"] = sheets

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "CsvReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("csv_writer")
class CsvWriterNode(Node):
    """
    Create a CSV from data

    ## Inputs
    ### Common Inputs
        load_option: Whether to load the CSV from a file or a string.
        selected_option: Whether to create a new CSV or update an existing one.
    ### When selected_option = 'new'
        columns: The columns to write to the CSV.
    ### When selected_option = 'old' and load_option = 'file'
        columns: The columns to write to the CSV.
        selected_file: The file to update.
    ### When selected_option = 'old' and load_option = 'text'
        csv_string: The CSV string to write.

    ## Outputs
    ### Common Outputs
        file: The CSV file created or updated.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "load_option",
            "helper_text": "Whether to load the CSV from a file or a string.",
            "value": "file",
            "type": "enum<string>",
        },
        {
            "field": "selected_option",
            "helper_text": "Whether to create a new CSV or update an existing one.",
            "value": "new",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file", "helper_text": "The CSV file created or updated."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new**(*)": {
            "inputs": [
                {
                    "field": "columns",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                    "helper_text": "The columns to write to the CSV.",
                    "table": {
                        "name": {"helper_text": "The name of the column"},
                        "value": {"helper_text": "The value of the column"},
                    },
                }
            ],
            "outputs": [],
        },
        "old**file": {
            "inputs": [
                {
                    "field": "selected_file",
                    "type": "file",
                    "helper_text": "The file to update.",
                },
                {
                    "field": "columns",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                    "helper_text": "The columns to write to the CSV.",
                    "table": {
                        "name": {"helper_text": "The name of the column"},
                        "value": {"helper_text": "The value of the column"},
                    },
                },
            ],
            "outputs": [],
        },
        "old**text": {
            "inputs": [
                {
                    "field": "csv_string",
                    "type": "string",
                    "value": "",
                    "helper_text": "The CSV string to write.",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["selected_option", "load_option"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        selected_option: str = "new",
        load_option: str = "file",
        columns: List[Any] = [],
        csv_string: str = "",
        selected_file: Optional[str] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["selected_option"] = selected_option
        params["load_option"] = load_option

        super().__init__(
            node_type="csv_writer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if selected_option is not None:
            self.inputs["selected_option"] = selected_option
        if load_option is not None:
            self.inputs["load_option"] = load_option
        if columns is not None:
            self.inputs["columns"] = columns
        if selected_file is not None:
            self.inputs["selected_file"] = selected_file
        if csv_string is not None:
            self.inputs["csv_string"] = csv_string

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def file(self) -> str:
        """
        The CSV file created or updated.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file")

    @classmethod
    def from_dict(cls, data: dict) -> "CsvWriterNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("create_list")
class CreateListNode(Node):
    """
    Create a list from input texts. Final list is ordered in the order of the inputs.

    ## Inputs
    ### Common Inputs
        type: The type of the list
    ### <T>
        list: Value to be added to the list

    ## Outputs
    ### <T>
        output: The created list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": ["", ""],
                    "helper_text": "Value to be added to the list",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The created list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        list: List[Any] = ["", ""],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="create_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[Any]:
        """
        The created list

        Available: <T>


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "CreateListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("combine_list")
class CombineListNode(Node):
    """
    Combine multiple lists into one list. Final list is ordered in the order of the input lists.

    ## Inputs
    ### Common Inputs
        type: The type of the list
    ### <T>
        list: List to be combined

    ## Outputs
    ### <T>
        output: The combined list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<vec<<T>>>",
                    "value": ["", ""],
                    "helper_text": "List to be combined",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The combined list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        list: List[List[Any]] = ["", ""],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="combine_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[Any]:
        """
        The combined list

        Available: <T>


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "CombineListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("list_trimmer")
class ListTrimmerNode(Node):
    """
    Trim a list to just the sections you want. Enter enter the number of items or specify the section of the list that you want to keep.

    ## Inputs
    ### Common Inputs
        specify_section: Check this to specify a section of the list to keep. Leave unchecked to keep a specified number of items from the start.
        type: The type of the list
    ### When specify_section = True and type = '<T>'
        end_index: The ending index of the section to keep (exclusive).
        list: The list to trim
        start_index: The starting index of the section to keep (inclusive). The first item of the list is index 0.
    ### When specify_section = False and type = '<T>'
        item_to_keep: Check this to specify a section of the list to keep. Leave unchecked to keep a specified number of items.
        list: The list to trim

    ## Outputs
    ### When specify_section = False and type = '<T>'
        output: The trimmed list
    ### When specify_section = True and type = '<T>'
        output: The trimmed list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "specify_section",
            "helper_text": "Check this to specify a section of the list to keep. Leave unchecked to keep a specified number of items from the start.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**<T>": {
            "inputs": [
                {
                    "field": "item_to_keep",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Check this to specify a section of the list to keep. Leave unchecked to keep a specified number of items.",
                },
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The list to trim",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The trimmed list",
                }
            ],
        },
        "true**<T>": {
            "inputs": [
                {
                    "field": "start_index",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The starting index of the section to keep (inclusive). The first item of the list is index 0.",
                },
                {
                    "field": "end_index",
                    "type": "int32",
                    "value": 1,
                    "helper_text": "The ending index of the section to keep (exclusive).",
                },
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The list to trim",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The trimmed list",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["specify_section", "type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        specify_section: bool = False,
        type: str = "string",
        end_index: int = 1,
        item_to_keep: int = 0,
        list: List[Any] = [],
        start_index: int = 0,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["specify_section"] = specify_section
        params["type"] = type

        super().__init__(
            node_type="list_trimmer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if specify_section is not None:
            self.inputs["specify_section"] = specify_section
        if item_to_keep is not None:
            self.inputs["item_to_keep"] = item_to_keep
        if list is not None:
            self.inputs["list"] = list
        if start_index is not None:
            self.inputs["start_index"] = start_index
        if end_index is not None:
            self.inputs["end_index"] = end_index

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[Any]:
        """
        The trimmed list

        Available: When specify_section = False and type = '<T>', When specify_section = True and type = '<T>'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "ListTrimmerNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("duplicate_list")
class DuplicateListNode(Node):
    """
    Create a new list by duplicating a single item with the size of the new list either matching the size of another list, or a specified size.

    ## Inputs
    ### Common Inputs
        specify_list_size: Check this box if you want to manually specify the list size. In this case 'Match List Size' will not be used.
        type: The type of the list
    ### When specify_list_size = True and type = '<T>'
        input_field: Item to duplicate
        list_size: The size of the new list
    ### When specify_list_size = False and type = '<T>'
        input_field: Item to duplicate
        list_size_to_match: The size of the list you want to match

    ## Outputs
    ### When specify_list_size = True and type = '<T>'
        output: The duplicated list
    ### When specify_list_size = False and type = '<T>'
        output: The duplicated list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "specify_list_size",
            "helper_text": "Check this box if you want to manually specify the list size. In this case 'Match List Size' will not be used.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**<T>": {
            "inputs": [
                {
                    "field": "list_size",
                    "type": "int32",
                    "value": 1,
                    "helper_text": "The size of the new list",
                },
                {
                    "field": "input_field",
                    "type": "<T>",
                    "value": "",
                    "helper_text": "Item to duplicate",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The duplicated list",
                }
            ],
        },
        "false**<T>": {
            "inputs": [
                {
                    "field": "list_size_to_match",
                    "type": "vec<string>",
                    "value": "",
                    "helper_text": "The size of the list you want to match",
                },
                {
                    "field": "input_field",
                    "type": "<T>",
                    "value": "",
                    "helper_text": "Item to duplicate",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The duplicated list",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["specify_list_size", "type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        specify_list_size: bool = False,
        type: str = "string",
        list_size: int = 1,
        list_size_to_match: List[str] = [],
        input_field: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["specify_list_size"] = specify_list_size
        params["type"] = type

        super().__init__(
            node_type="duplicate_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if specify_list_size is not None:
            self.inputs["specify_list_size"] = specify_list_size
        if list_size is not None:
            self.inputs["list_size"] = list_size
        if input_field is not None:
            self.inputs["input_field"] = input_field
        if list_size_to_match is not None:
            self.inputs["list_size_to_match"] = list_size_to_match
        if input_field is not None:
            self.inputs["input_field"] = input_field

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[Any]:
        """
        The duplicated list

        Available: When specify_list_size = True and type = '<T>', When specify_list_size = False and type = '<T>'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "DuplicateListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("flatten_list")
class FlattenListNode(Node):
    """
    Flatten list of lists into a single list. For example, [[a, b], [c, d]] becomes [a,b,c,d].

    ## Inputs
    ### Common Inputs
        type: The type of the list
    ### <T>
        list_of_lists: List of lists to be flattened

    ## Outputs
    ### <T>
        flattened_list: The flattened list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list_of_lists",
                    "type": "vec<vec<<T>>>",
                    "value": "",
                    "helper_text": "List of lists to be flattened",
                }
            ],
            "outputs": [
                {
                    "field": "flattened_list",
                    "type": "vec<<T>>",
                    "helper_text": "The flattened list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        list_of_lists: List[List[Any]] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="flatten_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if list_of_lists is not None:
            self.inputs["list_of_lists"] = list_of_lists

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def flattened_list(self) -> List[Any]:
        """
        The flattened list

        Available: <T>


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("flattened_list")

    @classmethod
    def from_dict(cls, data: dict) -> "FlattenListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("join_list_item")
class JoinListItemNode(Node):
    """
    Join a list of items into a single string. If join_by_newline is true, the items are joined by a newline character.

    ## Inputs
    ### Common Inputs
        join_by_newline: Separate each line in the final output with a new line
        type: The type of the list
    ### When join_by_newline = False
        join_characters: Use a specified character to join list items into a single string
    ### When type = '<T>'
        list: List of items to be joined

    ## Outputs
    ### Common Outputs
        joined_text: The joined string
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "join_by_newline",
            "helper_text": "Separate each line in the final output with a new line",
            "value": False,
            "type": "bool",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "joined_text", "helper_text": "The joined string"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)": {
            "inputs": [
                {
                    "field": "join_characters",
                    "type": "string",
                    "value": "",
                    "helper_text": "Use a specified character to join list items into a single string",
                }
            ],
            "outputs": [],
        },
        "(*)**<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "List of items to be joined",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["join_by_newline", "type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        join_by_newline: bool = False,
        type: str = "string",
        join_characters: str = "",
        list: List[Any] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["join_by_newline"] = join_by_newline
        params["type"] = type

        super().__init__(
            node_type="join_list_item",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if join_by_newline is not None:
            self.inputs["join_by_newline"] = join_by_newline
        if join_characters is not None:
            self.inputs["join_characters"] = join_characters
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def joined_text(self) -> str:
        """
        The joined string


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("joined_text")

    @classmethod
    def from_dict(cls, data: dict) -> "JoinListItemNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("csv_to_excel")
class CsvToExcelNode(Node):
    """
    Convert a CSV file into XLSX

    ## Inputs
    ### Common Inputs
        csv_file: The CSV file to convert.
        horizontal_alignment: The horizontal alignment of the text
        max_column_width: The maximum width of the columns
        vertical_alignment: The vertical alignment of the text
        wrap_text: Enable text wrapping

    ## Outputs
    ### Common Outputs
        xlsx_file: The Excel file created.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "csv_file",
            "helper_text": "The CSV file to convert.",
            "value": None,
            "type": "file",
        },
        {
            "field": "horizontal_alignment",
            "helper_text": "The horizontal alignment of the text",
            "value": "left",
            "type": "enum<string>",
        },
        {
            "field": "max_column_width",
            "helper_text": "The maximum width of the columns",
            "value": 100,
            "type": "int32",
        },
        {
            "field": "vertical_alignment",
            "helper_text": "The vertical alignment of the text",
            "value": "top",
            "type": "enum<string>",
        },
        {
            "field": "wrap_text",
            "helper_text": "Enable text wrapping",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "xlsx_file", "helper_text": "The Excel file created."}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        csv_file: Optional[str] = None,
        horizontal_alignment: str = "left",
        max_column_width: int = 100,
        vertical_alignment: str = "top",
        wrap_text: bool = True,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="csv_to_excel",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if csv_file is not None:
            self.inputs["csv_file"] = csv_file
        if wrap_text is not None:
            self.inputs["wrap_text"] = wrap_text
        if max_column_width is not None:
            self.inputs["max_column_width"] = max_column_width
        if horizontal_alignment is not None:
            self.inputs["horizontal_alignment"] = horizontal_alignment
        if vertical_alignment is not None:
            self.inputs["vertical_alignment"] = vertical_alignment

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def xlsx_file(self) -> str:
        """
        The Excel file created.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("xlsx_file")

    @classmethod
    def from_dict(cls, data: dict) -> "CsvToExcelNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("text_formatter")
class TextFormatterNode(Node):
    """
    Format text based off a specified formatter

    ## Inputs
    ### Common Inputs
        formatter: The formatter to apply to the text
        text: The text to format
    ### Truncate
        max_num_token: The maximum number of tokens to truncate the text to

    ## Outputs
    ### Common Outputs
        output: The formatted text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "formatter",
            "helper_text": "The formatter to apply to the text",
            "value": "To Uppercase",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to format",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The formatted text"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "Truncate": {
            "inputs": [
                {
                    "field": "max_num_token",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The maximum number of tokens to truncate the text to",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["formatter"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        formatter: str = "To Uppercase",
        max_num_token: int = 0,
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["formatter"] = formatter

        super().__init__(
            node_type="text_formatter",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text
        if formatter is not None:
            self.inputs["formatter"] = formatter
        if max_num_token is not None:
            self.inputs["max_num_token"] = max_num_token

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The formatted text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "TextFormatterNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("json_operations")
class JsonOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="json_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "JsonOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("list_operations")
class ListOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="list_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "ListOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_gmail")
class IntegrationGmailNode(Node):
    """
    Gmail

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'create_draft'
        attachments: Attachments to be appended.
        body: The body of the email
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients’ emails
        subject: The subject of the email
    ### When action = 'send_email'
        attachments: Attachments to be appended.
        body: The body of the email
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients’ emails
        subject: The subject of the email
    ### When action = 'draft_reply'
        attachments: Attachments to be appended.
        body: The body of the email
        email_id: The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients’ emails
    ### When action = 'send_reply'
        attachments: Attachments to be appended.
        body: The body of the email
        email_id: The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients’ emails
    ### When action = 'list_messages'
        bcc: Emails BCC'd to this address
        body: The body of the email
        category: Filter by tab (e.g. Primary, Social)
        cc: Emails CC'd to this address
        custom_params: Extra filters as raw query
        filename: Find attachments by name or type
        from: Emails sent by this address
        has: Filter by feature (e.g. attachment, drive)
        has_attachment: Only emails with attachments
        has_images: Emails containing images
        has_links: Emails containing links
        has_starred: Only starred emails
        has_unread: Only unread emails
        has_user_labels: Emails with custom labels
        in: Search within a folder (e.g. sent, spam)
        include_spam_trash: Include spam and trash emails
        is: Filter by status (e.g. read, unread, starred)
        label: Search emails with this label
        label_ids: Emails with all listed label IDs
        larger: Emails larger than this size (e.g. 5M)
        list: Emails from this mailing list
        msg_id: Search by message ID (ignores other filters)
        newer_than: Emails newer than a time (e.g. 7d, 2m)
        older_than: Emails older than a time (e.g. 7d, 2m)
        page_token: Use to fetch next page of results
        projection: Select which fields to return
        query: Raw query string to use directly. If provided, overrides all other query parameters.
        smaller: Emails smaller than this size (e.g. 5M)
        subject: The subject of the email
        to: Emails sent to this address
        use_date: Toggle to use dates
    ### When action = 'list_messages' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'list_messages' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'list_messages' and use_date = False
        num_messages: Specify the last n number of emails
    ### When action = 'list_messages' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'list_messages'
        attachments: The attachments of the retrieved emails
        email_bodies: The content of the retrieved emails
        email_dates: The sent dates of the retrieved emails
        email_display_names: The display names of the senders
        email_ids: The IDs of the retrieved emails
        email_subjects: The subjects of the retrieved emails
        recipient_addresses: The email addresses of the recipients
        sender_addresses: The email addresses of the senders
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Gmail>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_nodes",
        },
        "create_draft**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients’ emails",
                    "order": 4,
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Introduction to John",
                    "helper_text": "The subject of the email",
                    "order": 5,
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                    "order": 6,
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                    "order": 3,
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                    "order": 7,
                },
            ],
            "outputs": [],
            "name": "create_draft",
            "task_name": "tasks.gmail.create_email_draft",
            "description": "Create (but do not send) a new email",
            "label": "Create Email Draft",
            "inputs_sort_order": [
                "integration",
                "action",
                "format",
                "recipients",
                "subject",
                "body",
                "attachments",
            ],
        },
        "send_email**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients’ emails",
                    "order": 4,
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Introduction to John",
                    "helper_text": "The subject of the email",
                    "order": 5,
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                    "order": 6,
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                    "order": 3,
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                    "order": 7,
                },
            ],
            "outputs": [],
            "name": "send_email",
            "task_name": "tasks.gmail.send_email",
            "description": "Create and send a new email",
            "label": "Send Email",
            "inputs_sort_order": [
                "integration",
                "action",
                "format",
                "recipients",
                "subject",
                "body",
                "attachments",
            ],
        },
        "draft_reply**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients’ emails",
                    "order": 4,
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                    "order": 5,
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                    "order": 3,
                },
                {
                    "field": "email_id",
                    "type": "string",
                    "value": "",
                    "label": "Email Id",
                    "placeholder": "john@company.com",
                    "helper_text": "The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)",
                    "order": 6,
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                    "order": 7,
                },
            ],
            "outputs": [],
            "name": "draft_reply",
            "task_name": "tasks.gmail.draft_reply",
            "description": "Create (but do not send) a draft of a reply to an existing email",
            "label": "Draft Reply",
            "inputs_sort_order": [
                "integration",
                "action",
                "format",
                "recipients",
                "body",
                "email_id",
                "attachments",
            ],
        },
        "send_reply**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients’ emails",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "email_id",
                    "type": "string",
                    "value": "",
                    "label": "Email Id",
                    "placeholder": "john@company.com",
                    "helper_text": "The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [],
            "name": "send_reply",
            "task_name": "tasks.gmail.send_reply",
            "description": "Create and send a new reply to an existing email",
            "label": "Send Reply",
            "inputs_sort_order": [
                "integration",
                "action",
                "format",
                "recipients",
                "body",
                "email_id",
                "attachments",
            ],
        },
        "list_messages**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "order": 3,
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Raw Query",
                    "helper_text": "Raw query string to use directly. If provided, overrides all other query parameters.",
                },
                {
                    "field": "from",
                    "type": "string",
                    "value": "",
                    "label": "From",
                    "helper_text": "Emails sent by this address",
                },
                {
                    "field": "to",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "helper_text": "Emails sent to this address",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "helper_text": "Search keywords in the subject",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "helper_text": "Search text in the email body",
                },
                {
                    "field": "has_attachment",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only emails with attachments",
                    "label": "Has Attachment",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Emails With Attachments", "value": "True"},
                            {"label": "Emails Without Attachments", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_images",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Emails containing images",
                    "label": "Has Images",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Emails With Images", "value": "True"},
                            {"label": "Emails Without Images", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_links",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Emails containing links",
                    "label": "Has Links",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Emails With Links", "value": "True"},
                            {"label": "Emails Without Links", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_starred",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only starred emails",
                    "label": "Has Starred",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Starred Emails", "value": "True"},
                            {"label": "Exclude Starred Emails", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_unread",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only unread emails",
                    "label": "Has Unread",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Unread Emails", "value": "True"},
                            {"label": "Exclude Unread Emails", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "label",
                    "type": "string",
                    "value": "",
                    "label": "Label",
                    "helper_text": "Search emails with this label",
                },
                {
                    "field": "in",
                    "type": "string",
                    "value": "",
                    "label": "Inside Folder",
                    "helper_text": "Search within a folder (e.g. sent, spam)",
                },
                {
                    "field": "is",
                    "type": "string",
                    "value": "",
                    "label": "Is",
                    "helper_text": "Filter by status (e.g. read, unread, starred)",
                },
                {
                    "field": "has",
                    "type": "string",
                    "value": "",
                    "label": "Has",
                    "helper_text": "Filter by feature (e.g. attachment, drive)",
                },
                {
                    "field": "filename",
                    "type": "string",
                    "value": "",
                    "label": "Filename",
                    "helper_text": "Find attachments by name or type",
                },
                {
                    "field": "newer_than",
                    "type": "string",
                    "value": "",
                    "label": "Newer Than",
                    "helper_text": "Emails newer than a time (e.g. 7d, 2m)",
                },
                {
                    "field": "older_than",
                    "type": "string",
                    "value": "",
                    "label": "Older Than",
                    "helper_text": "Emails older than a time (e.g. 7d, 2m)",
                },
                {
                    "field": "cc",
                    "type": "string",
                    "value": "",
                    "label": "CC",
                    "helper_text": "Emails CC'd to this address",
                },
                {
                    "field": "bcc",
                    "type": "string",
                    "value": "",
                    "label": "BCC",
                    "helper_text": "Emails BCC'd to this address",
                },
                {
                    "field": "list",
                    "type": "string",
                    "value": "",
                    "label": "List",
                    "helper_text": "Emails from this mailing list",
                },
                {
                    "field": "category",
                    "type": "string",
                    "value": "",
                    "label": "Category",
                    "helper_text": "Filter by tab (e.g. Primary, Social)",
                },
                {
                    "field": "larger",
                    "type": "string",
                    "value": "",
                    "label": "Larger",
                    "helper_text": "Emails larger than this size (e.g. 5M)",
                },
                {
                    "field": "smaller",
                    "type": "string",
                    "value": "",
                    "label": "Smaller",
                    "helper_text": "Emails smaller than this size (e.g. 5M)",
                },
                {
                    "field": "custom_params",
                    "type": "string",
                    "value": "",
                    "label": "Custom Parameters",
                    "helper_text": "Extra filters as raw query",
                },
                {
                    "field": "projection",
                    "type": "string",
                    "value": "",
                    "label": "Projection",
                    "helper_text": "Select which fields to return",
                },
                {
                    "field": "page_token",
                    "type": "string",
                    "value": "",
                    "label": "Page Token",
                    "helper_text": "Use to fetch next page of results",
                },
                {
                    "field": "label_ids",
                    "type": "string",
                    "value": "",
                    "label": "Label IDs",
                    "helper_text": "Emails with all listed label IDs",
                },
                {
                    "field": "has_user_labels",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Emails with custom labels",
                    "label": "Has User Labels",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Emails With User Labels", "value": "True"},
                            {"label": "Emails Without User Labels", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "include_spam_trash",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Include spam and trash emails",
                    "label": "Include Spam Trash",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Spam and Trash Emails", "value": "True"},
                            {
                                "label": "Exclude Spam and Trash Emails",
                                "value": "False",
                            },
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "msg_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "helper_text": "Search by message ID (ignores other filters)",
                },
            ],
            "outputs": [
                {
                    "field": "email_ids",
                    "type": "vec<string>",
                    "helper_text": "The IDs of the retrieved emails",
                },
                {
                    "field": "email_subjects",
                    "type": "vec<string>",
                    "helper_text": "The subjects of the retrieved emails",
                },
                {
                    "field": "email_dates",
                    "type": "vec<string>",
                    "helper_text": "The sent dates of the retrieved emails",
                },
                {
                    "field": "email_bodies",
                    "type": "vec<string>",
                    "helper_text": "The content of the retrieved emails",
                },
                {
                    "field": "sender_addresses",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the senders",
                },
                {
                    "field": "email_display_names",
                    "type": "vec<string>",
                    "helper_text": "The display names of the senders",
                },
                {
                    "field": "recipient_addresses",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the recipients",
                },
                {
                    "field": "attachments",
                    "type": "vec<vec<file>>",
                    "helper_text": "The attachments of the retrieved emails",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "list_messages",
            "task_name": "tasks.gmail.list_messages",
            "description": "Get emails from Gmail",
            "label": "Get Emails",
            "inputs_sort_order": [
                "integration",
                "action",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "query",
                "from",
                "to",
                "subject",
                "body",
                "has_attachment",
            ],
        },
        "list_messages**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Emails",
                    "helper_text": "Specify the last n number of emails",
                    "order": 5,
                }
            ],
            "outputs": [],
        },
        "list_messages**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "order": 4,
                }
            ],
            "outputs": [],
        },
        "list_messages**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "label": "Date Range",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "list_messages**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "label": "Exact date",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        attachments: List[str] = [],
        bcc: str = "",
        body: str = "",
        category: str = "",
        cc: str = "",
        custom_params: str = "",
        email_id: str = "",
        exact_date: Any = {"start": "", "end": ""},
        filename: str = "",
        format: str = "text",
        from_: str = "",
        has: str = "",
        has_attachment: str = "Ignore",
        has_images: str = "Ignore",
        has_links: str = "Ignore",
        has_starred: str = "Ignore",
        has_unread: str = "Ignore",
        has_user_labels: str = "Ignore",
        in_: str = "",
        include_spam_trash: str = "Ignore",
        is_: str = "",
        label: str = "",
        label_ids: str = "",
        larger: str = "",
        list: str = "",
        msg_id: str = "",
        newer_than: str = "",
        num_messages: int = 10,
        older_than: str = "",
        page_token: str = "",
        projection: str = "",
        query: str = "",
        recipients: str = "",
        smaller: str = "",
        subject: str = "",
        to: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_gmail",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if recipients is not None:
            self.inputs["recipients"] = recipients
        if subject is not None:
            self.inputs["subject"] = subject
        if body is not None:
            self.inputs["body"] = body
        if format is not None:
            self.inputs["format"] = format
        if attachments is not None:
            self.inputs["attachments"] = attachments
        if email_id is not None:
            self.inputs["email_id"] = email_id
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if query is not None:
            self.inputs["query"] = query
        if from_ is not None:
            self.inputs["from"] = from_
        if to is not None:
            self.inputs["to"] = to
        if has_attachment is not None:
            self.inputs["has_attachment"] = has_attachment
        if has_images is not None:
            self.inputs["has_images"] = has_images
        if has_links is not None:
            self.inputs["has_links"] = has_links
        if has_starred is not None:
            self.inputs["has_starred"] = has_starred
        if has_unread is not None:
            self.inputs["has_unread"] = has_unread
        if label is not None:
            self.inputs["label"] = label
        if in_ is not None:
            self.inputs["in"] = in_
        if is_ is not None:
            self.inputs["is"] = is_
        if has is not None:
            self.inputs["has"] = has
        if filename is not None:
            self.inputs["filename"] = filename
        if newer_than is not None:
            self.inputs["newer_than"] = newer_than
        if older_than is not None:
            self.inputs["older_than"] = older_than
        if cc is not None:
            self.inputs["cc"] = cc
        if bcc is not None:
            self.inputs["bcc"] = bcc
        if list is not None:
            self.inputs["list"] = list
        if category is not None:
            self.inputs["category"] = category
        if larger is not None:
            self.inputs["larger"] = larger
        if smaller is not None:
            self.inputs["smaller"] = smaller
        if custom_params is not None:
            self.inputs["custom_params"] = custom_params
        if projection is not None:
            self.inputs["projection"] = projection
        if page_token is not None:
            self.inputs["page_token"] = page_token
        if label_ids is not None:
            self.inputs["label_ids"] = label_ids
        if has_user_labels is not None:
            self.inputs["has_user_labels"] = has_user_labels
        if include_spam_trash is not None:
            self.inputs["include_spam_trash"] = include_spam_trash
        if msg_id is not None:
            self.inputs["msg_id"] = msg_id
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if from_ is not None:
            self.inputs["from"] = from_
        if in_ is not None:
            self.inputs["in"] = in_
        if integration is not None:
            self.inputs["integration"] = integration
        if is_ is not None:
            self.inputs["is"] = is_

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attachments(self) -> List[List[str]]:
        """
        The attachments of the retrieved emails

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attachments")

    @property
    def email_bodies(self) -> List[str]:
        """
        The content of the retrieved emails

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_bodies")

    @property
    def email_dates(self) -> List[str]:
        """
        The sent dates of the retrieved emails

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_dates")

    @property
    def email_display_names(self) -> List[str]:
        """
        The display names of the senders

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_display_names")

    @property
    def email_ids(self) -> List[str]:
        """
        The IDs of the retrieved emails

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_ids")

    @property
    def email_subjects(self) -> List[str]:
        """
        The subjects of the retrieved emails

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_subjects")

    @property
    def recipient_addresses(self) -> List[str]:
        """
        The email addresses of the recipients

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("recipient_addresses")

    @property
    def sender_addresses(self) -> List[str]:
        """
        The email addresses of the senders

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("sender_addresses")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGmailNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_copper")
class IntegrationCopperNode(Node):
    """
    Copper

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_lead
        email: The email of the lead
        name: The name of the lead

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Copper>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_lead": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name",
                    "placeholder": "John Smith",
                    "helper_text": "The name of the lead",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@company.com",
                    "helper_text": "The email of the lead",
                },
            ],
            "outputs": [],
            "name": "create_lead",
            "task_name": "tasks.copper.create_lead",
            "description": "Create a new lead",
            "label": "Create Lead",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        email: str = "",
        name: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_copper",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if name is not None:
            self.inputs["name"] = name
        if email is not None:
            self.inputs["email"] = email
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationCopperNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_discord")
class IntegrationDiscordNode(Node):
    """
    Discord

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### send_message
        channel_name: The name of the Discord channel
        message: The message you want to send

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Discord>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "send_message": {
            "inputs": [
                {
                    "field": "channel_name",
                    "type": "string",
                    "value": "",
                    "label": "Channel Name",
                    "placeholder": "General",
                    "helper_text": "The name of the Discord channel",
                },
                {
                    "field": "message",
                    "type": "string",
                    "value": "",
                    "label": "Message",
                    "placeholder": "Hello World!",
                    "helper_text": "The message you want to send",
                },
            ],
            "outputs": [],
            "name": "send_message",
            "task_name": "tasks.discord.send_message",
            "description": "Send a message to a specific channel",
            "label": "Send Message",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        channel_name: str = "",
        message: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_discord",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if channel_name is not None:
            self.inputs["channel_name"] = channel_name
        if message is not None:
            self.inputs["message"] = message
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationDiscordNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_linear")
class IntegrationLinearNode(Node):
    """
    Linear

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_comment
        comment: The comment on the issue
        issue_name: The name of the issue for the comment
    ### create_issue
        description: The description of the ticket
        team_name: The team within Linear
        title: The title of the issue

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Linear>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_issue": {
            "inputs": [
                {
                    "field": "team_name",
                    "type": "string",
                    "label": "Team",
                    "helper_text": "The team within Linear",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "label": "Title",
                    "placeholder": "Bug on submit button",
                    "helper_text": "The title of the issue",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Clicking on submit button leads to wrong page",
                    "helper_text": "The description of the ticket",
                },
            ],
            "outputs": [],
            "name": "create_issue",
            "task_name": "tasks.linear.create_new_issue",
            "description": "Create a new issue",
            "label": "Create Issue",
            "variant": "common_integration_nodes",
        },
        "create_comment": {
            "inputs": [
                {
                    "field": "issue_name",
                    "type": "string",
                    "value": "",
                    "label": "Issue",
                    "placeholder": "Bug on submit button",
                    "helper_text": "The name of the issue for the comment",
                },
                {
                    "field": "comment",
                    "type": "string",
                    "value": "",
                    "label": "Comment",
                    "placeholder": "More users are facing this issue",
                    "helper_text": "The comment on the issue",
                },
            ],
            "outputs": [],
            "name": "create_comment",
            "task_name": "tasks.linear.create_new_comment",
            "description": "Create a new comment",
            "label": "Create Comment",
            "variant": "default_integration_nodes",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        comment: str = "",
        description: str = "",
        issue_name: str = "",
        team_name: Optional[str] = None,
        title: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_linear",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if team_name is not None:
            self.inputs["team_name"] = team_name
        if title is not None:
            self.inputs["title"] = title
        if description is not None:
            self.inputs["description"] = description
        if issue_name is not None:
            self.inputs["issue_name"] = issue_name
        if comment is not None:
            self.inputs["comment"] = comment
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationLinearNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_outlook")
class IntegrationOutlookNode(Node):
    """
    Outlook

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'create_draft'
        attachments: Attachments to be appended.
        body: The body of the email
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
        subject: The subject of the email
    ### When action = 'send_email'
        attachments: Attachments to be appended.
        body: The body of the email
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
        subject: The subject of the email
    ### When action = 'draft_reply'
        attachments: Attachments to be appended.
        body: The body of the email
        email_id: The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
    ### When action = 'send_reply'
        attachments: Attachments to be appended.
        body: The body of the email
        email_id: The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
    ### When action = 'read_email' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'read_email' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'read_email'
        item_id: Select an email to read
        use_date: Toggle to use dates
    ### When action = 'read_email' and use_date = False
        num_messages: Specify the last n number of emails
    ### When action = 'read_email' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_email'
        attachments: The attachments for each email
        email_bodies: The content of the retrieved emails
        email_dates: The sent dates of the retrieved emails
        email_ids: The IDs of the retrieved emails
        email_labels: The display names of the senders
        email_subjects: The subjects of the retrieved emails
        recipient_addresses: The email addresses of the recipients
        sender_addresses: The email addresses of the senders
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Outlook>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_nodes",
        },
        "create_draft**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Introduction to John",
                    "helper_text": "The subject of the email",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [],
            "name": "create_draft",
            "task_name": "tasks.outlook.create_email_draft",
            "description": "Create (but do not send) a new email",
            "label": "Create Email Draft",
            "inputs_sort_order": [
                "integration",
                "action",
                "recipients",
                "subject",
                "format",
                "body",
            ],
        },
        "send_email**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Introduction to John",
                    "helper_text": "The subject of the email",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [""],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [],
            "name": "send_email",
            "task_name": "tasks.outlook.send_email",
            "description": "Create and send a new email",
            "label": "Send Email",
            "inputs_sort_order": [
                "integration",
                "action",
                "recipients",
                "subject",
                "format",
                "body",
                "attachments",
            ],
        },
        "draft_reply**(*)**(*)": {
            "inputs": [
                {
                    "field": "email_id",
                    "type": "string",
                    "value": "",
                    "label": "Email Id",
                    "placeholder": "john@company.com",
                    "helper_text": "The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)",
                },
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [],
            "name": "draft_reply",
            "task_name": "tasks.outlook.draft_reply",
            "description": "Create (but do not send) a draft of a reply to an existing email",
            "label": "Draft Reply",
            "inputs_sort_order": [
                "integration",
                "action",
                "email_id",
                "recipients",
                "format",
                "body",
            ],
        },
        "send_reply**(*)**(*)": {
            "inputs": [
                {
                    "field": "email_id",
                    "type": "string",
                    "value": "",
                    "label": "Email Id",
                    "placeholder": "john@company.com",
                    "helper_text": "The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)",
                },
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [],
            "name": "send_reply",
            "task_name": "tasks.outlook.send_reply",
            "description": "Create and send a new reply to an existing email",
            "label": "Send Reply",
            "inputs_sort_order": [
                "integration",
                "action",
                "email_id",
                "recipients",
                "format",
                "body",
                "attachments",
            ],
        },
        "read_email**(*)**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "label": "Mailbox",
                    "helper_text": "Select an email to read",
                    "show_date_range": True,
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "order": 1,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "hidden": True,
                    "order": 2,
                },
            ],
            "outputs": [
                {
                    "field": "email_ids",
                    "type": "vec<string>",
                    "helper_text": "The IDs of the retrieved emails",
                },
                {
                    "field": "email_subjects",
                    "type": "vec<string>",
                    "helper_text": "The subjects of the retrieved emails",
                },
                {
                    "field": "email_dates",
                    "type": "vec<string>",
                    "helper_text": "The sent dates of the retrieved emails",
                },
                {
                    "field": "email_bodies",
                    "type": "vec<string>",
                    "helper_text": "The content of the retrieved emails",
                },
                {
                    "field": "sender_addresses",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the senders",
                },
                {
                    "field": "email_labels",
                    "type": "vec<string>",
                    "helper_text": "The display names of the senders",
                },
                {
                    "field": "recipient_addresses",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the recipients",
                },
                {
                    "field": "attachments",
                    "type": "vec<vec<file>>",
                    "helper_text": "The attachments for each email",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "read_email",
            "task_name": "tasks.outlook.read_email",
            "description": "Read emails from Outlook",
            "label": "Read Emails",
            "inputs_sort_order": [
                "integration",
                "action",
                "item_id",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
            ],
        },
        "read_email**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Emails",
                    "helper_text": "Specify the last n number of emails",
                    "hidden": True,
                    "order": 5,
                }
            ],
            "outputs": [],
        },
        "read_email**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "hidden": True,
                    "order": 3,
                }
            ],
            "outputs": [],
        },
        "read_email**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                    "order": 4,
                }
            ],
            "outputs": [],
        },
        "read_email**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                    "order": 4,
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        attachments: List[str] = [],
        body: str = "",
        email_id: str = "",
        exact_date: Any = {"start": "", "end": ""},
        format: str = "text",
        item_id: Optional[str] = None,
        num_messages: int = 10,
        recipients: str = "",
        subject: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_outlook",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if recipients is not None:
            self.inputs["recipients"] = recipients
        if subject is not None:
            self.inputs["subject"] = subject
        if body is not None:
            self.inputs["body"] = body
        if format is not None:
            self.inputs["format"] = format
        if attachments is not None:
            self.inputs["attachments"] = attachments
        if email_id is not None:
            self.inputs["email_id"] = email_id
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attachments(self) -> List[List[str]]:
        """
        The attachments for each email

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attachments")

    @property
    def email_bodies(self) -> List[str]:
        """
        The content of the retrieved emails

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_bodies")

    @property
    def email_dates(self) -> List[str]:
        """
        The sent dates of the retrieved emails

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_dates")

    @property
    def email_ids(self) -> List[str]:
        """
        The IDs of the retrieved emails

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_ids")

    @property
    def email_labels(self) -> List[str]:
        """
        The display names of the senders

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_labels")

    @property
    def email_subjects(self) -> List[str]:
        """
        The subjects of the retrieved emails

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_subjects")

    @property
    def recipient_addresses(self) -> List[str]:
        """
        The email addresses of the recipients

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("recipient_addresses")

    @property
    def sender_addresses(self) -> List[str]:
        """
        The email addresses of the senders

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("sender_addresses")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationOutlookNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_salesforce")
class IntegrationSalesforceNode(Node):
    """
    Salesforce

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'run_sql_query'
        sql_query: SQL Query in Salesforce Object Query Language

    ## Outputs
    ### When action = 'run_sql_query'
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Salesforce>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "run_sql_query**(*)**(*)": {
            "inputs": [
                {
                    "field": "sql_query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "SELECT Id, Name, AccountNumber FROM Account",
                    "helper_text": "SQL Query in Salesforce Object Query Language",
                }
            ],
            "outputs": [{"field": "output", "type": "string"}],
            "name": "run_sql_query",
            "task_name": "tasks.salesforce.run_sql_query",
            "description": "Run a SQL query to query data",
            "label": "Run SQL Query",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        sql_query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_salesforce",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if sql_query is not None:
            self.inputs["sql_query"] = sql_query
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The output output

        Available: When action = 'run_sql_query'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationSalesforceNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_slack")
class IntegrationSlackNode(Node):
    """
    Slack

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'send_message'
        attachments: Attachments to be appended.
        channel: The name of the Slack channel
        message: The message you want to send
        team: The name of the Slack team
    ### When action = 'read_message'
        channel: The name of the Slack channel
        team: The name of the Slack team
        use_date: Toggle to use dates
    ### When action = 'read_message' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'read_message' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'read_message' and use_date = False
        num_messages: Specify the last n number of messages
    ### When action = 'read_message' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_message'
        attachment_names: The retrieved attachment names
        message: The retrieved messages
        sender_id: The retrieved sender ids
        thread_id: The retrieved thread ids
        thread_link: The retrieved thread links
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Slack>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_nodes",
        },
        "send_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Slack team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "label": "Channel",
                    "placeholder": "General",
                    "helper_text": "The name of the Slack channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "message",
                    "type": "string",
                    "value": "",
                    "label": "Message",
                    "placeholder": "Hello World!",
                    "helper_text": "The message you want to send",
                    "order": 5,
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [],
            "name": "send_message",
            "task_name": "tasks.slack.create_message",
            "description": "Post a new message to a specific channel",
            "label": "Send Message",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "message",
                "attachments",
            ],
        },
        "read_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Slack team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "label": "Channel",
                    "placeholder": "General",
                    "helper_text": "The name of the Slack channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "hidden": True,
                },
            ],
            "outputs": [
                {
                    "field": "message",
                    "type": "vec<string>",
                    "helper_text": "The retrieved messages",
                },
                {
                    "field": "thread_id",
                    "type": "vec<string>",
                    "helper_text": "The retrieved thread ids",
                },
                {
                    "field": "attachment_names",
                    "type": "vec<vec<string>>",
                    "helper_text": "The retrieved attachment names",
                },
                {
                    "field": "sender_id",
                    "type": "vec<string>",
                    "helper_text": "The retrieved sender ids",
                },
                {
                    "field": "thread_link",
                    "type": "vec<string>",
                    "helper_text": "The retrieved thread links",
                },
            ],
            "name": "read_message",
            "task_name": "tasks.slack.read_messages",
            "description": "Reads n messages from a channel",
            "label": "Read Message",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
            ],
        },
        "read_message**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Messages",
                    "helper_text": "Specify the last n number of messages",
                    "hidden": True,
                }
            ],
            "outputs": [],
        },
        "read_message**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "hidden": True,
                }
            ],
            "outputs": [],
        },
        "read_message**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "read_message**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        attachments: List[str] = [],
        channel: str = "",
        exact_date: Any = {"start": "", "end": ""},
        message: str = "",
        num_messages: int = 10,
        team: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_slack",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if team is not None:
            self.inputs["team"] = team
        if channel is not None:
            self.inputs["channel"] = channel
        if message is not None:
            self.inputs["message"] = message
        if attachments is not None:
            self.inputs["attachments"] = attachments
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attachment_names(self) -> List[List[str]]:
        """
        The retrieved attachment names

        Available: When action = 'read_message'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attachment_names")

    @property
    def message(self) -> List[str]:
        """
        The retrieved messages

        Available: When action = 'read_message'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("message")

    @property
    def sender_id(self) -> List[str]:
        """
        The retrieved sender ids

        Available: When action = 'read_message'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("sender_id")

    @property
    def thread_id(self) -> List[str]:
        """
        The retrieved thread ids

        Available: When action = 'read_message'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("thread_id")

    @property
    def thread_link(self) -> List[str]:
        """
        The retrieved thread links

        Available: When action = 'read_message'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("thread_link")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationSlackNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_jira")
class IntegrationJiraNode(Node):
    """
    Jira

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: The integration input
    ### When action = 'get_issues'
        affected_version: Filter by affected version
        assignee_name: Account Name of the user to assign the issue to
        comment: The comment text to add
        comment_exact: Match comment exactly
        component: Filter by issue component
        created: Issue creation (YYYY-MM-DD)
        description: Detailed description of the issue
        description_exact: Match description exactly
        due: Due (YYYY-MM-DD)
        fix_version: Filter by fix version
        issue_summary: Search by issue summary
        issue_type: Type of issue (e.g. Task, Bug, Story)
        labels: Filter by issue labels
        project: The name of the project
        query: The query to filter issues
        reporter_name: Account Name of the user who reported the issue
        resolution: Filter by resolution status
        resolved: Resolution (YYYY-MM-DD)
        site: The name of the Jira site
        status: The status of the issue (e.g. Open, Closed, In Progress)
        summary_exact: Match summary exactly
        text: Search in all text fields
        text_exact: Match text exactly across fields
        updated: Last update (YYYY-MM-DD)
        use_date: Toggle to use dates
    ### When action = 'create_issue'
        assignee_name: Account Name of the user to assign the issue to
        description: Detailed description of the issue
        issue_type: Type of issue (e.g. Task, Bug, Story)
        project: The name of the project
        site: The name of the Jira site
        summary: A brief title or summary of the issue
    ### When action = 'add_issue_comment'
        comment: The comment text to add
        issue_key: The key of the issue to update (e.g. PROJ-123)
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'get_issues' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'get_issues' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'update_issue'
        issue_key: The key of the issue to update (e.g. PROJ-123)
        project: The name of the project
        site: The name of the Jira site
        update_assignee_name: Account Name of the user to assign the issue to
        update_description: The new description for the issue
        update_issue_type: Type of issue (e.g. Task, Bug, Story)
        update_summary: The new summary for the issue
    ### When action = 'read_issue'
        issue_key: The key of the issue to update (e.g. PROJ-123)
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'read_issue_comments'
        issue_key: The key of the issue to update (e.g. PROJ-123)
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'get_issues' and use_date = False
        num_messages: Specify the number of issues to fetch
    ### When action = 'get_users'
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'get_issues' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'get_users'
        account_id: The account IDs of the users in the project
        active: The active status of the users in the project
        display_name: The display names of the users in the project
        email: The email addresses of the users in the project
        raw_data: The raw response data from Jira API
    ### When action = 'read_issue'
        assignee_email: The email address of the assignees
        assignee_id: The account ID of the assignees
        assignee_name: The display name of the assignees
        browser_url: The URL to view the issues in browser
        comments: The comments of the issues
        created_date: The date and time when the issues was created
        description: The description of the issues
        issue_attachments: The attachments of the issues
        issue_id: The unique identifier of the issues
        issue_key: The key of the issues (e.g. PROJ-123)
        issue_type: The type of the issues
        raw_data: The raw response data from Jira API
        reporter_email: The email address of the reporters
        reporter_id: The account ID of the reporters
        reporter_name: The display name of the reporters
        status: The current status of the issues
        summary: The summary/title of the issues
        updated_date: The date and time when the issues was last updated
    ### When action = 'get_issues'
        assignee_emails: The email address of the assignee
        assignee_ids: The account ID of the assignee
        assignee_names: The display name of the assignee
        browser_urls: The URL to view the issue in browser
        comments: The comments of the issue
        created_dates: The date and time when the issue was created
        descriptions: The description of the issue
        issue_attachments: The attachments of the issue
        issue_ids: The unique identifier of the issue
        issue_keys: The key of the issue (e.g. PROJ-123)
        issue_types: The type of the issue
        raw_data: The raw response data from Jira API
        reporter_emails: The email address of the reporter
        reporter_ids: The account ID of the reporter
        reporter_names: The display name of the reporter
        statuses: The current status of the issue
        summaries: The summary/title of the issue
        updated_dates: The date and time when the issue was last updated
    ### When action = 'read_issue_comments'
        author_email: Array of comment author email addresses
        author_id: Array of comment author account IDs
        author_name: Array of comment author display names
        body: Array of comment bodies
        comment_id: Array of comment IDs
        created_date: Array of comment creation dates
        raw_data: The raw response data from Jira API
        total: Total number of comments
        updated_date: Array of comment update dates
    ### When action = 'add_issue_comment'
        comment_id: ID of the newly created comment
        created_date: Creation date of the comment
        message: Success message
        raw_data: The raw response data from Jira API
        updated_date: Last update date of the comment
    ### When action = 'create_issue'
        issue_id: The ID of the created issue
        issue_key: The key of the created issue
        raw_data: The raw response data from Jira API
        site: The name of the Jira site
        url: The URL of the created issue
    ### When action = 'update_issue'
        issue_key: The key of the updated issue
        message: Success message confirming the update
        raw_data: The raw response data from Jira API
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Jira>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "summary",
                    "label": "Summary",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue summary",
                    "helper_text": "A brief title or summary of the issue",
                    "order": 7,
                },
                {
                    "field": "description",
                    "label": "Description",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter detailed description",
                    "helper_text": "Detailed description of the issue",
                    "order": 8,
                },
                {
                    "field": "issue_type",
                    "label": "Issue Type",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select issue type",
                    "helper_text": "Type of issue (e.g. Task, Bug, Story)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_type&project={inputs.project}&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "assignee_name",
                    "label": "Assignee Name",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select assignee",
                    "helper_text": "Account Name of the user to assign the issue to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee_name&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "The ID of the created issue",
                },
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the created issue",
                },
                {
                    "field": "url",
                    "type": "string",
                    "helper_text": "The URL of the created issue",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_issue",
            "task_name": "tasks.jira.create_issue",
            "description": "Create a issue",
            "label": "Create Issue",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_type",
                "assignee_name",
                "summary",
                "description",
            ],
        },
        "update_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to update (e.g. PROJ-123)",
                    "order": 5,
                },
                {
                    "field": "update_summary",
                    "label": "Summary",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter new summary",
                    "helper_text": "The new summary for the issue",
                },
                {
                    "field": "update_description",
                    "label": "Description",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter new description",
                    "helper_text": "The new description for the issue",
                },
                {
                    "field": "update_issue_type",
                    "label": "Issue Type",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select issue type",
                    "helper_text": "Type of issue (e.g. Task, Bug, Story)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_type&project={inputs.project}&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "update_assignee_name",
                    "label": "Assignee Name",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select assignee",
                    "helper_text": "Account Name of the user to assign the issue to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee_name&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the updated issue",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message confirming the update",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_issue",
            "task_name": "tasks.jira.update_issue",
            "description": "Update an existing Jira issue",
            "label": "Update Issue",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "update_issue_type",
                "update_assignee_name",
                "issue_key",
                "update_summary",
                "update_description",
            ],
        },
        "get_users**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "account_id",
                    "type": "vec<string>",
                    "helper_text": "The account IDs of the users in the project",
                },
                {
                    "field": "email",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the users in the project",
                },
                {
                    "field": "display_name",
                    "type": "vec<string>",
                    "helper_text": "The display names of the users in the project",
                },
                {
                    "field": "active",
                    "type": "vec<bool>",
                    "helper_text": "The active status of the users in the project",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_users",
            "task_name": "tasks.jira.get_users",
            "description": "Get users from a Jira project",
            "label": "Get Users",
            "inputs_sort_order": ["integration", "action", "site", "project"],
        },
        "read_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to retrieve (e.g. PROJ-123)",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "The unique identifier of the issues",
                },
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the issues (e.g. PROJ-123)",
                },
                {
                    "field": "summary",
                    "type": "string",
                    "helper_text": "The summary/title of the issues",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "The description of the issues",
                },
                {
                    "field": "comments",
                    "type": "vec<string>",
                    "helper_text": "The comments of the issues",
                },
                {
                    "field": "issue_attachments",
                    "type": "vec<file>",
                    "helper_text": "The attachments of the issues",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "helper_text": "The date and time when the issues was created",
                },
                {
                    "field": "updated_date",
                    "type": "string",
                    "helper_text": "The date and time when the issues was last updated",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "The current status of the issues",
                },
                {
                    "field": "browser_url",
                    "type": "string",
                    "helper_text": "The URL to view the issues in browser",
                },
                {
                    "field": "issue_type",
                    "type": "string",
                    "helper_text": "The type of the issues",
                },
                {
                    "field": "assignee_id",
                    "type": "string",
                    "helper_text": "The account ID of the assignees",
                },
                {
                    "field": "assignee_name",
                    "type": "string",
                    "helper_text": "The display name of the assignees",
                },
                {
                    "field": "assignee_email",
                    "type": "string",
                    "helper_text": "The email address of the assignees",
                },
                {
                    "field": "reporter_id",
                    "type": "string",
                    "helper_text": "The account ID of the reporters",
                },
                {
                    "field": "reporter_name",
                    "type": "string",
                    "helper_text": "The display name of the reporters",
                },
                {
                    "field": "reporter_email",
                    "type": "string",
                    "helper_text": "The email address of the reporters",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_issue",
            "task_name": "tasks.jira.read_issue",
            "description": "Retrieve details of an existing Jira issue",
            "label": "Read Issue",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
            ],
        },
        "read_issue_comments**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to get comments for (e.g. PROJ-123)",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "type": "vec<string>",
                    "helper_text": "Array of comment IDs",
                },
                {
                    "field": "body",
                    "type": "vec<string>",
                    "helper_text": "Array of comment bodies",
                },
                {
                    "field": "created_date",
                    "type": "vec<string>",
                    "helper_text": "Array of comment creation dates",
                },
                {
                    "field": "updated_date",
                    "type": "vec<string>",
                    "helper_text": "Array of comment update dates",
                },
                {
                    "field": "author_id",
                    "type": "vec<string>",
                    "helper_text": "Array of comment author account IDs",
                },
                {
                    "field": "author_email",
                    "type": "vec<string>",
                    "helper_text": "Array of comment author email addresses",
                },
                {
                    "field": "author_name",
                    "type": "vec<string>",
                    "helper_text": "Array of comment author display names",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of comments",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_issue_comments",
            "task_name": "tasks.jira.read_issue_comments",
            "description": "Get all comments for a Jira issue",
            "label": "Read Issue Comments",
        },
        "add_issue_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to add comment to (e.g. PROJ-123)",
                    "order": 6,
                },
                {
                    "field": "comment",
                    "label": "Comment",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter your comment",
                    "helper_text": "The comment text to add",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "label": "Comment Id",
                    "type": "string",
                    "helper_text": "ID of the newly created comment",
                },
                {
                    "field": "created_date",
                    "label": "Created Dates",
                    "type": "string",
                    "helper_text": "Creation date of the comment",
                },
                {
                    "field": "updated_date",
                    "type": "string",
                    "helper_text": "Last update date of the comment",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "add_issue_comment",
            "task_name": "tasks.jira.add_issue_comment",
            "description": "Add a comment to a Jira issue",
            "label": "Add Issue Comment",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
                "comment",
            ],
        },
        "get_issues**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "order": 7,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "issue_type",
                    "label": "Issue Type",
                    "type": "string",
                    "hidden": True,
                    "value": "",
                    "placeholder": "Select issue type",
                    "helper_text": "Type of issue (e.g. Task, Bug, Story)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_type&project={inputs.project}&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "assignee_name",
                    "label": "Assignee Name",
                    "type": "string",
                    "hidden": True,
                    "value": "",
                    "placeholder": "Select assignee",
                    "helper_text": "Account Name of the user to assign the issue to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee_name&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "status",
                    "type": "string",
                    "value": "",
                    "label": "Status",
                    "placeholder": "Open",
                    "helper_text": "The status of the issue (e.g. Open, Closed, In Progress)",
                },
                {
                    "field": "reporter_name",
                    "label": "Reporter Name",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select reporter",
                    "helper_text": "Account Name of the user who reported the issue",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "Query",
                    "helper_text": "The query to filter issues",
                },
                {
                    "field": "issue_summary",
                    "type": "string",
                    "value": "",
                    "label": "Summary",
                    "placeholder": "Summary",
                    "helper_text": "Search by issue summary",
                },
                {
                    "field": "summary_exact",
                    "type": "string",
                    "value": "",
                    "label": "Summary Exact",
                    "placeholder": "Summary Exact",
                    "helper_text": "Match summary exactly",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Description",
                    "helper_text": "Search in issue description",
                },
                {
                    "field": "description_exact",
                    "type": "string",
                    "value": "",
                    "label": "Description Exact",
                    "placeholder": "Description Exact",
                    "helper_text": "Match description exactly",
                },
                {
                    "field": "comment",
                    "type": "string",
                    "value": "",
                    "label": "Comment",
                    "placeholder": "Comment",
                    "helper_text": "Search in issue comments",
                },
                {
                    "field": "comment_exact",
                    "type": "string",
                    "value": "",
                    "label": "Comment Exact",
                    "placeholder": "Comment Exact",
                    "helper_text": "Match comment exactly",
                },
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Text",
                    "placeholder": "Text",
                    "helper_text": "Search in all text fields",
                },
                {
                    "field": "text_exact",
                    "type": "string",
                    "value": "",
                    "label": "Text Exact",
                    "placeholder": "Text Exact",
                    "helper_text": "Match text exactly across fields",
                },
                {
                    "field": "labels",
                    "type": "string",
                    "value": "",
                    "label": "Labels",
                    "placeholder": "Labels",
                    "helper_text": "Filter by issue labels",
                },
                {
                    "field": "fix_version",
                    "type": "string",
                    "value": "",
                    "label": "Fix Version",
                    "placeholder": "Fix Version",
                    "helper_text": "Filter by fix version",
                },
                {
                    "field": "affected_version",
                    "type": "string",
                    "value": "",
                    "label": "Affected Version",
                    "placeholder": "Affected Version",
                    "helper_text": "Filter by affected version",
                },
                {
                    "field": "component",
                    "type": "string",
                    "value": "",
                    "label": "Component",
                    "placeholder": "Component",
                    "helper_text": "Filter by issue component",
                },
                {
                    "field": "resolution",
                    "type": "string",
                    "value": "",
                    "label": "Resolution",
                    "placeholder": "Resolution",
                    "helper_text": "Filter by resolution status",
                },
                {
                    "field": "created",
                    "type": "string",
                    "value": "",
                    "label": "Created",
                    "placeholder": "YYYY-MM-DD",
                    "helper_text": "Issue creation (YYYY-MM-DD)",
                },
                {
                    "field": "updated",
                    "type": "string",
                    "value": "",
                    "label": "Updated",
                    "placeholder": "YYYY-MM-DD",
                    "helper_text": "Last update (YYYY-MM-DD)",
                },
                {
                    "field": "resolved",
                    "type": "string",
                    "value": "",
                    "label": "Resolved",
                    "placeholder": "YYYY-MM-DD",
                    "helper_text": "Resolution (YYYY-MM-DD)",
                },
                {
                    "field": "due",
                    "type": "string",
                    "value": "",
                    "label": "Due",
                    "placeholder": "YYYY-MM-DD",
                    "helper_text": "Due (YYYY-MM-DD)",
                },
            ],
            "outputs": [
                {
                    "field": "issue_ids",
                    "type": "vec<string>",
                    "helper_text": "The unique identifier of the issue",
                },
                {
                    "field": "issue_keys",
                    "type": "vec<string>",
                    "helper_text": "The key of the issue (e.g. PROJ-123)",
                },
                {
                    "field": "summaries",
                    "type": "vec<string>",
                    "helper_text": "The summary/title of the issue",
                },
                {
                    "field": "descriptions",
                    "type": "vec<string>",
                    "helper_text": "The description of the issue",
                },
                {
                    "field": "comments",
                    "type": "vec<vec<string>>",
                    "helper_text": "The comments of the issue",
                },
                {
                    "field": "issue_attachments",
                    "type": "vec<file>",
                    "helper_text": "The attachments of the issue",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "The date and time when the issue was created",
                },
                {
                    "field": "updated_dates",
                    "type": "vec<string>",
                    "helper_text": "The date and time when the issue was last updated",
                },
                {
                    "field": "statuses",
                    "type": "vec<string>",
                    "helper_text": "The current status of the issue",
                },
                {
                    "field": "browser_urls",
                    "type": "vec<string>",
                    "helper_text": "The URL to view the issue in browser",
                },
                {
                    "field": "issue_types",
                    "type": "vec<string>",
                    "helper_text": "The type of the issue",
                },
                {
                    "field": "assignee_ids",
                    "type": "vec<string>",
                    "helper_text": "The account ID of the assignee",
                },
                {
                    "field": "assignee_names",
                    "type": "vec<string>",
                    "helper_text": "The display name of the assignee",
                },
                {
                    "field": "assignee_emails",
                    "type": "vec<string>",
                    "helper_text": "The email address of the assignee",
                },
                {
                    "field": "reporter_ids",
                    "type": "vec<string>",
                    "helper_text": "The account ID of the reporter",
                },
                {
                    "field": "reporter_names",
                    "type": "vec<string>",
                    "helper_text": "The display name of the reporter",
                },
                {
                    "field": "reporter_emails",
                    "type": "vec<string>",
                    "helper_text": "The email address of the reporter",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_issues",
            "task_name": "tasks.jira.get_issues",
            "description": "Get all issues for a Jira project",
            "label": "Get Issues",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_type",
                "status",
                "assignee_name",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "reporter_name",
                "query",
                "issue_summary",
                "summary_exact",
                "description",
                "description_exact",
                "comment",
                "comment_exact",
                "text",
                "text_exact",
                "labels",
                "fix_version",
                "affected_version",
                "component",
                "resolution",
                "created",
                "updated",
                "resolved",
                "due",
            ],
        },
        "get_issues**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Issues",
                    "helper_text": "Specify the number of issues to fetch",
                    "order": 6,
                }
            ],
            "outputs": [],
        },
        "get_issues**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "order": 8,
                }
            ],
            "outputs": [],
        },
        "get_issues**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "label": "Date Range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "order": 9,
                }
            ],
            "outputs": [],
        },
        "get_issues**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "label": "Exact date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "order": 9,
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        affected_version: str = "",
        assignee_name: str = "",
        comment: str = "",
        comment_exact: str = "",
        component: str = "",
        created: str = "",
        description: str = "",
        description_exact: str = "",
        due: str = "",
        exact_date: Any = {"start": "", "end": ""},
        fix_version: str = "",
        issue_key: str = "",
        issue_summary: str = "",
        issue_type: str = "",
        labels: str = "",
        num_messages: int = 10,
        project: str = "",
        query: str = "",
        reporter_name: str = "",
        resolution: str = "",
        resolved: str = "",
        site: str = "",
        status: str = "",
        summary: str = "",
        summary_exact: str = "",
        text: str = "",
        text_exact: str = "",
        update_assignee_name: str = "",
        update_description: str = "",
        update_issue_type: str = "",
        update_summary: str = "",
        updated: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_jira",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if site is not None:
            self.inputs["site"] = site
        if project is not None:
            self.inputs["project"] = project
        if summary is not None:
            self.inputs["summary"] = summary
        if description is not None:
            self.inputs["description"] = description
        if issue_type is not None:
            self.inputs["issue_type"] = issue_type
        if assignee_name is not None:
            self.inputs["assignee_name"] = assignee_name
        if issue_key is not None:
            self.inputs["issue_key"] = issue_key
        if update_summary is not None:
            self.inputs["update_summary"] = update_summary
        if update_description is not None:
            self.inputs["update_description"] = update_description
        if update_issue_type is not None:
            self.inputs["update_issue_type"] = update_issue_type
        if update_assignee_name is not None:
            self.inputs["update_assignee_name"] = update_assignee_name
        if comment is not None:
            self.inputs["comment"] = comment
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if status is not None:
            self.inputs["status"] = status
        if reporter_name is not None:
            self.inputs["reporter_name"] = reporter_name
        if query is not None:
            self.inputs["query"] = query
        if issue_summary is not None:
            self.inputs["issue_summary"] = issue_summary
        if summary_exact is not None:
            self.inputs["summary_exact"] = summary_exact
        if description_exact is not None:
            self.inputs["description_exact"] = description_exact
        if comment_exact is not None:
            self.inputs["comment_exact"] = comment_exact
        if text is not None:
            self.inputs["text"] = text
        if text_exact is not None:
            self.inputs["text_exact"] = text_exact
        if labels is not None:
            self.inputs["labels"] = labels
        if fix_version is not None:
            self.inputs["fix_version"] = fix_version
        if affected_version is not None:
            self.inputs["affected_version"] = affected_version
        if component is not None:
            self.inputs["component"] = component
        if resolution is not None:
            self.inputs["resolution"] = resolution
        if created is not None:
            self.inputs["created"] = created
        if updated is not None:
            self.inputs["updated"] = updated
        if resolved is not None:
            self.inputs["resolved"] = resolved
        if due is not None:
            self.inputs["due"] = due
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def account_id(self) -> List[str]:
        """
        The account IDs of the users in the project

        Available: When action = 'get_users'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("account_id")

    @property
    def active(self) -> List[bool]:
        """
        The active status of the users in the project

        Available: When action = 'get_users'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("active")

    @property
    def assignee_email(self) -> str:
        """
        The email address of the assignees

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignee_email")

    @property
    def assignee_emails(self) -> List[str]:
        """
        The email address of the assignee

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignee_emails")

    @property
    def assignee_id(self) -> str:
        """
        The account ID of the assignees

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignee_id")

    @property
    def assignee_ids(self) -> List[str]:
        """
        The account ID of the assignee

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignee_ids")

    @property
    def assignee_name(self) -> str:
        """
        The display name of the assignees

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignee_name")

    @property
    def assignee_names(self) -> List[str]:
        """
        The display name of the assignee

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignee_names")

    @property
    def author_email(self) -> List[str]:
        """
        Array of comment author email addresses

        Available: When action = 'read_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("author_email")

    @property
    def author_id(self) -> List[str]:
        """
        Array of comment author account IDs

        Available: When action = 'read_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("author_id")

    @property
    def author_name(self) -> List[str]:
        """
        Array of comment author display names

        Available: When action = 'read_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("author_name")

    @property
    def body(self) -> List[str]:
        """
        Array of comment bodies

        Available: When action = 'read_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("body")

    @property
    def browser_url(self) -> str:
        """
        The URL to view the issues in browser

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("browser_url")

    @property
    def browser_urls(self) -> List[str]:
        """
        The URL to view the issue in browser

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("browser_urls")

    @property
    def comment_id(self) -> List[str]:
        """
        Array of comment IDs

        Different behavior based on configuration:
          - Array of comment IDs (When action = 'read_issue_comments')
          - ID of the newly created comment (When action = 'add_issue_comment')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_id")

    @property
    def comments(self) -> List[str]:
        """
        The comments of the issues

        Different behavior based on configuration:
          - The comments of the issues (When action = 'read_issue')
          - The comments of the issue (When action = 'get_issues')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comments")

    @property
    def created_date(self) -> str:
        """
        The date and time when the issues was created

        Different behavior based on configuration:
          - The date and time when the issues was created (When action = 'read_issue')
          - Array of comment creation dates (When action = 'read_issue_comments')
          - Creation date of the comment (When action = 'add_issue_comment')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_date")

    @property
    def created_dates(self) -> List[str]:
        """
        The date and time when the issue was created

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_dates")

    @property
    def description(self) -> str:
        """
        The description of the issues

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("description")

    @property
    def descriptions(self) -> List[str]:
        """
        The description of the issue

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("descriptions")

    @property
    def display_name(self) -> List[str]:
        """
        The display names of the users in the project

        Available: When action = 'get_users'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("display_name")

    @property
    def email(self) -> List[str]:
        """
        The email addresses of the users in the project

        Available: When action = 'get_users'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email")

    @property
    def issue_attachments(self) -> List[str]:
        """
        The attachments of the issues

        Different behavior based on configuration:
          - The attachments of the issues (When action = 'read_issue')
          - The attachments of the issue (When action = 'get_issues')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_attachments")

    @property
    def issue_id(self) -> str:
        """
        The ID of the created issue

        Different behavior based on configuration:
          - The ID of the created issue (When action = 'create_issue')
          - The unique identifier of the issues (When action = 'read_issue')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_id")

    @property
    def issue_ids(self) -> List[str]:
        """
        The unique identifier of the issue

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_ids")

    @property
    def issue_key(self) -> str:
        """
        The key of the created issue

        Different behavior based on configuration:
          - The key of the created issue (When action = 'create_issue')
          - The key of the updated issue (When action = 'update_issue')
          - The key of the issues (e.g. PROJ-123) (When action = 'read_issue')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_key")

    @property
    def issue_keys(self) -> List[str]:
        """
        The key of the issue (e.g. PROJ-123)

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_keys")

    @property
    def issue_type(self) -> str:
        """
        The type of the issues

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_type")

    @property
    def issue_types(self) -> List[str]:
        """
        The type of the issue

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_types")

    @property
    def message(self) -> str:
        """
        Success message confirming the update

        Different behavior based on configuration:
          - Success message confirming the update (When action = 'update_issue')
          - Success message (When action = 'add_issue_comment')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("message")

    @property
    def raw_data(self) -> str:
        """
        The raw response data from Jira API

        Available: When action = 'create_issue', When action = 'update_issue', When action = 'get_users', When action = 'read_issue', When action = 'read_issue_comments', When action = 'add_issue_comment', When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("raw_data")

    @property
    def reporter_email(self) -> str:
        """
        The email address of the reporters

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("reporter_email")

    @property
    def reporter_emails(self) -> List[str]:
        """
        The email address of the reporter

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("reporter_emails")

    @property
    def reporter_id(self) -> str:
        """
        The account ID of the reporters

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("reporter_id")

    @property
    def reporter_ids(self) -> List[str]:
        """
        The account ID of the reporter

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("reporter_ids")

    @property
    def reporter_name(self) -> str:
        """
        The display name of the reporters

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("reporter_name")

    @property
    def reporter_names(self) -> List[str]:
        """
        The display name of the reporter

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("reporter_names")

    @property
    def site(self) -> str:
        """
        The name of the Jira site

        Available: When action = 'create_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("site")

    @property
    def status(self) -> str:
        """
        The current status of the issues

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("status")

    @property
    def statuses(self) -> List[str]:
        """
        The current status of the issue

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("statuses")

    @property
    def summaries(self) -> List[str]:
        """
        The summary/title of the issue

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("summaries")

    @property
    def summary(self) -> str:
        """
        The summary/title of the issues

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("summary")

    @property
    def total(self) -> int:
        """
        Total number of comments

        Available: When action = 'read_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("total")

    @property
    def updated_date(self) -> str:
        """
        The date and time when the issues was last updated

        Different behavior based on configuration:
          - The date and time when the issues was last updated (When action = 'read_issue')
          - Array of comment update dates (When action = 'read_issue_comments')
          - Last update date of the comment (When action = 'add_issue_comment')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated_date")

    @property
    def updated_dates(self) -> List[str]:
        """
        The date and time when the issue was last updated

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated_dates")

    @property
    def url(self) -> str:
        """
        The URL of the created issue

        Available: When action = 'create_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("url")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationJiraNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_sugar_crm")
class IntegrationSugarCrmNode(Node):
    """
    SugarCRM

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### get_records
        filter: To filter records within module
        module: Your existing module on SugarCRM

    ## Outputs
    ### get_records
        output: The retrieved output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<SugarCRM>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "get_records": {
            "inputs": [
                {
                    "field": "module",
                    "type": "string",
                    "value": "",
                    "label": "Module",
                    "placeholder": "customer_support",
                    "helper_text": "Your existing module on SugarCRM",
                },
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "label": "Filter",
                    "placeholder": "Name = 'John'",
                    "helper_text": "To filter records within module",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "any",
                    "helper_text": "The retrieved output",
                }
            ],
            "name": "get_records",
            "task_name": "tasks.sugar_crm.get_records",
            "description": "Fetch records",
            "label": "Get Records",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        filter: str = "",
        module: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_sugar_crm",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if module is not None:
            self.inputs["module"] = module
        if filter is not None:
            self.inputs["filter"] = filter
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> Any:
        """
        The retrieved output

        Available: get_records


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationSugarCrmNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_github")
class IntegrationGithubNode(Node):
    """
    Github

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'get_repositories'
        affiliation: Affiliation filter
        direction: Sort direction
        owner: Owner of the repository
        sort: Sort repositories by
        type: Repository type filter
        use_date: Toggle to use dates
        visibility: Visibility filter
    ### When action = 'get_issues'
        assignee: Assignee filter
        creator: Creator filter
        direction: Sort direction
        labels: Comma-separated list of labels
        mentioned: Mentioned user filter
        milestone: Milestone number
        owner: Owner of the repository
        repository_name: Name of the repository to create
        sort: Sort repositories by
        state: Issue state filter
        use_date: Toggle to use dates
    ### When action = 'create_issue'
        assignees: Comma-separated list of assignee usernames
        issue_body: Body content of the issue
        issue_title: Title of the issue
        labels: Comma-separated list of labels
        milestone: Milestone number
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'create_file'
        author_email: Email of the author
        author_name: Name of the author
        branch_name: Branch to create the file on
        commit_message: Message for the merge commit
        committer_email: Email of the committer
        committer_name: Name of the committer
        file_content: Content of the file
        file_path: Path where the file will be created
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'create_repository'
        auto_init: Initialize repository with a README
        gitignore_template: GitIgnore template to use
        homepage: Homepage URL for the repository
        is_private: Whether the repository should be private
        license_template: License template to use
        repository_description: Description of the repository
        repository_name: Name of the repository to create
    ### When action = 'create_pull_request'
        base: Base branch (target)
        draft: Create as draft pull request
        head: Head branch (source)
        maintainer_can_modify: Allow maintainer modifications
        owner: Owner of the repository
        pull_request_body: Body content of the pull request
        pull_request_title: Title of the pull request
        repository_name: Name of the repository to create
    ### When action = 'get_pull_requests'
        base: Base branch (target)
        direction: Sort direction
        head: Head branch (source)
        owner: Owner of the repository
        repository_name: Name of the repository to create
        sort: Sort repositories by
        state: Issue state filter
        use_date: Toggle to use dates
    ### When action = 'create_branch'
        branch_name: Branch to create the file on
        owner: Owner of the repository
        repository_name: Name of the repository to create
        source_branch: Source branch to create from
    ### When action = 'read_branch'
        branch_name: Branch to create the file on
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'delete_branch'
        branch_name: Branch to create the file on
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'create_issue_comment'
        comment_body: Body content of the comment
        issue_number: Number of the issue to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'update_issue_comment'
        comment_id: ID of the comment to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
        update_comment_body: New body for the comment
    ### When action = 'read_issue_comment'
        comment_id: ID of the comment to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'delete_issue_comment'
        comment_id: ID of the comment to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'merge_pull_request'
        commit_message: Message for the merge commit
        commit_title: Title for the merge commit
        merge_method: Merge method to use
        owner: Owner of the repository
        pull_request_number: Number of the pull request to update
        repository_name: Name of the repository to create
        sha: SHA that pull request head must match
    ### When action = 'create_webhook'
        content_type: Content type for webhook payloads
        insecure_ssl: Allow insecure SSL
        owner: Owner of the repository
        repository_name: Name of the repository to create
        webhook_active: Whether the webhook is active
        webhook_events: Events to trigger webhook (comma-separated)
        webhook_name: Name of the webhook
        webhook_secret: Secret key for webhook security
        webhook_url: URL to send webhook payloads to
    ### When action = 'get_repositories' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_issues' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_pull_requests' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_issue_comments' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_releases' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_branches' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_organization_members' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_webhooks' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'delete_file'
        delete_author_email: Email of the author
        delete_author_name: Name of the author
        delete_branch_name: Branch to delete the file from
        delete_commit_message: Commit message for the file deletion
        delete_committer_email: Email of the committer
        delete_committer_name: Name of the committer
        delete_file_sha: Current SHA of the file to delete
        file_path: Path where the file will be created
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'get_issue_comments'
        direction: Sort direction
        issue_number: Number of the issue to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
        sort: Sort repositories by
        use_date: Toggle to use dates
    ### When action = 'create_release'
        draft: Create as draft pull request
        generate_release_notes: Auto-generate release notes
        owner: Owner of the repository
        prerelease: Mark as prerelease
        release_body: Description of the release
        release_name: Name of the release
        repository_name: Name of the repository to create
        tag_name: Name of the tag for the release
        target_commitish: Commitish value for the release
    ### When action = 'get_repositories' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_issues' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_pull_requests' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_issue_comments' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_releases' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_branches' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_organization_members' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_webhooks' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'update_file'
        file_path: Path where the file will be created
        file_sha: Current SHA of the file
        owner: Owner of the repository
        repository_name: Name of the repository to create
        update_author_email: Email of the author
        update_author_name: Name of the author
        update_branch_name: Branch to update the file on
        update_commit_message: Commit message for the file update
        update_committer_email: Email of the committer
        update_committer_name: Name of the committer
        update_file_content: New content of the file
    ### When action = 'read_file'
        file_path: Path where the file will be created
        owner: Owner of the repository
        ref: Branch, tag, or commit to read from
        repository_name: Name of the repository to create
    ### When action = 'get_organization_members'
        filter: Filter members by role
        organization: Name of the organization
        role: Filter by member role
        use_date: Toggle to use dates
    ### When action = 'update_issue'
        issue_number: Number of the issue to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
        update_assignees: New assignees for the issue
        update_issue_body: New body for the issue
        update_issue_state: New state for the issue
        update_issue_title: New title for the issue
        update_labels: New labels for the issue
        update_milestone: New milestone for the issue
    ### When action = 'read_issue'
        issue_number: Number of the issue to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'get_repositories' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_issues' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_pull_requests' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_issue_comments' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_releases' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_branches' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_organization_members' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_webhooks' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'update_repository'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        update_has_issues: Enable/disable issues
        update_has_projects: Enable/disable projects
        update_has_wiki: Enable/disable wiki
        update_homepage: New homepage URL
        update_is_private: Update privacy setting
        update_repository_description: New description for the repository
        update_repository_name: New name for the repository
    ### When action = 'read_repository'
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'delete_repository'
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'update_pull_request'
        owner: Owner of the repository
        pull_request_number: Number of the pull request to update
        repository_name: Name of the repository to create
        update_base: New base branch
        update_maintainer_can_modify: Update maintainer modification permission
        update_pull_request_body: New body for the pull request
        update_pull_request_state: New state for the pull request
        update_pull_request_title: New title for the pull request
    ### When action = 'read_pull_request'
        owner: Owner of the repository
        pull_request_number: Number of the pull request to update
        repository_name: Name of the repository to create
    ### When action = 'update_release'
        owner: Owner of the repository
        release_id: ID of the release to update
        repository_name: Name of the repository to create
        update_draft: Update draft status
        update_prerelease: Update prerelease status
        update_release_body: New description for the release
        update_release_name: New name for the release
        update_tag_name: New tag name for the release
        update_target_commitish: New commitish value for the release
    ### When action = 'read_release'
        owner: Owner of the repository
        release_id: ID of the release to update
        repository_name: Name of the repository to create
    ### When action = 'get_releases'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        use_date: Toggle to use dates
    ### When action = 'delete_release'
        owner: Owner of the repository
        release_id: ID of the release to update
        repository_name: Name of the repository to create
    ### When action = 'get_branches'
        owner: Owner of the repository
        protected: Filter by protected status
        repository_name: Name of the repository to create
        use_date: Toggle to use dates
    ### When action = 'update_webhook'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        update_content_type: New content type
        update_insecure_ssl: Update insecure SSL setting
        update_webhook_active: Update webhook active status
        update_webhook_events: New events to trigger webhook
        update_webhook_secret: New secret key for webhook
        update_webhook_url: New URL for webhook payloads
        webhook_id: ID of the webhook to update
    ### When action = 'read_webhook'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        webhook_id: ID of the webhook to update
    ### When action = 'get_webhooks'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        use_date: Toggle to use dates
    ### When action = 'delete_webhook'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        webhook_id: ID of the webhook to update
    ### When action = 'ping_webhook'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        webhook_id: ID of the webhook to update
    ### When action = 'get_repositories' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_issues' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_pull_requests' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_issue_comments' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_releases' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_branches' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_organization_members' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_webhooks' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'read_user'
        username: Username to read information for

    ## Outputs
    ### When action = 'read_pull_request'
        additions_count: Number of additions
        assignees: List of assignees
        base_details: Base branch details
        changed_files_count: Number of changed files
        closed_at: Closure timestamp
        commits_count: Number of commits
        created_at: Creation timestamp
        deletions_count: Number of deletions
        draft: Whether the pull request is a draft
        head_details: Head branch details
        labels: List of labels
        mergeable: Whether the pull request is mergeable
        merged: Whether the pull request is merged
        merged_at: Merge timestamp
        milestone: Milestone details
        pull_request_body: Body of the pull request
        pull_request_details: Pull request details in JSON format
        pull_request_id: ID of the pull request
        pull_request_number: Number of the pull request
        pull_request_state: State of the pull request
        pull_request_title: Title of the pull request
        pull_request_url: URL of the pull request
        requested_reviewers: List of requested reviewers
        updated_at: Last update timestamp
    ### When action = 'read_release'
        assets_details: Release assets details
        author_details: Release author details
        created_at: Creation timestamp
        draft: Whether the release is a draft
        prerelease: Whether the release is a prerelease
        published_at: Publication timestamp
        release_body: Body of the release
        release_details: Release details in JSON format
        release_id: ID of the release
        release_name: Name of the release
        release_url: URL of the release
        tag_name: Tag name of the release
        tarball_url: Tarball download URL
        zipball_url: Zipball download URL
    ### When action = 'get_releases'
        assets_details: List of assets details
        author_details: List of author details
        created_dates: List of creation dates
        draft_flags: List of draft flags
        prerelease_flags: List of prerelease flags
        published_dates: List of publication dates
        raw_data: Raw API response data
        release_bodies: List of release bodies
        release_details: Release details in JSON format
        release_ids: List of release IDs
        release_names: List of release names
        release_urls: List of release URLs
        tag_names: List of tag names
        tarball_urls: List of tarball URLs
        zipball_urls: List of zipball URLs
    ### When action = 'create_issue'
        assignees: List of assignees
        created_at: Creation timestamp
        issue_details: Issue details in JSON format
        issue_id: ID of the created issue
        issue_number: Number of the created issue
        issue_state: State of the created issue
        issue_title: Title of the created issue
        issue_url: URL of the created issue
        labels: List of labels
        milestone: Milestone details
    ### When action = 'update_issue'
        assignees: List of assignees
        issue_details: Issue details in JSON format
        issue_id: ID of the updated issue
        issue_number: Number of the updated issue
        issue_state: State of the updated issue
        issue_title: Title of the updated issue
        issue_url: URL of the updated issue
        labels: List of labels
        milestone: Milestone details
        updated_at: Update timestamp
    ### When action = 'read_issue'
        assignees: List of assignees
        author: Issue author details
        closed_at: Closure timestamp
        comments_count: Number of comments
        created_at: Creation timestamp
        issue_body: Body of the issue
        issue_details: Issue details in JSON format
        issue_id: ID of the issue
        issue_number: Number of the issue
        issue_state: State of the issue
        issue_title: Title of the issue
        issue_url: URL of the issue
        labels: List of labels
        milestone: Milestone details
        updated_at: Last update timestamp
    ### When action = 'get_issues'
        assignees_details: List of assignee details
        author_details: List of author details
        closed_dates: List of closure dates
        comments_counts: List of comment counts
        created_dates: List of creation dates
        issue_bodies: List of issue bodies
        issue_details: Issue details in JSON format
        issue_ids: List of issue IDs
        issue_numbers: List of issue numbers
        issue_states: List of issue states
        issue_titles: List of issue titles
        issue_urls: List of issue URLs
        labels_details: List of label details
        milestone_details: List of milestone details
        raw_data: Raw API response data
        updated_dates: List of update dates
    ### When action = 'get_pull_requests'
        assignees_details: List of assignee details
        base_details: List of base branch details
        closed_dates: List of closure dates
        created_dates: List of creation dates
        draft_flags: List of draft flags
        head_details: List of head branch details
        labels_details: List of label details
        mergeable_flags: List of mergeable flags
        merged_dates: List of merge dates
        merged_flags: List of merged flags
        milestone_details: List of milestone details
        pull_request_bodies: List of pull request bodies
        pull_request_details: Pull request details in JSON format
        pull_request_ids: List of pull request IDs
        pull_request_numbers: List of pull request numbers
        pull_request_states: List of pull request states
        pull_request_titles: List of pull request titles
        pull_request_urls: List of pull request URLs
        raw_data: Raw API response data
        requested_reviewers_details: List of requested reviewer details
        updated_dates: List of update dates
    ### When action = 'create_issue_comment'
        author_details: Comment author details
        comment_body: Body of the created comment
        comment_details: Comment details in JSON format
        comment_id: ID of the created comment
        comment_url: URL of the created comment
        created_at: Creation timestamp
    ### When action = 'update_issue_comment'
        author_details: Comment author details
        comment_body: Body of the updated comment
        comment_details: Comment details in JSON format
        comment_id: ID of the updated comment
        comment_url: URL of the updated comment
        updated_at: Update timestamp
    ### When action = 'read_issue_comment'
        author_details: Comment author details
        comment_body: Body of the comment
        comment_details: Comment details in JSON format
        comment_id: ID of the comment
        comment_url: URL of the comment
        created_at: Creation timestamp
        updated_at: Last update timestamp
    ### When action = 'get_issue_comments'
        author_details: List of comment author details
        comment_bodies: List of comment bodies
        comment_details: Comment details in JSON format
        comment_ids: List of comment IDs
        comment_urls: List of comment URLs
        created_dates: List of creation dates
        raw_data: Raw API response data
        updated_dates: List of update dates
    ### When action = 'read_user'
        avatar_url: Avatar URL of the user
        bio: Bio of the user
        blog: Blog URL of the user
        company: Company of the user
        html_url: Profile URL of the user
        location: Location of the user
        user_details: User details in JSON format
        user_email: Email of the user
        user_id: ID of the user
        user_name: Display name of the user
        username: Username of the user
    ### When action = 'get_organization_members'
        avatar_urls: List of avatar URLs
        html_urls: List of profile URLs
        member_roles: List of member roles
        raw_data: Raw API response data
        user_details: User details in JSON format
        user_emails: List of user emails
        user_ids: List of user IDs
        user_names: List of display names
        user_types: List of user types
        usernames: List of usernames
    ### When action = 'create_branch'
        branch_details: Branch details in JSON format
        branch_name: Name of the created branch
        ref: Reference of the branch
        sha: SHA of the branch
        url: URL of the branch
    ### When action = 'read_branch'
        branch_details: Branch details in JSON format
        branch_name: Name of the branch
        commit_author: Author of the latest commit
        commit_committer: Committer of the latest commit
        commit_date: Date of the latest commit
        commit_message: Message of the latest commit
        commit_url: URL of the latest commit
        protected: Whether the branch is protected
        sha: SHA of the latest commit
    ### When action = 'get_branches'
        branch_details: Branch details in JSON format
        branch_names: List of branch names
        commit_authors: List of commit authors
        commit_committers: List of commit committers
        commit_dates: List of commit dates
        commit_messages: List of commit messages
        commit_shas: List of commit SHAs
        commit_urls: List of commit URLs
        protected_flags: List of protection flags
        raw_data: Raw API response data
    ### When action = 'delete_branch'
        branch_name: Name of the deleted branch
        message: Success message
        success: Whether the branch was successfully deleted
    ### When action = 'create_repository'
        clone_url: Clone URL for the repository
        created_at: Creation timestamp
        is_private: Whether the repository is private
        repository_details: Repository details in JSON format
        repository_full_name: Full name of the repository (owner/repo)
        repository_id: ID of the created repository
        repository_name: Name of the created repository
        repository_url: URL of the repository
        ssh_url: SSH URL for the repository
    ### When action = 'read_repository'
        clone_url: Clone URL for the repository
        created_at: Creation timestamp
        default_branch: Default branch name
        forks_count: Number of forks
        is_fork: Whether the repository is a fork
        is_private: Whether the repository is private
        language: Primary programming language
        open_issues_count: Number of open issues
        owner_details: Repository owner details
        pushed_at: Last push timestamp
        repository_description: Description of the repository
        repository_details: Repository details in JSON format
        repository_full_name: Full name of the repository
        repository_id: ID of the repository
        repository_name: Name of the repository
        repository_url: URL of the repository
        ssh_url: SSH URL for the repository
        stargazers_count: Number of stars
        updated_at: Last update timestamp
        watchers_count: Number of watchers
    ### When action = 'get_repositories'
        clone_urls: List of clone URLs
        created_dates: List of creation dates
        default_branches: List of default branch names
        forks_counts: List of fork counts
        is_private_flags: List of privacy flags
        languages: List of primary languages
        open_issues_counts: List of open issue counts
        owner_details: List of owner details
        pushed_dates: List of last push dates
        raw_data: Raw API response data
        repository_descriptions: List of repository descriptions
        repository_details: Repository details in JSON format
        repository_full_names: List of full repository names
        repository_ids: List of repository IDs
        repository_names: List of repository names
        repository_urls: List of repository URLs
        ssh_urls: List of SSH URLs
        stargazers_counts: List of star counts
        updated_dates: List of update dates
        watchers_counts: List of watcher counts
    ### When action = 'delete_issue_comment'
        comment_id: ID of the deleted comment
        message: Success message
        success: Whether the comment was successfully deleted
    ### When action = 'create_file'
        commit_sha: SHA of the commit
        download_url: Download URL of the file
        file_details: File details in JSON format
        file_path: Path of the created file
        file_url: URL of the created file
        sha: SHA of the created file
    ### When action = 'update_file'
        commit_sha: SHA of the commit
        download_url: Download URL of the file
        file_details: File details in JSON format
        file_path: Path of the updated file
        file_url: URL of the updated file
        sha: New SHA of the updated file
    ### When action = 'delete_file'
        commit_sha: SHA of the commit
        file_path: Path of the deleted file
        message: Success message
        success: Whether the file was successfully deleted
    ### When action = 'create_pull_request'
        created_at: Creation timestamp
        draft: Whether the pull request is a draft
        pull_request_details: Pull request details in JSON format
        pull_request_id: ID of the created pull request
        pull_request_number: Number of the created pull request
        pull_request_state: State of the created pull request
        pull_request_title: Title of the created pull request
        pull_request_url: URL of the created pull request
    ### When action = 'create_release'
        created_at: Creation timestamp
        draft: Whether the release is a draft
        prerelease: Whether the release is a prerelease
        published_at: Publication timestamp
        release_details: Release details in JSON format
        release_id: ID of the created release
        release_name: Name of the created release
        release_url: URL of the created release
        tag_name: Tag name of the created release
        tarball_url: Tarball download URL
        zipball_url: Zipball download URL
    ### When action = 'create_webhook'
        created_at: Creation timestamp
        webhook_active: Whether the webhook is active
        webhook_details: Webhook details in JSON format
        webhook_events: List of webhook events
        webhook_id: ID of the created webhook
        webhook_name: Name of the created webhook
        webhook_url: URL of the created webhook
    ### When action = 'read_webhook'
        created_at: Creation timestamp
        ping_url: Ping URL for the webhook
        test_url: Test URL for the webhook
        updated_at: Last update timestamp
        webhook_active: Whether the webhook is active
        webhook_config: Webhook configuration details
        webhook_details: Webhook details in JSON format
        webhook_events: List of webhook events
        webhook_id: ID of the webhook
        webhook_name: Name of the webhook
        webhook_url: URL of the webhook
    ### When action = 'get_webhooks'
        created_dates: List of creation dates
        ping_urls: List of ping URLs
        raw_data: Raw API response data
        test_urls: List of test URLs
        updated_dates: List of update dates
        webhook_active_flags: List of webhook active flags
        webhook_configs: List of webhook configurations
        webhook_details: Webhook details in JSON format
        webhook_events: List of webhook events
        webhook_ids: List of webhook IDs
        webhook_names: List of webhook names
        webhook_urls: List of webhook URLs
    ### When action = 'ping_webhook'
        delivery_id: ID of the delivery
        message: Response message
        success: Whether the webhook ping was successful
        webhook_details: Webhook response details
    ### When action = 'read_file'
        download_url: Download URL of the file
        encoding: Encoding of the file
        file_content: Content of the file
        file_details: File details in JSON format
        file_name: Name of the file
        file_path: Path of the file
        file_sha: SHA of the file
        file_size: Size of the file in bytes
        file_type: Type of the file
        file_url: URL of the file
        git_url: Git URL of the file
        html_url: HTML URL of the file
    ### When action = 'merge_pull_request'
        merged: Whether the pull request was merged
        message: Merge result message
        pull_request_details: Updated pull request details
        sha: SHA of the merge commit
    ### When action = 'delete_repository'
        message: Success message
        repository_name: Name of the deleted repository
        success: Whether the repository was successfully deleted
    ### When action = 'delete_release'
        message: Success message
        release_id: ID of the deleted release
        success: Whether the release was successfully deleted
    ### When action = 'delete_webhook'
        message: Success message
        success: Whether the webhook was successfully deleted
        webhook_id: ID of the deleted webhook
    ### When action = 'update_pull_request'
        pull_request_details: Pull request details in JSON format
        pull_request_id: ID of the updated pull request
        pull_request_number: Number of the updated pull request
        pull_request_state: State of the updated pull request
        pull_request_title: Title of the updated pull request
        pull_request_url: URL of the updated pull request
        updated_at: Update timestamp
    ### When action = 'update_release'
        release_details: Release details in JSON format
        release_id: ID of the updated release
        release_name: Name of the updated release
        release_url: URL of the updated release
        tag_name: Tag name of the updated release
        updated_at: Update timestamp
    ### When action = 'update_repository'
        repository_details: Repository details in JSON format
        repository_full_name: Full name of the repository
        repository_id: ID of the repository
        repository_name: Updated name of the repository
        repository_url: URL of the repository
        updated_at: Update timestamp
    ### When action = 'update_webhook'
        updated_at: Update timestamp
        webhook_active: Whether the webhook is active
        webhook_details: Webhook details in JSON format
        webhook_events: List of webhook events
        webhook_id: ID of the updated webhook
        webhook_name: Name of the updated webhook
        webhook_url: URL of the updated webhook
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Github>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_repository**(*)**(*)": {
            "inputs": [
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository to create",
                    "label": "Repository Name",
                    "placeholder": "my-awesome-repo",
                },
                {
                    "field": "repository_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the repository",
                    "label": "Description",
                    "placeholder": "This is an awesome repository",
                },
                {
                    "field": "is_private",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the repository should be private",
                    "label": "Private Repository",
                },
                {
                    "field": "auto_init",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Initialize repository with a README",
                    "label": "Auto Initialize",
                },
                {
                    "field": "gitignore_template",
                    "type": "string",
                    "value": "",
                    "helper_text": "GitIgnore template to use",
                    "label": "GitIgnore Template",
                    "placeholder": "Node",
                },
                {
                    "field": "license_template",
                    "type": "string",
                    "value": "",
                    "helper_text": "License template to use",
                    "label": "License Template",
                    "placeholder": "mit",
                },
                {
                    "field": "homepage",
                    "type": "string",
                    "value": "",
                    "helper_text": "Homepage URL for the repository",
                    "label": "Homepage",
                    "placeholder": "https://example.com",
                },
            ],
            "outputs": [
                {
                    "field": "repository_id",
                    "type": "string",
                    "helper_text": "ID of the created repository",
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "helper_text": "Name of the created repository",
                },
                {
                    "field": "repository_full_name",
                    "type": "string",
                    "helper_text": "Full name of the repository (owner/repo)",
                },
                {
                    "field": "repository_url",
                    "type": "string",
                    "helper_text": "URL of the repository",
                },
                {
                    "field": "clone_url",
                    "type": "string",
                    "helper_text": "Clone URL for the repository",
                },
                {
                    "field": "ssh_url",
                    "type": "string",
                    "helper_text": "SSH URL for the repository",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "is_private",
                    "type": "bool",
                    "helper_text": "Whether the repository is private",
                },
                {
                    "field": "repository_details",
                    "type": "vec<string>",
                    "helper_text": "Repository details in JSON format",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "create_repository",
            "task_name": "tasks.github.create_repository",
            "description": "Create a new repository on GitHub",
            "label": "Create Repository",
        },
        "update_repository**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository to update",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "update_repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the repository",
                    "label": "New Repository Name",
                    "placeholder": "new-repo-name",
                },
                {
                    "field": "update_repository_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the repository",
                    "label": "New Description",
                    "placeholder": "Updated description",
                },
                {
                    "field": "update_homepage",
                    "type": "string",
                    "value": "",
                    "helper_text": "New homepage URL",
                    "label": "New Homepage",
                    "placeholder": "https://newsite.com",
                },
                {
                    "field": "update_is_private",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Update privacy setting",
                    "label": "Private Repository",
                },
                {
                    "field": "update_has_issues",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Enable/disable issues",
                    "label": "Has Issues",
                },
                {
                    "field": "update_has_projects",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Enable/disable projects",
                    "label": "Has Projects",
                },
                {
                    "field": "update_has_wiki",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Enable/disable wiki",
                    "label": "Has Wiki",
                },
            ],
            "outputs": [
                {
                    "field": "repository_id",
                    "type": "string",
                    "helper_text": "ID of the repository",
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "helper_text": "Updated name of the repository",
                },
                {
                    "field": "repository_full_name",
                    "type": "string",
                    "helper_text": "Full name of the repository",
                },
                {
                    "field": "repository_url",
                    "type": "string",
                    "helper_text": "URL of the repository",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Update timestamp",
                },
                {
                    "field": "repository_details",
                    "type": "vec<string>",
                    "helper_text": "Repository details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_repository",
            "task_name": "tasks.github.update_repository",
            "description": "Update an existing repository on GitHub",
            "label": "Update Repository",
        },
        "read_repository**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository to read",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
            ],
            "outputs": [
                {
                    "field": "repository_id",
                    "type": "string",
                    "helper_text": "ID of the repository",
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "helper_text": "Name of the repository",
                },
                {
                    "field": "repository_full_name",
                    "type": "string",
                    "helper_text": "Full name of the repository",
                },
                {
                    "field": "repository_description",
                    "type": "string",
                    "helper_text": "Description of the repository",
                },
                {
                    "field": "repository_url",
                    "type": "string",
                    "helper_text": "URL of the repository",
                },
                {
                    "field": "clone_url",
                    "type": "string",
                    "helper_text": "Clone URL for the repository",
                },
                {
                    "field": "ssh_url",
                    "type": "string",
                    "helper_text": "SSH URL for the repository",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Last update timestamp",
                },
                {
                    "field": "pushed_at",
                    "type": "string",
                    "helper_text": "Last push timestamp",
                },
                {
                    "field": "is_private",
                    "type": "bool",
                    "helper_text": "Whether the repository is private",
                },
                {
                    "field": "is_fork",
                    "type": "bool",
                    "helper_text": "Whether the repository is a fork",
                },
                {
                    "field": "language",
                    "type": "string",
                    "helper_text": "Primary programming language",
                },
                {
                    "field": "stargazers_count",
                    "type": "string",
                    "helper_text": "Number of stars",
                },
                {
                    "field": "watchers_count",
                    "type": "string",
                    "helper_text": "Number of watchers",
                },
                {
                    "field": "forks_count",
                    "type": "string",
                    "helper_text": "Number of forks",
                },
                {
                    "field": "open_issues_count",
                    "type": "string",
                    "helper_text": "Number of open issues",
                },
                {
                    "field": "default_branch",
                    "type": "string",
                    "helper_text": "Default branch name",
                },
                {
                    "field": "owner_details",
                    "type": "string",
                    "helper_text": "Repository owner details",
                },
                {
                    "field": "repository_details",
                    "type": "vec<string>",
                    "helper_text": "Repository details in JSON format",
                },
            ],
            "name": "read_repository",
            "task_name": "tasks.github.read_repository",
            "description": "Read details of a GitHub repository",
            "label": "Read Repository",
            "variant": "common_integration_nodes",
        },
        "get_repositories**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner username (optional - defaults to authenticated user)",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "type",
                    "type": "string",
                    "value": "",
                    "helper_text": "Repository type filter",
                    "label": "Type",
                    "placeholder": "all",
                },
                {
                    "field": "sort",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort repositories by",
                    "label": "Sort",
                    "placeholder": "created",
                },
                {
                    "field": "direction",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort direction",
                    "label": "Direction",
                    "placeholder": "desc",
                },
                {
                    "field": "visibility",
                    "type": "string",
                    "value": "",
                    "helper_text": "Visibility filter",
                    "label": "Visibility",
                    "placeholder": "all",
                },
                {
                    "field": "affiliation",
                    "type": "string",
                    "value": "",
                    "helper_text": "Affiliation filter",
                    "label": "Affiliation",
                    "placeholder": "owner",
                },
            ],
            "outputs": [
                {
                    "field": "repository_ids",
                    "type": "vec<string>",
                    "helper_text": "List of repository IDs",
                },
                {
                    "field": "repository_names",
                    "type": "vec<string>",
                    "helper_text": "List of repository names",
                },
                {
                    "field": "repository_full_names",
                    "type": "vec<string>",
                    "helper_text": "List of full repository names",
                },
                {
                    "field": "repository_descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of repository descriptions",
                },
                {
                    "field": "repository_urls",
                    "type": "vec<string>",
                    "helper_text": "List of repository URLs",
                },
                {
                    "field": "clone_urls",
                    "type": "vec<string>",
                    "helper_text": "List of clone URLs",
                },
                {
                    "field": "ssh_urls",
                    "type": "vec<string>",
                    "helper_text": "List of SSH URLs",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of creation dates",
                },
                {
                    "field": "updated_dates",
                    "type": "vec<string>",
                    "helper_text": "List of update dates",
                },
                {
                    "field": "pushed_dates",
                    "type": "vec<string>",
                    "helper_text": "List of last push dates",
                },
                {
                    "field": "is_private_flags",
                    "type": "vec<string>",
                    "helper_text": "List of privacy flags",
                },
                {
                    "field": "languages",
                    "type": "vec<string>",
                    "helper_text": "List of primary languages",
                },
                {
                    "field": "stargazers_counts",
                    "type": "vec<string>",
                    "helper_text": "List of star counts",
                },
                {
                    "field": "watchers_counts",
                    "type": "vec<string>",
                    "helper_text": "List of watcher counts",
                },
                {
                    "field": "forks_counts",
                    "type": "vec<string>",
                    "helper_text": "List of fork counts",
                },
                {
                    "field": "open_issues_counts",
                    "type": "vec<string>",
                    "helper_text": "List of open issue counts",
                },
                {
                    "field": "default_branches",
                    "type": "vec<string>",
                    "helper_text": "List of default branch names",
                },
                {
                    "field": "owner_details",
                    "type": "vec<string>",
                    "helper_text": "List of owner details",
                },
                {
                    "field": "repository_details",
                    "type": "vec<string>",
                    "helper_text": "Repository details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_repositories",
            "task_name": "tasks.github.get_repositories",
            "description": "Get a list of repositories from GitHub",
            "label": "Get Repositories",
        },
        "get_repositories**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Repositories",
                    "helper_text": "Specify the number of repositories to fetch",
                }
            ],
            "outputs": [],
        },
        "get_repositories**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_repositories**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_repositories**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "delete_repository**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository to delete",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the repository was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "helper_text": "Name of the deleted repository",
                },
            ],
            "name": "delete_repository",
            "task_name": "tasks.github.delete_repository",
            "description": "Delete a GitHub repository",
            "label": "Delete Repository",
            "variant": "common_integration_nodes",
        },
        "create_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "issue_title",
                    "type": "string",
                    "value": "",
                    "helper_text": "Title of the issue",
                    "label": "Issue Title",
                    "placeholder": "Bug: Something is broken",
                },
                {
                    "field": "issue_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Body content of the issue",
                    "label": "Issue Body",
                    "placeholder": "Detailed description of the issue",
                },
                {
                    "field": "assignees",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of assignee usernames",
                    "label": "Assignees",
                    "placeholder": "user1,user2",
                },
                {
                    "field": "milestone",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Milestone number",
                    "label": "Milestone",
                    "placeholder": "1",
                },
                {
                    "field": "labels",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of labels",
                    "label": "Labels",
                    "placeholder": "bug,critical",
                },
            ],
            "outputs": [
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "ID of the created issue",
                },
                {
                    "field": "issue_number",
                    "type": "string",
                    "helper_text": "Number of the created issue",
                },
                {
                    "field": "issue_title",
                    "type": "string",
                    "helper_text": "Title of the created issue",
                },
                {
                    "field": "issue_url",
                    "type": "string",
                    "helper_text": "URL of the created issue",
                },
                {
                    "field": "issue_state",
                    "type": "string",
                    "helper_text": "State of the created issue",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "assignees",
                    "type": "vec<string>",
                    "helper_text": "List of assignees",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "List of labels",
                },
                {
                    "field": "milestone",
                    "type": "string",
                    "helper_text": "Milestone details",
                },
                {
                    "field": "issue_details",
                    "type": "vec<string>",
                    "helper_text": "Issue details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_issue",
            "task_name": "tasks.github.create_issue",
            "description": "Create a new issue on GitHub",
            "label": "Create Issue",
        },
        "update_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "issue_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the issue to update",
                    "label": "Issue Number",
                    "placeholder": "123",
                },
                {
                    "field": "update_issue_title",
                    "type": "string",
                    "value": "",
                    "helper_text": "New title for the issue",
                    "label": "New Issue Title",
                    "placeholder": "Updated title",
                },
                {
                    "field": "update_issue_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "New body for the issue",
                    "label": "New Issue Body",
                    "placeholder": "Updated description",
                },
                {
                    "field": "update_issue_state",
                    "type": "string",
                    "value": "",
                    "helper_text": "New state for the issue",
                    "label": "New State",
                    "placeholder": "closed",
                },
                {
                    "field": "update_assignees",
                    "type": "string",
                    "value": "",
                    "helper_text": "New assignees for the issue",
                    "label": "New Assignees",
                    "placeholder": "user1,user2",
                },
                {
                    "field": "update_milestone",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "New milestone for the issue",
                    "label": "New Milestone",
                    "placeholder": "2",
                },
                {
                    "field": "update_labels",
                    "type": "string",
                    "value": "",
                    "helper_text": "New labels for the issue",
                    "label": "New Labels",
                    "placeholder": "bug,fixed",
                },
            ],
            "outputs": [
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "ID of the updated issue",
                },
                {
                    "field": "issue_number",
                    "type": "string",
                    "helper_text": "Number of the updated issue",
                },
                {
                    "field": "issue_title",
                    "type": "string",
                    "helper_text": "Title of the updated issue",
                },
                {
                    "field": "issue_url",
                    "type": "string",
                    "helper_text": "URL of the updated issue",
                },
                {
                    "field": "issue_state",
                    "type": "string",
                    "helper_text": "State of the updated issue",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Update timestamp",
                },
                {
                    "field": "assignees",
                    "type": "vec<string>",
                    "helper_text": "List of assignees",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "List of labels",
                },
                {
                    "field": "milestone",
                    "type": "string",
                    "helper_text": "Milestone details",
                },
                {
                    "field": "issue_details",
                    "type": "vec<string>",
                    "helper_text": "Issue details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_issue",
            "task_name": "tasks.github.update_issue",
            "description": "Update an existing issue on GitHub",
            "label": "Update Issue",
        },
        "read_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "issue_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the issue to read",
                    "label": "Issue Number",
                    "placeholder": "123",
                },
            ],
            "outputs": [
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "ID of the issue",
                },
                {
                    "field": "issue_number",
                    "type": "string",
                    "helper_text": "Number of the issue",
                },
                {
                    "field": "issue_title",
                    "type": "string",
                    "helper_text": "Title of the issue",
                },
                {
                    "field": "issue_body",
                    "type": "string",
                    "helper_text": "Body of the issue",
                },
                {
                    "field": "issue_url",
                    "type": "string",
                    "helper_text": "URL of the issue",
                },
                {
                    "field": "issue_state",
                    "type": "string",
                    "helper_text": "State of the issue",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Last update timestamp",
                },
                {
                    "field": "closed_at",
                    "type": "string",
                    "helper_text": "Closure timestamp",
                },
                {
                    "field": "assignees",
                    "type": "vec<string>",
                    "helper_text": "List of assignees",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "List of labels",
                },
                {
                    "field": "milestone",
                    "type": "string",
                    "helper_text": "Milestone details",
                },
                {
                    "field": "author",
                    "type": "string",
                    "helper_text": "Issue author details",
                },
                {
                    "field": "comments_count",
                    "type": "string",
                    "helper_text": "Number of comments",
                },
                {
                    "field": "issue_details",
                    "type": "vec<string>",
                    "helper_text": "Issue details in JSON format",
                },
            ],
            "name": "read_issue",
            "task_name": "tasks.github.read_issue",
            "description": "Read details of a GitHub issue",
            "label": "Read Issue",
            "variant": "common_integration_nodes",
        },
        "get_issues**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "state",
                    "type": "string",
                    "value": "",
                    "helper_text": "Issue state filter",
                    "label": "State",
                    "placeholder": "open",
                },
                {
                    "field": "labels",
                    "type": "string",
                    "value": "",
                    "helper_text": "Labels filter",
                    "label": "Labels",
                    "placeholder": "bug,enhancement",
                },
                {
                    "field": "sort",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort issues by",
                    "label": "Sort",
                    "placeholder": "created",
                },
                {
                    "field": "direction",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort direction",
                    "label": "Direction",
                    "placeholder": "desc",
                },
                {
                    "field": "assignee",
                    "type": "string",
                    "value": "",
                    "helper_text": "Assignee filter",
                    "label": "Assignee",
                    "placeholder": "username",
                },
                {
                    "field": "creator",
                    "type": "string",
                    "value": "",
                    "helper_text": "Creator filter",
                    "label": "Creator",
                    "placeholder": "username",
                },
                {
                    "field": "mentioned",
                    "type": "string",
                    "value": "",
                    "helper_text": "Mentioned user filter",
                    "label": "Mentioned",
                    "placeholder": "username",
                },
                {
                    "field": "milestone",
                    "type": "string",
                    "value": "",
                    "helper_text": "Milestone filter",
                    "label": "Milestone",
                    "placeholder": "v1.0",
                },
            ],
            "outputs": [
                {
                    "field": "issue_ids",
                    "type": "vec<string>",
                    "helper_text": "List of issue IDs",
                },
                {
                    "field": "issue_numbers",
                    "type": "vec<string>",
                    "helper_text": "List of issue numbers",
                },
                {
                    "field": "issue_titles",
                    "type": "vec<string>",
                    "helper_text": "List of issue titles",
                },
                {
                    "field": "issue_bodies",
                    "type": "vec<string>",
                    "helper_text": "List of issue bodies",
                },
                {
                    "field": "issue_urls",
                    "type": "vec<string>",
                    "helper_text": "List of issue URLs",
                },
                {
                    "field": "issue_states",
                    "type": "vec<string>",
                    "helper_text": "List of issue states",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of creation dates",
                },
                {
                    "field": "updated_dates",
                    "type": "vec<string>",
                    "helper_text": "List of update dates",
                },
                {
                    "field": "closed_dates",
                    "type": "vec<string>",
                    "helper_text": "List of closure dates",
                },
                {
                    "field": "assignees_details",
                    "type": "vec<string>",
                    "helper_text": "List of assignee details",
                },
                {
                    "field": "labels_details",
                    "type": "vec<string>",
                    "helper_text": "List of label details",
                },
                {
                    "field": "milestone_details",
                    "type": "vec<string>",
                    "helper_text": "List of milestone details",
                },
                {
                    "field": "author_details",
                    "type": "vec<string>",
                    "helper_text": "List of author details",
                },
                {
                    "field": "comments_counts",
                    "type": "vec<string>",
                    "helper_text": "List of comment counts",
                },
                {
                    "field": "issue_details",
                    "type": "vec<string>",
                    "helper_text": "Issue details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_issues",
            "task_name": "tasks.github.get_issues",
            "description": "Get a list of issues from GitHub",
            "label": "Get Issues",
        },
        "get_issues**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Issues",
                    "helper_text": "Specify the number of issues to fetch",
                }
            ],
            "outputs": [],
        },
        "get_issues**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_issues**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_issues**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_pull_request**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "pull_request_title",
                    "type": "string",
                    "value": "",
                    "helper_text": "Title of the pull request",
                    "label": "Pull Request Title",
                    "placeholder": "Add new feature",
                },
                {
                    "field": "head",
                    "type": "string",
                    "value": "",
                    "helper_text": "Head branch (source)",
                    "label": "Head Branch",
                    "placeholder": "feature-branch",
                },
                {
                    "field": "base",
                    "type": "string",
                    "value": "",
                    "helper_text": "Base branch (target)",
                    "label": "Base Branch",
                    "placeholder": "main",
                },
                {
                    "field": "pull_request_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Body content of the pull request",
                    "label": "Pull Request Body",
                    "placeholder": "This PR adds a new feature",
                },
                {
                    "field": "draft",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Create as draft pull request",
                    "label": "Draft",
                },
                {
                    "field": "maintainer_can_modify",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Allow maintainer modifications",
                    "label": "Maintainer Can Modify",
                },
            ],
            "outputs": [
                {
                    "field": "pull_request_id",
                    "type": "string",
                    "helper_text": "ID of the created pull request",
                },
                {
                    "field": "pull_request_number",
                    "type": "string",
                    "helper_text": "Number of the created pull request",
                },
                {
                    "field": "pull_request_title",
                    "type": "string",
                    "helper_text": "Title of the created pull request",
                },
                {
                    "field": "pull_request_url",
                    "type": "string",
                    "helper_text": "URL of the created pull request",
                },
                {
                    "field": "pull_request_state",
                    "type": "string",
                    "helper_text": "State of the created pull request",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "draft",
                    "type": "bool",
                    "helper_text": "Whether the pull request is a draft",
                },
                {
                    "field": "pull_request_details",
                    "type": "vec<string>",
                    "helper_text": "Pull request details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_pull_request",
            "task_name": "tasks.github.create_pull_request",
            "description": "Create a new pull request on GitHub",
            "label": "Create Pull Request",
        },
        "update_pull_request**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "pull_request_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the pull request to update",
                    "label": "Pull Request Number",
                    "placeholder": "123",
                },
                {
                    "field": "update_pull_request_title",
                    "type": "string",
                    "value": "",
                    "helper_text": "New title for the pull request",
                    "label": "New Title",
                    "placeholder": "Updated title",
                },
                {
                    "field": "update_pull_request_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "New body for the pull request",
                    "label": "New Body",
                    "placeholder": "Updated description",
                },
                {
                    "field": "update_pull_request_state",
                    "type": "string",
                    "value": "",
                    "helper_text": "New state for the pull request",
                    "label": "New State",
                    "placeholder": "closed",
                },
                {
                    "field": "update_base",
                    "type": "string",
                    "value": "",
                    "helper_text": "New base branch",
                    "label": "New Base Branch",
                    "placeholder": "develop",
                },
                {
                    "field": "update_maintainer_can_modify",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Update maintainer modification permission",
                    "label": "Maintainer Can Modify",
                },
            ],
            "outputs": [
                {
                    "field": "pull_request_id",
                    "type": "string",
                    "helper_text": "ID of the updated pull request",
                },
                {
                    "field": "pull_request_number",
                    "type": "string",
                    "helper_text": "Number of the updated pull request",
                },
                {
                    "field": "pull_request_title",
                    "type": "string",
                    "helper_text": "Title of the updated pull request",
                },
                {
                    "field": "pull_request_url",
                    "type": "string",
                    "helper_text": "URL of the updated pull request",
                },
                {
                    "field": "pull_request_state",
                    "type": "string",
                    "helper_text": "State of the updated pull request",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Update timestamp",
                },
                {
                    "field": "pull_request_details",
                    "type": "vec<string>",
                    "helper_text": "Pull request details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_pull_request",
            "task_name": "tasks.github.update_pull_request",
            "description": "Update an existing pull request on GitHub",
            "label": "Update Pull Request",
        },
        "read_pull_request**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "pull_request_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the pull request to read",
                    "label": "Pull Request Number",
                    "placeholder": "123",
                },
            ],
            "outputs": [
                {
                    "field": "pull_request_id",
                    "type": "string",
                    "helper_text": "ID of the pull request",
                },
                {
                    "field": "pull_request_number",
                    "type": "string",
                    "helper_text": "Number of the pull request",
                },
                {
                    "field": "pull_request_title",
                    "type": "string",
                    "helper_text": "Title of the pull request",
                },
                {
                    "field": "pull_request_body",
                    "type": "string",
                    "helper_text": "Body of the pull request",
                },
                {
                    "field": "pull_request_url",
                    "type": "string",
                    "helper_text": "URL of the pull request",
                },
                {
                    "field": "pull_request_state",
                    "type": "string",
                    "helper_text": "State of the pull request",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Last update timestamp",
                },
                {
                    "field": "closed_at",
                    "type": "string",
                    "helper_text": "Closure timestamp",
                },
                {
                    "field": "merged_at",
                    "type": "string",
                    "helper_text": "Merge timestamp",
                },
                {
                    "field": "draft",
                    "type": "bool",
                    "helper_text": "Whether the pull request is a draft",
                },
                {
                    "field": "merged",
                    "type": "bool",
                    "helper_text": "Whether the pull request is merged",
                },
                {
                    "field": "mergeable",
                    "type": "bool",
                    "helper_text": "Whether the pull request is mergeable",
                },
                {
                    "field": "assignees",
                    "type": "vec<string>",
                    "helper_text": "List of assignees",
                },
                {
                    "field": "requested_reviewers",
                    "type": "vec<string>",
                    "helper_text": "List of requested reviewers",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "List of labels",
                },
                {
                    "field": "milestone",
                    "type": "string",
                    "helper_text": "Milestone details",
                },
                {
                    "field": "head_details",
                    "type": "string",
                    "helper_text": "Head branch details",
                },
                {
                    "field": "base_details",
                    "type": "string",
                    "helper_text": "Base branch details",
                },
                {
                    "field": "commits_count",
                    "type": "string",
                    "helper_text": "Number of commits",
                },
                {
                    "field": "additions_count",
                    "type": "string",
                    "helper_text": "Number of additions",
                },
                {
                    "field": "deletions_count",
                    "type": "string",
                    "helper_text": "Number of deletions",
                },
                {
                    "field": "changed_files_count",
                    "type": "string",
                    "helper_text": "Number of changed files",
                },
                {
                    "field": "pull_request_details",
                    "type": "vec<string>",
                    "helper_text": "Pull request details in JSON format",
                },
            ],
            "name": "read_pull_request",
            "task_name": "tasks.github.read_pull_request",
            "description": "Read details of a GitHub pull request",
            "label": "Read Pull Request",
            "variant": "common_integration_nodes",
        },
        "get_pull_requests**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "state",
                    "type": "string",
                    "value": "",
                    "helper_text": "Pull request state filter",
                    "label": "State",
                    "placeholder": "open",
                },
                {
                    "field": "head",
                    "type": "string",
                    "value": "",
                    "helper_text": "Head branch filter",
                    "label": "Head Branch",
                    "placeholder": "feature-branch",
                },
                {
                    "field": "base",
                    "type": "string",
                    "value": "",
                    "helper_text": "Base branch filter",
                    "label": "Base Branch",
                    "placeholder": "main",
                },
                {
                    "field": "sort",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort pull requests by",
                    "label": "Sort",
                    "placeholder": "created",
                },
                {
                    "field": "direction",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort direction",
                    "label": "Direction",
                    "placeholder": "desc",
                },
            ],
            "outputs": [
                {
                    "field": "pull_request_ids",
                    "type": "vec<string>",
                    "helper_text": "List of pull request IDs",
                },
                {
                    "field": "pull_request_numbers",
                    "type": "vec<string>",
                    "helper_text": "List of pull request numbers",
                },
                {
                    "field": "pull_request_titles",
                    "type": "vec<string>",
                    "helper_text": "List of pull request titles",
                },
                {
                    "field": "pull_request_bodies",
                    "type": "vec<string>",
                    "helper_text": "List of pull request bodies",
                },
                {
                    "field": "pull_request_urls",
                    "type": "vec<string>",
                    "helper_text": "List of pull request URLs",
                },
                {
                    "field": "pull_request_states",
                    "type": "vec<string>",
                    "helper_text": "List of pull request states",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of creation dates",
                },
                {
                    "field": "updated_dates",
                    "type": "vec<string>",
                    "helper_text": "List of update dates",
                },
                {
                    "field": "closed_dates",
                    "type": "vec<string>",
                    "helper_text": "List of closure dates",
                },
                {
                    "field": "merged_dates",
                    "type": "vec<string>",
                    "helper_text": "List of merge dates",
                },
                {
                    "field": "draft_flags",
                    "type": "vec<string>",
                    "helper_text": "List of draft flags",
                },
                {
                    "field": "merged_flags",
                    "type": "vec<string>",
                    "helper_text": "List of merged flags",
                },
                {
                    "field": "mergeable_flags",
                    "type": "vec<string>",
                    "helper_text": "List of mergeable flags",
                },
                {
                    "field": "assignees_details",
                    "type": "vec<string>",
                    "helper_text": "List of assignee details",
                },
                {
                    "field": "requested_reviewers_details",
                    "type": "vec<string>",
                    "helper_text": "List of requested reviewer details",
                },
                {
                    "field": "labels_details",
                    "type": "vec<string>",
                    "helper_text": "List of label details",
                },
                {
                    "field": "milestone_details",
                    "type": "vec<string>",
                    "helper_text": "List of milestone details",
                },
                {
                    "field": "head_details",
                    "type": "vec<string>",
                    "helper_text": "List of head branch details",
                },
                {
                    "field": "base_details",
                    "type": "vec<string>",
                    "helper_text": "List of base branch details",
                },
                {
                    "field": "pull_request_details",
                    "type": "vec<string>",
                    "helper_text": "Pull request details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_pull_requests",
            "task_name": "tasks.github.get_pull_requests",
            "description": "Get a list of pull requests from GitHub",
            "label": "Get Pull Requests",
        },
        "get_pull_requests**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Pull Requests",
                    "helper_text": "Specify the number of pull requests to fetch",
                }
            ],
            "outputs": [],
        },
        "get_pull_requests**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_pull_requests**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_pull_requests**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "merge_pull_request**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "pull_request_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the pull request to merge",
                    "label": "Pull Request Number",
                    "placeholder": "123",
                },
                {
                    "field": "commit_title",
                    "type": "string",
                    "value": "",
                    "helper_text": "Title for the merge commit",
                    "label": "Commit Title",
                    "placeholder": "Merge pull request",
                },
                {
                    "field": "commit_message",
                    "type": "string",
                    "value": "",
                    "helper_text": "Message for the merge commit",
                    "label": "Commit Message",
                    "placeholder": "Merged feature branch",
                },
                {
                    "field": "sha",
                    "type": "string",
                    "value": "",
                    "helper_text": "SHA that pull request head must match",
                    "label": "SHA",
                    "placeholder": "abc123",
                },
                {
                    "field": "merge_method",
                    "type": "string",
                    "value": "",
                    "helper_text": "Merge method to use",
                    "label": "Merge Method",
                    "placeholder": "merge",
                },
            ],
            "outputs": [
                {
                    "field": "merged",
                    "type": "bool",
                    "helper_text": "Whether the pull request was merged",
                },
                {
                    "field": "sha",
                    "type": "string",
                    "helper_text": "SHA of the merge commit",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Merge result message",
                },
                {
                    "field": "pull_request_details",
                    "type": "vec<string>",
                    "helper_text": "Updated pull request details",
                },
            ],
            "name": "merge_pull_request",
            "task_name": "tasks.github.merge_pull_request",
            "description": "Merge a GitHub pull request",
            "label": "Merge Pull Request",
            "variant": "common_integration_nodes",
        },
        "create_issue_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "issue_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the issue to comment on",
                    "label": "Issue Number",
                    "placeholder": "123",
                },
                {
                    "field": "comment_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Body content of the comment",
                    "label": "Comment Body",
                    "placeholder": "This is a comment on the issue",
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "ID of the created comment",
                },
                {
                    "field": "comment_body",
                    "type": "string",
                    "helper_text": "Body of the created comment",
                },
                {
                    "field": "comment_url",
                    "type": "string",
                    "helper_text": "URL of the created comment",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "author_details",
                    "type": "string",
                    "helper_text": "Comment author details",
                },
                {
                    "field": "comment_details",
                    "type": "vec<string>",
                    "helper_text": "Comment details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_issue_comment",
            "task_name": "tasks.github.create_issue_comment",
            "description": "Create a new comment on a GitHub issue",
            "label": "Create Issue Comment",
        },
        "update_issue_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "comment_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the comment to update",
                    "label": "Comment ID",
                    "placeholder": "123456",
                },
                {
                    "field": "update_comment_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "New body for the comment",
                    "label": "New Comment Body",
                    "placeholder": "Updated comment content",
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "ID of the updated comment",
                },
                {
                    "field": "comment_body",
                    "type": "string",
                    "helper_text": "Body of the updated comment",
                },
                {
                    "field": "comment_url",
                    "type": "string",
                    "helper_text": "URL of the updated comment",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Update timestamp",
                },
                {
                    "field": "author_details",
                    "type": "string",
                    "helper_text": "Comment author details",
                },
                {
                    "field": "comment_details",
                    "type": "vec<string>",
                    "helper_text": "Comment details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_issue_comment",
            "task_name": "tasks.github.update_issue_comment",
            "description": "Update an existing comment on a GitHub issue",
            "label": "Update Issue Comment",
        },
        "read_issue_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "comment_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the comment to read",
                    "label": "Comment ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "ID of the comment",
                },
                {
                    "field": "comment_body",
                    "type": "string",
                    "helper_text": "Body of the comment",
                },
                {
                    "field": "comment_url",
                    "type": "string",
                    "helper_text": "URL of the comment",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Last update timestamp",
                },
                {
                    "field": "author_details",
                    "type": "string",
                    "helper_text": "Comment author details",
                },
                {
                    "field": "comment_details",
                    "type": "vec<string>",
                    "helper_text": "Comment details in JSON format",
                },
            ],
            "name": "read_issue_comment",
            "task_name": "tasks.github.read_issue_comment",
            "description": "Read details of a GitHub issue comment",
            "label": "Read Issue Comment",
            "variant": "common_integration_nodes",
        },
        "get_issue_comments**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "issue_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the issue to get comments from",
                    "label": "Issue Number",
                    "placeholder": "123",
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "sort",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort comments by",
                    "label": "Sort",
                    "placeholder": "created",
                },
                {
                    "field": "direction",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort direction",
                    "label": "Direction",
                    "placeholder": "asc",
                },
            ],
            "outputs": [
                {
                    "field": "comment_ids",
                    "type": "vec<string>",
                    "helper_text": "List of comment IDs",
                },
                {
                    "field": "comment_bodies",
                    "type": "vec<string>",
                    "helper_text": "List of comment bodies",
                },
                {
                    "field": "comment_urls",
                    "type": "vec<string>",
                    "helper_text": "List of comment URLs",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of creation dates",
                },
                {
                    "field": "updated_dates",
                    "type": "vec<string>",
                    "helper_text": "List of update dates",
                },
                {
                    "field": "author_details",
                    "type": "vec<string>",
                    "helper_text": "List of comment author details",
                },
                {
                    "field": "comment_details",
                    "type": "vec<string>",
                    "helper_text": "Comment details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_issue_comments",
            "task_name": "tasks.github.get_issue_comments",
            "description": "Get a list of comments from a GitHub issue",
            "label": "Get Issue Comments",
        },
        "get_issue_comments**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Comments",
                    "helper_text": "Specify the number of comments to fetch",
                }
            ],
            "outputs": [],
        },
        "get_issue_comments**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_issue_comments**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_issue_comments**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "delete_issue_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "comment_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the comment to delete",
                    "label": "Comment ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the comment was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "ID of the deleted comment",
                },
            ],
            "name": "delete_issue_comment",
            "task_name": "tasks.github.delete_issue_comment",
            "description": "Delete a GitHub issue comment",
            "label": "Delete Issue Comment",
            "variant": "common_integration_nodes",
        },
        "create_release**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the tag for the release",
                    "label": "Tag Name",
                    "placeholder": "v1.0.0",
                },
                {
                    "field": "release_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the release",
                    "label": "Release Name",
                    "placeholder": "Version 1.0.0",
                },
                {
                    "field": "release_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the release",
                    "label": "Release Body",
                    "placeholder": "Release notes and changelog",
                },
                {
                    "field": "target_commitish",
                    "type": "string",
                    "value": "",
                    "helper_text": "Commitish value for the release",
                    "label": "Target Commitish",
                    "placeholder": "main",
                },
                {
                    "field": "draft",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Create as draft release",
                    "label": "Draft",
                },
                {
                    "field": "prerelease",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Mark as prerelease",
                    "label": "Prerelease",
                },
                {
                    "field": "generate_release_notes",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Auto-generate release notes",
                    "label": "Generate Release Notes",
                },
            ],
            "outputs": [
                {
                    "field": "release_id",
                    "type": "string",
                    "helper_text": "ID of the created release",
                },
                {
                    "field": "release_name",
                    "type": "string",
                    "helper_text": "Name of the created release",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Tag name of the created release",
                },
                {
                    "field": "release_url",
                    "type": "string",
                    "helper_text": "URL of the created release",
                },
                {
                    "field": "tarball_url",
                    "type": "string",
                    "helper_text": "Tarball download URL",
                },
                {
                    "field": "zipball_url",
                    "type": "string",
                    "helper_text": "Zipball download URL",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "published_at",
                    "type": "string",
                    "helper_text": "Publication timestamp",
                },
                {
                    "field": "draft",
                    "type": "bool",
                    "helper_text": "Whether the release is a draft",
                },
                {
                    "field": "prerelease",
                    "type": "bool",
                    "helper_text": "Whether the release is a prerelease",
                },
                {
                    "field": "release_details",
                    "type": "vec<string>",
                    "helper_text": "Release details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_release",
            "task_name": "tasks.github.create_release",
            "description": "Create a new release on GitHub",
            "label": "Create Release",
        },
        "update_release**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "release_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the release to update",
                    "label": "Release ID",
                    "placeholder": "123456",
                },
                {
                    "field": "update_tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New tag name for the release",
                    "label": "New Tag Name",
                    "placeholder": "v1.0.1",
                },
                {
                    "field": "update_release_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the release",
                    "label": "New Release Name",
                    "placeholder": "Version 1.0.1",
                },
                {
                    "field": "update_release_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the release",
                    "label": "New Release Body",
                    "placeholder": "Updated release notes",
                },
                {
                    "field": "update_target_commitish",
                    "type": "string",
                    "value": "",
                    "helper_text": "New commitish value for the release",
                    "label": "New Target Commitish",
                    "placeholder": "main",
                },
                {
                    "field": "update_draft",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Update draft status",
                    "label": "Draft",
                },
                {
                    "field": "update_prerelease",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Update prerelease status",
                    "label": "Prerelease",
                },
            ],
            "outputs": [
                {
                    "field": "release_id",
                    "type": "string",
                    "helper_text": "ID of the updated release",
                },
                {
                    "field": "release_name",
                    "type": "string",
                    "helper_text": "Name of the updated release",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Tag name of the updated release",
                },
                {
                    "field": "release_url",
                    "type": "string",
                    "helper_text": "URL of the updated release",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Update timestamp",
                },
                {
                    "field": "release_details",
                    "type": "vec<string>",
                    "helper_text": "Release details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_release",
            "task_name": "tasks.github.update_release",
            "description": "Update an existing release on GitHub",
            "label": "Update Release",
        },
        "read_release**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "release_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the release to read",
                    "label": "Release ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "release_id",
                    "type": "string",
                    "helper_text": "ID of the release",
                },
                {
                    "field": "release_name",
                    "type": "string",
                    "helper_text": "Name of the release",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Tag name of the release",
                },
                {
                    "field": "release_body",
                    "type": "string",
                    "helper_text": "Body of the release",
                },
                {
                    "field": "release_url",
                    "type": "string",
                    "helper_text": "URL of the release",
                },
                {
                    "field": "tarball_url",
                    "type": "string",
                    "helper_text": "Tarball download URL",
                },
                {
                    "field": "zipball_url",
                    "type": "string",
                    "helper_text": "Zipball download URL",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "published_at",
                    "type": "string",
                    "helper_text": "Publication timestamp",
                },
                {
                    "field": "draft",
                    "type": "bool",
                    "helper_text": "Whether the release is a draft",
                },
                {
                    "field": "prerelease",
                    "type": "bool",
                    "helper_text": "Whether the release is a prerelease",
                },
                {
                    "field": "author_details",
                    "type": "string",
                    "helper_text": "Release author details",
                },
                {
                    "field": "assets_details",
                    "type": "vec<string>",
                    "helper_text": "Release assets details",
                },
                {
                    "field": "release_details",
                    "type": "vec<string>",
                    "helper_text": "Release details in JSON format",
                },
            ],
            "name": "read_release",
            "task_name": "tasks.github.read_release",
            "description": "Read details of a GitHub release",
            "label": "Read Release",
            "variant": "common_integration_nodes",
        },
        "get_releases**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
            ],
            "outputs": [
                {
                    "field": "release_ids",
                    "type": "vec<string>",
                    "helper_text": "List of release IDs",
                },
                {
                    "field": "release_names",
                    "type": "vec<string>",
                    "helper_text": "List of release names",
                },
                {
                    "field": "tag_names",
                    "type": "vec<string>",
                    "helper_text": "List of tag names",
                },
                {
                    "field": "release_bodies",
                    "type": "vec<string>",
                    "helper_text": "List of release bodies",
                },
                {
                    "field": "release_urls",
                    "type": "vec<string>",
                    "helper_text": "List of release URLs",
                },
                {
                    "field": "tarball_urls",
                    "type": "vec<string>",
                    "helper_text": "List of tarball URLs",
                },
                {
                    "field": "zipball_urls",
                    "type": "vec<string>",
                    "helper_text": "List of zipball URLs",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of creation dates",
                },
                {
                    "field": "published_dates",
                    "type": "vec<string>",
                    "helper_text": "List of publication dates",
                },
                {
                    "field": "draft_flags",
                    "type": "vec<string>",
                    "helper_text": "List of draft flags",
                },
                {
                    "field": "prerelease_flags",
                    "type": "vec<string>",
                    "helper_text": "List of prerelease flags",
                },
                {
                    "field": "author_details",
                    "type": "vec<string>",
                    "helper_text": "List of author details",
                },
                {
                    "field": "assets_details",
                    "type": "vec<string>",
                    "helper_text": "List of assets details",
                },
                {
                    "field": "release_details",
                    "type": "vec<string>",
                    "helper_text": "Release details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_releases",
            "task_name": "tasks.github.get_releases",
            "description": "Get a list of releases from GitHub",
            "label": "Get Releases",
        },
        "get_releases**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Releases",
                    "helper_text": "Specify the number of releases to fetch",
                }
            ],
            "outputs": [],
        },
        "get_releases**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_releases**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_releases**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "delete_release**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "release_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the release to delete",
                    "label": "Release ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the release was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "release_id",
                    "type": "string",
                    "helper_text": "ID of the deleted release",
                },
            ],
            "name": "delete_release",
            "task_name": "tasks.github.delete_release",
            "description": "Delete a GitHub release",
            "label": "Delete Release",
            "variant": "common_integration_nodes",
        },
        "create_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path where the file will be created",
                    "label": "File Path",
                    "placeholder": "src/main.js",
                },
                {
                    "field": "file_content",
                    "type": "string",
                    "value": "",
                    "helper_text": "Content of the file",
                    "label": "File Content",
                    "placeholder": "console.log('Hello World');",
                },
                {
                    "field": "commit_message",
                    "type": "string",
                    "value": "",
                    "helper_text": "Commit message for the file creation",
                    "label": "Commit Message",
                    "placeholder": "Add new file",
                },
                {
                    "field": "branch_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Branch to create the file on",
                    "label": "Branch Name",
                    "placeholder": "main",
                },
                {
                    "field": "committer_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the committer",
                    "label": "Committer Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "committer_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the committer",
                    "label": "Committer Email",
                    "placeholder": "john@example.com",
                },
                {
                    "field": "author_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the author",
                    "label": "Author Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "author_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the author",
                    "label": "Author Email",
                    "placeholder": "john@example.com",
                },
            ],
            "outputs": [
                {
                    "field": "file_path",
                    "type": "string",
                    "helper_text": "Path of the created file",
                },
                {
                    "field": "sha",
                    "type": "string",
                    "helper_text": "SHA of the created file",
                },
                {
                    "field": "commit_sha",
                    "type": "string",
                    "helper_text": "SHA of the commit",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "URL of the created file",
                },
                {
                    "field": "download_url",
                    "type": "string",
                    "helper_text": "Download URL of the file",
                },
                {
                    "field": "file_details",
                    "type": "vec<string>",
                    "helper_text": "File details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_file",
            "task_name": "tasks.github.create_file",
            "description": "Create a new file in a GitHub repository",
            "label": "Create File",
        },
        "update_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the file to update",
                    "label": "File Path",
                    "placeholder": "src/main.js",
                },
                {
                    "field": "update_file_content",
                    "type": "string",
                    "value": "",
                    "helper_text": "New content of the file",
                    "label": "New File Content",
                    "placeholder": "console.log('Updated Hello World');",
                },
                {
                    "field": "update_commit_message",
                    "type": "string",
                    "value": "",
                    "helper_text": "Commit message for the file update",
                    "label": "Commit Message",
                    "placeholder": "Update file",
                },
                {
                    "field": "update_branch_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Branch to update the file on",
                    "label": "Branch Name",
                    "placeholder": "main",
                },
                {
                    "field": "file_sha",
                    "type": "string",
                    "value": "",
                    "helper_text": "Current SHA of the file",
                    "label": "File SHA",
                    "placeholder": "abc123",
                },
                {
                    "field": "update_committer_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the committer",
                    "label": "Committer Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "update_committer_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the committer",
                    "label": "Committer Email",
                    "placeholder": "john@example.com",
                },
                {
                    "field": "update_author_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the author",
                    "label": "Author Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "update_author_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the author",
                    "label": "Author Email",
                    "placeholder": "john@example.com",
                },
            ],
            "outputs": [
                {
                    "field": "file_path",
                    "type": "string",
                    "helper_text": "Path of the updated file",
                },
                {
                    "field": "sha",
                    "type": "string",
                    "helper_text": "New SHA of the updated file",
                },
                {
                    "field": "commit_sha",
                    "type": "string",
                    "helper_text": "SHA of the commit",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "URL of the updated file",
                },
                {
                    "field": "download_url",
                    "type": "string",
                    "helper_text": "Download URL of the file",
                },
                {
                    "field": "file_details",
                    "type": "vec<string>",
                    "helper_text": "File details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_file",
            "task_name": "tasks.github.update_file",
            "description": "Update an existing file in a GitHub repository",
            "label": "Update File",
        },
        "read_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the file to read",
                    "label": "File Path",
                    "placeholder": "src/main.js",
                },
                {
                    "field": "ref",
                    "type": "string",
                    "value": "",
                    "helper_text": "Branch, tag, or commit to read from",
                    "label": "Reference",
                    "placeholder": "main",
                },
            ],
            "outputs": [
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the file",
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "helper_text": "Path of the file",
                },
                {
                    "field": "file_content",
                    "type": "string",
                    "helper_text": "Content of the file",
                },
                {
                    "field": "file_sha",
                    "type": "string",
                    "helper_text": "SHA of the file",
                },
                {
                    "field": "file_size",
                    "type": "string",
                    "helper_text": "Size of the file in bytes",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "URL of the file",
                },
                {
                    "field": "download_url",
                    "type": "string",
                    "helper_text": "Download URL of the file",
                },
                {
                    "field": "git_url",
                    "type": "string",
                    "helper_text": "Git URL of the file",
                },
                {
                    "field": "html_url",
                    "type": "string",
                    "helper_text": "HTML URL of the file",
                },
                {
                    "field": "encoding",
                    "type": "string",
                    "helper_text": "Encoding of the file",
                },
                {
                    "field": "file_type",
                    "type": "string",
                    "helper_text": "Type of the file",
                },
                {
                    "field": "file_details",
                    "type": "vec<string>",
                    "helper_text": "File details in JSON format",
                },
            ],
            "name": "read_file",
            "task_name": "tasks.github.read_file",
            "description": "Read a file from a GitHub repository",
            "label": "Read File",
            "variant": "common_integration_nodes",
        },
        "delete_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the file to delete",
                    "label": "File Path",
                    "placeholder": "src/main.js",
                },
                {
                    "field": "delete_commit_message",
                    "type": "string",
                    "value": "",
                    "helper_text": "Commit message for the file deletion",
                    "label": "Commit Message",
                    "placeholder": "Delete file",
                },
                {
                    "field": "delete_branch_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Branch to delete the file from",
                    "label": "Branch Name",
                    "placeholder": "main",
                },
                {
                    "field": "delete_file_sha",
                    "type": "string",
                    "value": "",
                    "helper_text": "Current SHA of the file to delete",
                    "label": "File SHA",
                    "placeholder": "abc123",
                },
                {
                    "field": "delete_committer_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the committer",
                    "label": "Committer Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "delete_committer_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the committer",
                    "label": "Committer Email",
                    "placeholder": "john@example.com",
                },
                {
                    "field": "delete_author_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the author",
                    "label": "Author Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "delete_author_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the author",
                    "label": "Author Email",
                    "placeholder": "john@example.com",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the file was successfully deleted",
                },
                {
                    "field": "commit_sha",
                    "type": "string",
                    "helper_text": "SHA of the commit",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "helper_text": "Path of the deleted file",
                },
            ],
            "name": "delete_file",
            "task_name": "tasks.github.delete_file",
            "description": "Delete a file from a GitHub repository",
            "label": "Delete File",
            "variant": "common_integration_nodes",
        },
        "create_branch**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "branch_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the new branch",
                    "label": "Branch Name",
                    "placeholder": "feature-branch",
                },
                {
                    "field": "source_branch",
                    "type": "string",
                    "value": "",
                    "helper_text": "Source branch to create from",
                    "label": "Source Branch",
                    "placeholder": "main",
                },
            ],
            "outputs": [
                {
                    "field": "branch_name",
                    "type": "string",
                    "helper_text": "Name of the created branch",
                },
                {"field": "sha", "type": "string", "helper_text": "SHA of the branch"},
                {
                    "field": "ref",
                    "type": "string",
                    "helper_text": "Reference of the branch",
                },
                {"field": "url", "type": "string", "helper_text": "URL of the branch"},
                {
                    "field": "branch_details",
                    "type": "vec<string>",
                    "helper_text": "Branch details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_branch",
            "task_name": "tasks.github.create_branch",
            "description": "Create a new branch in a GitHub repository",
            "label": "Create Branch",
        },
        "read_branch**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "branch_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the branch to read",
                    "label": "Branch Name",
                    "placeholder": "feature-branch",
                },
            ],
            "outputs": [
                {
                    "field": "branch_name",
                    "type": "string",
                    "helper_text": "Name of the branch",
                },
                {
                    "field": "sha",
                    "type": "string",
                    "helper_text": "SHA of the latest commit",
                },
                {
                    "field": "commit_url",
                    "type": "string",
                    "helper_text": "URL of the latest commit",
                },
                {
                    "field": "commit_message",
                    "type": "string",
                    "helper_text": "Message of the latest commit",
                },
                {
                    "field": "commit_author",
                    "type": "string",
                    "helper_text": "Author of the latest commit",
                },
                {
                    "field": "commit_committer",
                    "type": "string",
                    "helper_text": "Committer of the latest commit",
                },
                {
                    "field": "commit_date",
                    "type": "string",
                    "helper_text": "Date of the latest commit",
                },
                {
                    "field": "protected",
                    "type": "bool",
                    "helper_text": "Whether the branch is protected",
                },
                {
                    "field": "branch_details",
                    "type": "vec<string>",
                    "helper_text": "Branch details in JSON format",
                },
            ],
            "name": "read_branch",
            "task_name": "tasks.github.read_branch",
            "description": "Read details of a GitHub branch",
            "label": "Read Branch",
            "variant": "common_integration_nodes",
        },
        "get_branches**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "protected",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Filter by protected status",
                    "label": "Protected Only",
                },
            ],
            "outputs": [
                {
                    "field": "branch_names",
                    "type": "vec<string>",
                    "helper_text": "List of branch names",
                },
                {
                    "field": "commit_shas",
                    "type": "vec<string>",
                    "helper_text": "List of commit SHAs",
                },
                {
                    "field": "commit_urls",
                    "type": "vec<string>",
                    "helper_text": "List of commit URLs",
                },
                {
                    "field": "commit_messages",
                    "type": "vec<string>",
                    "helper_text": "List of commit messages",
                },
                {
                    "field": "commit_authors",
                    "type": "vec<string>",
                    "helper_text": "List of commit authors",
                },
                {
                    "field": "commit_committers",
                    "type": "vec<string>",
                    "helper_text": "List of commit committers",
                },
                {
                    "field": "commit_dates",
                    "type": "vec<string>",
                    "helper_text": "List of commit dates",
                },
                {
                    "field": "protected_flags",
                    "type": "vec<string>",
                    "helper_text": "List of protection flags",
                },
                {
                    "field": "branch_details",
                    "type": "vec<string>",
                    "helper_text": "Branch details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_branches",
            "task_name": "tasks.github.get_branches",
            "description": "Get a list of branches from GitHub",
            "label": "Get Branches",
        },
        "get_branches**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Branches",
                    "helper_text": "Specify the number of branches to fetch",
                }
            ],
            "outputs": [],
        },
        "get_branches**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_branches**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_branches**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "delete_branch**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "branch_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the branch to delete",
                    "label": "Branch Name",
                    "placeholder": "feature-branch",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the branch was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "branch_name",
                    "type": "string",
                    "helper_text": "Name of the deleted branch",
                },
            ],
            "name": "delete_branch",
            "task_name": "tasks.github.delete_branch",
            "description": "Delete a branch from a GitHub repository",
            "label": "Delete Branch",
            "variant": "common_integration_nodes",
        },
        "read_user**(*)**(*)": {
            "inputs": [
                {
                    "field": "username",
                    "type": "string",
                    "value": "",
                    "helper_text": "Username to read information for",
                    "label": "Username",
                    "placeholder": "octocat",
                }
            ],
            "outputs": [
                {"field": "user_id", "type": "string", "helper_text": "ID of the user"},
                {
                    "field": "username",
                    "type": "string",
                    "helper_text": "Username of the user",
                },
                {
                    "field": "user_name",
                    "type": "string",
                    "helper_text": "Display name of the user",
                },
                {
                    "field": "user_email",
                    "type": "string",
                    "helper_text": "Email of the user",
                },
                {
                    "field": "avatar_url",
                    "type": "string",
                    "helper_text": "Avatar URL of the user",
                },
                {
                    "field": "html_url",
                    "type": "string",
                    "helper_text": "Profile URL of the user",
                },
                {"field": "bio", "type": "string", "helper_text": "Bio of the user"},
                {
                    "field": "location",
                    "type": "string",
                    "helper_text": "Location of the user",
                },
                {
                    "field": "company",
                    "type": "string",
                    "helper_text": "Company of the user",
                },
                {
                    "field": "blog",
                    "type": "string",
                    "helper_text": "Blog URL of the user",
                },
                {
                    "field": "user_details",
                    "type": "vec<string>",
                    "helper_text": "User details in JSON format",
                },
            ],
            "name": "read_user",
            "task_name": "tasks.github.read_user",
            "description": "Read details of a GitHub user",
            "label": "Read User",
            "variant": "default_integration_nodes",
        },
        "get_organization_members**(*)**(*)": {
            "inputs": [
                {
                    "field": "organization",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the organization",
                    "label": "Organization",
                    "placeholder": "mycompany",
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter members by role",
                    "label": "Filter",
                    "placeholder": "all",
                },
                {
                    "field": "role",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by member role",
                    "label": "Role",
                    "placeholder": "member",
                },
            ],
            "outputs": [
                {
                    "field": "user_ids",
                    "type": "vec<string>",
                    "helper_text": "List of user IDs",
                },
                {
                    "field": "usernames",
                    "type": "vec<string>",
                    "helper_text": "List of usernames",
                },
                {
                    "field": "user_names",
                    "type": "vec<string>",
                    "helper_text": "List of display names",
                },
                {
                    "field": "user_emails",
                    "type": "vec<string>",
                    "helper_text": "List of user emails",
                },
                {
                    "field": "avatar_urls",
                    "type": "vec<string>",
                    "helper_text": "List of avatar URLs",
                },
                {
                    "field": "html_urls",
                    "type": "vec<string>",
                    "helper_text": "List of profile URLs",
                },
                {
                    "field": "user_types",
                    "type": "vec<string>",
                    "helper_text": "List of user types",
                },
                {
                    "field": "member_roles",
                    "type": "vec<string>",
                    "helper_text": "List of member roles",
                },
                {
                    "field": "user_details",
                    "type": "vec<string>",
                    "helper_text": "User details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_organization_members",
            "task_name": "tasks.github.get_organization_members",
            "description": "Get a list of organization members from GitHub",
            "label": "Get Organization Members",
        },
        "get_organization_members**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Members",
                    "helper_text": "Specify the number of members to fetch",
                }
            ],
            "outputs": [],
        },
        "get_organization_members**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_organization_members**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_organization_members**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_webhook**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "webhook_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the webhook",
                    "label": "Webhook Name",
                    "placeholder": "web",
                },
                {
                    "field": "webhook_url",
                    "type": "string",
                    "value": "",
                    "helper_text": "URL to send webhook payloads to",
                    "label": "Webhook URL",
                    "placeholder": "https://example.com/webhook",
                },
                {
                    "field": "webhook_events",
                    "type": "string",
                    "value": "",
                    "helper_text": "Events to trigger webhook (comma-separated)",
                    "label": "Events",
                    "placeholder": "push,pull_request",
                },
                {
                    "field": "webhook_secret",
                    "type": "string",
                    "value": "",
                    "helper_text": "Secret key for webhook security",
                    "label": "Secret",
                    "placeholder": "mysecret",
                },
                {
                    "field": "webhook_active",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Whether the webhook is active",
                    "label": "Active",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "value": "",
                    "helper_text": "Content type for webhook payloads",
                    "label": "Content Type",
                    "placeholder": "json",
                },
                {
                    "field": "insecure_ssl",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Allow insecure SSL",
                    "label": "Insecure SSL",
                },
            ],
            "outputs": [
                {
                    "field": "webhook_id",
                    "type": "string",
                    "helper_text": "ID of the created webhook",
                },
                {
                    "field": "webhook_name",
                    "type": "string",
                    "helper_text": "Name of the created webhook",
                },
                {
                    "field": "webhook_url",
                    "type": "string",
                    "helper_text": "URL of the created webhook",
                },
                {
                    "field": "webhook_events",
                    "type": "vec<string>",
                    "helper_text": "List of webhook events",
                },
                {
                    "field": "webhook_active",
                    "type": "bool",
                    "helper_text": "Whether the webhook is active",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "webhook_details",
                    "type": "vec<string>",
                    "helper_text": "Webhook details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_webhook",
            "task_name": "tasks.github.create_webhook",
            "description": "Create a new webhook on GitHub",
            "label": "Create Webhook",
        },
        "update_webhook**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "webhook_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the webhook to update",
                    "label": "Webhook ID",
                    "placeholder": "123456",
                },
                {
                    "field": "update_webhook_url",
                    "type": "string",
                    "value": "",
                    "helper_text": "New URL for webhook payloads",
                    "label": "New Webhook URL",
                    "placeholder": "https://example.com/new-webhook",
                },
                {
                    "field": "update_webhook_events",
                    "type": "string",
                    "value": "",
                    "helper_text": "New events to trigger webhook",
                    "label": "New Events",
                    "placeholder": "push,issues",
                },
                {
                    "field": "update_webhook_secret",
                    "type": "string",
                    "value": "",
                    "helper_text": "New secret key for webhook",
                    "label": "New Secret",
                    "placeholder": "newsecret",
                },
                {
                    "field": "update_webhook_active",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Update webhook active status",
                    "label": "Active",
                },
                {
                    "field": "update_content_type",
                    "type": "string",
                    "value": "",
                    "helper_text": "New content type",
                    "label": "New Content Type",
                    "placeholder": "form",
                },
                {
                    "field": "update_insecure_ssl",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Update insecure SSL setting",
                    "label": "Insecure SSL",
                },
            ],
            "outputs": [
                {
                    "field": "webhook_id",
                    "type": "string",
                    "helper_text": "ID of the updated webhook",
                },
                {
                    "field": "webhook_name",
                    "type": "string",
                    "helper_text": "Name of the updated webhook",
                },
                {
                    "field": "webhook_url",
                    "type": "string",
                    "helper_text": "URL of the updated webhook",
                },
                {
                    "field": "webhook_events",
                    "type": "vec<string>",
                    "helper_text": "List of webhook events",
                },
                {
                    "field": "webhook_active",
                    "type": "bool",
                    "helper_text": "Whether the webhook is active",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Update timestamp",
                },
                {
                    "field": "webhook_details",
                    "type": "vec<string>",
                    "helper_text": "Webhook details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_webhook",
            "task_name": "tasks.github.update_webhook",
            "description": "Update an existing webhook on GitHub",
            "label": "Update Webhook",
        },
        "read_webhook**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "webhook_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the webhook to read",
                    "label": "Webhook ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "webhook_id",
                    "type": "string",
                    "helper_text": "ID of the webhook",
                },
                {
                    "field": "webhook_name",
                    "type": "string",
                    "helper_text": "Name of the webhook",
                },
                {
                    "field": "webhook_url",
                    "type": "string",
                    "helper_text": "URL of the webhook",
                },
                {
                    "field": "webhook_events",
                    "type": "vec<string>",
                    "helper_text": "List of webhook events",
                },
                {
                    "field": "webhook_active",
                    "type": "bool",
                    "helper_text": "Whether the webhook is active",
                },
                {
                    "field": "webhook_config",
                    "type": "string",
                    "helper_text": "Webhook configuration details",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Last update timestamp",
                },
                {
                    "field": "ping_url",
                    "type": "string",
                    "helper_text": "Ping URL for the webhook",
                },
                {
                    "field": "test_url",
                    "type": "string",
                    "helper_text": "Test URL for the webhook",
                },
                {
                    "field": "webhook_details",
                    "type": "vec<string>",
                    "helper_text": "Webhook details in JSON format",
                },
            ],
            "name": "read_webhook",
            "task_name": "tasks.github.read_webhook",
            "description": "Read details of a GitHub webhook",
            "label": "Read Webhook",
            "variant": "common_integration_nodes",
        },
        "get_webhooks**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
            ],
            "outputs": [
                {
                    "field": "webhook_ids",
                    "type": "vec<string>",
                    "helper_text": "List of webhook IDs",
                },
                {
                    "field": "webhook_names",
                    "type": "vec<string>",
                    "helper_text": "List of webhook names",
                },
                {
                    "field": "webhook_urls",
                    "type": "vec<string>",
                    "helper_text": "List of webhook URLs",
                },
                {
                    "field": "webhook_events",
                    "type": "vec<string>",
                    "helper_text": "List of webhook events",
                },
                {
                    "field": "webhook_active_flags",
                    "type": "vec<string>",
                    "helper_text": "List of webhook active flags",
                },
                {
                    "field": "webhook_configs",
                    "type": "vec<string>",
                    "helper_text": "List of webhook configurations",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of creation dates",
                },
                {
                    "field": "updated_dates",
                    "type": "vec<string>",
                    "helper_text": "List of update dates",
                },
                {
                    "field": "ping_urls",
                    "type": "vec<string>",
                    "helper_text": "List of ping URLs",
                },
                {
                    "field": "test_urls",
                    "type": "vec<string>",
                    "helper_text": "List of test URLs",
                },
                {
                    "field": "webhook_details",
                    "type": "vec<string>",
                    "helper_text": "Webhook details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_webhooks",
            "task_name": "tasks.github.get_webhooks",
            "description": "Get a list of webhooks from GitHub",
            "label": "Get Webhooks",
        },
        "get_webhooks**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Webhooks",
                    "helper_text": "Specify the number of webhooks to fetch",
                }
            ],
            "outputs": [],
        },
        "get_webhooks**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_webhooks**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_webhooks**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "delete_webhook**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "webhook_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the webhook to delete",
                    "label": "Webhook ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the webhook was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "webhook_id",
                    "type": "string",
                    "helper_text": "ID of the deleted webhook",
                },
            ],
            "name": "delete_webhook",
            "task_name": "tasks.github.delete_webhook",
            "description": "Delete a GitHub webhook",
            "label": "Delete Webhook",
            "variant": "common_integration_nodes",
        },
        "ping_webhook**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "webhook_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the webhook to ping",
                    "label": "Webhook ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the webhook ping was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Response message",
                },
                {
                    "field": "delivery_id",
                    "type": "string",
                    "helper_text": "ID of the delivery",
                },
                {
                    "field": "webhook_details",
                    "type": "vec<string>",
                    "helper_text": "Webhook response details",
                },
            ],
            "name": "ping_webhook",
            "task_name": "tasks.github.ping_webhook",
            "description": "Ping a GitHub webhook",
            "label": "Ping Webhook",
            "variant": "common_integration_nodes",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        affiliation: str = "",
        assignee: str = "",
        assignees: str = "",
        author_email: str = "",
        author_name: str = "",
        auto_init: bool = True,
        base: str = "",
        branch_name: str = "",
        comment_body: str = "",
        comment_id: int = 0,
        commit_message: str = "",
        commit_title: str = "",
        committer_email: str = "",
        committer_name: str = "",
        content_type: str = "",
        creator: str = "",
        delete_author_email: str = "",
        delete_author_name: str = "",
        delete_branch_name: str = "",
        delete_commit_message: str = "",
        delete_committer_email: str = "",
        delete_committer_name: str = "",
        delete_file_sha: str = "",
        direction: str = "",
        draft: bool = False,
        exact_date: Any = {"start": "", "end": ""},
        file_content: str = "",
        file_path: str = "",
        file_sha: str = "",
        filter: str = "",
        generate_release_notes: bool = False,
        gitignore_template: str = "",
        head: str = "",
        homepage: str = "",
        insecure_ssl: bool = False,
        is_private: bool = False,
        issue_body: str = "",
        issue_number: int = 0,
        issue_title: str = "",
        labels: str = "",
        license_template: str = "",
        maintainer_can_modify: bool = True,
        mentioned: str = "",
        merge_method: str = "",
        milestone: int = 0,
        num_messages: int = 10,
        organization: str = "",
        owner: str = "",
        prerelease: bool = False,
        protected: bool = False,
        pull_request_body: str = "",
        pull_request_number: int = 0,
        pull_request_title: str = "",
        ref: str = "",
        release_body: str = "",
        release_id: int = 0,
        release_name: str = "",
        repository_description: str = "",
        repository_name: str = "",
        role: str = "",
        sha: str = "",
        sort: str = "",
        source_branch: str = "",
        state: str = "",
        tag_name: str = "",
        target_commitish: str = "",
        type: str = "",
        update_assignees: str = "",
        update_author_email: str = "",
        update_author_name: str = "",
        update_base: str = "",
        update_branch_name: str = "",
        update_comment_body: str = "",
        update_commit_message: str = "",
        update_committer_email: str = "",
        update_committer_name: str = "",
        update_content_type: str = "",
        update_draft: bool = False,
        update_file_content: str = "",
        update_has_issues: bool = True,
        update_has_projects: bool = True,
        update_has_wiki: bool = True,
        update_homepage: str = "",
        update_insecure_ssl: bool = False,
        update_is_private: bool = False,
        update_issue_body: str = "",
        update_issue_state: str = "",
        update_issue_title: str = "",
        update_labels: str = "",
        update_maintainer_can_modify: bool = True,
        update_milestone: int = 0,
        update_prerelease: bool = False,
        update_pull_request_body: str = "",
        update_pull_request_state: str = "",
        update_pull_request_title: str = "",
        update_release_body: str = "",
        update_release_name: str = "",
        update_repository_description: str = "",
        update_repository_name: str = "",
        update_tag_name: str = "",
        update_target_commitish: str = "",
        update_webhook_active: bool = True,
        update_webhook_events: str = "",
        update_webhook_secret: str = "",
        update_webhook_url: str = "",
        username: str = "",
        visibility: str = "",
        webhook_active: bool = True,
        webhook_events: str = "",
        webhook_id: int = 0,
        webhook_name: str = "",
        webhook_secret: str = "",
        webhook_url: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_github",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if repository_name is not None:
            self.inputs["repository_name"] = repository_name
        if repository_description is not None:
            self.inputs["repository_description"] = repository_description
        if is_private is not None:
            self.inputs["is_private"] = is_private
        if auto_init is not None:
            self.inputs["auto_init"] = auto_init
        if gitignore_template is not None:
            self.inputs["gitignore_template"] = gitignore_template
        if license_template is not None:
            self.inputs["license_template"] = license_template
        if homepage is not None:
            self.inputs["homepage"] = homepage
        if owner is not None:
            self.inputs["owner"] = owner
        if update_repository_name is not None:
            self.inputs["update_repository_name"] = update_repository_name
        if update_repository_description is not None:
            self.inputs["update_repository_description"] = update_repository_description
        if update_homepage is not None:
            self.inputs["update_homepage"] = update_homepage
        if update_is_private is not None:
            self.inputs["update_is_private"] = update_is_private
        if update_has_issues is not None:
            self.inputs["update_has_issues"] = update_has_issues
        if update_has_projects is not None:
            self.inputs["update_has_projects"] = update_has_projects
        if update_has_wiki is not None:
            self.inputs["update_has_wiki"] = update_has_wiki
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if type is not None:
            self.inputs["type"] = type
        if sort is not None:
            self.inputs["sort"] = sort
        if direction is not None:
            self.inputs["direction"] = direction
        if visibility is not None:
            self.inputs["visibility"] = visibility
        if affiliation is not None:
            self.inputs["affiliation"] = affiliation
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if issue_title is not None:
            self.inputs["issue_title"] = issue_title
        if issue_body is not None:
            self.inputs["issue_body"] = issue_body
        if assignees is not None:
            self.inputs["assignees"] = assignees
        if milestone is not None:
            self.inputs["milestone"] = milestone
        if labels is not None:
            self.inputs["labels"] = labels
        if issue_number is not None:
            self.inputs["issue_number"] = issue_number
        if update_issue_title is not None:
            self.inputs["update_issue_title"] = update_issue_title
        if update_issue_body is not None:
            self.inputs["update_issue_body"] = update_issue_body
        if update_issue_state is not None:
            self.inputs["update_issue_state"] = update_issue_state
        if update_assignees is not None:
            self.inputs["update_assignees"] = update_assignees
        if update_milestone is not None:
            self.inputs["update_milestone"] = update_milestone
        if update_labels is not None:
            self.inputs["update_labels"] = update_labels
        if state is not None:
            self.inputs["state"] = state
        if assignee is not None:
            self.inputs["assignee"] = assignee
        if creator is not None:
            self.inputs["creator"] = creator
        if mentioned is not None:
            self.inputs["mentioned"] = mentioned
        if pull_request_title is not None:
            self.inputs["pull_request_title"] = pull_request_title
        if head is not None:
            self.inputs["head"] = head
        if base is not None:
            self.inputs["base"] = base
        if pull_request_body is not None:
            self.inputs["pull_request_body"] = pull_request_body
        if draft is not None:
            self.inputs["draft"] = draft
        if maintainer_can_modify is not None:
            self.inputs["maintainer_can_modify"] = maintainer_can_modify
        if pull_request_number is not None:
            self.inputs["pull_request_number"] = pull_request_number
        if update_pull_request_title is not None:
            self.inputs["update_pull_request_title"] = update_pull_request_title
        if update_pull_request_body is not None:
            self.inputs["update_pull_request_body"] = update_pull_request_body
        if update_pull_request_state is not None:
            self.inputs["update_pull_request_state"] = update_pull_request_state
        if update_base is not None:
            self.inputs["update_base"] = update_base
        if update_maintainer_can_modify is not None:
            self.inputs["update_maintainer_can_modify"] = update_maintainer_can_modify
        if commit_title is not None:
            self.inputs["commit_title"] = commit_title
        if commit_message is not None:
            self.inputs["commit_message"] = commit_message
        if sha is not None:
            self.inputs["sha"] = sha
        if merge_method is not None:
            self.inputs["merge_method"] = merge_method
        if comment_body is not None:
            self.inputs["comment_body"] = comment_body
        if comment_id is not None:
            self.inputs["comment_id"] = comment_id
        if update_comment_body is not None:
            self.inputs["update_comment_body"] = update_comment_body
        if tag_name is not None:
            self.inputs["tag_name"] = tag_name
        if release_name is not None:
            self.inputs["release_name"] = release_name
        if release_body is not None:
            self.inputs["release_body"] = release_body
        if target_commitish is not None:
            self.inputs["target_commitish"] = target_commitish
        if prerelease is not None:
            self.inputs["prerelease"] = prerelease
        if generate_release_notes is not None:
            self.inputs["generate_release_notes"] = generate_release_notes
        if release_id is not None:
            self.inputs["release_id"] = release_id
        if update_tag_name is not None:
            self.inputs["update_tag_name"] = update_tag_name
        if update_release_name is not None:
            self.inputs["update_release_name"] = update_release_name
        if update_release_body is not None:
            self.inputs["update_release_body"] = update_release_body
        if update_target_commitish is not None:
            self.inputs["update_target_commitish"] = update_target_commitish
        if update_draft is not None:
            self.inputs["update_draft"] = update_draft
        if update_prerelease is not None:
            self.inputs["update_prerelease"] = update_prerelease
        if file_path is not None:
            self.inputs["file_path"] = file_path
        if file_content is not None:
            self.inputs["file_content"] = file_content
        if branch_name is not None:
            self.inputs["branch_name"] = branch_name
        if committer_name is not None:
            self.inputs["committer_name"] = committer_name
        if committer_email is not None:
            self.inputs["committer_email"] = committer_email
        if author_name is not None:
            self.inputs["author_name"] = author_name
        if author_email is not None:
            self.inputs["author_email"] = author_email
        if update_file_content is not None:
            self.inputs["update_file_content"] = update_file_content
        if update_commit_message is not None:
            self.inputs["update_commit_message"] = update_commit_message
        if update_branch_name is not None:
            self.inputs["update_branch_name"] = update_branch_name
        if file_sha is not None:
            self.inputs["file_sha"] = file_sha
        if update_committer_name is not None:
            self.inputs["update_committer_name"] = update_committer_name
        if update_committer_email is not None:
            self.inputs["update_committer_email"] = update_committer_email
        if update_author_name is not None:
            self.inputs["update_author_name"] = update_author_name
        if update_author_email is not None:
            self.inputs["update_author_email"] = update_author_email
        if ref is not None:
            self.inputs["ref"] = ref
        if delete_commit_message is not None:
            self.inputs["delete_commit_message"] = delete_commit_message
        if delete_branch_name is not None:
            self.inputs["delete_branch_name"] = delete_branch_name
        if delete_file_sha is not None:
            self.inputs["delete_file_sha"] = delete_file_sha
        if delete_committer_name is not None:
            self.inputs["delete_committer_name"] = delete_committer_name
        if delete_committer_email is not None:
            self.inputs["delete_committer_email"] = delete_committer_email
        if delete_author_name is not None:
            self.inputs["delete_author_name"] = delete_author_name
        if delete_author_email is not None:
            self.inputs["delete_author_email"] = delete_author_email
        if source_branch is not None:
            self.inputs["source_branch"] = source_branch
        if protected is not None:
            self.inputs["protected"] = protected
        if username is not None:
            self.inputs["username"] = username
        if organization is not None:
            self.inputs["organization"] = organization
        if filter is not None:
            self.inputs["filter"] = filter
        if role is not None:
            self.inputs["role"] = role
        if webhook_name is not None:
            self.inputs["webhook_name"] = webhook_name
        if webhook_url is not None:
            self.inputs["webhook_url"] = webhook_url
        if webhook_events is not None:
            self.inputs["webhook_events"] = webhook_events
        if webhook_secret is not None:
            self.inputs["webhook_secret"] = webhook_secret
        if webhook_active is not None:
            self.inputs["webhook_active"] = webhook_active
        if content_type is not None:
            self.inputs["content_type"] = content_type
        if insecure_ssl is not None:
            self.inputs["insecure_ssl"] = insecure_ssl
        if webhook_id is not None:
            self.inputs["webhook_id"] = webhook_id
        if update_webhook_url is not None:
            self.inputs["update_webhook_url"] = update_webhook_url
        if update_webhook_events is not None:
            self.inputs["update_webhook_events"] = update_webhook_events
        if update_webhook_secret is not None:
            self.inputs["update_webhook_secret"] = update_webhook_secret
        if update_webhook_active is not None:
            self.inputs["update_webhook_active"] = update_webhook_active
        if update_content_type is not None:
            self.inputs["update_content_type"] = update_content_type
        if update_insecure_ssl is not None:
            self.inputs["update_insecure_ssl"] = update_insecure_ssl
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def additions_count(self) -> str:
        """
        Number of additions

        Available: When action = 'read_pull_request'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("additions_count")

    @property
    def assets_details(self) -> List[str]:
        """
        Release assets details

        Different behavior based on configuration:
          - Release assets details (When action = 'read_release')
          - List of assets details (When action = 'get_releases')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assets_details")

    @property
    def assignees(self) -> List[str]:
        """
        List of assignees

        Available: When action = 'create_issue', When action = 'update_issue', When action = 'read_issue', When action = 'read_pull_request'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignees")

    @property
    def assignees_details(self) -> List[str]:
        """
        List of assignee details

        Available: When action = 'get_issues', When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignees_details")

    @property
    def author(self) -> str:
        """
        Issue author details

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("author")

    @property
    def author_details(self) -> List[str]:
        """
        List of author details

        Different behavior based on configuration:
          - List of author details (When action = 'get_issues', When action = 'get_releases')
          - Comment author details (When action = 'create_issue_comment', When action = 'update_issue_comment', When action = 'read_issue_comment')
          - List of comment author details (When action = 'get_issue_comments')
          - Release author details (When action = 'read_release')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("author_details")

    @property
    def avatar_url(self) -> str:
        """
        Avatar URL of the user

        Available: When action = 'read_user'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("avatar_url")

    @property
    def avatar_urls(self) -> List[str]:
        """
        List of avatar URLs

        Available: When action = 'get_organization_members'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("avatar_urls")

    @property
    def base_details(self) -> str:
        """
        Base branch details

        Different behavior based on configuration:
          - Base branch details (When action = 'read_pull_request')
          - List of base branch details (When action = 'get_pull_requests')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("base_details")

    @property
    def bio(self) -> str:
        """
        Bio of the user

        Available: When action = 'read_user'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("bio")

    @property
    def blog(self) -> str:
        """
        Blog URL of the user

        Available: When action = 'read_user'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("blog")

    @property
    def branch_details(self) -> List[str]:
        """
        Branch details in JSON format

        Available: When action = 'create_branch', When action = 'read_branch', When action = 'get_branches'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("branch_details")

    @property
    def branch_name(self) -> str:
        """
        Name of the created branch

        Different behavior based on configuration:
          - Name of the created branch (When action = 'create_branch')
          - Name of the branch (When action = 'read_branch')
          - Name of the deleted branch (When action = 'delete_branch')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("branch_name")

    @property
    def branch_names(self) -> List[str]:
        """
        List of branch names

        Available: When action = 'get_branches'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("branch_names")

    @property
    def changed_files_count(self) -> str:
        """
        Number of changed files

        Available: When action = 'read_pull_request'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("changed_files_count")

    @property
    def clone_url(self) -> str:
        """
        Clone URL for the repository

        Available: When action = 'create_repository', When action = 'read_repository'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("clone_url")

    @property
    def clone_urls(self) -> List[str]:
        """
        List of clone URLs

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("clone_urls")

    @property
    def closed_at(self) -> str:
        """
        Closure timestamp

        Available: When action = 'read_issue', When action = 'read_pull_request'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("closed_at")

    @property
    def closed_dates(self) -> List[str]:
        """
        List of closure dates

        Available: When action = 'get_issues', When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("closed_dates")

    @property
    def comment_bodies(self) -> List[str]:
        """
        List of comment bodies

        Available: When action = 'get_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_bodies")

    @property
    def comment_body(self) -> str:
        """
        Body of the created comment

        Different behavior based on configuration:
          - Body of the created comment (When action = 'create_issue_comment')
          - Body of the updated comment (When action = 'update_issue_comment')
          - Body of the comment (When action = 'read_issue_comment')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_body")

    @property
    def comment_details(self) -> List[str]:
        """
        Comment details in JSON format

        Available: When action = 'create_issue_comment', When action = 'update_issue_comment', When action = 'read_issue_comment', When action = 'get_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_details")

    @property
    def comment_id(self) -> str:
        """
        ID of the created comment

        Different behavior based on configuration:
          - ID of the created comment (When action = 'create_issue_comment')
          - ID of the updated comment (When action = 'update_issue_comment')
          - ID of the comment (When action = 'read_issue_comment')
          - ID of the deleted comment (When action = 'delete_issue_comment')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_id")

    @property
    def comment_ids(self) -> List[str]:
        """
        List of comment IDs

        Available: When action = 'get_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_ids")

    @property
    def comment_url(self) -> str:
        """
        URL of the created comment

        Different behavior based on configuration:
          - URL of the created comment (When action = 'create_issue_comment')
          - URL of the updated comment (When action = 'update_issue_comment')
          - URL of the comment (When action = 'read_issue_comment')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_url")

    @property
    def comment_urls(self) -> List[str]:
        """
        List of comment URLs

        Available: When action = 'get_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_urls")

    @property
    def comments_count(self) -> str:
        """
        Number of comments

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comments_count")

    @property
    def comments_counts(self) -> List[str]:
        """
        List of comment counts

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comments_counts")

    @property
    def commit_author(self) -> str:
        """
        Author of the latest commit

        Available: When action = 'read_branch'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("commit_author")

    @property
    def commit_authors(self) -> List[str]:
        """
        List of commit authors

        Available: When action = 'get_branches'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("commit_authors")

    @property
    def commit_committer(self) -> str:
        """
        Committer of the latest commit

        Available: When action = 'read_branch'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("commit_committer")

    @property
    def commit_committers(self) -> List[str]:
        """
        List of commit committers

        Available: When action = 'get_branches'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("commit_committers")

    @property
    def commit_date(self) -> str:
        """
        Date of the latest commit

        Available: When action = 'read_branch'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("commit_date")

    @property
    def commit_dates(self) -> List[str]:
        """
        List of commit dates

        Available: When action = 'get_branches'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("commit_dates")

    @property
    def commit_message(self) -> str:
        """
        Message of the latest commit

        Available: When action = 'read_branch'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("commit_message")

    @property
    def commit_messages(self) -> List[str]:
        """
        List of commit messages

        Available: When action = 'get_branches'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("commit_messages")

    @property
    def commit_sha(self) -> str:
        """
        SHA of the commit

        Available: When action = 'create_file', When action = 'update_file', When action = 'delete_file'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("commit_sha")

    @property
    def commit_shas(self) -> List[str]:
        """
        List of commit SHAs

        Available: When action = 'get_branches'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("commit_shas")

    @property
    def commit_url(self) -> str:
        """
        URL of the latest commit

        Available: When action = 'read_branch'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("commit_url")

    @property
    def commit_urls(self) -> List[str]:
        """
        List of commit URLs

        Available: When action = 'get_branches'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("commit_urls")

    @property
    def commits_count(self) -> str:
        """
        Number of commits

        Available: When action = 'read_pull_request'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("commits_count")

    @property
    def company(self) -> str:
        """
        Company of the user

        Available: When action = 'read_user'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("company")

    @property
    def created_at(self) -> str:
        """
        Creation timestamp

        Available: When action = 'create_repository', When action = 'read_repository', When action = 'create_issue', When action = 'read_issue', When action = 'create_pull_request', When action = 'read_pull_request', When action = 'create_issue_comment', When action = 'read_issue_comment', When action = 'create_release', When action = 'read_release', When action = 'create_webhook', When action = 'read_webhook'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_at")

    @property
    def created_dates(self) -> List[str]:
        """
        List of creation dates

        Available: When action = 'get_repositories', When action = 'get_issues', When action = 'get_pull_requests', When action = 'get_issue_comments', When action = 'get_releases', When action = 'get_webhooks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_dates")

    @property
    def default_branch(self) -> str:
        """
        Default branch name

        Available: When action = 'read_repository'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("default_branch")

    @property
    def default_branches(self) -> List[str]:
        """
        List of default branch names

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("default_branches")

    @property
    def deletions_count(self) -> str:
        """
        Number of deletions

        Available: When action = 'read_pull_request'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("deletions_count")

    @property
    def delivery_id(self) -> str:
        """
        ID of the delivery

        Available: When action = 'ping_webhook'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("delivery_id")

    @property
    def download_url(self) -> str:
        """
        Download URL of the file

        Available: When action = 'create_file', When action = 'update_file', When action = 'read_file'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("download_url")

    @property
    def draft(self) -> bool:
        """
        Whether the pull request is a draft

        Different behavior based on configuration:
          - Whether the pull request is a draft (When action = 'create_pull_request', When action = 'read_pull_request')
          - Whether the release is a draft (When action = 'create_release', When action = 'read_release')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("draft")

    @property
    def draft_flags(self) -> List[str]:
        """
        List of draft flags

        Available: When action = 'get_pull_requests', When action = 'get_releases'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("draft_flags")

    @property
    def encoding(self) -> str:
        """
        Encoding of the file

        Available: When action = 'read_file'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("encoding")

    @property
    def file_content(self) -> str:
        """
        Content of the file

        Available: When action = 'read_file'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_content")

    @property
    def file_details(self) -> List[str]:
        """
        File details in JSON format

        Available: When action = 'create_file', When action = 'update_file', When action = 'read_file'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_details")

    @property
    def file_name(self) -> str:
        """
        Name of the file

        Available: When action = 'read_file'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_name")

    @property
    def file_path(self) -> str:
        """
        Path of the created file

        Different behavior based on configuration:
          - Path of the created file (When action = 'create_file')
          - Path of the updated file (When action = 'update_file')
          - Path of the file (When action = 'read_file')
          - Path of the deleted file (When action = 'delete_file')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_path")

    @property
    def file_sha(self) -> str:
        """
        SHA of the file

        Available: When action = 'read_file'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_sha")

    @property
    def file_size(self) -> str:
        """
        Size of the file in bytes

        Available: When action = 'read_file'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_size")

    @property
    def file_type(self) -> str:
        """
        Type of the file

        Available: When action = 'read_file'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_type")

    @property
    def file_url(self) -> str:
        """
        URL of the created file

        Different behavior based on configuration:
          - URL of the created file (When action = 'create_file')
          - URL of the updated file (When action = 'update_file')
          - URL of the file (When action = 'read_file')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_url")

    @property
    def forks_count(self) -> str:
        """
        Number of forks

        Available: When action = 'read_repository'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("forks_count")

    @property
    def forks_counts(self) -> List[str]:
        """
        List of fork counts

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("forks_counts")

    @property
    def git_url(self) -> str:
        """
        Git URL of the file

        Available: When action = 'read_file'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("git_url")

    @property
    def head_details(self) -> str:
        """
        Head branch details

        Different behavior based on configuration:
          - Head branch details (When action = 'read_pull_request')
          - List of head branch details (When action = 'get_pull_requests')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("head_details")

    @property
    def html_url(self) -> str:
        """
        HTML URL of the file

        Different behavior based on configuration:
          - HTML URL of the file (When action = 'read_file')
          - Profile URL of the user (When action = 'read_user')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("html_url")

    @property
    def html_urls(self) -> List[str]:
        """
        List of profile URLs

        Available: When action = 'get_organization_members'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("html_urls")

    @property
    def is_fork(self) -> bool:
        """
        Whether the repository is a fork

        Available: When action = 'read_repository'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("is_fork")

    @property
    def is_private(self) -> bool:
        """
        Whether the repository is private

        Available: When action = 'create_repository', When action = 'read_repository'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("is_private")

    @property
    def is_private_flags(self) -> List[str]:
        """
        List of privacy flags

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("is_private_flags")

    @property
    def issue_bodies(self) -> List[str]:
        """
        List of issue bodies

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_bodies")

    @property
    def issue_body(self) -> str:
        """
        Body of the issue

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_body")

    @property
    def issue_details(self) -> List[str]:
        """
        Issue details in JSON format

        Available: When action = 'create_issue', When action = 'update_issue', When action = 'read_issue', When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_details")

    @property
    def issue_id(self) -> str:
        """
        ID of the created issue

        Different behavior based on configuration:
          - ID of the created issue (When action = 'create_issue')
          - ID of the updated issue (When action = 'update_issue')
          - ID of the issue (When action = 'read_issue')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_id")

    @property
    def issue_ids(self) -> List[str]:
        """
        List of issue IDs

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_ids")

    @property
    def issue_number(self) -> str:
        """
        Number of the created issue

        Different behavior based on configuration:
          - Number of the created issue (When action = 'create_issue')
          - Number of the updated issue (When action = 'update_issue')
          - Number of the issue (When action = 'read_issue')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_number")

    @property
    def issue_numbers(self) -> List[str]:
        """
        List of issue numbers

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_numbers")

    @property
    def issue_state(self) -> str:
        """
        State of the created issue

        Different behavior based on configuration:
          - State of the created issue (When action = 'create_issue')
          - State of the updated issue (When action = 'update_issue')
          - State of the issue (When action = 'read_issue')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_state")

    @property
    def issue_states(self) -> List[str]:
        """
        List of issue states

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_states")

    @property
    def issue_title(self) -> str:
        """
        Title of the created issue

        Different behavior based on configuration:
          - Title of the created issue (When action = 'create_issue')
          - Title of the updated issue (When action = 'update_issue')
          - Title of the issue (When action = 'read_issue')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_title")

    @property
    def issue_titles(self) -> List[str]:
        """
        List of issue titles

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_titles")

    @property
    def issue_url(self) -> str:
        """
        URL of the created issue

        Different behavior based on configuration:
          - URL of the created issue (When action = 'create_issue')
          - URL of the updated issue (When action = 'update_issue')
          - URL of the issue (When action = 'read_issue')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_url")

    @property
    def issue_urls(self) -> List[str]:
        """
        List of issue URLs

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_urls")

    @property
    def labels(self) -> List[str]:
        """
        List of labels

        Available: When action = 'create_issue', When action = 'update_issue', When action = 'read_issue', When action = 'read_pull_request'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("labels")

    @property
    def labels_details(self) -> List[str]:
        """
        List of label details

        Available: When action = 'get_issues', When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("labels_details")

    @property
    def language(self) -> str:
        """
        Primary programming language

        Available: When action = 'read_repository'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("language")

    @property
    def languages(self) -> List[str]:
        """
        List of primary languages

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("languages")

    @property
    def location(self) -> str:
        """
        Location of the user

        Available: When action = 'read_user'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("location")

    @property
    def member_roles(self) -> List[str]:
        """
        List of member roles

        Available: When action = 'get_organization_members'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("member_roles")

    @property
    def mergeable(self) -> bool:
        """
        Whether the pull request is mergeable

        Available: When action = 'read_pull_request'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("mergeable")

    @property
    def mergeable_flags(self) -> List[str]:
        """
        List of mergeable flags

        Available: When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("mergeable_flags")

    @property
    def merged(self) -> bool:
        """
        Whether the pull request is merged

        Different behavior based on configuration:
          - Whether the pull request is merged (When action = 'read_pull_request')
          - Whether the pull request was merged (When action = 'merge_pull_request')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("merged")

    @property
    def merged_at(self) -> str:
        """
        Merge timestamp

        Available: When action = 'read_pull_request'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("merged_at")

    @property
    def merged_dates(self) -> List[str]:
        """
        List of merge dates

        Available: When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("merged_dates")

    @property
    def merged_flags(self) -> List[str]:
        """
        List of merged flags

        Available: When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("merged_flags")

    @property
    def message(self) -> str:
        """
        Success message

        Different behavior based on configuration:
          - Success message (When action = 'delete_repository', When action = 'delete_issue_comment', When action = 'delete_release', When action = 'delete_file', When action = 'delete_branch', When action = 'delete_webhook')
          - Merge result message (When action = 'merge_pull_request')
          - Response message (When action = 'ping_webhook')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("message")

    @property
    def milestone(self) -> str:
        """
        Milestone details

        Available: When action = 'create_issue', When action = 'update_issue', When action = 'read_issue', When action = 'read_pull_request'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("milestone")

    @property
    def milestone_details(self) -> List[str]:
        """
        List of milestone details

        Available: When action = 'get_issues', When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("milestone_details")

    @property
    def open_issues_count(self) -> str:
        """
        Number of open issues

        Available: When action = 'read_repository'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("open_issues_count")

    @property
    def open_issues_counts(self) -> List[str]:
        """
        List of open issue counts

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("open_issues_counts")

    @property
    def owner_details(self) -> str:
        """
        Repository owner details

        Different behavior based on configuration:
          - Repository owner details (When action = 'read_repository')
          - List of owner details (When action = 'get_repositories')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("owner_details")

    @property
    def ping_url(self) -> str:
        """
        Ping URL for the webhook

        Available: When action = 'read_webhook'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ping_url")

    @property
    def ping_urls(self) -> List[str]:
        """
        List of ping URLs

        Available: When action = 'get_webhooks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ping_urls")

    @property
    def prerelease(self) -> bool:
        """
        Whether the release is a prerelease

        Available: When action = 'create_release', When action = 'read_release'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("prerelease")

    @property
    def prerelease_flags(self) -> List[str]:
        """
        List of prerelease flags

        Available: When action = 'get_releases'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("prerelease_flags")

    @property
    def protected(self) -> bool:
        """
        Whether the branch is protected

        Available: When action = 'read_branch'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("protected")

    @property
    def protected_flags(self) -> List[str]:
        """
        List of protection flags

        Available: When action = 'get_branches'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("protected_flags")

    @property
    def published_at(self) -> str:
        """
        Publication timestamp

        Available: When action = 'create_release', When action = 'read_release'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("published_at")

    @property
    def published_dates(self) -> List[str]:
        """
        List of publication dates

        Available: When action = 'get_releases'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("published_dates")

    @property
    def pull_request_bodies(self) -> List[str]:
        """
        List of pull request bodies

        Available: When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pull_request_bodies")

    @property
    def pull_request_body(self) -> str:
        """
        Body of the pull request

        Available: When action = 'read_pull_request'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pull_request_body")

    @property
    def pull_request_details(self) -> List[str]:
        """
        Pull request details in JSON format

        Different behavior based on configuration:
          - Pull request details in JSON format (When action = 'create_pull_request', When action = 'update_pull_request', When action = 'read_pull_request', When action = 'get_pull_requests')
          - Updated pull request details (When action = 'merge_pull_request')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pull_request_details")

    @property
    def pull_request_id(self) -> str:
        """
        ID of the created pull request

        Different behavior based on configuration:
          - ID of the created pull request (When action = 'create_pull_request')
          - ID of the updated pull request (When action = 'update_pull_request')
          - ID of the pull request (When action = 'read_pull_request')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pull_request_id")

    @property
    def pull_request_ids(self) -> List[str]:
        """
        List of pull request IDs

        Available: When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pull_request_ids")

    @property
    def pull_request_number(self) -> str:
        """
        Number of the created pull request

        Different behavior based on configuration:
          - Number of the created pull request (When action = 'create_pull_request')
          - Number of the updated pull request (When action = 'update_pull_request')
          - Number of the pull request (When action = 'read_pull_request')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pull_request_number")

    @property
    def pull_request_numbers(self) -> List[str]:
        """
        List of pull request numbers

        Available: When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pull_request_numbers")

    @property
    def pull_request_state(self) -> str:
        """
        State of the created pull request

        Different behavior based on configuration:
          - State of the created pull request (When action = 'create_pull_request')
          - State of the updated pull request (When action = 'update_pull_request')
          - State of the pull request (When action = 'read_pull_request')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pull_request_state")

    @property
    def pull_request_states(self) -> List[str]:
        """
        List of pull request states

        Available: When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pull_request_states")

    @property
    def pull_request_title(self) -> str:
        """
        Title of the created pull request

        Different behavior based on configuration:
          - Title of the created pull request (When action = 'create_pull_request')
          - Title of the updated pull request (When action = 'update_pull_request')
          - Title of the pull request (When action = 'read_pull_request')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pull_request_title")

    @property
    def pull_request_titles(self) -> List[str]:
        """
        List of pull request titles

        Available: When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pull_request_titles")

    @property
    def pull_request_url(self) -> str:
        """
        URL of the created pull request

        Different behavior based on configuration:
          - URL of the created pull request (When action = 'create_pull_request')
          - URL of the updated pull request (When action = 'update_pull_request')
          - URL of the pull request (When action = 'read_pull_request')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pull_request_url")

    @property
    def pull_request_urls(self) -> List[str]:
        """
        List of pull request URLs

        Available: When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pull_request_urls")

    @property
    def pushed_at(self) -> str:
        """
        Last push timestamp

        Available: When action = 'read_repository'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pushed_at")

    @property
    def pushed_dates(self) -> List[str]:
        """
        List of last push dates

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pushed_dates")

    @property
    def raw_data(self) -> str:
        """
        Raw API response data

        Available: When action = 'get_repositories', When action = 'get_issues', When action = 'get_pull_requests', When action = 'get_issue_comments', When action = 'get_releases', When action = 'get_branches', When action = 'get_organization_members', When action = 'get_webhooks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("raw_data")

    @property
    def ref(self) -> str:
        """
        Reference of the branch

        Available: When action = 'create_branch'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ref")

    @property
    def release_bodies(self) -> List[str]:
        """
        List of release bodies

        Available: When action = 'get_releases'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("release_bodies")

    @property
    def release_body(self) -> str:
        """
        Body of the release

        Available: When action = 'read_release'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("release_body")

    @property
    def release_details(self) -> List[str]:
        """
        Release details in JSON format

        Available: When action = 'create_release', When action = 'update_release', When action = 'read_release', When action = 'get_releases'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("release_details")

    @property
    def release_id(self) -> str:
        """
        ID of the created release

        Different behavior based on configuration:
          - ID of the created release (When action = 'create_release')
          - ID of the updated release (When action = 'update_release')
          - ID of the release (When action = 'read_release')
          - ID of the deleted release (When action = 'delete_release')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("release_id")

    @property
    def release_ids(self) -> List[str]:
        """
        List of release IDs

        Available: When action = 'get_releases'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("release_ids")

    @property
    def release_name(self) -> str:
        """
        Name of the created release

        Different behavior based on configuration:
          - Name of the created release (When action = 'create_release')
          - Name of the updated release (When action = 'update_release')
          - Name of the release (When action = 'read_release')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("release_name")

    @property
    def release_names(self) -> List[str]:
        """
        List of release names

        Available: When action = 'get_releases'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("release_names")

    @property
    def release_url(self) -> str:
        """
        URL of the created release

        Different behavior based on configuration:
          - URL of the created release (When action = 'create_release')
          - URL of the updated release (When action = 'update_release')
          - URL of the release (When action = 'read_release')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("release_url")

    @property
    def release_urls(self) -> List[str]:
        """
        List of release URLs

        Available: When action = 'get_releases'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("release_urls")

    @property
    def repository_description(self) -> str:
        """
        Description of the repository

        Available: When action = 'read_repository'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("repository_description")

    @property
    def repository_descriptions(self) -> List[str]:
        """
        List of repository descriptions

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("repository_descriptions")

    @property
    def repository_details(self) -> List[str]:
        """
        Repository details in JSON format

        Available: When action = 'create_repository', When action = 'update_repository', When action = 'read_repository', When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("repository_details")

    @property
    def repository_full_name(self) -> str:
        """
        Full name of the repository (owner/repo)

        Different behavior based on configuration:
          - Full name of the repository (owner/repo) (When action = 'create_repository')
          - Full name of the repository (When action = 'update_repository', When action = 'read_repository')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("repository_full_name")

    @property
    def repository_full_names(self) -> List[str]:
        """
        List of full repository names

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("repository_full_names")

    @property
    def repository_id(self) -> str:
        """
        ID of the created repository

        Different behavior based on configuration:
          - ID of the created repository (When action = 'create_repository')
          - ID of the repository (When action = 'update_repository', When action = 'read_repository')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("repository_id")

    @property
    def repository_ids(self) -> List[str]:
        """
        List of repository IDs

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("repository_ids")

    @property
    def repository_name(self) -> str:
        """
        Name of the created repository

        Different behavior based on configuration:
          - Name of the created repository (When action = 'create_repository')
          - Updated name of the repository (When action = 'update_repository')
          - Name of the repository (When action = 'read_repository')
          - Name of the deleted repository (When action = 'delete_repository')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("repository_name")

    @property
    def repository_names(self) -> List[str]:
        """
        List of repository names

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("repository_names")

    @property
    def repository_url(self) -> str:
        """
        URL of the repository

        Available: When action = 'create_repository', When action = 'update_repository', When action = 'read_repository'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("repository_url")

    @property
    def repository_urls(self) -> List[str]:
        """
        List of repository URLs

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("repository_urls")

    @property
    def requested_reviewers(self) -> List[str]:
        """
        List of requested reviewers

        Available: When action = 'read_pull_request'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("requested_reviewers")

    @property
    def requested_reviewers_details(self) -> List[str]:
        """
        List of requested reviewer details

        Available: When action = 'get_pull_requests'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("requested_reviewers_details")

    @property
    def sha(self) -> str:
        """
        SHA of the merge commit

        Different behavior based on configuration:
          - SHA of the merge commit (When action = 'merge_pull_request')
          - SHA of the created file (When action = 'create_file')
          - New SHA of the updated file (When action = 'update_file')
          - SHA of the branch (When action = 'create_branch')
          - SHA of the latest commit (When action = 'read_branch')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("sha")

    @property
    def ssh_url(self) -> str:
        """
        SSH URL for the repository

        Available: When action = 'create_repository', When action = 'read_repository'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ssh_url")

    @property
    def ssh_urls(self) -> List[str]:
        """
        List of SSH URLs

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ssh_urls")

    @property
    def stargazers_count(self) -> str:
        """
        Number of stars

        Available: When action = 'read_repository'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("stargazers_count")

    @property
    def stargazers_counts(self) -> List[str]:
        """
        List of star counts

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("stargazers_counts")

    @property
    def success(self) -> bool:
        """
        Whether the repository was successfully deleted

        Different behavior based on configuration:
          - Whether the repository was successfully deleted (When action = 'delete_repository')
          - Whether the comment was successfully deleted (When action = 'delete_issue_comment')
          - Whether the release was successfully deleted (When action = 'delete_release')
          - Whether the file was successfully deleted (When action = 'delete_file')
          - Whether the branch was successfully deleted (When action = 'delete_branch')
          - Whether the webhook was successfully deleted (When action = 'delete_webhook')
          - Whether the webhook ping was successful (When action = 'ping_webhook')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("success")

    @property
    def tag_name(self) -> str:
        """
        Tag name of the created release

        Different behavior based on configuration:
          - Tag name of the created release (When action = 'create_release')
          - Tag name of the updated release (When action = 'update_release')
          - Tag name of the release (When action = 'read_release')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tag_name")

    @property
    def tag_names(self) -> List[str]:
        """
        List of tag names

        Available: When action = 'get_releases'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tag_names")

    @property
    def tarball_url(self) -> str:
        """
        Tarball download URL

        Available: When action = 'create_release', When action = 'read_release'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tarball_url")

    @property
    def tarball_urls(self) -> List[str]:
        """
        List of tarball URLs

        Available: When action = 'get_releases'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tarball_urls")

    @property
    def test_url(self) -> str:
        """
        Test URL for the webhook

        Available: When action = 'read_webhook'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("test_url")

    @property
    def test_urls(self) -> List[str]:
        """
        List of test URLs

        Available: When action = 'get_webhooks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("test_urls")

    @property
    def updated_at(self) -> str:
        """
        Update timestamp

        Different behavior based on configuration:
          - Update timestamp (When action = 'update_repository', When action = 'update_issue', When action = 'update_pull_request', When action = 'update_issue_comment', When action = 'update_release', When action = 'update_webhook')
          - Last update timestamp (When action = 'read_repository', When action = 'read_issue', When action = 'read_pull_request', When action = 'read_issue_comment', When action = 'read_webhook')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated_at")

    @property
    def updated_dates(self) -> List[str]:
        """
        List of update dates

        Available: When action = 'get_repositories', When action = 'get_issues', When action = 'get_pull_requests', When action = 'get_issue_comments', When action = 'get_webhooks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated_dates")

    @property
    def url(self) -> str:
        """
        URL of the branch

        Available: When action = 'create_branch'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("url")

    @property
    def user_details(self) -> List[str]:
        """
        User details in JSON format

        Available: When action = 'read_user', When action = 'get_organization_members'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("user_details")

    @property
    def user_email(self) -> str:
        """
        Email of the user

        Available: When action = 'read_user'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("user_email")

    @property
    def user_emails(self) -> List[str]:
        """
        List of user emails

        Available: When action = 'get_organization_members'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("user_emails")

    @property
    def user_id(self) -> str:
        """
        ID of the user

        Available: When action = 'read_user'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("user_id")

    @property
    def user_ids(self) -> List[str]:
        """
        List of user IDs

        Available: When action = 'get_organization_members'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("user_ids")

    @property
    def user_name(self) -> str:
        """
        Display name of the user

        Available: When action = 'read_user'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("user_name")

    @property
    def user_names(self) -> List[str]:
        """
        List of display names

        Available: When action = 'get_organization_members'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("user_names")

    @property
    def user_types(self) -> List[str]:
        """
        List of user types

        Available: When action = 'get_organization_members'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("user_types")

    @property
    def username(self) -> str:
        """
        Username of the user

        Available: When action = 'read_user'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("username")

    @property
    def usernames(self) -> List[str]:
        """
        List of usernames

        Available: When action = 'get_organization_members'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("usernames")

    @property
    def watchers_count(self) -> str:
        """
        Number of watchers

        Available: When action = 'read_repository'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("watchers_count")

    @property
    def watchers_counts(self) -> List[str]:
        """
        List of watcher counts

        Available: When action = 'get_repositories'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("watchers_counts")

    @property
    def webhook_active(self) -> bool:
        """
        Whether the webhook is active

        Available: When action = 'create_webhook', When action = 'update_webhook', When action = 'read_webhook'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("webhook_active")

    @property
    def webhook_active_flags(self) -> List[str]:
        """
        List of webhook active flags

        Available: When action = 'get_webhooks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("webhook_active_flags")

    @property
    def webhook_config(self) -> str:
        """
        Webhook configuration details

        Available: When action = 'read_webhook'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("webhook_config")

    @property
    def webhook_configs(self) -> List[str]:
        """
        List of webhook configurations

        Available: When action = 'get_webhooks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("webhook_configs")

    @property
    def webhook_details(self) -> List[str]:
        """
        Webhook details in JSON format

        Different behavior based on configuration:
          - Webhook details in JSON format (When action = 'create_webhook', When action = 'update_webhook', When action = 'read_webhook', When action = 'get_webhooks')
          - Webhook response details (When action = 'ping_webhook')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("webhook_details")

    @property
    def webhook_events(self) -> List[str]:
        """
        List of webhook events

        Available: When action = 'create_webhook', When action = 'update_webhook', When action = 'read_webhook', When action = 'get_webhooks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("webhook_events")

    @property
    def webhook_id(self) -> str:
        """
        ID of the created webhook

        Different behavior based on configuration:
          - ID of the created webhook (When action = 'create_webhook')
          - ID of the updated webhook (When action = 'update_webhook')
          - ID of the webhook (When action = 'read_webhook')
          - ID of the deleted webhook (When action = 'delete_webhook')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("webhook_id")

    @property
    def webhook_ids(self) -> List[str]:
        """
        List of webhook IDs

        Available: When action = 'get_webhooks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("webhook_ids")

    @property
    def webhook_name(self) -> str:
        """
        Name of the created webhook

        Different behavior based on configuration:
          - Name of the created webhook (When action = 'create_webhook')
          - Name of the updated webhook (When action = 'update_webhook')
          - Name of the webhook (When action = 'read_webhook')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("webhook_name")

    @property
    def webhook_names(self) -> List[str]:
        """
        List of webhook names

        Available: When action = 'get_webhooks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("webhook_names")

    @property
    def webhook_url(self) -> str:
        """
        URL of the created webhook

        Different behavior based on configuration:
          - URL of the created webhook (When action = 'create_webhook')
          - URL of the updated webhook (When action = 'update_webhook')
          - URL of the webhook (When action = 'read_webhook')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("webhook_url")

    @property
    def webhook_urls(self) -> List[str]:
        """
        List of webhook URLs

        Available: When action = 'get_webhooks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("webhook_urls")

    @property
    def zipball_url(self) -> str:
        """
        Zipball download URL

        Available: When action = 'create_release', When action = 'read_release'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("zipball_url")

    @property
    def zipball_urls(self) -> List[str]:
        """
        List of zipball URLs

        Available: When action = 'get_releases'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("zipball_urls")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGithubNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_zendesk")
class IntegrationZendeskNode(Node):
    """
    Zendesk

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'get_tickets'
        assignee: Assignee of the ticket
        body: Search in the full ticket content
        brand: Filter by brand
        comment: Search in ticket comments
        comment_exact: Match comment exactly
        description: Search in the ticket description
        due: Tickets due on this date
        external_id: Search by external ID
        group: Filter by assigned group
        include: Include related data (e.g. users)
        organization: Organization of the ticket
        priority: Priority of the ticket
        requester: Requester of the ticket
        satisfaction: Customer satisfaction rating
        solved: Tickets solved on this date
        sort_by: Field to sort results by
        sort_order: Order of sorting (asc/desc)
        status: Status of the ticket
        subject: Search tickets by subject
        subject_exact: Match subject exactly
        ticket_form: Filter by ticket form
        ticket_type: Type of the ticket
        updated: Tickets updated on this date
        use_date: Toggle to use dates
    ### When action = 'get_tickets' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_tickets' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_tickets' and use_date = False
        num_messages: Specify the number of tickets to fetch
    ### When action = 'create_comment'
        public: Whether the comment should be public
        ticket_body: Body content of the ticket
        ticket_id: The ID of Zendesk ticket to update
    ### When action = 'create_ticket'
        requester_email: Email of the requester
        requester_name: Name of the requester (Required if requester email is not already registered)
        ticket_body: Body content of the ticket
        ticket_priority: Priority of the ticket
        ticket_status: Status of the ticket
        ticket_subject: Subject content of the ticket
        ticket_type: Type of the ticket
    ### When action = 'update_ticket'
        ticket_id: The ID of Zendesk ticket to update
        ticket_priority: Priority of the ticket
        ticket_status: Status of the ticket
        ticket_type: Type of the ticket
        update_ticket_assignee_id: The ID of the assignee to update the ticket to
        update_ticket_body: Body content of the ticket
        update_ticket_subject: Subject content of the ticket
    ### When action = 'read_ticket'
        ticket_id: The ID of Zendesk ticket to update
    ### When action = 'read_ticket_comments'
        ticket_id: The ID of Zendesk ticket to update
    ### When action = 'get_tickets' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_ticket'
        created_at: Date and time the ticket was created
        ticket_assignee_id: ID of ticket assignee
        ticket_attachments: Attachments of the ticket
        ticket_body: Body of the ticket
        ticket_details: Ticket details in JSON format
        ticket_priority: Priority of the ticket
        ticket_requester_id: ID of ticket requester
        ticket_status: Status of the ticket
        ticket_subject: Subject of the ticket
        ticket_type: Type of the ticket
        ticket_url: URL of the ticket
        updated_at: Date and time the ticket was last updated
    ### When action = 'get_tickets'
        created_at: Date and time the tickets was created
        ticket_assignee_id: ID of tickets assignee
        ticket_attachments: Attachments of the tickets
        ticket_body: Body of the tickets
        ticket_details: Tickets details in JSON format
        ticket_id: ID of the tickets
        ticket_priority: Priority of the tickets
        ticket_requester_id: ID of tickets requester
        ticket_status: Status of the tickets
        ticket_subject: Subject of the tickets
        ticket_type: Type of the tickets
        ticket_url: URL of the tickets
        updated_at: Date and time the tickets was last updated
    ### When action = 'read_ticket_comments'
        ticket_attachments: Attachments of the ticket
        ticket_comments: Ticket comments in JSON format
        ticket_details: Ticket details in JSON format
    ### When action = 'create_ticket'
        ticket_details: Ticket details in JSON format
        ticket_id: Ticket ID of the created ticket
    ### When action = 'update_ticket'
        ticket_details: Ticket details in JSON format
    ### When action = 'create_comment'
        ticket_details: Ticket details in JSON format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Zendesk>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_subject",
                    "type": "string",
                    "value": "",
                    "helper_text": "Subject content of the ticket",
                    "label": "Subject",
                    "placeholder": "Incident report",
                },
                {
                    "field": "ticket_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Body content of the ticket",
                    "label": "Body",
                    "placeholder": "Clicking on submit button doens’t work",
                },
                {
                    "field": "requester_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the requester",
                    "label": "Requester Email",
                    "placeholder": "john@company.com",
                },
                {
                    "field": "requester_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the requester (Required if requester email is not already registered)",
                    "label": "Requester Name",
                    "placeholder": "John Smith",
                },
                {
                    "field": "ticket_priority",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Priority of the ticket",
                    "label": "Priority",
                    "placeholder": "High",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Low", "value": "Low"},
                            {"label": "Normal", "value": "Normal"},
                            {"label": "High", "value": "High"},
                            {"label": "Urgent", "value": "Urgent"},
                        ],
                    },
                },
                {
                    "field": "ticket_type",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Type of the ticket",
                    "label": "Type",
                    "placeholder": "Incident",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Question", "value": "Question"},
                            {"label": "Incident", "value": "Incident"},
                            {"label": "Problem", "value": "Problem"},
                            {"label": "Task", "value": "Task"},
                        ],
                    },
                },
                {
                    "field": "ticket_status",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Status of the ticket",
                    "label": "Status",
                    "placeholder": "Open",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "New", "value": "New"},
                            {"label": "Open", "value": "Open"},
                            {"label": "Pending", "value": "Pending"},
                            {"label": "Hold", "value": "Hold"},
                            {"label": "Solved", "value": "Solved"},
                            {"label": "Closed", "value": "Closed"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "helper_text": "Ticket ID of the created ticket",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_ticket",
            "task_name": "tasks.zendesk.create_ticket",
            "description": "Create a new ticket on Zendesk",
            "label": "Create Ticket",
            "inputs_sort_order": [
                "integration",
                "action",
                "ticket_priority",
                "ticket_type",
                "ticket_status",
                "ticket_subject",
                "ticket_body",
                "requester_email",
                "requester_name",
            ],
        },
        "update_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of Zendesk ticket to update",
                    "label": "Ticket ID",
                    "placeholder": "123",
                },
                {
                    "field": "update_ticket_subject",
                    "type": "string",
                    "value": "",
                    "helper_text": "Subject content of the ticket",
                    "label": "Subject",
                    "placeholder": "Incident report",
                },
                {
                    "field": "update_ticket_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Body content of the ticket",
                    "label": "Body",
                    "placeholder": "Clicking on submit button not working",
                },
                {
                    "field": "update_ticket_assignee_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the assignee to update the ticket to",
                    "label": "Assignee ID",
                    "placeholder": "1234",
                },
                {
                    "field": "ticket_priority",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Priority of the ticket",
                    "label": "Priority",
                    "placeholder": "High",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Low", "value": "Low"},
                            {"label": "Normal", "value": "Normal"},
                            {"label": "High", "value": "High"},
                            {"label": "Urgent", "value": "Urgent"},
                        ],
                    },
                },
                {
                    "field": "ticket_type",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Type of the ticket",
                    "label": "Type",
                    "placeholder": "Incident",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Question", "value": "Question"},
                            {"label": "Incident", "value": "Incident"},
                            {"label": "Problem", "value": "Problem"},
                            {"label": "Task", "value": "Task"},
                        ],
                    },
                },
                {
                    "field": "ticket_status",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Status of the ticket",
                    "label": "Status",
                    "placeholder": "Open",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "New", "value": "New"},
                            {"label": "Open", "value": "Open"},
                            {"label": "Pending", "value": "Pending"},
                            {"label": "Hold", "value": "Hold"},
                            {"label": "Solved", "value": "Solved"},
                            {"label": "Closed", "value": "Closed"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "update_ticket",
            "task_name": "tasks.zendesk.update_ticket",
            "description": "Update an existing ticket on Zendesk",
            "label": "Update Ticket",
            "inputs_sort_order": [
                "integration",
                "action",
                "ticket_priority",
                "ticket_type",
                "ticket_status",
                "ticket_id",
                "update_ticket_subject",
                "update_ticket_body",
                "update_ticket_assignee_id",
            ],
        },
        "create_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of Zendesk ticket to add comment to",
                    "label": "Ticket ID",
                    "placeholder": "123",
                },
                {
                    "field": "ticket_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Content of the comment",
                    "label": "Comment Body",
                    "placeholder": "Clicking on submit button not working",
                },
                {
                    "field": "public",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Whether the comment should be public",
                    "label": "Public",
                },
            ],
            "outputs": [
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                }
            ],
            "name": "create_comment",
            "task_name": "tasks.zendesk.create_comment",
            "description": "Create a new comment on a Zendesk ticket",
            "label": "Create Comment",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "ticket_id",
                "ticket_body",
                "public",
            ],
        },
        "read_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of Zendesk ticket to read",
                    "label": "Ticket ID",
                    "placeholder": "123",
                }
            ],
            "outputs": [
                {
                    "field": "ticket_subject",
                    "type": "string",
                    "helper_text": "Subject of the ticket",
                },
                {
                    "field": "ticket_body",
                    "type": "vec<string>",
                    "helper_text": "Body of the ticket",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Date and time the ticket was created",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Date and time the ticket was last updated",
                },
                {
                    "field": "ticket_priority",
                    "type": "string",
                    "helper_text": "Priority of the ticket",
                },
                {
                    "field": "ticket_type",
                    "type": "string",
                    "helper_text": "Type of the ticket",
                },
                {
                    "field": "ticket_status",
                    "type": "string",
                    "helper_text": "Status of the ticket",
                },
                {
                    "field": "ticket_url",
                    "type": "string",
                    "helper_text": "URL of the ticket",
                },
                {
                    "field": "ticket_attachments",
                    "type": "vec<file>",
                    "helper_text": "Attachments of the ticket",
                },
                {
                    "field": "ticket_assignee_id",
                    "type": "string",
                    "helper_text": "ID of ticket assignee",
                },
                {
                    "field": "ticket_requester_id",
                    "type": "string",
                    "helper_text": "ID of ticket requester",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                },
            ],
            "name": "read_ticket",
            "task_name": "tasks.zendesk.read_ticket",
            "description": "Read an existing ticket on Zendesk",
            "label": "Read Ticket",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "ticket_id"],
        },
        "read_ticket_comments**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of Zendesk ticket to read comments from",
                    "label": "Ticket ID",
                    "placeholder": "123",
                }
            ],
            "outputs": [
                {
                    "field": "ticket_comments",
                    "type": "vec<string>",
                    "helper_text": "Ticket comments in JSON format",
                },
                {
                    "field": "ticket_attachments",
                    "type": "vec<file>",
                    "helper_text": "Attachments of the ticket",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                },
            ],
            "name": "read_ticket_comments",
            "task_name": "tasks.zendesk.read_ticket_comments",
            "description": "Read comments from an existing ticket on Zendesk",
            "label": "Read Ticket Comments",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "ticket_id"],
        },
        "get_tickets**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "assignee",
                    "type": "string",
                    "value": "",
                    "label": "Assignee",
                    "helper_text": "Assignee of the ticket",
                    "placeholder": "John Smith",
                },
                {
                    "field": "requester",
                    "type": "string",
                    "value": "",
                    "label": "Requester",
                    "helper_text": "Requester of the ticket",
                    "placeholder": "John Smith",
                },
                {
                    "field": "organization",
                    "type": "string",
                    "value": "",
                    "label": "Organization",
                    "helper_text": "Organization of the ticket",
                    "placeholder": "Acme Corp",
                },
                {
                    "field": "priority",
                    "type": "enum<string>",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Priority of the ticket",
                    "label": "Priority",
                    "placeholder": "High",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Low", "value": "Low"},
                            {"label": "Normal", "value": "Normal"},
                            {"label": "High", "value": "High"},
                            {"label": "Urgent", "value": "Urgent"},
                        ],
                    },
                },
                {
                    "field": "ticket_type",
                    "type": "enum<string>",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Type of the ticket",
                    "label": "Type",
                    "placeholder": "Incident",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Question", "value": "Question"},
                            {"label": "Incident", "value": "Incident"},
                            {"label": "Problem", "value": "Problem"},
                            {"label": "Task", "value": "Task"},
                        ],
                    },
                },
                {
                    "field": "status",
                    "type": "enum<string>",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Status of the ticket",
                    "label": "Status",
                    "placeholder": "Open",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "New", "value": "New"},
                            {"label": "Open", "value": "Open"},
                            {"label": "Pending", "value": "Pending"},
                            {"label": "Hold", "value": "Hold"},
                            {"label": "Solved", "value": "Solved"},
                            {"label": "Closed", "value": "Closed"},
                        ],
                    },
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "helper_text": "Search tickets by subject",
                    "placeholder": "Incident report",
                },
                {
                    "field": "subject_exact",
                    "type": "string",
                    "value": "",
                    "label": "Subject Exact",
                    "helper_text": "Match subject exactly",
                    "placeholder": "Incident report",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "helper_text": "Search in the ticket description",
                    "placeholder": "Clicking on submit button doesn't work",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "helper_text": "Search in the full ticket content",
                    "placeholder": "Clicking on submit button doesn't work",
                },
                {
                    "field": "comment",
                    "type": "string",
                    "value": "",
                    "label": "Comment",
                    "helper_text": "Search in ticket comments",
                    "placeholder": "Clicking on submit button doesn't work",
                },
                {
                    "field": "comment_exact",
                    "type": "string",
                    "value": "",
                    "label": "Comment Exact",
                    "helper_text": "Match comment exactly",
                    "placeholder": "Clicking on submit button doesn't work",
                },
                {
                    "field": "updated",
                    "type": "string",
                    "value": "",
                    "label": "Updated Date",
                    "helper_text": "Tickets updated on this date",
                    "placeholder": "YYYY-MM-DD",
                },
                {
                    "field": "solved",
                    "type": "string",
                    "value": "",
                    "label": "Solved Date",
                    "helper_text": "Tickets solved on this date",
                    "placeholder": "YYYY-MM-DD",
                },
                {
                    "field": "due",
                    "type": "string",
                    "value": "",
                    "label": "Due Date",
                    "helper_text": "Tickets due on this date",
                    "placeholder": "YYYY-MM-DD",
                },
                {
                    "field": "brand",
                    "type": "string",
                    "value": "",
                    "label": "Brand",
                    "helper_text": "Filter by brand",
                    "placeholder": "Acme Corp",
                },
                {
                    "field": "satisfaction",
                    "type": "enum<string>",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Customer satisfaction rating",
                    "label": "Satisfaction",
                    "placeholder": "Good",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Good", "value": "good"},
                            {"label": "Bad", "value": "bad"},
                            {"label": "Offered", "value": "offered"},
                        ],
                    },
                },
                {
                    "field": "ticket_form",
                    "type": "string",
                    "value": "",
                    "label": "Ticket Form",
                    "helper_text": "Filter by ticket form",
                    "placeholder": "Support",
                },
                {
                    "field": "group",
                    "type": "string",
                    "value": "",
                    "label": "Group",
                    "helper_text": "Filter by assigned group",
                    "placeholder": "Support",
                },
                {
                    "field": "sort_by",
                    "type": "string",
                    "value": "",
                    "label": "Sort By",
                    "helper_text": "Field to sort results by",
                    "placeholder": "created_at",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "helper_text": "Order of sorting (asc/desc)",
                    "placeholder": "desc",
                },
                {
                    "field": "external_id",
                    "type": "string",
                    "value": "",
                    "label": "External ID",
                    "helper_text": "Search by external ID",
                    "placeholder": "123",
                },
                {
                    "field": "include",
                    "type": "string",
                    "value": "",
                    "label": "Include",
                    "helper_text": "Include related data (e.g. users)",
                    "placeholder": "users,groups,organizations",
                },
            ],
            "outputs": [
                {
                    "field": "ticket_id",
                    "type": "vec<string>",
                    "helper_text": "ID of the tickets",
                },
                {
                    "field": "ticket_subject",
                    "type": "vec<string>",
                    "helper_text": "Subject of the tickets",
                },
                {
                    "field": "ticket_body",
                    "type": "vec<string>",
                    "helper_text": "Body of the tickets",
                },
                {
                    "field": "created_at",
                    "type": "vec<string>",
                    "helper_text": "Date and time the tickets was created",
                },
                {
                    "field": "updated_at",
                    "type": "vec<string>",
                    "helper_text": "Date and time the tickets was last updated",
                },
                {
                    "field": "ticket_priority",
                    "type": "vec<string>",
                    "helper_text": "Priority of the tickets",
                },
                {
                    "field": "ticket_type",
                    "type": "vec<string>",
                    "helper_text": "Type of the tickets",
                },
                {
                    "field": "ticket_status",
                    "type": "vec<string>",
                    "helper_text": "Status of the tickets",
                },
                {
                    "field": "ticket_url",
                    "type": "vec<string>",
                    "helper_text": "URL of the tickets",
                },
                {
                    "field": "ticket_attachments",
                    "type": "vec<vec<file>>",
                    "helper_text": "Attachments of the tickets",
                },
                {
                    "field": "ticket_assignee_id",
                    "type": "vec<string>",
                    "helper_text": "ID of tickets assignee",
                },
                {
                    "field": "ticket_requester_id",
                    "type": "vec<string>",
                    "helper_text": "ID of tickets requester",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Tickets details in JSON format",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_tickets",
            "task_name": "tasks.zendesk.get_tickets",
            "description": "Get a list of tickets from Zendesk",
            "label": "Get Tickets",
            "inputs_sort_order": [
                "integration",
                "action",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "ticket_subject",
                "ticket_body",
                "requester_email",
                "requester_name",
                "ticket_priority",
                "ticket_type",
                "ticket_status",
                "assignee",
                "requester",
                "organization",
                "subject",
                "subject_exact",
                "description",
                "body",
                "comment",
                "comment_exact",
                "updated",
                "solved",
                "due",
                "brand",
                "satisfaction",
                "ticket_form",
                "group",
                "sort_by",
                "sort_order",
                "external_id",
                "include",
            ],
        },
        "get_tickets**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Tickets",
                    "helper_text": "Specify the number of tickets to fetch",
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        assignee: str = "",
        body: str = "",
        brand: str = "",
        comment: str = "",
        comment_exact: str = "",
        description: str = "",
        due: str = "",
        exact_date: Any = {"start": "", "end": ""},
        external_id: str = "",
        group: str = "",
        include: str = "",
        num_messages: int = 10,
        organization: str = "",
        priority: str = "",
        public: bool = True,
        requester: str = "",
        requester_email: str = "",
        requester_name: str = "",
        satisfaction: str = "",
        solved: str = "",
        sort_by: str = "",
        sort_order: str = "",
        status: str = "",
        subject: str = "",
        subject_exact: str = "",
        ticket_body: str = "",
        ticket_form: str = "",
        ticket_id: str = "",
        ticket_priority: str = "",
        ticket_status: str = "",
        ticket_subject: str = "",
        ticket_type: str = "",
        update_ticket_assignee_id: str = "",
        update_ticket_body: str = "",
        update_ticket_subject: str = "",
        updated: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_zendesk",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if ticket_subject is not None:
            self.inputs["ticket_subject"] = ticket_subject
        if ticket_body is not None:
            self.inputs["ticket_body"] = ticket_body
        if requester_email is not None:
            self.inputs["requester_email"] = requester_email
        if requester_name is not None:
            self.inputs["requester_name"] = requester_name
        if ticket_priority is not None:
            self.inputs["ticket_priority"] = ticket_priority
        if ticket_type is not None:
            self.inputs["ticket_type"] = ticket_type
        if ticket_status is not None:
            self.inputs["ticket_status"] = ticket_status
        if ticket_id is not None:
            self.inputs["ticket_id"] = ticket_id
        if update_ticket_subject is not None:
            self.inputs["update_ticket_subject"] = update_ticket_subject
        if update_ticket_body is not None:
            self.inputs["update_ticket_body"] = update_ticket_body
        if update_ticket_assignee_id is not None:
            self.inputs["update_ticket_assignee_id"] = update_ticket_assignee_id
        if public is not None:
            self.inputs["public"] = public
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if assignee is not None:
            self.inputs["assignee"] = assignee
        if requester is not None:
            self.inputs["requester"] = requester
        if organization is not None:
            self.inputs["organization"] = organization
        if priority is not None:
            self.inputs["priority"] = priority
        if status is not None:
            self.inputs["status"] = status
        if subject is not None:
            self.inputs["subject"] = subject
        if subject_exact is not None:
            self.inputs["subject_exact"] = subject_exact
        if description is not None:
            self.inputs["description"] = description
        if body is not None:
            self.inputs["body"] = body
        if comment is not None:
            self.inputs["comment"] = comment
        if comment_exact is not None:
            self.inputs["comment_exact"] = comment_exact
        if updated is not None:
            self.inputs["updated"] = updated
        if solved is not None:
            self.inputs["solved"] = solved
        if due is not None:
            self.inputs["due"] = due
        if brand is not None:
            self.inputs["brand"] = brand
        if satisfaction is not None:
            self.inputs["satisfaction"] = satisfaction
        if ticket_form is not None:
            self.inputs["ticket_form"] = ticket_form
        if group is not None:
            self.inputs["group"] = group
        if sort_by is not None:
            self.inputs["sort_by"] = sort_by
        if sort_order is not None:
            self.inputs["sort_order"] = sort_order
        if external_id is not None:
            self.inputs["external_id"] = external_id
        if include is not None:
            self.inputs["include"] = include
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def created_at(self) -> str:
        """
        Date and time the ticket was created

        Different behavior based on configuration:
          - Date and time the ticket was created (When action = 'read_ticket')
          - Date and time the tickets was created (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_at")

    @property
    def ticket_assignee_id(self) -> str:
        """
        ID of ticket assignee

        Different behavior based on configuration:
          - ID of ticket assignee (When action = 'read_ticket')
          - ID of tickets assignee (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_assignee_id")

    @property
    def ticket_attachments(self) -> List[str]:
        """
        Attachments of the ticket

        Different behavior based on configuration:
          - Attachments of the ticket (When action = 'read_ticket', When action = 'read_ticket_comments')
          - Attachments of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_attachments")

    @property
    def ticket_body(self) -> List[str]:
        """
        Body of the ticket

        Different behavior based on configuration:
          - Body of the ticket (When action = 'read_ticket')
          - Body of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_body")

    @property
    def ticket_comments(self) -> List[str]:
        """
        Ticket comments in JSON format

        Available: When action = 'read_ticket_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_comments")

    @property
    def ticket_details(self) -> str:
        """
        Ticket details in JSON format

        Different behavior based on configuration:
          - Ticket details in JSON format (When action = 'create_ticket', When action = 'update_ticket', When action = 'create_comment', When action = 'read_ticket', When action = 'read_ticket_comments')
          - Tickets details in JSON format (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_details")

    @property
    def ticket_id(self) -> str:
        """
        Ticket ID of the created ticket

        Different behavior based on configuration:
          - Ticket ID of the created ticket (When action = 'create_ticket')
          - ID of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_id")

    @property
    def ticket_priority(self) -> str:
        """
        Priority of the ticket

        Different behavior based on configuration:
          - Priority of the ticket (When action = 'read_ticket')
          - Priority of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_priority")

    @property
    def ticket_requester_id(self) -> str:
        """
        ID of ticket requester

        Different behavior based on configuration:
          - ID of ticket requester (When action = 'read_ticket')
          - ID of tickets requester (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_requester_id")

    @property
    def ticket_status(self) -> str:
        """
        Status of the ticket

        Different behavior based on configuration:
          - Status of the ticket (When action = 'read_ticket')
          - Status of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_status")

    @property
    def ticket_subject(self) -> str:
        """
        Subject of the ticket

        Different behavior based on configuration:
          - Subject of the ticket (When action = 'read_ticket')
          - Subject of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_subject")

    @property
    def ticket_type(self) -> str:
        """
        Type of the ticket

        Different behavior based on configuration:
          - Type of the ticket (When action = 'read_ticket')
          - Type of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_type")

    @property
    def ticket_url(self) -> str:
        """
        URL of the ticket

        Different behavior based on configuration:
          - URL of the ticket (When action = 'read_ticket')
          - URL of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_url")

    @property
    def updated_at(self) -> str:
        """
        Date and time the ticket was last updated

        Different behavior based on configuration:
          - Date and time the ticket was last updated (When action = 'read_ticket')
          - Date and time the tickets was last updated (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated_at")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationZendeskNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_stripe")
class IntegrationStripeNode(Node):
    """
    Stripe

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### add_customer_card
        card_customer_id: ID of the customer to add card to
        card_token: Token representing the card information
    ### create_charge
        charge_amount: Amount to charge in cents
        charge_currency: Three-letter currency code
        charge_description: Description of the charge
        charge_source: Payment source ID or token
        customer_id: ID of the customer to retrieve
    ### read_charge
        charge_id: ID of the charge to retrieve
    ### update_charge
        charge_id: ID of the charge to retrieve
        update_charge_description: New description for the charge
    ### create_coupon
        coupon_amount_off: Fixed amount off in cents
        coupon_currency: Currency for amount_off coupons
        coupon_duration: Duration of the coupon
        coupon_duration_in_months: Duration in months for repeating coupons
        coupon_max_redemptions: Maximum number of redemptions
        coupon_name: Name of the coupon
        coupon_percent_off: Percentage off
    ### create_customer
        customer_description: Description of the customer
        customer_email: Email address of the customer
        customer_name: Full name of the customer
        customer_phone: Phone number of the customer
    ### get_customers
        customer_email: Email address of the customer
        num_messages: Number of customers to retrieve
    ### read_customer
        customer_id: ID of the customer to retrieve
    ### update_customer
        customer_id: ID of the customer to retrieve
        update_customer_description: New description for the customer
        update_customer_email: New email for the customer
        update_customer_name: New name for the customer
        update_customer_phone: New phone for the customer
    ### delete_customer
        customer_id: ID of the customer to retrieve
    ### get_charges
        customer_id: ID of the customer to retrieve
        num_messages: Number of customers to retrieve
    ### delete_source
        delete_source_customer_id: ID of the customer whose source to delete
        delete_source_id: ID of the source to delete
    ### get_coupons
        num_messages: Number of customers to retrieve
    ### read_customer_card
        read_card_customer_id: ID of the customer whose card to retrieve
        read_card_source_id: ID of the card/source to retrieve
    ### read_source
        read_source_id: ID of the source to retrieve
    ### remove_customer_card
        remove_card_customer_id: ID of the customer whose card to remove
        remove_card_id: ID of the card to remove
    ### create_source
        source_amount: Amount in cents for this source
        source_currency: Three-letter currency code
        source_customer_id: ID of the customer to attach the source to
        source_statement_descriptor: Text to display on customer's statement
        source_type: Type of source to create
    ### create_token
        token_card_number: Card number
        token_cvc: Card security code
        token_exp_month: Expiration month
        token_exp_year: Expiration year

    ## Outputs
    ### get_balance
        available: Available balance amounts by currency
        livemode: Whether this is live or test mode
        object: Object type identifier
        pending: Pending balance amounts by currency
        raw_data: Raw response from Stripe API
    ### add_customer_card
        brand: Card brand (e.g., Visa, MasterCard)
        card_id: Unique ID of the added card
        customer_id: Customer ID the card is attached to
        exp_month: Card expiration month
        exp_year: Card expiration year
        fingerprint: Unique fingerprint for the card
        last4: Last 4 digits of the card
        raw_data: Raw response from Stripe API
    ### read_customer_card
        brand: Card brand (e.g., Visa, MasterCard)
        card_id: Unique ID of the card
        customer_id: Customer ID the card is attached to
        exp_month: Card expiration month
        exp_year: Card expiration year
        fingerprint: Unique fingerprint for the card
        last4: Last 4 digits of the card
        raw_data: Raw response from Stripe API
    ### create_token
        card_brand: Brand of the card
        card_exp_month: Card expiration month
        card_exp_year: Card expiration year
        card_fingerprint: Unique fingerprint for the card
        card_last4: Last 4 digits of the card
        created_at: Creation timestamp in RFC3339 format
        raw_data: Raw response from Stripe API
        token_id: Unique ID of the created token
        token_type: Type of the token
    ### remove_customer_card
        card_id: ID of the removed card
        deleted: Whether the card was successfully deleted
        message: Success message
        raw_data: Raw response from Stripe API
    ### create_charge
        charge_amount: Amount charged in cents
        charge_currency: Currency of the charge
        charge_customer: Customer ID associated with charge
        charge_description: Charge description
        charge_id: Unique ID of the created charge
        charge_paid: Whether the charge was paid
        charge_status: Status of the charge
        created_at: Creation timestamp in RFC3339 format
        raw_data: Raw response from Stripe API
    ### read_charge
        charge_amount: Amount charged in cents
        charge_currency: Currency of the charge
        charge_customer: Customer ID associated with charge
        charge_description: Charge description
        charge_id: Unique ID of the charge
        charge_paid: Whether the charge was paid
        charge_status: Status of the charge
        created_at: Creation timestamp in RFC3339 format
        raw_data: Raw response from Stripe API
    ### update_charge
        charge_amount: Amount charged in cents
        charge_currency: Currency of the charge
        charge_customer: Customer ID associated with charge
        charge_description: Charge description
        charge_id: Unique ID of the charge
        charge_paid: Whether the charge was paid
        charge_status: Status of the charge
        message: Success message
        raw_data: Raw response from Stripe API
    ### get_charges
        charge_amounts: List of charge amounts
        charge_currencies: List of charge currencies
        charge_customers: List of associated customer IDs
        charge_descriptions: List of charge descriptions
        charge_ids: List of charge IDs
        charge_paids: List of paid status booleans
        charge_statuses: List of charge statuses
        created_ats: List of creation timestamps
        raw_data: Raw response from Stripe API
    ### create_coupon
        coupon_amount_off: Fixed amount off in cents
        coupon_currency: Currency of the coupon
        coupon_duration: Duration of the coupon
        coupon_duration_in_months: Duration in months
        coupon_id: Unique ID of the created coupon
        coupon_max_redemptions: Maximum redemptions allowed
        coupon_name: Name of the coupon
        coupon_percent_off: Percentage off
        coupon_times_redeemed: Times already redeemed
        coupon_valid: Whether the coupon is valid
        created_at: Creation timestamp in RFC3339 format
        raw_data: Raw response from Stripe API
    ### get_coupons
        coupon_amount_offs: List of amount offs
        coupon_currencies: List of coupon currencies
        coupon_durations: List of coupon durations
        coupon_ids: List of coupon IDs
        coupon_names: List of coupon names
        coupon_percent_offs: List of percent offs
        coupon_valids: List of validity statuses
        created_ats: List of creation timestamps
        raw_data: Raw response from Stripe API
    ### create_customer
        created_at: Creation timestamp in RFC3339 format
        customer_description: Customer description
        customer_email: Customer's email address
        customer_id: Unique ID of the created customer
        customer_name: Customer's full name
        customer_phone: Customer's phone number
        raw_data: Raw response from Stripe API
    ### read_customer
        created_at: Creation timestamp in RFC3339 format
        customer_description: Customer description
        customer_email: Customer's email address
        customer_id: Unique ID of the customer
        customer_name: Customer's full name
        customer_phone: Customer's phone number
        raw_data: Raw response from Stripe API
    ### create_source
        created_at: Creation timestamp in RFC3339 format
        raw_data: Raw response from Stripe API
        source_amount: Amount for the source in cents
        source_currency: Currency of the source
        source_customer: Customer ID the source is attached to
        source_id: Unique ID of the created source
        source_status: Status of the source
        source_type: Type of the source
    ### read_source
        created_at: Creation timestamp in RFC3339 format
        raw_data: Raw response from Stripe API
        source_amount: Amount for the source in cents
        source_currency: Currency of the source
        source_customer: Customer ID the source is attached to
        source_id: Unique ID of the source
        source_status: Status of the source
        source_type: Type of the source
    ### get_customers
        created_ats: List of creation timestamps
        customer_descriptions: List of customer descriptions
        customer_emails: List of customer emails
        customer_ids: List of customer IDs
        customer_names: List of customer names
        customer_phones: List of customer phones
        raw_data: Raw response from Stripe API
    ### update_customer
        customer_description: Customer description
        customer_email: Customer's email address
        customer_id: Unique ID of the customer
        customer_name: Customer's full name
        customer_phone: Customer's phone number
        message: Success message
        raw_data: Raw response from Stripe API
    ### delete_customer
        customer_id: ID of the deleted customer
        deleted: Whether the deletion was successful
        message: Success message
        raw_data: Raw response from Stripe API
    ### delete_source
        deleted: Whether the source was successfully deleted
        message: Success message
        raw_data: Raw response from Stripe API
        source_id: ID of the deleted source
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Stripe>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "get_balance": {
            "inputs": [],
            "outputs": [
                {
                    "field": "object",
                    "type": "string",
                    "helper_text": "Object type identifier",
                },
                {
                    "field": "available",
                    "type": "string",
                    "helper_text": "Available balance amounts by currency",
                },
                {
                    "field": "pending",
                    "type": "string",
                    "helper_text": "Pending balance amounts by currency",
                },
                {
                    "field": "livemode",
                    "type": "bool",
                    "helper_text": "Whether this is live or test mode",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_balance",
            "task_name": "tasks.stripe.get_balance",
            "description": "Retrieve the balance of your Stripe account",
            "label": "Get Balance",
            "inputs_sort_order": ["integration", "action"],
        },
        "create_customer": {
            "inputs": [
                {
                    "field": "customer_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Full name of the customer",
                    "label": "Customer Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "customer_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email address of the customer",
                    "label": "Customer Email",
                    "placeholder": "john@example.com",
                },
                {
                    "field": "customer_phone",
                    "type": "string",
                    "value": "",
                    "helper_text": "Phone number of the customer",
                    "label": "Customer Phone",
                    "placeholder": "+1-555-123-4567",
                },
                {
                    "field": "customer_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the customer",
                    "label": "Customer Description",
                    "placeholder": "VIP customer",
                },
            ],
            "outputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "helper_text": "Unique ID of the created customer",
                },
                {
                    "field": "customer_email",
                    "type": "string",
                    "helper_text": "Customer's email address",
                },
                {
                    "field": "customer_name",
                    "type": "string",
                    "helper_text": "Customer's full name",
                },
                {
                    "field": "customer_phone",
                    "type": "string",
                    "helper_text": "Customer's phone number",
                },
                {
                    "field": "customer_description",
                    "type": "string",
                    "helper_text": "Customer description",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_customer",
            "task_name": "tasks.stripe.create_customer",
            "description": "Create a new customer in Stripe",
            "label": "Create Customer",
            "inputs_sort_order": [
                "integration",
                "action",
                "customer_name",
                "customer_email",
                "customer_phone",
                "customer_description",
            ],
        },
        "read_customer": {
            "inputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer to retrieve",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                }
            ],
            "outputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "helper_text": "Unique ID of the customer",
                },
                {
                    "field": "customer_email",
                    "type": "string",
                    "helper_text": "Customer's email address",
                },
                {
                    "field": "customer_name",
                    "type": "string",
                    "helper_text": "Customer's full name",
                },
                {
                    "field": "customer_phone",
                    "type": "string",
                    "helper_text": "Customer's phone number",
                },
                {
                    "field": "customer_description",
                    "type": "string",
                    "helper_text": "Customer description",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "read_customer",
            "task_name": "tasks.stripe.read_customer",
            "description": "Retrieve details of an existing customer",
            "label": "Read Customer",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "customer_id"],
        },
        "update_customer": {
            "inputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer to update",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "update_customer_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the customer",
                    "label": "New Customer Name",
                    "placeholder": "Jane Doe",
                },
                {
                    "field": "update_customer_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "New email for the customer",
                    "label": "New Customer Email",
                    "placeholder": "jane@example.com",
                },
                {
                    "field": "update_customer_phone",
                    "type": "string",
                    "value": "",
                    "helper_text": "New phone for the customer",
                    "label": "New Customer Phone",
                    "placeholder": "+1-555-987-6543",
                },
                {
                    "field": "update_customer_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the customer",
                    "label": "New Customer Description",
                    "placeholder": "Updated description",
                },
            ],
            "outputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "helper_text": "Unique ID of the customer",
                },
                {
                    "field": "customer_email",
                    "type": "string",
                    "helper_text": "Customer's email address",
                },
                {
                    "field": "customer_name",
                    "type": "string",
                    "helper_text": "Customer's full name",
                },
                {
                    "field": "customer_phone",
                    "type": "string",
                    "helper_text": "Customer's phone number",
                },
                {
                    "field": "customer_description",
                    "type": "string",
                    "helper_text": "Customer description",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_customer",
            "task_name": "tasks.stripe.update_customer",
            "description": "Update an existing customer's information",
            "label": "Update Customer",
            "inputs_sort_order": [
                "integration",
                "action",
                "customer_id",
                "update_customer_name",
                "update_customer_email",
                "update_customer_phone",
                "update_customer_description",
            ],
        },
        "delete_customer": {
            "inputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer to delete",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                }
            ],
            "outputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "helper_text": "ID of the deleted customer",
                },
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "delete_customer",
            "task_name": "tasks.stripe.delete_customer",
            "description": "Delete an existing customer",
            "label": "Delete Customer",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "customer_id"],
        },
        "get_customers": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Number of customers to retrieve",
                    "label": "Number of Customers",
                },
                {
                    "field": "customer_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by customer email",
                    "label": "Filter by Email",
                    "placeholder": "john@example.com",
                },
            ],
            "outputs": [
                {
                    "field": "customer_ids",
                    "type": "vec<string>",
                    "helper_text": "List of customer IDs",
                },
                {
                    "field": "customer_emails",
                    "type": "vec<string>",
                    "helper_text": "List of customer emails",
                },
                {
                    "field": "customer_names",
                    "type": "vec<string>",
                    "helper_text": "List of customer names",
                },
                {
                    "field": "customer_phones",
                    "type": "vec<string>",
                    "helper_text": "List of customer phones",
                },
                {
                    "field": "customer_descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of customer descriptions",
                },
                {
                    "field": "created_ats",
                    "type": "vec<string>",
                    "helper_text": "List of creation timestamps",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_customers",
            "task_name": "tasks.stripe.get_customers",
            "description": "Retrieve a list of customers",
            "label": "Get Customers",
            "inputs_sort_order": [
                "integration",
                "action",
                "num_messages",
                "customer_email",
            ],
        },
        "create_charge": {
            "inputs": [
                {
                    "field": "charge_amount",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Amount to charge in cents",
                    "label": "Charge Amount (cents)",
                    "placeholder": "5000",
                },
                {
                    "field": "charge_currency",
                    "type": "string",
                    "value": "USD",
                    "helper_text": "Three-letter currency code",
                    "label": "Currency",
                    "placeholder": "USD",
                },
                {
                    "field": "charge_source",
                    "type": "string",
                    "value": "",
                    "helper_text": "Payment source ID or token",
                    "label": "Payment Source",
                    "placeholder": "tok_visa",
                },
                {
                    "field": "customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Customer ID to associate with charge",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "charge_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the charge",
                    "label": "Charge Description",
                    "placeholder": "Payment for services",
                },
            ],
            "outputs": [
                {
                    "field": "charge_id",
                    "type": "string",
                    "helper_text": "Unique ID of the created charge",
                },
                {
                    "field": "charge_amount",
                    "type": "int32",
                    "helper_text": "Amount charged in cents",
                },
                {
                    "field": "charge_currency",
                    "type": "string",
                    "helper_text": "Currency of the charge",
                },
                {
                    "field": "charge_customer",
                    "type": "string",
                    "helper_text": "Customer ID associated with charge",
                },
                {
                    "field": "charge_description",
                    "type": "string",
                    "helper_text": "Charge description",
                },
                {
                    "field": "charge_status",
                    "type": "string",
                    "helper_text": "Status of the charge",
                },
                {
                    "field": "charge_paid",
                    "type": "bool",
                    "helper_text": "Whether the charge was paid",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_charge",
            "task_name": "tasks.stripe.create_charge",
            "description": "Create a new charge",
            "label": "Create Charge",
            "inputs_sort_order": [
                "integration",
                "action",
                "charge_amount",
                "charge_currency",
                "charge_source",
                "customer_id",
                "charge_description",
            ],
        },
        "read_charge": {
            "inputs": [
                {
                    "field": "charge_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the charge to retrieve",
                    "label": "Charge ID",
                    "placeholder": "ch_123456789",
                }
            ],
            "outputs": [
                {
                    "field": "charge_id",
                    "type": "string",
                    "helper_text": "Unique ID of the charge",
                },
                {
                    "field": "charge_amount",
                    "type": "int32",
                    "helper_text": "Amount charged in cents",
                },
                {
                    "field": "charge_currency",
                    "type": "string",
                    "helper_text": "Currency of the charge",
                },
                {
                    "field": "charge_customer",
                    "type": "string",
                    "helper_text": "Customer ID associated with charge",
                },
                {
                    "field": "charge_description",
                    "type": "string",
                    "helper_text": "Charge description",
                },
                {
                    "field": "charge_status",
                    "type": "string",
                    "helper_text": "Status of the charge",
                },
                {
                    "field": "charge_paid",
                    "type": "bool",
                    "helper_text": "Whether the charge was paid",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "read_charge",
            "task_name": "tasks.stripe.read_charge",
            "description": "Retrieve details of an existing charge",
            "label": "Read Charge",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "charge_id"],
        },
        "update_charge": {
            "inputs": [
                {
                    "field": "charge_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the charge to update",
                    "label": "Charge ID",
                    "placeholder": "ch_123456789",
                },
                {
                    "field": "update_charge_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the charge",
                    "label": "New Description",
                    "placeholder": "Updated payment description",
                },
            ],
            "outputs": [
                {
                    "field": "charge_id",
                    "type": "string",
                    "helper_text": "Unique ID of the charge",
                },
                {
                    "field": "charge_amount",
                    "type": "int32",
                    "helper_text": "Amount charged in cents",
                },
                {
                    "field": "charge_currency",
                    "type": "string",
                    "helper_text": "Currency of the charge",
                },
                {
                    "field": "charge_customer",
                    "type": "string",
                    "helper_text": "Customer ID associated with charge",
                },
                {
                    "field": "charge_description",
                    "type": "string",
                    "helper_text": "Charge description",
                },
                {
                    "field": "charge_status",
                    "type": "string",
                    "helper_text": "Status of the charge",
                },
                {
                    "field": "charge_paid",
                    "type": "bool",
                    "helper_text": "Whether the charge was paid",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_charge",
            "task_name": "tasks.stripe.update_charge",
            "description": "Update an existing charge",
            "label": "Update Charge",
            "inputs_sort_order": [
                "integration",
                "action",
                "charge_id",
                "update_charge_description",
            ],
        },
        "get_charges": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Number of charges to retrieve",
                    "label": "Number of Charges",
                },
                {
                    "field": "customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by customer ID",
                    "label": "Filter by Customer ID",
                    "placeholder": "cus_123456789",
                },
            ],
            "outputs": [
                {
                    "field": "charge_ids",
                    "type": "vec<string>",
                    "helper_text": "List of charge IDs",
                },
                {
                    "field": "charge_amounts",
                    "type": "vec<int32>",
                    "helper_text": "List of charge amounts",
                },
                {
                    "field": "charge_currencies",
                    "type": "vec<string>",
                    "helper_text": "List of charge currencies",
                },
                {
                    "field": "charge_customers",
                    "type": "vec<string>",
                    "helper_text": "List of associated customer IDs",
                },
                {
                    "field": "charge_descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of charge descriptions",
                },
                {
                    "field": "charge_statuses",
                    "type": "vec<string>",
                    "helper_text": "List of charge statuses",
                },
                {
                    "field": "charge_paids",
                    "type": "vec<bool>",
                    "helper_text": "List of paid status booleans",
                },
                {
                    "field": "created_ats",
                    "type": "vec<string>",
                    "helper_text": "List of creation timestamps",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_charges",
            "task_name": "tasks.stripe.get_charges",
            "description": "Retrieve a list of charges",
            "label": "Get Charges",
            "inputs_sort_order": [
                "integration",
                "action",
                "num_messages",
                "customer_id",
            ],
        },
        "create_coupon": {
            "inputs": [
                {
                    "field": "coupon_duration",
                    "type": "string",
                    "value": "once",
                    "helper_text": "Duration of the coupon",
                    "label": "Duration",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Once", "value": "once"},
                            {"label": "Repeating", "value": "repeating"},
                            {"label": "Forever", "value": "forever"},
                        ],
                    },
                },
                {
                    "field": "coupon_amount_off",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Fixed amount off in cents",
                    "label": "Amount Off (cents)",
                    "placeholder": "1000",
                },
                {
                    "field": "coupon_percent_off",
                    "type": "float",
                    "value": 0.0,
                    "helper_text": "Percentage off",
                    "label": "Percent Off",
                    "placeholder": "25.0",
                },
                {
                    "field": "coupon_currency",
                    "type": "string",
                    "value": "USD",
                    "helper_text": "Currency for amount_off coupons",
                    "label": "Currency",
                    "placeholder": "USD",
                },
                {
                    "field": "coupon_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the coupon",
                    "label": "Coupon Name",
                    "placeholder": "Holiday Sale",
                },
                {
                    "field": "coupon_duration_in_months",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Duration in months for repeating coupons",
                    "label": "Duration (months)",
                },
                {
                    "field": "coupon_max_redemptions",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Maximum number of redemptions",
                    "label": "Max Redemptions",
                },
            ],
            "outputs": [
                {
                    "field": "coupon_id",
                    "type": "string",
                    "helper_text": "Unique ID of the created coupon",
                },
                {
                    "field": "coupon_name",
                    "type": "string",
                    "helper_text": "Name of the coupon",
                },
                {
                    "field": "coupon_duration",
                    "type": "string",
                    "helper_text": "Duration of the coupon",
                },
                {
                    "field": "coupon_amount_off",
                    "type": "int32",
                    "helper_text": "Fixed amount off in cents",
                },
                {
                    "field": "coupon_percent_off",
                    "type": "float",
                    "helper_text": "Percentage off",
                },
                {
                    "field": "coupon_currency",
                    "type": "string",
                    "helper_text": "Currency of the coupon",
                },
                {
                    "field": "coupon_duration_in_months",
                    "type": "int32",
                    "helper_text": "Duration in months",
                },
                {
                    "field": "coupon_max_redemptions",
                    "type": "int32",
                    "helper_text": "Maximum redemptions allowed",
                },
                {
                    "field": "coupon_times_redeemed",
                    "type": "int32",
                    "helper_text": "Times already redeemed",
                },
                {
                    "field": "coupon_valid",
                    "type": "bool",
                    "helper_text": "Whether the coupon is valid",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_coupon",
            "task_name": "tasks.stripe.create_coupon",
            "description": "Create a new coupon",
            "label": "Create Coupon",
            "inputs_sort_order": [
                "integration",
                "action",
                "coupon_duration",
                "coupon_amount_off",
                "coupon_percent_off",
                "coupon_currency",
                "coupon_name",
                "coupon_duration_in_months",
                "coupon_max_redemptions",
            ],
        },
        "get_coupons": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Number of coupons to retrieve",
                    "label": "Number of Coupons",
                }
            ],
            "outputs": [
                {
                    "field": "coupon_ids",
                    "type": "vec<string>",
                    "helper_text": "List of coupon IDs",
                },
                {
                    "field": "coupon_names",
                    "type": "vec<string>",
                    "helper_text": "List of coupon names",
                },
                {
                    "field": "coupon_durations",
                    "type": "vec<string>",
                    "helper_text": "List of coupon durations",
                },
                {
                    "field": "coupon_amount_offs",
                    "type": "vec<int32>",
                    "helper_text": "List of amount offs",
                },
                {
                    "field": "coupon_percent_offs",
                    "type": "vec<float>",
                    "helper_text": "List of percent offs",
                },
                {
                    "field": "coupon_currencies",
                    "type": "vec<string>",
                    "helper_text": "List of coupon currencies",
                },
                {
                    "field": "coupon_valids",
                    "type": "vec<bool>",
                    "helper_text": "List of validity statuses",
                },
                {
                    "field": "created_ats",
                    "type": "vec<string>",
                    "helper_text": "List of creation timestamps",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_coupons",
            "task_name": "tasks.stripe.get_coupons",
            "description": "Retrieve a list of coupons",
            "label": "Get Coupons",
            "inputs_sort_order": ["integration", "action", "num_messages"],
        },
        "add_customer_card": {
            "inputs": [
                {
                    "field": "card_customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer to add card to",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "card_token",
                    "type": "string",
                    "value": "",
                    "helper_text": "Token representing the card information",
                    "label": "Card Token",
                    "placeholder": "tok_1IMfKdJhRTnqS5TKQVG1LI9o",
                },
            ],
            "outputs": [
                {
                    "field": "card_id",
                    "type": "string",
                    "helper_text": "Unique ID of the added card",
                },
                {
                    "field": "customer_id",
                    "type": "string",
                    "helper_text": "Customer ID the card is attached to",
                },
                {
                    "field": "brand",
                    "type": "string",
                    "helper_text": "Card brand (e.g., Visa, MasterCard)",
                },
                {
                    "field": "last4",
                    "type": "string",
                    "helper_text": "Last 4 digits of the card",
                },
                {
                    "field": "exp_month",
                    "type": "int32",
                    "helper_text": "Card expiration month",
                },
                {
                    "field": "exp_year",
                    "type": "int32",
                    "helper_text": "Card expiration year",
                },
                {
                    "field": "fingerprint",
                    "type": "string",
                    "helper_text": "Unique fingerprint for the card",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "add_customer_card",
            "task_name": "tasks.stripe.add_customer_card",
            "description": "Add a card to a customer",
            "label": "Add Customer Card",
            "inputs_sort_order": [
                "integration",
                "action",
                "card_customer_id",
                "card_token",
            ],
        },
        "read_customer_card": {
            "inputs": [
                {
                    "field": "read_card_customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer whose card to retrieve",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "read_card_source_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the card/source to retrieve",
                    "label": "Source ID",
                    "placeholder": "card_1A2B3C4D5E6F7G8H",
                },
            ],
            "outputs": [
                {
                    "field": "card_id",
                    "type": "string",
                    "helper_text": "Unique ID of the card",
                },
                {
                    "field": "customer_id",
                    "type": "string",
                    "helper_text": "Customer ID the card is attached to",
                },
                {
                    "field": "brand",
                    "type": "string",
                    "helper_text": "Card brand (e.g., Visa, MasterCard)",
                },
                {
                    "field": "last4",
                    "type": "string",
                    "helper_text": "Last 4 digits of the card",
                },
                {
                    "field": "exp_month",
                    "type": "int32",
                    "helper_text": "Card expiration month",
                },
                {
                    "field": "exp_year",
                    "type": "int32",
                    "helper_text": "Card expiration year",
                },
                {
                    "field": "fingerprint",
                    "type": "string",
                    "helper_text": "Unique fingerprint for the card",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "read_customer_card",
            "task_name": "tasks.stripe.read_customer_card",
            "description": "Retrieve details of a customer's card",
            "label": "Read Customer Card",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "read_card_customer_id",
                "read_card_source_id",
            ],
        },
        "remove_customer_card": {
            "inputs": [
                {
                    "field": "remove_card_customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer whose card to remove",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "remove_card_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the card to remove",
                    "label": "Card ID",
                    "placeholder": "card_1A2B3C4D5E6F7G8H",
                },
            ],
            "outputs": [
                {
                    "field": "card_id",
                    "type": "string",
                    "helper_text": "ID of the removed card",
                },
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "Whether the card was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "remove_customer_card",
            "task_name": "tasks.stripe.remove_customer_card",
            "description": "Remove a card from a customer",
            "label": "Remove Customer Card",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "remove_card_customer_id",
                "remove_card_id",
            ],
        },
        "create_source": {
            "inputs": [
                {
                    "field": "source_customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer to attach the source to",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "source_type",
                    "type": "string",
                    "value": "wechat",
                    "helper_text": "Type of source to create",
                    "label": "Source Type",
                    "component": {
                        "type": "dropdown",
                        "options": [{"label": "WeChat", "value": "wechat"}],
                    },
                },
                {
                    "field": "source_amount",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Amount in cents for this source",
                    "label": "Amount (cents)",
                    "placeholder": "5000",
                },
                {
                    "field": "source_currency",
                    "type": "string",
                    "value": "USD",
                    "helper_text": "Three-letter currency code",
                    "label": "Currency",
                    "placeholder": "USD",
                },
                {
                    "field": "source_statement_descriptor",
                    "type": "string",
                    "value": "",
                    "helper_text": "Text to display on customer's statement",
                    "label": "Statement Descriptor",
                    "placeholder": "Payment description",
                },
            ],
            "outputs": [
                {
                    "field": "source_id",
                    "type": "string",
                    "helper_text": "Unique ID of the created source",
                },
                {
                    "field": "source_type",
                    "type": "string",
                    "helper_text": "Type of the source",
                },
                {
                    "field": "source_amount",
                    "type": "int32",
                    "helper_text": "Amount for the source in cents",
                },
                {
                    "field": "source_currency",
                    "type": "string",
                    "helper_text": "Currency of the source",
                },
                {
                    "field": "source_status",
                    "type": "string",
                    "helper_text": "Status of the source",
                },
                {
                    "field": "source_customer",
                    "type": "string",
                    "helper_text": "Customer ID the source is attached to",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_source",
            "task_name": "tasks.stripe.create_source",
            "description": "Create a new payment source",
            "label": "Create Source",
            "inputs_sort_order": [
                "integration",
                "action",
                "source_customer_id",
                "source_type",
                "source_amount",
                "source_currency",
                "source_statement_descriptor",
            ],
        },
        "read_source": {
            "inputs": [
                {
                    "field": "read_source_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the source to retrieve",
                    "label": "Source ID",
                    "placeholder": "src_123456789",
                }
            ],
            "outputs": [
                {
                    "field": "source_id",
                    "type": "string",
                    "helper_text": "Unique ID of the source",
                },
                {
                    "field": "source_type",
                    "type": "string",
                    "helper_text": "Type of the source",
                },
                {
                    "field": "source_amount",
                    "type": "int32",
                    "helper_text": "Amount for the source in cents",
                },
                {
                    "field": "source_currency",
                    "type": "string",
                    "helper_text": "Currency of the source",
                },
                {
                    "field": "source_status",
                    "type": "string",
                    "helper_text": "Status of the source",
                },
                {
                    "field": "source_customer",
                    "type": "string",
                    "helper_text": "Customer ID the source is attached to",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "read_source",
            "task_name": "tasks.stripe.read_source",
            "description": "Retrieve details of a source",
            "label": "Read Source",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "read_source_id"],
        },
        "delete_source": {
            "inputs": [
                {
                    "field": "delete_source_customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer whose source to delete",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "delete_source_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the source to delete",
                    "label": "Source ID",
                    "placeholder": "src_123456789",
                },
            ],
            "outputs": [
                {
                    "field": "source_id",
                    "type": "string",
                    "helper_text": "ID of the deleted source",
                },
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "Whether the source was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "delete_source",
            "task_name": "tasks.stripe.delete_source",
            "description": "Delete a source from a customer",
            "label": "Delete Source",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "delete_source_customer_id",
                "delete_source_id",
            ],
        },
        "create_token": {
            "inputs": [
                {
                    "field": "token_card_number",
                    "type": "string",
                    "value": "",
                    "helper_text": "Card number",
                    "label": "Card Number",
                    "placeholder": "4242424242424242",
                },
                {
                    "field": "token_cvc",
                    "type": "string",
                    "value": "",
                    "helper_text": "Card security code",
                    "label": "CVC",
                    "placeholder": "314",
                },
                {
                    "field": "token_exp_month",
                    "type": "string",
                    "value": "",
                    "helper_text": "Expiration month",
                    "label": "Expiration Month",
                    "placeholder": "10",
                },
                {
                    "field": "token_exp_year",
                    "type": "string",
                    "value": "",
                    "helper_text": "Expiration year",
                    "label": "Expiration Year",
                    "placeholder": "2027",
                },
            ],
            "outputs": [
                {
                    "field": "token_id",
                    "type": "string",
                    "helper_text": "Unique ID of the created token",
                },
                {
                    "field": "token_type",
                    "type": "string",
                    "helper_text": "Type of the token",
                },
                {
                    "field": "card_brand",
                    "type": "string",
                    "helper_text": "Brand of the card",
                },
                {
                    "field": "card_last4",
                    "type": "string",
                    "helper_text": "Last 4 digits of the card",
                },
                {
                    "field": "card_exp_month",
                    "type": "int32",
                    "helper_text": "Card expiration month",
                },
                {
                    "field": "card_exp_year",
                    "type": "int32",
                    "helper_text": "Card expiration year",
                },
                {
                    "field": "card_fingerprint",
                    "type": "string",
                    "helper_text": "Unique fingerprint for the card",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "create_token",
            "task_name": "tasks.stripe.create_token",
            "description": "Create a new card token",
            "label": "Create Token",
            "inputs_sort_order": [
                "integration",
                "action",
                "token_card_number",
                "token_cvc",
                "token_exp_month",
                "token_exp_year",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        card_customer_id: str = "",
        card_token: str = "",
        charge_amount: int = 0,
        charge_currency: str = "USD",
        charge_description: str = "",
        charge_id: str = "",
        charge_source: str = "",
        coupon_amount_off: int = 0,
        coupon_currency: str = "USD",
        coupon_duration: str = "once",
        coupon_duration_in_months: int = 0,
        coupon_max_redemptions: int = 0,
        coupon_name: str = "",
        coupon_percent_off: Any = 0.0,
        customer_description: str = "",
        customer_email: str = "",
        customer_id: str = "",
        customer_name: str = "",
        customer_phone: str = "",
        delete_source_customer_id: str = "",
        delete_source_id: str = "",
        num_messages: int = 10,
        read_card_customer_id: str = "",
        read_card_source_id: str = "",
        read_source_id: str = "",
        remove_card_customer_id: str = "",
        remove_card_id: str = "",
        source_amount: int = 0,
        source_currency: str = "USD",
        source_customer_id: str = "",
        source_statement_descriptor: str = "",
        source_type: str = "wechat",
        token_card_number: str = "",
        token_cvc: str = "",
        token_exp_month: str = "",
        token_exp_year: str = "",
        update_charge_description: str = "",
        update_customer_description: str = "",
        update_customer_email: str = "",
        update_customer_name: str = "",
        update_customer_phone: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_stripe",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if customer_name is not None:
            self.inputs["customer_name"] = customer_name
        if customer_email is not None:
            self.inputs["customer_email"] = customer_email
        if customer_phone is not None:
            self.inputs["customer_phone"] = customer_phone
        if customer_description is not None:
            self.inputs["customer_description"] = customer_description
        if customer_id is not None:
            self.inputs["customer_id"] = customer_id
        if update_customer_name is not None:
            self.inputs["update_customer_name"] = update_customer_name
        if update_customer_email is not None:
            self.inputs["update_customer_email"] = update_customer_email
        if update_customer_phone is not None:
            self.inputs["update_customer_phone"] = update_customer_phone
        if update_customer_description is not None:
            self.inputs["update_customer_description"] = update_customer_description
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if charge_amount is not None:
            self.inputs["charge_amount"] = charge_amount
        if charge_currency is not None:
            self.inputs["charge_currency"] = charge_currency
        if charge_source is not None:
            self.inputs["charge_source"] = charge_source
        if charge_description is not None:
            self.inputs["charge_description"] = charge_description
        if charge_id is not None:
            self.inputs["charge_id"] = charge_id
        if update_charge_description is not None:
            self.inputs["update_charge_description"] = update_charge_description
        if coupon_duration is not None:
            self.inputs["coupon_duration"] = coupon_duration
        if coupon_amount_off is not None:
            self.inputs["coupon_amount_off"] = coupon_amount_off
        if coupon_percent_off is not None:
            self.inputs["coupon_percent_off"] = coupon_percent_off
        if coupon_currency is not None:
            self.inputs["coupon_currency"] = coupon_currency
        if coupon_name is not None:
            self.inputs["coupon_name"] = coupon_name
        if coupon_duration_in_months is not None:
            self.inputs["coupon_duration_in_months"] = coupon_duration_in_months
        if coupon_max_redemptions is not None:
            self.inputs["coupon_max_redemptions"] = coupon_max_redemptions
        if card_customer_id is not None:
            self.inputs["card_customer_id"] = card_customer_id
        if card_token is not None:
            self.inputs["card_token"] = card_token
        if read_card_customer_id is not None:
            self.inputs["read_card_customer_id"] = read_card_customer_id
        if read_card_source_id is not None:
            self.inputs["read_card_source_id"] = read_card_source_id
        if remove_card_customer_id is not None:
            self.inputs["remove_card_customer_id"] = remove_card_customer_id
        if remove_card_id is not None:
            self.inputs["remove_card_id"] = remove_card_id
        if source_customer_id is not None:
            self.inputs["source_customer_id"] = source_customer_id
        if source_type is not None:
            self.inputs["source_type"] = source_type
        if source_amount is not None:
            self.inputs["source_amount"] = source_amount
        if source_currency is not None:
            self.inputs["source_currency"] = source_currency
        if source_statement_descriptor is not None:
            self.inputs["source_statement_descriptor"] = source_statement_descriptor
        if read_source_id is not None:
            self.inputs["read_source_id"] = read_source_id
        if delete_source_customer_id is not None:
            self.inputs["delete_source_customer_id"] = delete_source_customer_id
        if delete_source_id is not None:
            self.inputs["delete_source_id"] = delete_source_id
        if token_card_number is not None:
            self.inputs["token_card_number"] = token_card_number
        if token_cvc is not None:
            self.inputs["token_cvc"] = token_cvc
        if token_exp_month is not None:
            self.inputs["token_exp_month"] = token_exp_month
        if token_exp_year is not None:
            self.inputs["token_exp_year"] = token_exp_year
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def available(self) -> str:
        """
        Available balance amounts by currency

        Available: get_balance


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("available")

    @property
    def brand(self) -> str:
        """
        Card brand (e.g., Visa, MasterCard)

        Available: add_customer_card, read_customer_card


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("brand")

    @property
    def card_brand(self) -> str:
        """
        Brand of the card

        Available: create_token


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("card_brand")

    @property
    def card_exp_month(self) -> int:
        """
        Card expiration month

        Available: create_token


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("card_exp_month")

    @property
    def card_exp_year(self) -> int:
        """
        Card expiration year

        Available: create_token


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("card_exp_year")

    @property
    def card_fingerprint(self) -> str:
        """
        Unique fingerprint for the card

        Available: create_token


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("card_fingerprint")

    @property
    def card_id(self) -> str:
        """
        Unique ID of the added card

        Different behavior based on configuration:
          - Unique ID of the added card (add_customer_card)
          - Unique ID of the card (read_customer_card)
          - ID of the removed card (remove_customer_card)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("card_id")

    @property
    def card_last4(self) -> str:
        """
        Last 4 digits of the card

        Available: create_token


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("card_last4")

    @property
    def charge_amount(self) -> int:
        """
        Amount charged in cents

        Available: create_charge, read_charge, update_charge


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_amount")

    @property
    def charge_amounts(self) -> List[int]:
        """
        List of charge amounts

        Available: get_charges


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_amounts")

    @property
    def charge_currencies(self) -> List[str]:
        """
        List of charge currencies

        Available: get_charges


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_currencies")

    @property
    def charge_currency(self) -> str:
        """
        Currency of the charge

        Available: create_charge, read_charge, update_charge


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_currency")

    @property
    def charge_customer(self) -> str:
        """
        Customer ID associated with charge

        Available: create_charge, read_charge, update_charge


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_customer")

    @property
    def charge_customers(self) -> List[str]:
        """
        List of associated customer IDs

        Available: get_charges


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_customers")

    @property
    def charge_description(self) -> str:
        """
        Charge description

        Available: create_charge, read_charge, update_charge


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_description")

    @property
    def charge_descriptions(self) -> List[str]:
        """
        List of charge descriptions

        Available: get_charges


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_descriptions")

    @property
    def charge_id(self) -> str:
        """
        Unique ID of the created charge

        Different behavior based on configuration:
          - Unique ID of the created charge (create_charge)
          - Unique ID of the charge (read_charge, update_charge)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_id")

    @property
    def charge_ids(self) -> List[str]:
        """
        List of charge IDs

        Available: get_charges


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_ids")

    @property
    def charge_paid(self) -> bool:
        """
        Whether the charge was paid

        Available: create_charge, read_charge, update_charge


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_paid")

    @property
    def charge_paids(self) -> List[bool]:
        """
        List of paid status booleans

        Available: get_charges


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_paids")

    @property
    def charge_status(self) -> str:
        """
        Status of the charge

        Available: create_charge, read_charge, update_charge


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_status")

    @property
    def charge_statuses(self) -> List[str]:
        """
        List of charge statuses

        Available: get_charges


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("charge_statuses")

    @property
    def coupon_amount_off(self) -> int:
        """
        Fixed amount off in cents

        Available: create_coupon


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_amount_off")

    @property
    def coupon_amount_offs(self) -> List[int]:
        """
        List of amount offs

        Available: get_coupons


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_amount_offs")

    @property
    def coupon_currencies(self) -> List[str]:
        """
        List of coupon currencies

        Available: get_coupons


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_currencies")

    @property
    def coupon_currency(self) -> str:
        """
        Currency of the coupon

        Available: create_coupon


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_currency")

    @property
    def coupon_duration(self) -> str:
        """
        Duration of the coupon

        Available: create_coupon


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_duration")

    @property
    def coupon_duration_in_months(self) -> int:
        """
        Duration in months

        Available: create_coupon


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_duration_in_months")

    @property
    def coupon_durations(self) -> List[str]:
        """
        List of coupon durations

        Available: get_coupons


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_durations")

    @property
    def coupon_id(self) -> str:
        """
        Unique ID of the created coupon

        Available: create_coupon


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_id")

    @property
    def coupon_ids(self) -> List[str]:
        """
        List of coupon IDs

        Available: get_coupons


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_ids")

    @property
    def coupon_max_redemptions(self) -> int:
        """
        Maximum redemptions allowed

        Available: create_coupon


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_max_redemptions")

    @property
    def coupon_name(self) -> str:
        """
        Name of the coupon

        Available: create_coupon


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_name")

    @property
    def coupon_names(self) -> List[str]:
        """
        List of coupon names

        Available: get_coupons


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_names")

    @property
    def coupon_percent_off(self) -> Any:
        """
        Percentage off

        Available: create_coupon


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_percent_off")

    @property
    def coupon_percent_offs(self) -> List[Any]:
        """
        List of percent offs

        Available: get_coupons


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_percent_offs")

    @property
    def coupon_times_redeemed(self) -> int:
        """
        Times already redeemed

        Available: create_coupon


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_times_redeemed")

    @property
    def coupon_valid(self) -> bool:
        """
        Whether the coupon is valid

        Available: create_coupon


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_valid")

    @property
    def coupon_valids(self) -> List[bool]:
        """
        List of validity statuses

        Available: get_coupons


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("coupon_valids")

    @property
    def created_at(self) -> str:
        """
        Creation timestamp in RFC3339 format

        Available: create_customer, read_customer, create_charge, read_charge, create_coupon, create_source, read_source, create_token


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_at")

    @property
    def created_ats(self) -> List[str]:
        """
        List of creation timestamps

        Available: get_customers, get_charges, get_coupons


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_ats")

    @property
    def customer_description(self) -> str:
        """
        Customer description

        Available: create_customer, read_customer, update_customer


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("customer_description")

    @property
    def customer_descriptions(self) -> List[str]:
        """
        List of customer descriptions

        Available: get_customers


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("customer_descriptions")

    @property
    def customer_email(self) -> str:
        """
        Customer's email address

        Available: create_customer, read_customer, update_customer


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("customer_email")

    @property
    def customer_emails(self) -> List[str]:
        """
        List of customer emails

        Available: get_customers


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("customer_emails")

    @property
    def customer_id(self) -> str:
        """
        Unique ID of the created customer

        Different behavior based on configuration:
          - Unique ID of the created customer (create_customer)
          - Unique ID of the customer (read_customer, update_customer)
          - ID of the deleted customer (delete_customer)
          - Customer ID the card is attached to (add_customer_card, read_customer_card)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("customer_id")

    @property
    def customer_ids(self) -> List[str]:
        """
        List of customer IDs

        Available: get_customers


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("customer_ids")

    @property
    def customer_name(self) -> str:
        """
        Customer's full name

        Available: create_customer, read_customer, update_customer


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("customer_name")

    @property
    def customer_names(self) -> List[str]:
        """
        List of customer names

        Available: get_customers


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("customer_names")

    @property
    def customer_phone(self) -> str:
        """
        Customer's phone number

        Available: create_customer, read_customer, update_customer


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("customer_phone")

    @property
    def customer_phones(self) -> List[str]:
        """
        List of customer phones

        Available: get_customers


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("customer_phones")

    @property
    def deleted(self) -> bool:
        """
        Whether the deletion was successful

        Different behavior based on configuration:
          - Whether the deletion was successful (delete_customer)
          - Whether the card was successfully deleted (remove_customer_card)
          - Whether the source was successfully deleted (delete_source)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("deleted")

    @property
    def exp_month(self) -> int:
        """
        Card expiration month

        Available: add_customer_card, read_customer_card


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("exp_month")

    @property
    def exp_year(self) -> int:
        """
        Card expiration year

        Available: add_customer_card, read_customer_card


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("exp_year")

    @property
    def fingerprint(self) -> str:
        """
        Unique fingerprint for the card

        Available: add_customer_card, read_customer_card


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("fingerprint")

    @property
    def last4(self) -> str:
        """
        Last 4 digits of the card

        Available: add_customer_card, read_customer_card


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("last4")

    @property
    def livemode(self) -> bool:
        """
        Whether this is live or test mode

        Available: get_balance


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("livemode")

    @property
    def message(self) -> str:
        """
        Success message

        Available: update_customer, delete_customer, update_charge, remove_customer_card, delete_source


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("message")

    @property
    def object(self) -> str:
        """
        Object type identifier

        Available: get_balance


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("object")

    @property
    def pending(self) -> str:
        """
        Pending balance amounts by currency

        Available: get_balance


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pending")

    @property
    def raw_data(self) -> str:
        """
        Raw response from Stripe API

        Available: get_balance, create_customer, read_customer, update_customer, delete_customer, get_customers, create_charge, read_charge, update_charge, get_charges, create_coupon, get_coupons, add_customer_card, read_customer_card, remove_customer_card, create_source, read_source, delete_source, create_token


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("raw_data")

    @property
    def source_amount(self) -> int:
        """
        Amount for the source in cents

        Available: create_source, read_source


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("source_amount")

    @property
    def source_currency(self) -> str:
        """
        Currency of the source

        Available: create_source, read_source


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("source_currency")

    @property
    def source_customer(self) -> str:
        """
        Customer ID the source is attached to

        Available: create_source, read_source


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("source_customer")

    @property
    def source_id(self) -> str:
        """
        Unique ID of the created source

        Different behavior based on configuration:
          - Unique ID of the created source (create_source)
          - Unique ID of the source (read_source)
          - ID of the deleted source (delete_source)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("source_id")

    @property
    def source_status(self) -> str:
        """
        Status of the source

        Available: create_source, read_source


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("source_status")

    @property
    def source_type(self) -> str:
        """
        Type of the source

        Available: create_source, read_source


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("source_type")

    @property
    def token_id(self) -> str:
        """
        Unique ID of the created token

        Available: create_token


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("token_id")

    @property
    def token_type(self) -> str:
        """
        Type of the token

        Available: create_token


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("token_type")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationStripeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_teams")
class IntegrationTeamsNode(Node):
    """
    Teams

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### send_message
        channel_name: The name of the channel in the specified team
        message: The message you want to send
        team_name: The name of the team

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Teams>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "send_message": {
            "inputs": [
                {
                    "field": "team_name",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the team",
                    "agent_field_type": "static",
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "value": "",
                    "label": "Channel",
                    "placeholder": "General",
                    "helper_text": "The name of the channel in the specified team",
                    "agent_field_type": "static",
                },
                {
                    "field": "message",
                    "type": "string",
                    "value": "",
                    "label": "Message",
                    "placeholder": "Hello World!",
                    "helper_text": "The message you want to send",
                },
            ],
            "outputs": [],
            "name": "send_message",
            "task_name": "teams.create_message",
            "description": "Post a new message to a specific teams channel",
            "label": "Send Message",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        channel_name: str = "",
        message: str = "",
        team_name: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_teams",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if team_name is not None:
            self.inputs["team_name"] = team_name
        if channel_name is not None:
            self.inputs["channel_name"] = channel_name
        if message is not None:
            self.inputs["message"] = message
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationTeamsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_x")
class IntegrationXNode(Node):
    """
    X

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_post
        text: The text of the post
    ### create_thread
        text: The text of the post

    ## Outputs
    ### create_post
        post_url: URL of the created post
    ### create_thread
        post_url: URL of the created thread
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<X>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "create_post": {
            "inputs": [
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Text",
                    "placeholder": "Hello World!",
                    "helper_text": "The text of the post",
                }
            ],
            "outputs": [
                {
                    "field": "post_url",
                    "type": "string",
                    "helper_text": "URL of the created post",
                }
            ],
            "name": "create_post",
            "task_name": "tasks.x.create_post",
            "description": "Create a new post on X",
            "label": "Create Post",
        },
        "create_thread": {
            "inputs": [
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Text",
                    "placeholder": '["Post1", "Post2", "Post3"]',
                    "helper_text": "A list of text to be posted as a thread",
                }
            ],
            "outputs": [
                {
                    "field": "post_url",
                    "type": "string",
                    "helper_text": "URL of the created thread",
                }
            ],
            "name": "create_thread",
            "task_name": "tasks.x.create_thread",
            "description": "Create a new thread on X",
            "label": "Create Thread",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        text: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_x",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if text is not None:
            self.inputs["text"] = text
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def post_url(self) -> str:
        """
        URL of the created post

        Different behavior based on configuration:
          - URL of the created post (create_post)
          - URL of the created thread (create_thread)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("post_url")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationXNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_gohighlevel")
class IntegrationGohighlevelNode(Node):
    """
    GoHighLevel

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_opportunity
        contact_name: Name of the existing contact to link to the opportunity. One contact can only be linked to one opportunity.
        name: Name of the opportunity
        pipeline_name: Name of the existing pipeline to link to the opportunity
        status: Status of the opportunity (must be one of: 'open', 'won', 'lost', 'abandoned')
        value: Money value of the opportunity
    ### create_contact
        email: Email address of the contact
        first_name: First name of the contact
        last_name: Last name of the contact
        phone: Phone number of the contact

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<GoHighLevel>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "create_contact": {
            "inputs": [
                {
                    "field": "first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "John",
                    "helper_text": "First name of the contact",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Doe",
                    "helper_text": "Last name of the contact",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@doe.com",
                    "helper_text": "Email address of the contact",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "value": "",
                    "label": "Phone",
                    "placeholder": "+1 888-888-8888",
                    "helper_text": "Phone number of the contact",
                },
            ],
            "outputs": [],
            "name": "create_contact",
            "task_name": "tasks.gohighlevel.create_contact",
            "description": "Create a new contact on GoHighLevel",
            "label": "Create Contact",
        },
        "create_opportunity": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name",
                    "placeholder": "First op",
                    "helper_text": "Name of the opportunity",
                },
                {
                    "field": "status",
                    "type": "string",
                    "value": "",
                    "label": "Status",
                    "placeholder": "open",
                    "helper_text": "Status of the opportunity (must be one of: 'open', 'won', 'lost', 'abandoned')",
                },
                {
                    "field": "value",
                    "type": "string",
                    "value": "",
                    "label": "Value",
                    "placeholder": "500",
                    "helper_text": "Money value of the opportunity",
                },
                {
                    "field": "pipeline_name",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline Name",
                    "placeholder": "onboarding",
                    "helper_text": "Name of the existing pipeline to link to the opportunity",
                },
                {
                    "field": "contact_name",
                    "type": "string",
                    "value": "",
                    "label": "Contact Name",
                    "placeholder": "John",
                    "helper_text": "Name of the existing contact to link to the opportunity. One contact can only be linked to one opportunity.",
                },
            ],
            "outputs": [],
            "name": "create_opportunity",
            "task_name": "tasks.gohighlevel.create_opportunity",
            "description": "Create a new opportunity on GoHighLevel",
            "label": "Create Opportunity",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        contact_name: str = "",
        email: str = "",
        first_name: str = "",
        last_name: str = "",
        name: str = "",
        phone: str = "",
        pipeline_name: str = "",
        status: str = "",
        value: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_gohighlevel",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if first_name is not None:
            self.inputs["first_name"] = first_name
        if last_name is not None:
            self.inputs["last_name"] = last_name
        if email is not None:
            self.inputs["email"] = email
        if phone is not None:
            self.inputs["phone"] = phone
        if name is not None:
            self.inputs["name"] = name
        if status is not None:
            self.inputs["status"] = status
        if value is not None:
            self.inputs["value"] = value
        if pipeline_name is not None:
            self.inputs["pipeline_name"] = pipeline_name
        if contact_name is not None:
            self.inputs["contact_name"] = contact_name
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGohighlevelNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_peopledatalabs")
class IntegrationPeopledatalabsNode(Node):
    """
    PeopleDataLabs

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### enrich_person
        company: The name, website, or social URL of a company where the person has worked
        email: Email address of the person
        first_name: First name of the person
        last_name: Last name of the person
        location: The location where a person lives (can be address, city, country, etc.)
        profile_url: Social media profile URLs for the contact (LinkedIn, Twitter, Facebook, etc.)
    ### search_companies
        company_size_ranges: Comma-separated list of company size ranges. The value should be one of the ones mentioned here: https://docs.peopledatalabs.com/docs/company-sizes
        country: Name of the country
        founded_year_range: A range representing the founding year of the company
        industries: Comma-separated list of industries
        number_of_results: Number of results to return
        tags: Comma-separated tags associated with the company
    ### search_people
        country: Name of the country
        job_company_names: Comma-separated list of company names to search within
        job_titles: Comma-separated list of job titles
        number_of_results: Number of results to return
        skills: Comma-separated list of skills to search for
    ### search_people_query
        es_query: A valid Elasticsearch query. Available Fields: https://docs.peopledatalabs.com/docs/elasticsearch-mapping
        number_of_results: Number of results to return
        sql: A valid SQL query
    ### search_companies_query
        es_query: A valid Elasticsearch query. Available Fields: https://docs.peopledatalabs.com/docs/elasticsearch-mapping
        number_of_results: Number of results to return
        sql: A valid SQL query
    ### enrich_company
        name: The name of the company
        profile: Company social media profile URL
        website: Company website URL

    ## Outputs
    ### enrich_person
        output: Enriched person data including additional information found
    ### search_people
        output: List of matching people profiles
    ### search_people_query
        output: List of matching people profiles
    ### enrich_company
        output: Enriched company data including additional information found
    ### search_companies
        output: List of matching company profiles
    ### search_companies_query
        output: List of matching company profiles
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<PeopleDataLabs>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "enrich_person": {
            "inputs": [
                {
                    "field": "first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "John",
                    "helper_text": "First name of the person",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Doe",
                    "helper_text": "Last name of the person",
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "placeholder": "San Francisco, CA",
                    "helper_text": "The location where a person lives (can be address, city, country, etc.)",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@doe.com",
                    "helper_text": "Email address of the person",
                },
                {
                    "field": "company",
                    "type": "string",
                    "value": "",
                    "label": "Company",
                    "placeholder": "Acme Corp",
                    "helper_text": "The name, website, or social URL of a company where the person has worked",
                },
                {
                    "field": "profile_url",
                    "type": "string",
                    "value": "",
                    "label": "Profile URL",
                    "placeholder": "linkedin.com/in/johnsmith",
                    "helper_text": "Social media profile URLs for the contact (LinkedIn, Twitter, Facebook, etc.)",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Enriched person data including additional information found",
                }
            ],
            "name": "enrich_person",
            "task_name": "tasks.peopledatalabs.enrich_person",
            "description": "Enrich Person",
            "label": "Enrich Person",
        },
        "search_people": {
            "inputs": [
                {
                    "field": "country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "US",
                    "helper_text": "Name of the country",
                },
                {
                    "field": "job_titles",
                    "type": "string",
                    "value": "",
                    "label": "Job Titles",
                    "placeholder": "Software Engineer, Product Manager, CTO",
                    "helper_text": "Comma-separated list of job titles",
                },
                {
                    "field": "job_company_names",
                    "type": "string",
                    "value": "",
                    "label": "Job Company Names",
                    "placeholder": "Google, Microsoft, Apple",
                    "helper_text": "Comma-separated list of company names to search within",
                },
                {
                    "field": "skills",
                    "type": "string",
                    "value": "",
                    "label": "Skills",
                    "placeholder": "Python, Machine Learning, Leadership",
                    "helper_text": "Comma-separated list of skills to search for",
                },
                {
                    "field": "number_of_results",
                    "type": "string",
                    "value": "",
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Number of results to return",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matching people profiles",
                }
            ],
            "name": "search_people",
            "task_name": "tasks.peopledatalabs.search_people",
            "description": "Search People",
            "label": "Search People",
        },
        "search_people_query": {
            "inputs": [
                {
                    "field": "es_query",
                    "type": "string",
                    "value": "",
                    "label": "ES Query",
                    "placeholder": '{"query": {"match_all": {}}}',
                    "helper_text": "A valid Elasticsearch query. Available Fields: https://docs.peopledatalabs.com/docs/elasticsearch-mapping",
                },
                {
                    "field": "sql",
                    "type": "string",
                    "value": "",
                    "label": "SQL",
                    "placeholder": '{"query": {"match": {"job_title": "Software Engineer"}}}',
                    "helper_text": "A valid SQL query",
                },
                {
                    "field": "number_of_results",
                    "type": "string",
                    "value": "",
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Number of results to return",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matching people profiles",
                }
            ],
            "name": "search_people_query",
            "task_name": "tasks.peopledatalabs.search_people_query",
            "description": "Search People (query)",
            "label": "Search People (query)",
        },
        "enrich_company": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name",
                    "placeholder": "Acme Corp",
                    "helper_text": "The name of the company",
                },
                {
                    "field": "profile",
                    "type": "string",
                    "value": "",
                    "label": "Profile",
                    "placeholder": "linkedin.com/company/acme-corp",
                    "helper_text": "Company social media profile URL",
                },
                {
                    "field": "website",
                    "type": "string",
                    "value": "",
                    "label": "Website",
                    "placeholder": "www.acmecorp.com",
                    "helper_text": "Company website URL",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Enriched company data including additional information found",
                }
            ],
            "name": "enrich_company",
            "task_name": "tasks.peopledatalabs.enrich_company",
            "description": "Enrich Company",
            "label": "Enrich Company",
        },
        "search_companies": {
            "inputs": [
                {
                    "field": "tags",
                    "type": "string",
                    "value": "",
                    "label": "Tags",
                    "placeholder": "B2B, SaaS, Fintech",
                    "helper_text": "Comma-separated tags associated with the company",
                },
                {
                    "field": "industries",
                    "type": "string",
                    "value": "",
                    "label": "Industries",
                    "placeholder": "Technology, Healthcare, Finance",
                    "helper_text": "Comma-separated list of industries",
                },
                {
                    "field": "company_size_ranges",
                    "type": "string",
                    "value": "",
                    "label": "Company Size Ranges",
                    "placeholder": "1-10, 11-50, 51-200, 201-500, 501-1000, 1000+",
                    "helper_text": "Comma-separated list of company size ranges. The value should be one of the ones mentioned here: https://docs.peopledatalabs.com/docs/company-sizes",
                },
                {
                    "field": "founded_year_range",
                    "type": "string",
                    "value": "",
                    "label": "Founded Year Range",
                    "placeholder": "2015-2020",
                    "helper_text": "A range representing the founding year of the company",
                },
                {
                    "field": "country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "US",
                    "helper_text": "Name of the country",
                },
                {
                    "field": "number_of_results",
                    "type": "string",
                    "value": "",
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Number of results to return",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matching company profiles",
                }
            ],
            "name": "search_companies",
            "task_name": "tasks.peopledatalabs.search_companies",
            "description": "Search Companies",
            "label": "Search Companies",
        },
        "search_companies_query": {
            "inputs": [
                {
                    "field": "es_query",
                    "type": "string",
                    "value": "",
                    "label": "Elastic Search Query",
                    "placeholder": '{"query": {"match_all": {}}}',
                    "helper_text": "A valid Elasticsearch query. Available fields: https://docs.peopledatalabs.com/docs/elasticsearch-mapping-company",
                },
                {
                    "field": "sql",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "SELECT * FROM companies WHERE industry = 'Technology'",
                    "helper_text": "A valid SQL Query. Available fields: https://docs.peopledatalabs.com/docs/company-schema",
                },
                {
                    "field": "number_of_results",
                    "type": "int32",
                    "value": 10,
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Number of results to display",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matching company profiles",
                }
            ],
            "name": "search_companies_query",
            "task_name": "tasks.peopledatalabs.search_companies_query",
            "description": "Search Companies (query)",
            "label": "Search Companies (query)",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        company: str = "",
        company_size_ranges: str = "",
        country: str = "",
        email: str = "",
        es_query: str = "",
        first_name: str = "",
        founded_year_range: str = "",
        industries: str = "",
        job_company_names: str = "",
        job_titles: str = "",
        last_name: str = "",
        location: str = "",
        name: str = "",
        number_of_results: str = "",
        profile: str = "",
        profile_url: str = "",
        skills: str = "",
        sql: str = "",
        tags: str = "",
        website: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_peopledatalabs",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if first_name is not None:
            self.inputs["first_name"] = first_name
        if last_name is not None:
            self.inputs["last_name"] = last_name
        if location is not None:
            self.inputs["location"] = location
        if email is not None:
            self.inputs["email"] = email
        if company is not None:
            self.inputs["company"] = company
        if profile_url is not None:
            self.inputs["profile_url"] = profile_url
        if country is not None:
            self.inputs["country"] = country
        if job_titles is not None:
            self.inputs["job_titles"] = job_titles
        if job_company_names is not None:
            self.inputs["job_company_names"] = job_company_names
        if skills is not None:
            self.inputs["skills"] = skills
        if number_of_results is not None:
            self.inputs["number_of_results"] = number_of_results
        if es_query is not None:
            self.inputs["es_query"] = es_query
        if sql is not None:
            self.inputs["sql"] = sql
        if name is not None:
            self.inputs["name"] = name
        if profile is not None:
            self.inputs["profile"] = profile
        if website is not None:
            self.inputs["website"] = website
        if tags is not None:
            self.inputs["tags"] = tags
        if industries is not None:
            self.inputs["industries"] = industries
        if company_size_ranges is not None:
            self.inputs["company_size_ranges"] = company_size_ranges
        if founded_year_range is not None:
            self.inputs["founded_year_range"] = founded_year_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Enriched person data including additional information found

        Different behavior based on configuration:
          - Enriched person data including additional information found (enrich_person)
          - List of matching people profiles (search_people, search_people_query)
          - Enriched company data including additional information found (enrich_company)
          - List of matching company profiles (search_companies, search_companies_query)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationPeopledatalabsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_hubspot")
class IntegrationHubspotNode(Node):
    """
    Hubspot

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'create_company'
        about_us: About the company
        annual_revenue: Annual revenue
        city: City of residence
        company_domain_name: Company's domain name
        company_owner: Owner's user ID
        country_region: Country or region
        create_company_name: Required company name
        description: Company description
        industry: Type of industry
        lead_status: Filter by lead status
        lifecycle: Lifecycle stage
        number_of_employees: Employee count
        phone_number: Main phone number
        website_url: Contact's website
    ### When action = 'create_deal'
        amount: Deal amount
        associated_company: Associated company IDs
        associated_vids: Associated contact IDs
        close_date: Close date
        create_deal_stage: Required deal stage ID
        deal_name: Deal name
        deal_owner: Deal owner ID
        deal_type: Deal type
        description: Company description
        pipeline: Pipeline ID
    ### When action = 'get_deals'
        amount: Deal amount
        close_date: Close date
        created_date: Filter by creation date (YYYY-MM-DD)
        deal_currency_code: Filter by currency code
        deal_name: Deal name
        deal_stage: Filter by deal stage
        deal_type: Deal type
        hs_analytics_source: Filter by original source
        hs_date_entered_closed_lost: Filter by date entered closed lost
        hs_date_entered_closed_won: Filter by date entered closed won
        hs_deal_stage_probability: Filter by deal probability
        hs_forecast_amount: Filter by forecast amount
        hs_is_closed: Filter by closed status
        hs_is_deal_split: Filter by deal split status
        hs_latest_source: Filter by latest source
        hubspot_owner_id: Filter by contact owner ID
        last_modified_date: Filter by last modified date (YYYY-MM-DD)
        num_associated_contacts: Filter by number of associated contacts
        num_contacted_notes: Filter by number of contact notes
        pipeline: Pipeline ID
        properties: Comma-separated properties to fetch
        query: General search query
        sort_by: Field to sort by
        sort_order: Sort order (asc/desc)
        use_date: Toggle to use dates
    ### When action = 'get_companies'
        annual_revenue: Annual revenue
        city: City of residence
        country: Country name
        created_date: Filter by creation date (YYYY-MM-DD)
        domain: Search by domain
        founded_year: Filter by founded year
        hs_analytics_source: Filter by original source
        hs_analytics_source_data_1: Filter by source data 1
        hs_analytics_source_data_2: Filter by source data 2
        hubspot_owner_id: Filter by contact owner ID
        industry: Type of industry
        is_public: Filter by public company status
        last_modified_date: Filter by last modified date (YYYY-MM-DD)
        lead_status: Filter by lead status
        lifecycle_stage: Filter by lifecycle stage
        name: Search by company name
        number_of_employees: Employee count
        phone: Search by phone number
        properties: Comma-separated properties to fetch
        query: General search query
        sort_by: Field to sort by
        sort_order: Sort order (asc/desc)
        state: Search by state
        type: Filter by company type
        use_date: Toggle to use dates
        web_technologies: Filter by web technologies
        zip: Search by zip code
    ### When action = 'create_contact'
        associated_company_id: ID of associated company
        city: City of residence
        company: Name of the company
        country: Country name
        create_email: Required contact email
        custom_properties: Custom properties to add to the contact
        first_name: Contact's first name
        job_title: Job title of the contact
        last_name: Contact's last name
        mobile_phone_number: Mobile number
        phone_number: Main phone number
        postal_code: Postal or ZIP code
        state_region: State or region
        street_address: Street address
        website_url: Contact's website
    ### When action = 'create_ticket'
        associated_company_ids: Associated companies
        associated_contact_ids: Associated contacts
        category: Ticket category
        close_date: Close date
        create_ticket_name: Ticket subject (required)
        create_ticket_pipeline_id: Pipeline ID (required)
        create_ticket_stage_id: Stage ID (required)
        description: Company description
        priority: Priority level
        ticket_owner_id: Ticket owner ID
    ### When action = 'add_contact_to_list'
        by: Method to identify contacts: email or id
        contact_ids: Comma-separated contact IDs
        emails: Array of email addresses (when by=email)
        list_id: HubSpot list ID (required)
    ### When action = 'get_contacts'
        city: City of residence
        company_name: Search by company name
        country: Country name
        created_date: Filter by creation date (YYYY-MM-DD)
        email: Search by email address
        first_name: Contact's first name
        hs_analytics_source: Filter by original source
        hs_latest_source: Filter by latest source
        hs_lead_status: Filter by HubSpot lead status
        hubspot_owner_id: Filter by contact owner ID
        job_title: Job title of the contact
        last_modified_date: Filter by last modified date (YYYY-MM-DD)
        last_name: Contact's last name
        lead_status: Filter by lead status
        lifecycle_stage: Filter by lifecycle stage
        phone: Search by phone number
        properties: Comma-separated properties to fetch
        query: General search query
        sort_by: Field to sort by
        sort_order: Sort order (asc/desc)
        state: Search by state
        use_date: Toggle to use dates
        website: Search by website
    ### When action = 'get_tickets'
        closed_date: Filter by closed date (YYYY-MM-DD)
        created_date: Filter by creation date (YYYY-MM-DD)
        first_agent_reply_date: Filter by first agent reply date
        hs_num_times_contacted: Filter by number of times contacted
        hs_pipeline: Filter by pipeline
        hs_pipeline_stage: Filter by pipeline stage
        hs_resolution: Filter by ticket resolution
        hs_ticket_category: Filter by ticket category
        hs_ticket_priority: Filter by ticket priority
        hs_time_to_close: Filter by time to close (milliseconds)
        hs_time_to_first_agent_reply: Filter by time to first agent reply
        hubspot_owner_id: Filter by contact owner ID
        last_modified_date: Filter by last modified date (YYYY-MM-DD)
        properties: Comma-separated properties to fetch
        query: General search query
        sort_by: Field to sort by
        sort_order: Sort order (asc/desc)
        source_type: Filter by source type
        subject: Search by ticket subject
        tags: Filter by tags (comma-separated)
        use_date: Toggle to use dates
    ### When action = 'get_engagements'
        company_id: Filter by associated company ID
        contact_id: Filter by associated contact ID
        created_date: Filter by creation date (YYYY-MM-DD)
        deal_id: Filter by associated deal ID
        engagement_type: Filter by engagement type (CALL, EMAIL, MEETING, TASK)
        hs_activity_type: Filter by activity type
        hs_communication_channel_type: Filter by communication channel type
        hs_communication_logged_from: Filter by where engagement was logged from
        hubspot_owner_id: Filter by contact owner ID
        last_modified_date: Filter by last modified date (YYYY-MM-DD)
        properties: Comma-separated properties to fetch
        query: General search query
        sort_by: Field to sort by
        sort_order: Sort order (asc/desc)
        timestamp: Engagement timestamp (ISO format)
        use_date: Toggle to use dates
    ### When action = 'create_engagement'
        company_ids: Comma-separated company IDs
        contact_ids: Comma-separated contact IDs
        create_engagement_type: Select Engagement type (required)
        deal_ids: Comma-separated deal IDs
        metadata: Type-specific metadata (JSON)
        owner_id: Engagement owner ID
        timestamp: Engagement timestamp (ISO format)
    ### When action = 'remove_contact_from_list'
        contact_ids: Comma-separated contact IDs
        list_id: HubSpot list ID (required)
    ### When action = 'get_contacts' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_companies' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_deals' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_tickets' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_engagements' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'delete_company'
        delete_company_id: HubSpot company ID to delete (required)
    ### When action = 'delete_contact'
        delete_contact_id: HubSpot contact ID to delete (required)
    ### When action = 'delete_deal'
        delete_deal_id: HubSpot deal ID to delete (required)
    ### When action = 'delete_engagement'
        delete_engagement_id: HubSpot engagement ID to delete (required)
        type: Filter by company type
    ### When action = 'delete_ticket'
        delete_ticket_id: HubSpot ticket ID to delete (required)
    ### When action = 'get_contacts' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_companies' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_deals' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_tickets' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_engagements' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'read_company'
        include_merge_audits: Include merge history if true
        properties: Comma-separated properties to fetch
        read_company_id: HubSpot company ID to read (required)
    ### When action = 'read_deal'
        include_property_versions: Include property history if true
        properties: Comma-separated properties to fetch
        read_deal_id: HubSpot deal ID to read (required)
    ### When action = 'get_contacts' and use_date = False
        num_messages: Specify the number of contacts to fetch
    ### When action = 'get_companies' and use_date = False
        num_messages: Specify the number of contacts to fetch
    ### When action = 'get_deals' and use_date = False
        num_messages: Specify the number of contacts to fetch
    ### When action = 'get_tickets' and use_date = False
        num_messages: Specify the number of contacts to fetch
    ### When action = 'get_engagements' and use_date = False
        num_messages: Specify the number of contacts to fetch
    ### When action = 'read_contact'
        properties: Comma-separated properties to fetch
        read_contact_id: HubSpot contact ID to read (required)
        show_list_memberships: Include list memberships
    ### When action = 'read_ticket'
        properties: Comma-separated properties to fetch
        read_ticket_id: HubSpot ticket ID to read (required)
    ### When action = 'read_engagement'
        properties: Comma-separated properties to fetch
        read_engagement_id: HubSpot engagement ID to read (required)
        type: Filter by company type
    ### When action = 'update_company'
        update_about_us: About the company
        update_annual_revenue: Annual revenue
        update_city: City of residence
        update_company_domain_name: Company domain
        update_company_id: HubSpot company ID to update (required)
        update_company_name: Company name
        update_company_owner: Owner's user ID
        update_country_region: Country or region
        update_description: Company description
        update_industry: Type of industry
        update_lead_status: Lead status
        update_lifecycle: Lifecycle stage
        update_number_of_employees: Employee count
        update_phone_number: Main phone number
        update_website_url: Contact's website
    ### When action = 'update_deal'
        update_amount: Deal amount
        update_close_date: Close date
        update_deal_id: HubSpot deal ID to update (required)
        update_deal_name: Deal name
        update_deal_owner: Deal owner ID
        update_deal_stage: Deal stage ID
        update_deal_type: Deal type
        update_description: Company description
        update_pipeline: Pipeline ID
    ### When action = 'update_ticket'
        update_category: Ticket category
        update_close_date: Close date
        update_description: Company description
        update_priority: Priority level
        update_stage_id: Stage ID
        update_ticket_id: HubSpot ticket ID to update (required)
        update_ticket_name: Ticket subject
        update_ticket_owner_id: Ticket owner ID
    ### When action = 'update_contact'
        update_city: City of residence
        update_company: Name of the company
        update_contact_id: HubSpot contact ID to update (required)
        update_country: Country name
        update_custom_properties: Custom properties to add to the contact
        update_email: Contact email
        update_first_name: Contact's first name
        update_job_title: Job title of the contact
        update_last_name: Contact's last name
        update_mobile_phone_number: Mobile number
        update_phone_number: Main phone number
        update_postal_code: Postal or ZIP code
        update_state_region: State or region
        update_street_address: Street address
        update_website_url: Contact's website
    ### When action = 'get_contacts' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_companies' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_deals' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_tickets' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_engagements' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_deal'
        amount: Deal amount
        close_date: Deal close date
        deal_id: HubSpot deal ID
        deal_name: Deal name
        deal_owner: Deal owner
        deal_type: Deal type
        description: Deal description
        pipeline: Deal pipeline
        probability: Deal probability
        raw_data: Full response data
        stage: Deal stage
    ### When action = 'get_deals'
        amounts: List of amounts
        close_dates: List of close dates
        deal_ids: List of deal IDs
        deal_names: List of deal names
        deal_owners: List of owners
        deal_types: List of deal types
        descriptions: List of descriptions
        pipelines: List of pipelines
        probabilities: List of probabilities
        raw_data: Full response data
        stages: List of stages
        total: Total deals retrieved
    ### When action = 'read_company'
        annual_revenue: Annual revenue
        city: City
        company_id: HubSpot company ID
        country: Country
        description: Company description
        domain: Company domain
        industry: Industry
        name: Company name
        number_of_employees: Employee count
        phone_number: Phone number
        raw_data: Full response data
        state: State
        website: Website
    ### When action = 'get_companies'
        annual_revenues: List of revenues
        cities: List of cities
        company_ids: List of company IDs
        countries: List of countries
        descriptions: List of descriptions
        domains: List of domains
        industries: List of industries
        names: List of company names
        number_of_employees: List of employee counts
        phone_numbers: List of phone numbers
        raw_data: Full response data
        states: List of states
        total: Total count returned
        websites: List of websites
    ### When action = 'get_engagements'
        bodies: Engagement bodies/notes
        created_ats: Created dates
        engagement_ids: HubSpot engagement IDs
        engagement_types: Engagement types (call, email, meeting, task)
        owner_ids: Engagement owner IDs
        raw_data: Raw response data
        subjects: Engagement subjects
        timestamps: Engagement timestamps
        total: Total number of engagements retrieved
        updated_ats: Updated dates
    ### When action = 'read_engagement'
        body: Engagement body/notes
        created_at: Created date
        engagement_id: HubSpot engagement ID
        engagement_type: Engagement type (call, email, meeting, task)
        owner_id: Engagement owner ID
        raw_data: Raw response data
        subject: Engagement subject
        timestamp: Engagement timestamp
        updated_at: Updated date
    ### When action = 'get_tickets'
        categories: Ticket categories
        created_ats: Created dates
        descriptions: Ticket descriptions
        owners: Ticket owners
        pipelines: Ticket pipelines
        priorities: Ticket priorities
        raw_data: Raw response data
        stages: Ticket stages
        statuses: Ticket statuses
        subjects: Ticket subjects
        ticket_ids: HubSpot ticket IDs
        total: Total number of tickets retrieved
        updated_ats: Updated dates
    ### When action = 'read_ticket'
        category: Ticket category
        created_at: Created date
        description: Ticket description
        owner: Ticket owner
        pipeline: Ticket pipeline
        priority: Ticket priority
        raw_data: Raw response data
        stage: Ticket stage
        status: Ticket status
        subject: Ticket subject
        ticket_id: HubSpot ticket ID
        updated_at: Updated date
    ### When action = 'get_contacts'
        cities: List of cities
        companies: List of companies
        contact_ids: List of contact IDs
        countries: List of countries
        emails: List of email addresses
        first_names: List of first names
        job_titles: List of job titles
        last_names: List of last names
        phone_numbers: List of phone numbers
        raw_data: Raw response from HubSpot
        states: List of states
        total: Total contacts retrieved
        websites: List of websites
    ### When action = 'read_contact'
        city: Contact's city
        company: Contact's company
        contact_id: HubSpot contact ID
        country: Contact's country
        email: Contact's email address
        first_name: Contact's first name
        job_title: Contact's job title
        last_name: Contact's last name
        phone_number: Contact's phone number
        raw_data: Raw response from HubSpot
        state: Contact's state
        website: Contact's website
    ### When action = 'create_company'
        company_id: HubSpot company ID
    ### When action = 'create_contact'
        contact_id: HubSpot contact ID
    ### When action = 'create_deal'
        deal_id: HubSpot deal ID
    ### When action = 'delete_contact'
        deleted: True if contact was deleted
    ### When action = 'delete_company'
        deleted: True if company was deleted
    ### When action = 'delete_deal'
        deleted: True if deal was deleted
    ### When action = 'delete_ticket'
        deleted: Whether the ticket was deleted
    ### When action = 'delete_engagement'
        deleted: Whether the engagement was deleted
    ### When action = 'create_engagement'
        engagement_id: HubSpot engagement ID
    ### When action = 'add_contact_to_list'
        success: Whether contacts were added successfully
    ### When action = 'remove_contact_from_list'
        success: Whether contacts were removed successfully
    ### When action = 'create_ticket'
        ticket_id: HubSpot ticket ID
    ### When action = 'update_contact'
        updated: True if contact was updated
    ### When action = 'update_company'
        updated: True if update succeeded
    ### When action = 'update_deal'
        updated: True if deal was updated
    ### When action = 'update_ticket'
        updated: Whether the ticket was updated
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Hubspot>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_contact**(*)**(*)": {
            "inputs": [
                {
                    "field": "create_email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@example.com",
                    "helper_text": "Required contact email",
                },
                {
                    "field": "first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "John",
                    "helper_text": "Contact's first name",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Doe",
                    "helper_text": "Contact's last name",
                },
                {
                    "field": "company",
                    "type": "string",
                    "value": "",
                    "label": "Company",
                    "placeholder": "Acme Corp",
                    "helper_text": "Name of the company",
                },
                {
                    "field": "job_title",
                    "type": "string",
                    "value": "",
                    "label": "Job Title",
                    "placeholder": "Sales Manager",
                    "helper_text": "Job title of the contact",
                },
                {
                    "field": "phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Phone Number",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Main phone number",
                },
                {
                    "field": "mobile_phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Mobile Phone",
                    "placeholder": "+1-555-987-6543",
                    "helper_text": "Mobile number",
                },
                {
                    "field": "street_address",
                    "type": "string",
                    "value": "",
                    "label": "Street Address",
                    "placeholder": "123 Main St",
                    "helper_text": "Street address",
                },
                {
                    "field": "city",
                    "type": "string",
                    "value": "",
                    "label": "City",
                    "placeholder": "Boston",
                    "helper_text": "City of residence",
                },
                {
                    "field": "state_region",
                    "type": "string",
                    "value": "",
                    "label": "State/Region",
                    "placeholder": "MA",
                    "helper_text": "State or region",
                },
                {
                    "field": "postal_code",
                    "type": "string",
                    "value": "",
                    "label": "Postal Code",
                    "placeholder": "02101",
                    "helper_text": "Postal or ZIP code",
                },
                {
                    "field": "country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "United States",
                    "helper_text": "Country name",
                },
                {
                    "field": "website_url",
                    "type": "string",
                    "value": "",
                    "label": "Website URL",
                    "placeholder": "https://example.com",
                    "helper_text": "Contact's website",
                },
                {
                    "field": "associated_company_id",
                    "type": "string",
                    "value": "",
                    "label": "Associated Company ID",
                    "placeholder": "12345",
                    "helper_text": "ID of associated company",
                },
                {
                    "field": "custom_properties",
                    "type": "string",
                    "value": "",
                    "label": "Custom Properties",
                    "helper_text": "Custom properties to add to the contact",
                },
            ],
            "outputs": [
                {
                    "field": "contact_id",
                    "type": "string",
                    "helper_text": "HubSpot contact ID",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "create_contact",
            "task_name": "tasks.hubspot.create_contact",
            "description": "Creates a new contact",
            "label": "Create Contact",
        },
        "update_contact**(*)**(*)": {
            "inputs": [
                {
                    "field": "update_contact_id",
                    "type": "string",
                    "value": "",
                    "label": "Contact ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot contact ID to update (required)",
                },
                {
                    "field": "update_email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@example.com",
                    "helper_text": "Contact email",
                },
                {
                    "field": "update_first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "John",
                    "helper_text": "Contact's first name",
                },
                {
                    "field": "update_last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Doe",
                    "helper_text": "Contact's last name",
                },
                {
                    "field": "update_company",
                    "type": "string",
                    "value": "",
                    "label": "Company",
                    "placeholder": "Acme Corp",
                    "helper_text": "Name of the company",
                },
                {
                    "field": "update_job_title",
                    "type": "string",
                    "value": "",
                    "label": "Job Title",
                    "placeholder": "Sales Manager",
                    "helper_text": "Job title of the contact",
                },
                {
                    "field": "update_phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Phone Number",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Main phone number",
                },
                {
                    "field": "update_mobile_phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Mobile Phone",
                    "placeholder": "+1-555-987-6543",
                    "helper_text": "Mobile number",
                },
                {
                    "field": "update_street_address",
                    "type": "string",
                    "value": "",
                    "label": "Street Address",
                    "placeholder": "123 Main St",
                    "helper_text": "Street address",
                },
                {
                    "field": "update_city",
                    "type": "string",
                    "value": "",
                    "label": "City",
                    "placeholder": "Boston",
                    "helper_text": "City of residence",
                },
                {
                    "field": "update_state_region",
                    "type": "string",
                    "value": "",
                    "label": "State/Region",
                    "placeholder": "MA",
                    "helper_text": "State or region",
                },
                {
                    "field": "update_postal_code",
                    "type": "string",
                    "value": "",
                    "label": "Postal Code",
                    "placeholder": "02101",
                    "helper_text": "Postal or ZIP code",
                },
                {
                    "field": "update_country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "United States",
                    "helper_text": "Country name",
                },
                {
                    "field": "update_website_url",
                    "type": "string",
                    "value": "",
                    "label": "Website URL",
                    "placeholder": "https://example.com",
                    "helper_text": "Contact's website",
                },
                {
                    "field": "update_custom_properties",
                    "type": "string",
                    "value": "",
                    "label": "Custom Properties",
                    "helper_text": "Custom properties to add to the contact",
                },
            ],
            "outputs": [
                {
                    "field": "updated",
                    "type": "bool",
                    "helper_text": "True if contact was updated",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "update_contact",
            "task_name": "tasks.hubspot.update_contact",
            "description": "Updates an existing contact",
            "label": "Update Contact",
        },
        "delete_contact**(*)**(*)": {
            "inputs": [
                {
                    "field": "delete_contact_id",
                    "type": "string",
                    "value": "",
                    "label": "Contact ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot contact ID to delete (required)",
                }
            ],
            "outputs": [
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "True if contact was deleted",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "delete_contact",
            "task_name": "tasks.hubspot.delete_contact",
            "description": "Deletes a contact by ID",
            "label": "Delete Contact",
        },
        "read_contact**(*)**(*)": {
            "inputs": [
                {
                    "field": "read_contact_id",
                    "type": "string",
                    "value": "",
                    "label": "Contact ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot contact ID to read (required)",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
                {
                    "field": "show_list_memberships",
                    "type": "bool",
                    "value": False,
                    "label": "Show List Memberships",
                    "helper_text": "Include list memberships",
                },
            ],
            "outputs": [
                {
                    "field": "contact_id",
                    "type": "string",
                    "helper_text": "HubSpot contact ID",
                },
                {
                    "field": "first_name",
                    "type": "string",
                    "helper_text": "Contact's first name",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "helper_text": "Contact's last name",
                },
                {
                    "field": "email",
                    "type": "string",
                    "helper_text": "Contact's email address",
                },
                {
                    "field": "phone_number",
                    "type": "string",
                    "helper_text": "Contact's phone number",
                },
                {
                    "field": "company",
                    "type": "string",
                    "helper_text": "Contact's company",
                },
                {
                    "field": "job_title",
                    "type": "string",
                    "helper_text": "Contact's job title",
                },
                {"field": "city", "type": "string", "helper_text": "Contact's city"},
                {"field": "state", "type": "string", "helper_text": "Contact's state"},
                {
                    "field": "country",
                    "type": "string",
                    "helper_text": "Contact's country",
                },
                {
                    "field": "website",
                    "type": "string",
                    "helper_text": "Contact's website",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from HubSpot",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_contact",
            "task_name": "tasks.hubspot.read_contact",
            "description": "Retrieves a specific contact by ID",
            "label": "Read Contact",
        },
        "get_contacts**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "placeholder": "john",
                    "helper_text": "General search query",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@example.com",
                    "helper_text": "Search by email address",
                },
                {
                    "field": "first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "John",
                    "helper_text": "Search by first name",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Doe",
                    "helper_text": "Search by last name",
                },
                {
                    "field": "company_name",
                    "type": "string",
                    "value": "",
                    "label": "Company",
                    "placeholder": "Acme Corp",
                    "helper_text": "Search by company name",
                },
                {
                    "field": "job_title",
                    "type": "string",
                    "value": "",
                    "label": "Job Title",
                    "placeholder": "Manager",
                    "helper_text": "Search by job title",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "value": "",
                    "label": "Phone",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Search by phone number",
                },
                {
                    "field": "city",
                    "type": "string",
                    "value": "",
                    "label": "City",
                    "placeholder": "Boston",
                    "helper_text": "Search by city",
                },
                {
                    "field": "state",
                    "type": "string",
                    "value": "",
                    "label": "State",
                    "placeholder": "MA",
                    "helper_text": "Search by state",
                },
                {
                    "field": "country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "United States",
                    "helper_text": "Search by country",
                },
                {
                    "field": "website",
                    "type": "string",
                    "value": "",
                    "label": "Website",
                    "placeholder": "example.com",
                    "helper_text": "Search by website",
                },
                {
                    "field": "lifecycle_stage",
                    "type": "string",
                    "value": "",
                    "label": "Lifecycle Stage",
                    "placeholder": "lead",
                    "helper_text": "Filter by lifecycle stage",
                },
                {
                    "field": "lead_status",
                    "type": "string",
                    "value": "",
                    "label": "Lead Status",
                    "placeholder": "new",
                    "helper_text": "Filter by lead status",
                },
                {
                    "field": "hs_lead_status",
                    "type": "string",
                    "value": "",
                    "label": "HubSpot Lead Status",
                    "placeholder": "NEW",
                    "helper_text": "Filter by HubSpot lead status",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "value": "",
                    "label": "Created Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by creation date (YYYY-MM-DD)",
                },
                {
                    "field": "last_modified_date",
                    "type": "string",
                    "value": "",
                    "label": "Last Modified Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by last modified date (YYYY-MM-DD)",
                },
                {
                    "field": "hs_analytics_source",
                    "type": "string",
                    "value": "",
                    "label": "Original Source",
                    "placeholder": "ORGANIC_SEARCH",
                    "helper_text": "Filter by original source",
                },
                {
                    "field": "hs_latest_source",
                    "type": "string",
                    "value": "",
                    "label": "Latest Source",
                    "placeholder": "DIRECT_TRAFFIC",
                    "helper_text": "Filter by latest source",
                },
                {
                    "field": "hubspot_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Owner ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by contact owner ID",
                },
                {
                    "field": "sort_by",
                    "type": "string",
                    "value": "",
                    "label": "Sort By",
                    "placeholder": "createdate",
                    "helper_text": "Field to sort by",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "placeholder": "desc",
                    "helper_text": "Sort order (asc/desc)",
                },
            ],
            "outputs": [
                {
                    "field": "contact_ids",
                    "type": "vec<string>",
                    "helper_text": "List of contact IDs",
                },
                {
                    "field": "first_names",
                    "type": "vec<string>",
                    "helper_text": "List of first names",
                },
                {
                    "field": "last_names",
                    "type": "vec<string>",
                    "helper_text": "List of last names",
                },
                {
                    "field": "emails",
                    "type": "vec<string>",
                    "helper_text": "List of email addresses",
                },
                {
                    "field": "phone_numbers",
                    "type": "vec<string>",
                    "helper_text": "List of phone numbers",
                },
                {
                    "field": "companies",
                    "type": "vec<string>",
                    "helper_text": "List of companies",
                },
                {
                    "field": "job_titles",
                    "type": "vec<string>",
                    "helper_text": "List of job titles",
                },
                {
                    "field": "cities",
                    "type": "vec<string>",
                    "helper_text": "List of cities",
                },
                {
                    "field": "states",
                    "type": "vec<string>",
                    "helper_text": "List of states",
                },
                {
                    "field": "countries",
                    "type": "vec<string>",
                    "helper_text": "List of countries",
                },
                {
                    "field": "websites",
                    "type": "vec<string>",
                    "helper_text": "List of websites",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total contacts retrieved",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from HubSpot",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_contacts",
            "task_name": "tasks.hubspot.get_contacts",
            "description": "Retrieves multiple contacts with advanced filtering",
            "label": "Get Contacts",
        },
        "get_contacts**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Contacts",
                    "helper_text": "Specify the number of contacts to fetch",
                }
            ],
            "outputs": [],
        },
        "get_contacts**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_contacts**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_contacts**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_company**(*)**(*)": {
            "inputs": [
                {
                    "field": "create_company_name",
                    "type": "string",
                    "value": "",
                    "label": "Company Name",
                    "placeholder": "Acme Corp",
                    "helper_text": "Required company name",
                },
                {
                    "field": "about_us",
                    "type": "string",
                    "value": "",
                    "label": "About Us",
                    "placeholder": "Leading software company",
                    "helper_text": "About the company",
                },
                {
                    "field": "annual_revenue",
                    "type": "int32",
                    "value": 0,
                    "label": "Annual Revenue",
                    "helper_text": "Annual revenue",
                },
                {
                    "field": "city",
                    "type": "string",
                    "value": "",
                    "label": "City",
                    "placeholder": "Boston",
                    "helper_text": "City",
                },
                {
                    "field": "company_domain_name",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "placeholder": "acme.com",
                    "helper_text": "Company's domain name",
                },
                {
                    "field": "company_owner",
                    "type": "string",
                    "value": "",
                    "label": "Company Owner",
                    "placeholder": "12345",
                    "helper_text": "Owner's user ID",
                },
                {
                    "field": "country_region",
                    "type": "string",
                    "value": "",
                    "label": "Country/Region",
                    "placeholder": "United States",
                    "helper_text": "Country or region",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Company description",
                    "helper_text": "Company description",
                },
                {
                    "field": "industry",
                    "type": "string",
                    "value": "ACCOUNTING",
                    "helper_text": "Type of industry",
                    "placeholder": "Accounting",
                    "label": "Industry",
                    "component": {"type": "dropdown", "referenced_options": "industry"},
                },
                {
                    "field": "lifecycle",
                    "type": "string",
                    "value": "subscriber",
                    "helper_text": "Lifecycle stage",
                    "placeholder": "Subscriber",
                    "label": "Lifecycle",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "life_cycle",
                    },
                },
                {
                    "field": "lead_status",
                    "type": "string",
                    "value": "NEW",
                    "helper_text": "Lead status",
                    "placeholder": "New",
                    "label": "Lead Status",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "lead_status",
                    },
                },
                {
                    "field": "number_of_employees",
                    "type": "int32",
                    "value": 0,
                    "label": "Number of Employees",
                    "helper_text": "Employee count",
                },
                {
                    "field": "phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Phone Number",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Phone number",
                },
                {
                    "field": "website_url",
                    "type": "string",
                    "value": "",
                    "label": "Website URL",
                    "placeholder": "https://acme.com",
                    "helper_text": "Website URL",
                },
            ],
            "outputs": [
                {
                    "field": "company_id",
                    "type": "string",
                    "helper_text": "HubSpot company ID",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "create_company",
            "task_name": "tasks.hubspot.create_company",
            "description": "Creates a new company",
            "label": "Create Company",
        },
        "update_company**(*)**(*)": {
            "inputs": [
                {
                    "field": "update_company_id",
                    "type": "string",
                    "value": "",
                    "label": "Company ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot company ID to update (required)",
                },
                {
                    "field": "update_company_name",
                    "type": "string",
                    "value": "",
                    "label": "Company Name",
                    "placeholder": "Acme Corp",
                    "helper_text": "Company name",
                },
                {
                    "field": "update_about_us",
                    "type": "string",
                    "value": "",
                    "label": "About Us",
                    "placeholder": "Leading software company",
                    "helper_text": "About the company",
                },
                {
                    "field": "update_annual_revenue",
                    "type": "int32",
                    "value": 0,
                    "label": "Annual Revenue",
                    "helper_text": "Annual revenue",
                },
                {
                    "field": "update_city",
                    "type": "string",
                    "value": "",
                    "label": "City",
                    "placeholder": "Boston",
                    "helper_text": "City",
                },
                {
                    "field": "update_company_domain_name",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "placeholder": "acme.com",
                    "helper_text": "Company domain",
                },
                {
                    "field": "update_company_owner",
                    "type": "string",
                    "value": "",
                    "label": "Company Owner",
                    "placeholder": "12345",
                    "helper_text": "Owner's user ID",
                },
                {
                    "field": "update_country_region",
                    "type": "string",
                    "value": "",
                    "label": "Country/Region",
                    "placeholder": "United States",
                    "helper_text": "Country or region",
                },
                {
                    "field": "update_description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Company description",
                    "helper_text": "Company description",
                },
                {
                    "field": "update_industry",
                    "type": "string",
                    "value": "ACCOUNTING",
                    "helper_text": "Type of industry",
                    "placeholder": "Accounting",
                    "label": "Industry",
                    "component": {"type": "dropdown", "referenced_options": "industry"},
                },
                {
                    "field": "update_lifecycle",
                    "type": "string",
                    "value": "subscriber",
                    "helper_text": "Lifecycle stage",
                    "placeholder": "Subscriber",
                    "label": "Lifecycle",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "life_cycle",
                    },
                },
                {
                    "field": "update_lead_status",
                    "type": "string",
                    "value": "NEW",
                    "helper_text": "Lead status",
                    "placeholder": "New",
                    "label": "Lead Status",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "lead_status",
                    },
                },
                {
                    "field": "update_number_of_employees",
                    "type": "int32",
                    "value": 0,
                    "label": "Number of Employees",
                    "helper_text": "Employee count",
                },
                {
                    "field": "update_phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Phone Number",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Phone number",
                },
                {
                    "field": "update_website_url",
                    "type": "string",
                    "value": "",
                    "label": "Website URL",
                    "placeholder": "https://acme.com",
                    "helper_text": "Website URL",
                },
            ],
            "outputs": [
                {
                    "field": "updated",
                    "type": "bool",
                    "helper_text": "True if update succeeded",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "update_company",
            "task_name": "tasks.hubspot.update_company",
            "description": "Updates an existing company",
            "label": "Update Company",
        },
        "delete_company**(*)**(*)": {
            "inputs": [
                {
                    "field": "delete_company_id",
                    "type": "string",
                    "value": "",
                    "label": "Company ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot company ID to delete (required)",
                }
            ],
            "outputs": [
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "True if company was deleted",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "delete_company",
            "task_name": "tasks.hubspot.delete_company",
            "description": "Deletes a company by ID",
            "label": "Delete Company",
        },
        "read_company**(*)**(*)": {
            "inputs": [
                {
                    "field": "read_company_id",
                    "type": "string",
                    "value": "",
                    "label": "Company ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot company ID to read (required)",
                },
                {
                    "field": "include_merge_audits",
                    "type": "bool",
                    "value": False,
                    "label": "Include Merge Audits",
                    "helper_text": "Include merge history if true",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
            ],
            "outputs": [
                {
                    "field": "company_id",
                    "type": "string",
                    "helper_text": "HubSpot company ID",
                },
                {"field": "name", "type": "string", "helper_text": "Company name"},
                {"field": "domain", "type": "string", "helper_text": "Company domain"},
                {
                    "field": "phone_number",
                    "type": "string",
                    "helper_text": "Phone number",
                },
                {"field": "city", "type": "string", "helper_text": "City"},
                {"field": "state", "type": "string", "helper_text": "State"},
                {"field": "country", "type": "string", "helper_text": "Country"},
                {"field": "industry", "type": "string", "helper_text": "Industry"},
                {"field": "website", "type": "string", "helper_text": "Website"},
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Company description",
                },
                {
                    "field": "number_of_employees",
                    "type": "string",
                    "helper_text": "Employee count",
                },
                {
                    "field": "annual_revenue",
                    "type": "string",
                    "helper_text": "Annual revenue",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Full response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_company",
            "task_name": "tasks.hubspot.read_company",
            "description": "Retrieves a specific company by ID",
            "label": "Read Company",
        },
        "get_companies**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "placeholder": "acme",
                    "helper_text": "General search query",
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Company Name",
                    "placeholder": "Acme Corp",
                    "helper_text": "Search by company name",
                },
                {
                    "field": "domain",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "placeholder": "acme.com",
                    "helper_text": "Search by domain",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "value": "",
                    "label": "Phone",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Search by phone number",
                },
                {
                    "field": "city",
                    "type": "string",
                    "value": "",
                    "label": "City",
                    "placeholder": "Boston",
                    "helper_text": "Search by city",
                },
                {
                    "field": "state",
                    "type": "string",
                    "value": "",
                    "label": "State",
                    "placeholder": "MA",
                    "helper_text": "Search by state",
                },
                {
                    "field": "country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "United States",
                    "helper_text": "Search by country",
                },
                {
                    "field": "zip",
                    "type": "string",
                    "value": "",
                    "label": "Zip Code",
                    "placeholder": "02101",
                    "helper_text": "Search by zip code",
                },
                {
                    "field": "industry",
                    "type": "string",
                    "value": "",
                    "label": "Industry",
                    "placeholder": "Technology",
                    "helper_text": "Filter by industry",
                },
                {
                    "field": "type",
                    "type": "string",
                    "value": "",
                    "label": "Company Type",
                    "placeholder": "PROSPECT",
                    "helper_text": "Filter by company type",
                },
                {
                    "field": "lifecycle_stage",
                    "type": "string",
                    "value": "",
                    "label": "Lifecycle Stage",
                    "placeholder": "customer",
                    "helper_text": "Filter by lifecycle stage",
                },
                {
                    "field": "lead_status",
                    "type": "string",
                    "value": "",
                    "label": "Lead Status",
                    "placeholder": "NEW",
                    "helper_text": "Filter by lead status",
                },
                {
                    "field": "number_of_employees",
                    "type": "string",
                    "value": "",
                    "label": "Number of Employees",
                    "placeholder": "1-10",
                    "helper_text": "Filter by employee count range",
                },
                {
                    "field": "annual_revenue",
                    "type": "string",
                    "value": "",
                    "label": "Annual Revenue",
                    "placeholder": "1000000",
                    "helper_text": "Filter by annual revenue",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "value": "",
                    "label": "Created Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by creation date (YYYY-MM-DD)",
                },
                {
                    "field": "last_modified_date",
                    "type": "string",
                    "value": "",
                    "label": "Last Modified Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by last modified date (YYYY-MM-DD)",
                },
                {
                    "field": "hubspot_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Owner ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by company owner ID",
                },
                {
                    "field": "hs_analytics_source",
                    "type": "string",
                    "value": "",
                    "label": "Original Source",
                    "placeholder": "ORGANIC_SEARCH",
                    "helper_text": "Filter by original source",
                },
                {
                    "field": "hs_analytics_source_data_1",
                    "type": "string",
                    "value": "",
                    "label": "Source Data 1",
                    "placeholder": "google",
                    "helper_text": "Filter by source data 1",
                },
                {
                    "field": "hs_analytics_source_data_2",
                    "type": "string",
                    "value": "",
                    "label": "Source Data 2",
                    "placeholder": "keywords",
                    "helper_text": "Filter by source data 2",
                },
                {
                    "field": "web_technologies",
                    "type": "string",
                    "value": "",
                    "label": "Web Technologies",
                    "placeholder": "wordpress",
                    "helper_text": "Filter by web technologies",
                },
                {
                    "field": "founded_year",
                    "type": "string",
                    "value": "",
                    "label": "Founded Year",
                    "placeholder": "2020",
                    "helper_text": "Filter by founded year",
                },
                {
                    "field": "is_public",
                    "type": "bool",
                    "value": False,
                    "label": "Is Public Company",
                    "helper_text": "Filter by public company status",
                },
                {
                    "field": "sort_by",
                    "type": "string",
                    "value": "",
                    "label": "Sort By",
                    "placeholder": "createdate",
                    "helper_text": "Field to sort by",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "placeholder": "desc",
                    "helper_text": "Sort order (asc/desc)",
                },
            ],
            "outputs": [
                {
                    "field": "company_ids",
                    "type": "vec<string>",
                    "helper_text": "List of company IDs",
                },
                {
                    "field": "names",
                    "type": "vec<string>",
                    "helper_text": "List of company names",
                },
                {
                    "field": "domains",
                    "type": "vec<string>",
                    "helper_text": "List of domains",
                },
                {
                    "field": "phone_numbers",
                    "type": "vec<string>",
                    "helper_text": "List of phone numbers",
                },
                {
                    "field": "cities",
                    "type": "vec<string>",
                    "helper_text": "List of cities",
                },
                {
                    "field": "states",
                    "type": "vec<string>",
                    "helper_text": "List of states",
                },
                {
                    "field": "countries",
                    "type": "vec<string>",
                    "helper_text": "List of countries",
                },
                {
                    "field": "industries",
                    "type": "vec<string>",
                    "helper_text": "List of industries",
                },
                {
                    "field": "websites",
                    "type": "vec<string>",
                    "helper_text": "List of websites",
                },
                {
                    "field": "descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of descriptions",
                },
                {
                    "field": "number_of_employees",
                    "type": "vec<string>",
                    "helper_text": "List of employee counts",
                },
                {
                    "field": "annual_revenues",
                    "type": "vec<string>",
                    "helper_text": "List of revenues",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total count returned",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Full response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_companies",
            "task_name": "tasks.hubspot.get_companies",
            "description": "Retrieves multiple companies with advanced filtering",
            "label": "Get Companies",
        },
        "get_companies**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Companies",
                    "helper_text": "Specify the number of companies to fetch",
                }
            ],
            "outputs": [],
        },
        "get_companies**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_companies**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_companies**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_deal**(*)**(*)": {
            "inputs": [
                {
                    "field": "create_deal_stage",
                    "type": "string",
                    "value": "",
                    "label": "Stage",
                    "placeholder": "appointmentscheduled",
                    "helper_text": "Required deal stage ID",
                },
                {
                    "field": "deal_name",
                    "type": "string",
                    "value": "",
                    "label": "Deal Name",
                    "placeholder": "Enterprise Solution 2024",
                    "helper_text": "Deal name",
                },
                {
                    "field": "amount",
                    "type": "int32",
                    "value": 0,
                    "label": "Amount",
                    "helper_text": "Deal amount",
                },
                {
                    "field": "close_date",
                    "type": "string",
                    "value": "",
                    "label": "Close Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "Close date",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Deal description",
                    "helper_text": "Deal description",
                },
                {
                    "field": "deal_owner",
                    "type": "string",
                    "value": "",
                    "label": "Deal Owner",
                    "placeholder": "12345",
                    "helper_text": "Deal owner ID",
                },
                {
                    "field": "deal_type",
                    "type": "string",
                    "value": "",
                    "label": "Deal Type",
                    "placeholder": "newbusiness",
                    "helper_text": "Deal type",
                },
                {
                    "field": "pipeline",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline",
                    "placeholder": "default",
                    "helper_text": "Pipeline ID",
                },
                {
                    "field": "associated_company",
                    "type": "string",
                    "value": "",
                    "label": "Associated Companies",
                    "placeholder": "12345",
                    "helper_text": "Associated company IDs",
                },
                {
                    "field": "associated_vids",
                    "type": "string",
                    "value": "",
                    "label": "Associated Contacts",
                    "placeholder": "12345",
                    "helper_text": "Associated contact IDs",
                },
            ],
            "outputs": [
                {"field": "deal_id", "type": "string", "helper_text": "HubSpot deal ID"}
            ],
            "variant": "common_integration_nodes",
            "name": "create_deal",
            "task_name": "tasks.hubspot.create_deal",
            "description": "Creates a new deal",
            "label": "Create Deal",
        },
        "update_deal**(*)**(*)": {
            "inputs": [
                {
                    "field": "update_deal_id",
                    "type": "string",
                    "value": "",
                    "label": "Deal ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot deal ID to update (required)",
                },
                {
                    "field": "update_deal_stage",
                    "type": "string",
                    "value": "",
                    "label": "Stage",
                    "placeholder": "appointmentscheduled",
                    "helper_text": "Deal stage ID",
                },
                {
                    "field": "update_deal_name",
                    "type": "string",
                    "value": "",
                    "label": "Deal Name",
                    "placeholder": "Enterprise Solution 2024",
                    "helper_text": "Deal name",
                },
                {
                    "field": "update_amount",
                    "type": "int32",
                    "value": 0,
                    "label": "Amount",
                    "helper_text": "Deal amount",
                },
                {
                    "field": "update_close_date",
                    "type": "string",
                    "value": "",
                    "label": "Close Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "Close date",
                },
                {
                    "field": "update_description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Deal description",
                    "helper_text": "Deal description",
                },
                {
                    "field": "update_deal_owner",
                    "type": "string",
                    "value": "",
                    "label": "Deal Owner",
                    "placeholder": "12345",
                    "helper_text": "Deal owner ID",
                },
                {
                    "field": "update_deal_type",
                    "type": "string",
                    "value": "",
                    "label": "Deal Type",
                    "placeholder": "newbusiness",
                    "helper_text": "Deal type",
                },
                {
                    "field": "update_pipeline",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline",
                    "placeholder": "default",
                    "helper_text": "Pipeline ID",
                },
            ],
            "outputs": [
                {
                    "field": "updated",
                    "type": "bool",
                    "helper_text": "True if deal was updated",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "update_deal",
            "task_name": "tasks.hubspot.update_deal",
            "description": "Updates an existing deal",
            "label": "Update Deal",
        },
        "delete_deal**(*)**(*)": {
            "inputs": [
                {
                    "field": "delete_deal_id",
                    "type": "string",
                    "value": "",
                    "label": "Deal ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot deal ID to delete (required)",
                }
            ],
            "outputs": [
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "True if deal was deleted",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "delete_deal",
            "task_name": "tasks.hubspot.delete_deal",
            "description": "Deletes a deal by ID",
            "label": "Delete Deal",
        },
        "read_deal**(*)**(*)": {
            "inputs": [
                {
                    "field": "read_deal_id",
                    "type": "string",
                    "value": "",
                    "label": "Deal ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot deal ID to read (required)",
                },
                {
                    "field": "include_property_versions",
                    "type": "bool",
                    "value": False,
                    "label": "Include Property Versions",
                    "helper_text": "Include property history if true",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated fields to retrieve",
                },
            ],
            "outputs": [
                {
                    "field": "deal_id",
                    "type": "string",
                    "helper_text": "HubSpot deal ID",
                },
                {"field": "deal_name", "type": "string", "helper_text": "Deal name"},
                {"field": "amount", "type": "string", "helper_text": "Deal amount"},
                {"field": "stage", "type": "string", "helper_text": "Deal stage"},
                {"field": "pipeline", "type": "string", "helper_text": "Deal pipeline"},
                {
                    "field": "close_date",
                    "type": "string",
                    "helper_text": "Deal close date",
                },
                {"field": "deal_type", "type": "string", "helper_text": "Deal type"},
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Deal description",
                },
                {"field": "deal_owner", "type": "string", "helper_text": "Deal owner"},
                {
                    "field": "probability",
                    "type": "string",
                    "helper_text": "Deal probability",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Full response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_deal",
            "task_name": "tasks.hubspot.read_deal",
            "description": "Retrieves a specific deal by ID",
            "label": "Read Deal",
        },
        "get_deals**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "placeholder": "enterprise",
                    "helper_text": "General search query",
                },
                {
                    "field": "deal_name",
                    "type": "string",
                    "value": "",
                    "label": "Deal Name",
                    "placeholder": "Enterprise Solution",
                    "helper_text": "Search by deal name",
                },
                {
                    "field": "amount",
                    "type": "string",
                    "value": "",
                    "label": "Amount",
                    "placeholder": "50000",
                    "helper_text": "Filter by deal amount",
                },
                {
                    "field": "deal_stage",
                    "type": "string",
                    "value": "",
                    "label": "Deal Stage",
                    "placeholder": "closedwon",
                    "helper_text": "Filter by deal stage",
                },
                {
                    "field": "pipeline",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline",
                    "placeholder": "default",
                    "helper_text": "Filter by pipeline",
                },
                {
                    "field": "deal_type",
                    "type": "string",
                    "value": "",
                    "label": "Deal Type",
                    "placeholder": "newbusiness",
                    "helper_text": "Filter by deal type",
                },
                {
                    "field": "close_date",
                    "type": "string",
                    "value": "",
                    "label": "Close Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "Filter by close date (YYYY-MM-DD)",
                },
                {
                    "field": "hubspot_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Owner ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by deal owner ID",
                },
                {
                    "field": "deal_currency_code",
                    "type": "string",
                    "value": "",
                    "label": "Currency Code",
                    "placeholder": "USD",
                    "helper_text": "Filter by currency code",
                },
                {
                    "field": "hs_deal_stage_probability",
                    "type": "string",
                    "value": "",
                    "label": "Deal Probability",
                    "placeholder": "0.5",
                    "helper_text": "Filter by deal probability",
                },
                {
                    "field": "num_associated_contacts",
                    "type": "string",
                    "value": "",
                    "label": "Associated Contacts",
                    "placeholder": "5",
                    "helper_text": "Filter by number of associated contacts",
                },
                {
                    "field": "num_contacted_notes",
                    "type": "string",
                    "value": "",
                    "label": "Contact Notes",
                    "placeholder": "10",
                    "helper_text": "Filter by number of contact notes",
                },
                {
                    "field": "hs_analytics_source",
                    "type": "string",
                    "value": "",
                    "label": "Original Source",
                    "placeholder": "ORGANIC_SEARCH",
                    "helper_text": "Filter by original source",
                },
                {
                    "field": "hs_latest_source",
                    "type": "string",
                    "value": "",
                    "label": "Latest Source",
                    "placeholder": "DIRECT_TRAFFIC",
                    "helper_text": "Filter by latest source",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "value": "",
                    "label": "Created Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by creation date (YYYY-MM-DD)",
                },
                {
                    "field": "last_modified_date",
                    "type": "string",
                    "value": "",
                    "label": "Last Modified Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by last modified date (YYYY-MM-DD)",
                },
                {
                    "field": "hs_date_entered_closed_won",
                    "type": "string",
                    "value": "",
                    "label": "Date Closed Won",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by date entered closed won",
                },
                {
                    "field": "hs_date_entered_closed_lost",
                    "type": "string",
                    "value": "",
                    "label": "Date Closed Lost",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by date entered closed lost",
                },
                {
                    "field": "hs_forecast_amount",
                    "type": "string",
                    "value": "",
                    "label": "Forecast Amount",
                    "placeholder": "45000",
                    "helper_text": "Filter by forecast amount",
                },
                {
                    "field": "hs_is_closed",
                    "type": "bool",
                    "value": False,
                    "label": "Is Closed",
                    "helper_text": "Filter by closed status",
                },
                {
                    "field": "hs_is_deal_split",
                    "type": "bool",
                    "value": False,
                    "label": "Is Deal Split",
                    "helper_text": "Filter by deal split status",
                },
                {
                    "field": "sort_by",
                    "type": "string",
                    "value": "",
                    "label": "Sort By",
                    "placeholder": "createdate",
                    "helper_text": "Field to sort by",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "placeholder": "desc",
                    "helper_text": "Sort order (asc/desc)",
                },
            ],
            "outputs": [
                {
                    "field": "deal_ids",
                    "type": "vec<string>",
                    "helper_text": "List of deal IDs",
                },
                {
                    "field": "deal_names",
                    "type": "vec<string>",
                    "helper_text": "List of deal names",
                },
                {
                    "field": "amounts",
                    "type": "vec<string>",
                    "helper_text": "List of amounts",
                },
                {
                    "field": "stages",
                    "type": "vec<string>",
                    "helper_text": "List of stages",
                },
                {
                    "field": "pipelines",
                    "type": "vec<string>",
                    "helper_text": "List of pipelines",
                },
                {
                    "field": "close_dates",
                    "type": "vec<string>",
                    "helper_text": "List of close dates",
                },
                {
                    "field": "deal_types",
                    "type": "vec<string>",
                    "helper_text": "List of deal types",
                },
                {
                    "field": "descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of descriptions",
                },
                {
                    "field": "deal_owners",
                    "type": "vec<string>",
                    "helper_text": "List of owners",
                },
                {
                    "field": "probabilities",
                    "type": "vec<string>",
                    "helper_text": "List of probabilities",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total deals retrieved",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Full response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_deals",
            "task_name": "tasks.hubspot.get_deals",
            "description": "Retrieves multiple deals with advanced filtering",
            "label": "Get Deals",
        },
        "get_deals**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Deals",
                    "helper_text": "Specify the number of deals to fetch",
                }
            ],
            "outputs": [],
        },
        "get_deals**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_deals**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_deals**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "create_ticket_pipeline_id",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline ID",
                    "placeholder": "0",
                    "helper_text": "Pipeline ID (required)",
                },
                {
                    "field": "create_ticket_stage_id",
                    "type": "string",
                    "value": "",
                    "label": "Stage ID",
                    "placeholder": "1",
                    "helper_text": "Stage ID (required)",
                },
                {
                    "field": "create_ticket_name",
                    "type": "string",
                    "value": "",
                    "label": "Ticket Subject",
                    "placeholder": "Technical Support Request",
                    "helper_text": "Ticket subject (required)",
                },
                {
                    "field": "category",
                    "type": "string",
                    "value": "",
                    "label": "Category",
                    "placeholder": "TECHNICAL_SUPPORT",
                    "helper_text": "Ticket category",
                },
                {
                    "field": "close_date",
                    "type": "string",
                    "value": "",
                    "label": "Close Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "Close date",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Customer needs help with...",
                    "helper_text": "Ticket description",
                },
                {
                    "field": "priority",
                    "type": "string",
                    "value": "",
                    "label": "Priority",
                    "placeholder": "HIGH",
                    "helper_text": "Priority level",
                },
                {
                    "field": "ticket_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Ticket Owner",
                    "placeholder": "12345",
                    "helper_text": "Ticket owner ID",
                },
                {
                    "field": "associated_company_ids",
                    "type": "string",
                    "value": "",
                    "label": "Associated Companies",
                    "helper_text": "Associated companies",
                },
                {
                    "field": "associated_contact_ids",
                    "type": "string",
                    "value": "",
                    "label": "Associated Contacts",
                    "helper_text": "Associated contacts",
                },
            ],
            "outputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "helper_text": "HubSpot ticket ID",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "create_ticket",
            "task_name": "tasks.hubspot.create_ticket",
            "description": "Creates a new support ticket",
            "label": "Create Ticket",
        },
        "update_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "update_ticket_id",
                    "type": "string",
                    "value": "",
                    "label": "Ticket ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot ticket ID to update (required)",
                },
                {
                    "field": "update_ticket_name",
                    "type": "string",
                    "value": "",
                    "label": "Ticket Subject",
                    "placeholder": "Technical Support Request",
                    "helper_text": "Ticket subject",
                },
                {
                    "field": "update_category",
                    "type": "string",
                    "value": "",
                    "label": "Category",
                    "placeholder": "TECHNICAL_SUPPORT",
                    "helper_text": "Ticket category",
                },
                {
                    "field": "update_description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Customer needs help with...",
                    "helper_text": "Ticket description",
                },
                {
                    "field": "update_priority",
                    "type": "string",
                    "value": "",
                    "label": "Priority",
                    "placeholder": "HIGH",
                    "helper_text": "Priority level",
                },
                {
                    "field": "update_stage_id",
                    "type": "string",
                    "value": "",
                    "label": "Stage ID",
                    "placeholder": "2",
                    "helper_text": "Stage ID",
                },
                {
                    "field": "update_ticket_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Ticket Owner",
                    "placeholder": "12345",
                    "helper_text": "Ticket owner ID",
                },
                {
                    "field": "update_close_date",
                    "type": "string",
                    "value": "",
                    "label": "Close Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "Close date",
                },
            ],
            "outputs": [
                {
                    "field": "updated",
                    "type": "bool",
                    "helper_text": "Whether the ticket was updated",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "update_ticket",
            "task_name": "tasks.hubspot.update_ticket",
            "description": "Updates an existing ticket",
            "label": "Update Ticket",
        },
        "delete_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "delete_ticket_id",
                    "type": "string",
                    "value": "",
                    "label": "Ticket ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot ticket ID to delete (required)",
                }
            ],
            "outputs": [
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "Whether the ticket was deleted",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "delete_ticket",
            "task_name": "tasks.hubspot.delete_ticket",
            "description": "Deletes a ticket by ID",
            "label": "Delete Ticket",
        },
        "read_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "read_ticket_id",
                    "type": "string",
                    "value": "",
                    "label": "Ticket ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot ticket ID to read (required)",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Properties to retrieve",
                },
            ],
            "outputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "helper_text": "HubSpot ticket ID",
                },
                {"field": "subject", "type": "string", "helper_text": "Ticket subject"},
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Ticket description",
                },
                {"field": "status", "type": "string", "helper_text": "Ticket status"},
                {
                    "field": "priority",
                    "type": "string",
                    "helper_text": "Ticket priority",
                },
                {
                    "field": "category",
                    "type": "string",
                    "helper_text": "Ticket category",
                },
                {
                    "field": "pipeline",
                    "type": "string",
                    "helper_text": "Ticket pipeline",
                },
                {"field": "stage", "type": "string", "helper_text": "Ticket stage"},
                {"field": "owner", "type": "string", "helper_text": "Ticket owner"},
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Created date",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Updated date",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_ticket",
            "task_name": "tasks.hubspot.read_ticket",
            "description": "Retrieves a specific ticket by ID",
            "label": "Read Ticket",
        },
        "get_tickets**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "placeholder": "support request",
                    "helper_text": "General search query",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Technical Support",
                    "helper_text": "Search by ticket subject",
                },
                {
                    "field": "hs_ticket_category",
                    "type": "string",
                    "value": "",
                    "label": "Category",
                    "placeholder": "TECHNICAL_SUPPORT",
                    "helper_text": "Filter by ticket category",
                },
                {
                    "field": "hs_ticket_priority",
                    "type": "string",
                    "value": "",
                    "label": "Priority",
                    "placeholder": "HIGH",
                    "helper_text": "Filter by ticket priority",
                },
                {
                    "field": "hs_pipeline_stage",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline Stage",
                    "placeholder": "1",
                    "helper_text": "Filter by pipeline stage",
                },
                {
                    "field": "hs_pipeline",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline",
                    "placeholder": "0",
                    "helper_text": "Filter by pipeline",
                },
                {
                    "field": "hubspot_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Owner ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by ticket owner ID",
                },
                {
                    "field": "hs_resolution",
                    "type": "string",
                    "value": "",
                    "label": "Resolution",
                    "placeholder": "RESOLVED",
                    "helper_text": "Filter by ticket resolution",
                },
                {
                    "field": "source_type",
                    "type": "string",
                    "value": "",
                    "label": "Source Type",
                    "placeholder": "EMAIL",
                    "helper_text": "Filter by source type",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "value": "",
                    "label": "Created Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by creation date (YYYY-MM-DD)",
                },
                {
                    "field": "last_modified_date",
                    "type": "string",
                    "value": "",
                    "label": "Last Modified Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by last modified date (YYYY-MM-DD)",
                },
                {
                    "field": "closed_date",
                    "type": "string",
                    "value": "",
                    "label": "Closed Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by closed date (YYYY-MM-DD)",
                },
                {
                    "field": "first_agent_reply_date",
                    "type": "string",
                    "value": "",
                    "label": "First Agent Reply Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by first agent reply date",
                },
                {
                    "field": "hs_time_to_close",
                    "type": "string",
                    "value": "",
                    "label": "Time to Close",
                    "placeholder": "3600000",
                    "helper_text": "Filter by time to close (milliseconds)",
                },
                {
                    "field": "hs_time_to_first_agent_reply",
                    "type": "string",
                    "value": "",
                    "label": "Time to First Reply",
                    "placeholder": "1800000",
                    "helper_text": "Filter by time to first agent reply",
                },
                {
                    "field": "hs_num_times_contacted",
                    "type": "string",
                    "value": "",
                    "label": "Times Contacted",
                    "placeholder": "5",
                    "helper_text": "Filter by number of times contacted",
                },
                {
                    "field": "tags",
                    "type": "string",
                    "value": "",
                    "label": "Tags",
                    "placeholder": "urgent,bug",
                    "helper_text": "Filter by tags (comma-separated)",
                },
                {
                    "field": "sort_by",
                    "type": "string",
                    "value": "",
                    "label": "Sort By",
                    "placeholder": "createdate",
                    "helper_text": "Field to sort by",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "placeholder": "desc",
                    "helper_text": "Sort order (asc/desc)",
                },
            ],
            "outputs": [
                {
                    "field": "ticket_ids",
                    "type": "vec<string>",
                    "helper_text": "HubSpot ticket IDs",
                },
                {
                    "field": "subjects",
                    "type": "vec<string>",
                    "helper_text": "Ticket subjects",
                },
                {
                    "field": "descriptions",
                    "type": "vec<string>",
                    "helper_text": "Ticket descriptions",
                },
                {
                    "field": "statuses",
                    "type": "vec<string>",
                    "helper_text": "Ticket statuses",
                },
                {
                    "field": "priorities",
                    "type": "vec<string>",
                    "helper_text": "Ticket priorities",
                },
                {
                    "field": "categories",
                    "type": "vec<string>",
                    "helper_text": "Ticket categories",
                },
                {
                    "field": "pipelines",
                    "type": "vec<string>",
                    "helper_text": "Ticket pipelines",
                },
                {
                    "field": "stages",
                    "type": "vec<string>",
                    "helper_text": "Ticket stages",
                },
                {
                    "field": "owners",
                    "type": "vec<string>",
                    "helper_text": "Ticket owners",
                },
                {
                    "field": "created_ats",
                    "type": "vec<string>",
                    "helper_text": "Created dates",
                },
                {
                    "field": "updated_ats",
                    "type": "vec<string>",
                    "helper_text": "Updated dates",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of tickets retrieved",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_tickets",
            "task_name": "tasks.hubspot.get_tickets",
            "description": "Retrieves multiple tickets with advanced filtering",
            "label": "Get Tickets",
        },
        "get_tickets**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Tickets",
                    "helper_text": "Specify the number of tickets to fetch",
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_engagement**(*)**(*)": {
            "inputs": [
                {
                    "field": "create_engagement_type",
                    "type": "string",
                    "value": "call",
                    "label": "Type",
                    "placeholder": "Call",
                    "helper_text": "Select Engagement type (required)",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "engagement_type",
                    },
                },
                {
                    "field": "metadata",
                    "type": "string",
                    "value": "",
                    "label": "Metadata",
                    "placeholder": '{"body": "Call notes"}',
                    "helper_text": "Type-specific metadata (JSON)",
                },
                {
                    "field": "company_ids",
                    "type": "string",
                    "value": "",
                    "label": "Company IDs",
                    "placeholder": "123,456",
                    "helper_text": "Comma-separated company IDs",
                },
                {
                    "field": "contact_ids",
                    "type": "string",
                    "value": "",
                    "label": "Contact IDs",
                    "placeholder": "789,101",
                    "helper_text": "Comma-separated contact IDs",
                },
                {
                    "field": "deal_ids",
                    "type": "string",
                    "value": "",
                    "label": "Deal IDs",
                    "placeholder": "111,222",
                    "helper_text": "Comma-separated deal IDs",
                },
                {
                    "field": "owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Owner ID",
                    "placeholder": "12345",
                    "helper_text": "Engagement owner ID",
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "value": "",
                    "label": "Timestamp",
                    "placeholder": "2024-01-01T12:00:00Z",
                    "helper_text": "Engagement timestamp (ISO format)",
                },
            ],
            "outputs": [
                {
                    "field": "engagement_id",
                    "type": "string",
                    "helper_text": "HubSpot engagement ID",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "create_engagement",
            "task_name": "tasks.hubspot.create_engagement",
            "description": "Creates a new engagement (call, email, meeting, or task)",
            "label": "Create Engagement",
        },
        "delete_engagement**(*)**(*)": {
            "inputs": [
                {
                    "field": "delete_engagement_id",
                    "type": "string",
                    "value": "",
                    "label": "Engagement ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot engagement ID to delete (required)",
                },
                {
                    "field": "type",
                    "type": "string",
                    "value": "call",
                    "label": "Engagement Type",
                    "placeholder": "call",
                    "helper_text": "Type of engagement (call, email, meeting, task, note)",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "engagement_type",
                    },
                },
            ],
            "outputs": [
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "Whether the engagement was deleted",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "delete_engagement",
            "task_name": "tasks.hubspot.delete_engagement",
            "description": "Deletes an engagement by ID",
            "label": "Delete Engagement",
        },
        "read_engagement**(*)**(*)": {
            "inputs": [
                {
                    "field": "read_engagement_id",
                    "type": "string",
                    "value": "",
                    "label": "Engagement ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot engagement ID to read (required)",
                },
                {
                    "field": "type",
                    "type": "string",
                    "value": "call",
                    "label": "Engagement Type",
                    "placeholder": "call",
                    "helper_text": "Type of engagement (call, email, meeting, task, note)",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "engagement_type",
                    },
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
            ],
            "outputs": [
                {
                    "field": "engagement_id",
                    "type": "string",
                    "helper_text": "HubSpot engagement ID",
                },
                {
                    "field": "engagement_type",
                    "type": "string",
                    "helper_text": "Engagement type (call, email, meeting, task)",
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "helper_text": "Engagement timestamp",
                },
                {
                    "field": "body",
                    "type": "string",
                    "helper_text": "Engagement body/notes",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "helper_text": "Engagement subject",
                },
                {
                    "field": "owner_id",
                    "type": "string",
                    "helper_text": "Engagement owner ID",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Created date",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Updated date",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_engagement",
            "task_name": "tasks.hubspot.read_engagement",
            "description": "Retrieves a specific engagement by ID",
            "label": "Read Engagement",
        },
        "get_engagements**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "placeholder": "meeting",
                    "helper_text": "General search query",
                },
                {
                    "field": "engagement_type",
                    "type": "string",
                    "value": "",
                    "label": "Engagement Type",
                    "placeholder": "CALL",
                    "helper_text": "Filter by engagement type (CALL, EMAIL, MEETING, TASK)",
                },
                {
                    "field": "hubspot_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Owner ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by engagement owner ID",
                },
                {
                    "field": "contact_id",
                    "type": "string",
                    "value": "",
                    "label": "Contact ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by associated contact ID",
                },
                {
                    "field": "company_id",
                    "type": "string",
                    "value": "",
                    "label": "Company ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by associated company ID",
                },
                {
                    "field": "deal_id",
                    "type": "string",
                    "value": "",
                    "label": "Deal ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by associated deal ID",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "value": "",
                    "label": "Created Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by creation date (YYYY-MM-DD)",
                },
                {
                    "field": "last_modified_date",
                    "type": "string",
                    "value": "",
                    "label": "Last Modified Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by last modified date (YYYY-MM-DD)",
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "value": "",
                    "label": "Engagement Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by engagement date (YYYY-MM-DD)",
                },
                {
                    "field": "hs_communication_channel_type",
                    "type": "string",
                    "value": "",
                    "label": "Communication Channel",
                    "placeholder": "EMAIL",
                    "helper_text": "Filter by communication channel type",
                },
                {
                    "field": "hs_communication_logged_from",
                    "type": "string",
                    "value": "",
                    "label": "Logged From",
                    "placeholder": "CRM",
                    "helper_text": "Filter by where engagement was logged from",
                },
                {
                    "field": "hs_activity_type",
                    "type": "string",
                    "value": "",
                    "label": "Activity Type",
                    "placeholder": "INCOMING_EMAIL",
                    "helper_text": "Filter by activity type",
                },
                {
                    "field": "sort_by",
                    "type": "string",
                    "value": "",
                    "label": "Sort By",
                    "placeholder": "timestamp",
                    "helper_text": "Field to sort by",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "placeholder": "desc",
                    "helper_text": "Sort order (asc/desc)",
                },
            ],
            "outputs": [
                {
                    "field": "engagement_ids",
                    "type": "vec<string>",
                    "helper_text": "HubSpot engagement IDs",
                },
                {
                    "field": "engagement_types",
                    "type": "vec<string>",
                    "helper_text": "Engagement types (call, email, meeting, task)",
                },
                {
                    "field": "timestamps",
                    "type": "vec<string>",
                    "helper_text": "Engagement timestamps",
                },
                {
                    "field": "bodies",
                    "type": "vec<string>",
                    "helper_text": "Engagement bodies/notes",
                },
                {
                    "field": "subjects",
                    "type": "vec<string>",
                    "helper_text": "Engagement subjects",
                },
                {
                    "field": "owner_ids",
                    "type": "vec<string>",
                    "helper_text": "Engagement owner IDs",
                },
                {
                    "field": "created_ats",
                    "type": "vec<string>",
                    "helper_text": "Created dates",
                },
                {
                    "field": "updated_ats",
                    "type": "vec<string>",
                    "helper_text": "Updated dates",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of engagements retrieved",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_engagements",
            "task_name": "tasks.hubspot.get_engagements",
            "description": "Retrieves multiple engagements with advanced filtering",
            "label": "Get Engagements",
        },
        "get_engagements**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Engagements",
                    "helper_text": "Specify the number of engagements to fetch",
                }
            ],
            "outputs": [],
        },
        "get_engagements**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_engagements**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_engagements**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "add_contact_to_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "label": "List ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot list ID (required)",
                },
                {
                    "field": "by",
                    "type": "string",
                    "value": "email",
                    "label": "Identify By",
                    "placeholder": "email",
                    "helper_text": "Method to identify contacts: email or id",
                },
                {
                    "field": "emails",
                    "type": "string",
                    "value": "",
                    "label": "Email Addresses",
                    "helper_text": "Array of email addresses (when by=email)",
                },
                {
                    "field": "contact_ids",
                    "type": "string",
                    "value": "",
                    "label": "Contact IDs",
                    "helper_text": "Array of contact IDs (when by=id)",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether contacts were added successfully",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "add_contact_to_list",
            "task_name": "tasks.hubspot.add_contact_to_list",
            "description": "Adds contacts to a contact list",
            "label": "Add Contact to List",
        },
        "remove_contact_from_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "label": "List ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot list ID (required)",
                },
                {
                    "field": "contact_ids",
                    "type": "string",
                    "value": "",
                    "label": "Contact IDs",
                    "helper_text": "Array of contact IDs to remove",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether contacts were removed successfully",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "remove_contact_from_list",
            "task_name": "tasks.hubspot.remove_contact_from_list",
            "description": "Removes contacts from a contact list",
            "label": "Remove Contact from List",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        about_us: str = "",
        amount: int = 0,
        annual_revenue: int = 0,
        associated_company: str = "",
        associated_company_id: str = "",
        associated_company_ids: str = "",
        associated_contact_ids: str = "",
        associated_vids: str = "",
        by: str = "email",
        category: str = "",
        city: str = "",
        close_date: str = "",
        closed_date: str = "",
        company: str = "",
        company_domain_name: str = "",
        company_id: str = "",
        company_ids: str = "",
        company_name: str = "",
        company_owner: str = "",
        contact_id: str = "",
        contact_ids: str = "",
        country: str = "",
        country_region: str = "",
        create_company_name: str = "",
        create_deal_stage: str = "",
        create_email: str = "",
        create_engagement_type: str = "call",
        create_ticket_name: str = "",
        create_ticket_pipeline_id: str = "",
        create_ticket_stage_id: str = "",
        created_date: str = "",
        custom_properties: str = "",
        deal_currency_code: str = "",
        deal_id: str = "",
        deal_ids: str = "",
        deal_name: str = "",
        deal_owner: str = "",
        deal_stage: str = "",
        deal_type: str = "",
        delete_company_id: str = "",
        delete_contact_id: str = "",
        delete_deal_id: str = "",
        delete_engagement_id: str = "",
        delete_ticket_id: str = "",
        description: str = "",
        domain: str = "",
        email: str = "",
        emails: str = "",
        engagement_type: str = "",
        exact_date: Any = {"start": "", "end": ""},
        first_agent_reply_date: str = "",
        first_name: str = "",
        founded_year: str = "",
        hs_activity_type: str = "",
        hs_analytics_source: str = "",
        hs_analytics_source_data_1: str = "",
        hs_analytics_source_data_2: str = "",
        hs_communication_channel_type: str = "",
        hs_communication_logged_from: str = "",
        hs_date_entered_closed_lost: str = "",
        hs_date_entered_closed_won: str = "",
        hs_deal_stage_probability: str = "",
        hs_forecast_amount: str = "",
        hs_is_closed: bool = False,
        hs_is_deal_split: bool = False,
        hs_latest_source: str = "",
        hs_lead_status: str = "",
        hs_num_times_contacted: str = "",
        hs_pipeline: str = "",
        hs_pipeline_stage: str = "",
        hs_resolution: str = "",
        hs_ticket_category: str = "",
        hs_ticket_priority: str = "",
        hs_time_to_close: str = "",
        hs_time_to_first_agent_reply: str = "",
        hubspot_owner_id: str = "",
        include_merge_audits: bool = False,
        include_property_versions: bool = False,
        industry: str = "ACCOUNTING",
        is_public: bool = False,
        job_title: str = "",
        last_modified_date: str = "",
        last_name: str = "",
        lead_status: str = "",
        lifecycle: str = "subscriber",
        lifecycle_stage: str = "",
        list_id: str = "",
        metadata: str = "",
        mobile_phone_number: str = "",
        name: str = "",
        num_associated_contacts: str = "",
        num_contacted_notes: str = "",
        num_messages: int = 10,
        number_of_employees: int = 0,
        owner_id: str = "",
        phone: str = "",
        phone_number: str = "",
        pipeline: str = "",
        postal_code: str = "",
        priority: str = "",
        properties: str = "",
        query: str = "",
        read_company_id: str = "",
        read_contact_id: str = "",
        read_deal_id: str = "",
        read_engagement_id: str = "",
        read_ticket_id: str = "",
        show_list_memberships: bool = False,
        sort_by: str = "",
        sort_order: str = "",
        source_type: str = "",
        state: str = "",
        state_region: str = "",
        street_address: str = "",
        subject: str = "",
        tags: str = "",
        ticket_owner_id: str = "",
        timestamp: str = "",
        type: str = "",
        update_about_us: str = "",
        update_amount: int = 0,
        update_annual_revenue: int = 0,
        update_category: str = "",
        update_city: str = "",
        update_close_date: str = "",
        update_company: str = "",
        update_company_domain_name: str = "",
        update_company_id: str = "",
        update_company_name: str = "",
        update_company_owner: str = "",
        update_contact_id: str = "",
        update_country: str = "",
        update_country_region: str = "",
        update_custom_properties: str = "",
        update_deal_id: str = "",
        update_deal_name: str = "",
        update_deal_owner: str = "",
        update_deal_stage: str = "",
        update_deal_type: str = "",
        update_description: str = "",
        update_email: str = "",
        update_first_name: str = "",
        update_industry: str = "ACCOUNTING",
        update_job_title: str = "",
        update_last_name: str = "",
        update_lead_status: str = "NEW",
        update_lifecycle: str = "subscriber",
        update_mobile_phone_number: str = "",
        update_number_of_employees: int = 0,
        update_phone_number: str = "",
        update_pipeline: str = "",
        update_postal_code: str = "",
        update_priority: str = "",
        update_stage_id: str = "",
        update_state_region: str = "",
        update_street_address: str = "",
        update_ticket_id: str = "",
        update_ticket_name: str = "",
        update_ticket_owner_id: str = "",
        update_website_url: str = "",
        web_technologies: str = "",
        website: str = "",
        website_url: str = "",
        zip: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_hubspot",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if create_email is not None:
            self.inputs["create_email"] = create_email
        if first_name is not None:
            self.inputs["first_name"] = first_name
        if last_name is not None:
            self.inputs["last_name"] = last_name
        if company is not None:
            self.inputs["company"] = company
        if job_title is not None:
            self.inputs["job_title"] = job_title
        if phone_number is not None:
            self.inputs["phone_number"] = phone_number
        if mobile_phone_number is not None:
            self.inputs["mobile_phone_number"] = mobile_phone_number
        if street_address is not None:
            self.inputs["street_address"] = street_address
        if city is not None:
            self.inputs["city"] = city
        if state_region is not None:
            self.inputs["state_region"] = state_region
        if postal_code is not None:
            self.inputs["postal_code"] = postal_code
        if country is not None:
            self.inputs["country"] = country
        if website_url is not None:
            self.inputs["website_url"] = website_url
        if associated_company_id is not None:
            self.inputs["associated_company_id"] = associated_company_id
        if custom_properties is not None:
            self.inputs["custom_properties"] = custom_properties
        if update_contact_id is not None:
            self.inputs["update_contact_id"] = update_contact_id
        if update_email is not None:
            self.inputs["update_email"] = update_email
        if update_first_name is not None:
            self.inputs["update_first_name"] = update_first_name
        if update_last_name is not None:
            self.inputs["update_last_name"] = update_last_name
        if update_company is not None:
            self.inputs["update_company"] = update_company
        if update_job_title is not None:
            self.inputs["update_job_title"] = update_job_title
        if update_phone_number is not None:
            self.inputs["update_phone_number"] = update_phone_number
        if update_mobile_phone_number is not None:
            self.inputs["update_mobile_phone_number"] = update_mobile_phone_number
        if update_street_address is not None:
            self.inputs["update_street_address"] = update_street_address
        if update_city is not None:
            self.inputs["update_city"] = update_city
        if update_state_region is not None:
            self.inputs["update_state_region"] = update_state_region
        if update_postal_code is not None:
            self.inputs["update_postal_code"] = update_postal_code
        if update_country is not None:
            self.inputs["update_country"] = update_country
        if update_website_url is not None:
            self.inputs["update_website_url"] = update_website_url
        if update_custom_properties is not None:
            self.inputs["update_custom_properties"] = update_custom_properties
        if delete_contact_id is not None:
            self.inputs["delete_contact_id"] = delete_contact_id
        if read_contact_id is not None:
            self.inputs["read_contact_id"] = read_contact_id
        if properties is not None:
            self.inputs["properties"] = properties
        if show_list_memberships is not None:
            self.inputs["show_list_memberships"] = show_list_memberships
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if query is not None:
            self.inputs["query"] = query
        if email is not None:
            self.inputs["email"] = email
        if company_name is not None:
            self.inputs["company_name"] = company_name
        if phone is not None:
            self.inputs["phone"] = phone
        if state is not None:
            self.inputs["state"] = state
        if website is not None:
            self.inputs["website"] = website
        if lifecycle_stage is not None:
            self.inputs["lifecycle_stage"] = lifecycle_stage
        if lead_status is not None:
            self.inputs["lead_status"] = lead_status
        if hs_lead_status is not None:
            self.inputs["hs_lead_status"] = hs_lead_status
        if created_date is not None:
            self.inputs["created_date"] = created_date
        if last_modified_date is not None:
            self.inputs["last_modified_date"] = last_modified_date
        if hs_analytics_source is not None:
            self.inputs["hs_analytics_source"] = hs_analytics_source
        if hs_latest_source is not None:
            self.inputs["hs_latest_source"] = hs_latest_source
        if hubspot_owner_id is not None:
            self.inputs["hubspot_owner_id"] = hubspot_owner_id
        if sort_by is not None:
            self.inputs["sort_by"] = sort_by
        if sort_order is not None:
            self.inputs["sort_order"] = sort_order
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if create_company_name is not None:
            self.inputs["create_company_name"] = create_company_name
        if about_us is not None:
            self.inputs["about_us"] = about_us
        if annual_revenue is not None:
            self.inputs["annual_revenue"] = annual_revenue
        if company_domain_name is not None:
            self.inputs["company_domain_name"] = company_domain_name
        if company_owner is not None:
            self.inputs["company_owner"] = company_owner
        if country_region is not None:
            self.inputs["country_region"] = country_region
        if description is not None:
            self.inputs["description"] = description
        if industry is not None:
            self.inputs["industry"] = industry
        if lifecycle is not None:
            self.inputs["lifecycle"] = lifecycle
        if number_of_employees is not None:
            self.inputs["number_of_employees"] = number_of_employees
        if update_company_id is not None:
            self.inputs["update_company_id"] = update_company_id
        if update_company_name is not None:
            self.inputs["update_company_name"] = update_company_name
        if update_about_us is not None:
            self.inputs["update_about_us"] = update_about_us
        if update_annual_revenue is not None:
            self.inputs["update_annual_revenue"] = update_annual_revenue
        if update_company_domain_name is not None:
            self.inputs["update_company_domain_name"] = update_company_domain_name
        if update_company_owner is not None:
            self.inputs["update_company_owner"] = update_company_owner
        if update_country_region is not None:
            self.inputs["update_country_region"] = update_country_region
        if update_description is not None:
            self.inputs["update_description"] = update_description
        if update_industry is not None:
            self.inputs["update_industry"] = update_industry
        if update_lifecycle is not None:
            self.inputs["update_lifecycle"] = update_lifecycle
        if update_lead_status is not None:
            self.inputs["update_lead_status"] = update_lead_status
        if update_number_of_employees is not None:
            self.inputs["update_number_of_employees"] = update_number_of_employees
        if delete_company_id is not None:
            self.inputs["delete_company_id"] = delete_company_id
        if read_company_id is not None:
            self.inputs["read_company_id"] = read_company_id
        if include_merge_audits is not None:
            self.inputs["include_merge_audits"] = include_merge_audits
        if name is not None:
            self.inputs["name"] = name
        if domain is not None:
            self.inputs["domain"] = domain
        if zip is not None:
            self.inputs["zip"] = zip
        if type is not None:
            self.inputs["type"] = type
        if hs_analytics_source_data_1 is not None:
            self.inputs["hs_analytics_source_data_1"] = hs_analytics_source_data_1
        if hs_analytics_source_data_2 is not None:
            self.inputs["hs_analytics_source_data_2"] = hs_analytics_source_data_2
        if web_technologies is not None:
            self.inputs["web_technologies"] = web_technologies
        if founded_year is not None:
            self.inputs["founded_year"] = founded_year
        if is_public is not None:
            self.inputs["is_public"] = is_public
        if create_deal_stage is not None:
            self.inputs["create_deal_stage"] = create_deal_stage
        if deal_name is not None:
            self.inputs["deal_name"] = deal_name
        if amount is not None:
            self.inputs["amount"] = amount
        if close_date is not None:
            self.inputs["close_date"] = close_date
        if deal_owner is not None:
            self.inputs["deal_owner"] = deal_owner
        if deal_type is not None:
            self.inputs["deal_type"] = deal_type
        if pipeline is not None:
            self.inputs["pipeline"] = pipeline
        if associated_company is not None:
            self.inputs["associated_company"] = associated_company
        if associated_vids is not None:
            self.inputs["associated_vids"] = associated_vids
        if update_deal_id is not None:
            self.inputs["update_deal_id"] = update_deal_id
        if update_deal_stage is not None:
            self.inputs["update_deal_stage"] = update_deal_stage
        if update_deal_name is not None:
            self.inputs["update_deal_name"] = update_deal_name
        if update_amount is not None:
            self.inputs["update_amount"] = update_amount
        if update_close_date is not None:
            self.inputs["update_close_date"] = update_close_date
        if update_deal_owner is not None:
            self.inputs["update_deal_owner"] = update_deal_owner
        if update_deal_type is not None:
            self.inputs["update_deal_type"] = update_deal_type
        if update_pipeline is not None:
            self.inputs["update_pipeline"] = update_pipeline
        if delete_deal_id is not None:
            self.inputs["delete_deal_id"] = delete_deal_id
        if read_deal_id is not None:
            self.inputs["read_deal_id"] = read_deal_id
        if include_property_versions is not None:
            self.inputs["include_property_versions"] = include_property_versions
        if deal_stage is not None:
            self.inputs["deal_stage"] = deal_stage
        if deal_currency_code is not None:
            self.inputs["deal_currency_code"] = deal_currency_code
        if hs_deal_stage_probability is not None:
            self.inputs["hs_deal_stage_probability"] = hs_deal_stage_probability
        if num_associated_contacts is not None:
            self.inputs["num_associated_contacts"] = num_associated_contacts
        if num_contacted_notes is not None:
            self.inputs["num_contacted_notes"] = num_contacted_notes
        if hs_date_entered_closed_won is not None:
            self.inputs["hs_date_entered_closed_won"] = hs_date_entered_closed_won
        if hs_date_entered_closed_lost is not None:
            self.inputs["hs_date_entered_closed_lost"] = hs_date_entered_closed_lost
        if hs_forecast_amount is not None:
            self.inputs["hs_forecast_amount"] = hs_forecast_amount
        if hs_is_closed is not None:
            self.inputs["hs_is_closed"] = hs_is_closed
        if hs_is_deal_split is not None:
            self.inputs["hs_is_deal_split"] = hs_is_deal_split
        if create_ticket_pipeline_id is not None:
            self.inputs["create_ticket_pipeline_id"] = create_ticket_pipeline_id
        if create_ticket_stage_id is not None:
            self.inputs["create_ticket_stage_id"] = create_ticket_stage_id
        if create_ticket_name is not None:
            self.inputs["create_ticket_name"] = create_ticket_name
        if category is not None:
            self.inputs["category"] = category
        if priority is not None:
            self.inputs["priority"] = priority
        if ticket_owner_id is not None:
            self.inputs["ticket_owner_id"] = ticket_owner_id
        if associated_company_ids is not None:
            self.inputs["associated_company_ids"] = associated_company_ids
        if associated_contact_ids is not None:
            self.inputs["associated_contact_ids"] = associated_contact_ids
        if update_ticket_id is not None:
            self.inputs["update_ticket_id"] = update_ticket_id
        if update_ticket_name is not None:
            self.inputs["update_ticket_name"] = update_ticket_name
        if update_category is not None:
            self.inputs["update_category"] = update_category
        if update_priority is not None:
            self.inputs["update_priority"] = update_priority
        if update_stage_id is not None:
            self.inputs["update_stage_id"] = update_stage_id
        if update_ticket_owner_id is not None:
            self.inputs["update_ticket_owner_id"] = update_ticket_owner_id
        if delete_ticket_id is not None:
            self.inputs["delete_ticket_id"] = delete_ticket_id
        if read_ticket_id is not None:
            self.inputs["read_ticket_id"] = read_ticket_id
        if subject is not None:
            self.inputs["subject"] = subject
        if hs_ticket_category is not None:
            self.inputs["hs_ticket_category"] = hs_ticket_category
        if hs_ticket_priority is not None:
            self.inputs["hs_ticket_priority"] = hs_ticket_priority
        if hs_pipeline_stage is not None:
            self.inputs["hs_pipeline_stage"] = hs_pipeline_stage
        if hs_pipeline is not None:
            self.inputs["hs_pipeline"] = hs_pipeline
        if hs_resolution is not None:
            self.inputs["hs_resolution"] = hs_resolution
        if source_type is not None:
            self.inputs["source_type"] = source_type
        if closed_date is not None:
            self.inputs["closed_date"] = closed_date
        if first_agent_reply_date is not None:
            self.inputs["first_agent_reply_date"] = first_agent_reply_date
        if hs_time_to_close is not None:
            self.inputs["hs_time_to_close"] = hs_time_to_close
        if hs_time_to_first_agent_reply is not None:
            self.inputs["hs_time_to_first_agent_reply"] = hs_time_to_first_agent_reply
        if hs_num_times_contacted is not None:
            self.inputs["hs_num_times_contacted"] = hs_num_times_contacted
        if tags is not None:
            self.inputs["tags"] = tags
        if create_engagement_type is not None:
            self.inputs["create_engagement_type"] = create_engagement_type
        if metadata is not None:
            self.inputs["metadata"] = metadata
        if company_ids is not None:
            self.inputs["company_ids"] = company_ids
        if contact_ids is not None:
            self.inputs["contact_ids"] = contact_ids
        if deal_ids is not None:
            self.inputs["deal_ids"] = deal_ids
        if owner_id is not None:
            self.inputs["owner_id"] = owner_id
        if timestamp is not None:
            self.inputs["timestamp"] = timestamp
        if delete_engagement_id is not None:
            self.inputs["delete_engagement_id"] = delete_engagement_id
        if read_engagement_id is not None:
            self.inputs["read_engagement_id"] = read_engagement_id
        if engagement_type is not None:
            self.inputs["engagement_type"] = engagement_type
        if contact_id is not None:
            self.inputs["contact_id"] = contact_id
        if company_id is not None:
            self.inputs["company_id"] = company_id
        if deal_id is not None:
            self.inputs["deal_id"] = deal_id
        if hs_communication_channel_type is not None:
            self.inputs["hs_communication_channel_type"] = hs_communication_channel_type
        if hs_communication_logged_from is not None:
            self.inputs["hs_communication_logged_from"] = hs_communication_logged_from
        if hs_activity_type is not None:
            self.inputs["hs_activity_type"] = hs_activity_type
        if list_id is not None:
            self.inputs["list_id"] = list_id
        if by is not None:
            self.inputs["by"] = by
        if emails is not None:
            self.inputs["emails"] = emails
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def amount(self) -> str:
        """
        Deal amount

        Available: When action = 'read_deal'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("amount")

    @property
    def amounts(self) -> List[str]:
        """
        List of amounts

        Available: When action = 'get_deals'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("amounts")

    @property
    def annual_revenue(self) -> str:
        """
        Annual revenue

        Available: When action = 'read_company'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("annual_revenue")

    @property
    def annual_revenues(self) -> List[str]:
        """
        List of revenues

        Available: When action = 'get_companies'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("annual_revenues")

    @property
    def bodies(self) -> List[str]:
        """
        Engagement bodies/notes

        Available: When action = 'get_engagements'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("bodies")

    @property
    def body(self) -> str:
        """
        Engagement body/notes

        Available: When action = 'read_engagement'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("body")

    @property
    def categories(self) -> List[str]:
        """
        Ticket categories

        Available: When action = 'get_tickets'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("categories")

    @property
    def category(self) -> str:
        """
        Ticket category

        Available: When action = 'read_ticket'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("category")

    @property
    def cities(self) -> List[str]:
        """
        List of cities

        Available: When action = 'get_contacts', When action = 'get_companies'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("cities")

    @property
    def city(self) -> str:
        """
        Contact's city

        Different behavior based on configuration:
          - Contact's city (When action = 'read_contact')
          - City (When action = 'read_company')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("city")

    @property
    def close_date(self) -> str:
        """
        Deal close date

        Available: When action = 'read_deal'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("close_date")

    @property
    def close_dates(self) -> List[str]:
        """
        List of close dates

        Available: When action = 'get_deals'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("close_dates")

    @property
    def companies(self) -> List[str]:
        """
        List of companies

        Available: When action = 'get_contacts'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("companies")

    @property
    def company(self) -> str:
        """
        Contact's company

        Available: When action = 'read_contact'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("company")

    @property
    def company_id(self) -> str:
        """
        HubSpot company ID

        Available: When action = 'create_company', When action = 'read_company'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("company_id")

    @property
    def company_ids(self) -> List[str]:
        """
        List of company IDs

        Available: When action = 'get_companies'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("company_ids")

    @property
    def contact_id(self) -> str:
        """
        HubSpot contact ID

        Available: When action = 'create_contact', When action = 'read_contact'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("contact_id")

    @property
    def contact_ids(self) -> List[str]:
        """
        List of contact IDs

        Available: When action = 'get_contacts'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("contact_ids")

    @property
    def countries(self) -> List[str]:
        """
        List of countries

        Available: When action = 'get_contacts', When action = 'get_companies'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("countries")

    @property
    def country(self) -> str:
        """
        Contact's country

        Different behavior based on configuration:
          - Contact's country (When action = 'read_contact')
          - Country (When action = 'read_company')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("country")

    @property
    def created_at(self) -> str:
        """
        Created date

        Available: When action = 'read_ticket', When action = 'read_engagement'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_at")

    @property
    def created_ats(self) -> List[str]:
        """
        Created dates

        Available: When action = 'get_tickets', When action = 'get_engagements'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_ats")

    @property
    def deal_id(self) -> str:
        """
        HubSpot deal ID

        Available: When action = 'create_deal', When action = 'read_deal'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("deal_id")

    @property
    def deal_ids(self) -> List[str]:
        """
        List of deal IDs

        Available: When action = 'get_deals'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("deal_ids")

    @property
    def deal_name(self) -> str:
        """
        Deal name

        Available: When action = 'read_deal'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("deal_name")

    @property
    def deal_names(self) -> List[str]:
        """
        List of deal names

        Available: When action = 'get_deals'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("deal_names")

    @property
    def deal_owner(self) -> str:
        """
        Deal owner

        Available: When action = 'read_deal'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("deal_owner")

    @property
    def deal_owners(self) -> List[str]:
        """
        List of owners

        Available: When action = 'get_deals'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("deal_owners")

    @property
    def deal_type(self) -> str:
        """
        Deal type

        Available: When action = 'read_deal'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("deal_type")

    @property
    def deal_types(self) -> List[str]:
        """
        List of deal types

        Available: When action = 'get_deals'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("deal_types")

    @property
    def deleted(self) -> bool:
        """
        True if contact was deleted

        Different behavior based on configuration:
          - True if contact was deleted (When action = 'delete_contact')
          - True if company was deleted (When action = 'delete_company')
          - True if deal was deleted (When action = 'delete_deal')
          - Whether the ticket was deleted (When action = 'delete_ticket')
          - Whether the engagement was deleted (When action = 'delete_engagement')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("deleted")

    @property
    def description(self) -> str:
        """
        Company description

        Different behavior based on configuration:
          - Company description (When action = 'read_company')
          - Deal description (When action = 'read_deal')
          - Ticket description (When action = 'read_ticket')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("description")

    @property
    def descriptions(self) -> List[str]:
        """
        List of descriptions

        Different behavior based on configuration:
          - List of descriptions (When action = 'get_companies', When action = 'get_deals')
          - Ticket descriptions (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("descriptions")

    @property
    def domain(self) -> str:
        """
        Company domain

        Available: When action = 'read_company'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("domain")

    @property
    def domains(self) -> List[str]:
        """
        List of domains

        Available: When action = 'get_companies'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("domains")

    @property
    def email(self) -> str:
        """
        Contact's email address

        Available: When action = 'read_contact'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email")

    @property
    def emails(self) -> List[str]:
        """
        List of email addresses

        Available: When action = 'get_contacts'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("emails")

    @property
    def engagement_id(self) -> str:
        """
        HubSpot engagement ID

        Available: When action = 'create_engagement', When action = 'read_engagement'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("engagement_id")

    @property
    def engagement_ids(self) -> List[str]:
        """
        HubSpot engagement IDs

        Available: When action = 'get_engagements'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("engagement_ids")

    @property
    def engagement_type(self) -> str:
        """
        Engagement type (call, email, meeting, task)

        Available: When action = 'read_engagement'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("engagement_type")

    @property
    def engagement_types(self) -> List[str]:
        """
        Engagement types (call, email, meeting, task)

        Available: When action = 'get_engagements'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("engagement_types")

    @property
    def first_name(self) -> str:
        """
        Contact's first name

        Available: When action = 'read_contact'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("first_name")

    @property
    def first_names(self) -> List[str]:
        """
        List of first names

        Available: When action = 'get_contacts'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("first_names")

    @property
    def industries(self) -> List[str]:
        """
        List of industries

        Available: When action = 'get_companies'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("industries")

    @property
    def industry(self) -> str:
        """
        Industry

        Available: When action = 'read_company'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("industry")

    @property
    def job_title(self) -> str:
        """
        Contact's job title

        Available: When action = 'read_contact'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("job_title")

    @property
    def job_titles(self) -> List[str]:
        """
        List of job titles

        Available: When action = 'get_contacts'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("job_titles")

    @property
    def last_name(self) -> str:
        """
        Contact's last name

        Available: When action = 'read_contact'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("last_name")

    @property
    def last_names(self) -> List[str]:
        """
        List of last names

        Available: When action = 'get_contacts'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("last_names")

    @property
    def name(self) -> str:
        """
        Company name

        Available: When action = 'read_company'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("name")

    @property
    def names(self) -> List[str]:
        """
        List of company names

        Available: When action = 'get_companies'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("names")

    @property
    def number_of_employees(self) -> str:
        """
        Employee count

        Different behavior based on configuration:
          - Employee count (When action = 'read_company')
          - List of employee counts (When action = 'get_companies')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("number_of_employees")

    @property
    def owner(self) -> str:
        """
        Ticket owner

        Available: When action = 'read_ticket'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("owner")

    @property
    def owner_id(self) -> str:
        """
        Engagement owner ID

        Available: When action = 'read_engagement'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("owner_id")

    @property
    def owner_ids(self) -> List[str]:
        """
        Engagement owner IDs

        Available: When action = 'get_engagements'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("owner_ids")

    @property
    def owners(self) -> List[str]:
        """
        Ticket owners

        Available: When action = 'get_tickets'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("owners")

    @property
    def phone_number(self) -> str:
        """
        Contact's phone number

        Different behavior based on configuration:
          - Contact's phone number (When action = 'read_contact')
          - Phone number (When action = 'read_company')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("phone_number")

    @property
    def phone_numbers(self) -> List[str]:
        """
        List of phone numbers

        Available: When action = 'get_contacts', When action = 'get_companies'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("phone_numbers")

    @property
    def pipeline(self) -> str:
        """
        Deal pipeline

        Different behavior based on configuration:
          - Deal pipeline (When action = 'read_deal')
          - Ticket pipeline (When action = 'read_ticket')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pipeline")

    @property
    def pipelines(self) -> List[str]:
        """
        List of pipelines

        Different behavior based on configuration:
          - List of pipelines (When action = 'get_deals')
          - Ticket pipelines (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pipelines")

    @property
    def priorities(self) -> List[str]:
        """
        Ticket priorities

        Available: When action = 'get_tickets'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("priorities")

    @property
    def priority(self) -> str:
        """
        Ticket priority

        Available: When action = 'read_ticket'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("priority")

    @property
    def probabilities(self) -> List[str]:
        """
        List of probabilities

        Available: When action = 'get_deals'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("probabilities")

    @property
    def probability(self) -> str:
        """
        Deal probability

        Available: When action = 'read_deal'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("probability")

    @property
    def raw_data(self) -> str:
        """
        Raw response from HubSpot

        Different behavior based on configuration:
          - Raw response from HubSpot (When action = 'read_contact', When action = 'get_contacts')
          - Full response data (When action = 'read_company', When action = 'get_companies', When action = 'read_deal', When action = 'get_deals')
          - Raw response data (When action = 'read_ticket', When action = 'get_tickets', When action = 'read_engagement', When action = 'get_engagements')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("raw_data")

    @property
    def stage(self) -> str:
        """
        Deal stage

        Different behavior based on configuration:
          - Deal stage (When action = 'read_deal')
          - Ticket stage (When action = 'read_ticket')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("stage")

    @property
    def stages(self) -> List[str]:
        """
        List of stages

        Different behavior based on configuration:
          - List of stages (When action = 'get_deals')
          - Ticket stages (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("stages")

    @property
    def state(self) -> str:
        """
        Contact's state

        Different behavior based on configuration:
          - Contact's state (When action = 'read_contact')
          - State (When action = 'read_company')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("state")

    @property
    def states(self) -> List[str]:
        """
        List of states

        Available: When action = 'get_contacts', When action = 'get_companies'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("states")

    @property
    def status(self) -> str:
        """
        Ticket status

        Available: When action = 'read_ticket'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("status")

    @property
    def statuses(self) -> List[str]:
        """
        Ticket statuses

        Available: When action = 'get_tickets'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("statuses")

    @property
    def subject(self) -> str:
        """
        Ticket subject

        Different behavior based on configuration:
          - Ticket subject (When action = 'read_ticket')
          - Engagement subject (When action = 'read_engagement')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("subject")

    @property
    def subjects(self) -> List[str]:
        """
        Ticket subjects

        Different behavior based on configuration:
          - Ticket subjects (When action = 'get_tickets')
          - Engagement subjects (When action = 'get_engagements')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("subjects")

    @property
    def success(self) -> bool:
        """
        Whether contacts were added successfully

        Different behavior based on configuration:
          - Whether contacts were added successfully (When action = 'add_contact_to_list')
          - Whether contacts were removed successfully (When action = 'remove_contact_from_list')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("success")

    @property
    def ticket_id(self) -> str:
        """
        HubSpot ticket ID

        Available: When action = 'create_ticket', When action = 'read_ticket'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_id")

    @property
    def ticket_ids(self) -> List[str]:
        """
        HubSpot ticket IDs

        Available: When action = 'get_tickets'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_ids")

    @property
    def timestamp(self) -> str:
        """
        Engagement timestamp

        Available: When action = 'read_engagement'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("timestamp")

    @property
    def timestamps(self) -> List[str]:
        """
        Engagement timestamps

        Available: When action = 'get_engagements'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("timestamps")

    @property
    def total(self) -> int:
        """
        Total contacts retrieved

        Different behavior based on configuration:
          - Total contacts retrieved (When action = 'get_contacts')
          - Total count returned (When action = 'get_companies')
          - Total deals retrieved (When action = 'get_deals')
          - Total number of tickets retrieved (When action = 'get_tickets')
          - Total number of engagements retrieved (When action = 'get_engagements')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("total")

    @property
    def updated(self) -> bool:
        """
        True if contact was updated

        Different behavior based on configuration:
          - True if contact was updated (When action = 'update_contact')
          - True if update succeeded (When action = 'update_company')
          - True if deal was updated (When action = 'update_deal')
          - Whether the ticket was updated (When action = 'update_ticket')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated")

    @property
    def updated_at(self) -> str:
        """
        Updated date

        Available: When action = 'read_ticket', When action = 'read_engagement'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated_at")

    @property
    def updated_ats(self) -> List[str]:
        """
        Updated dates

        Available: When action = 'get_tickets', When action = 'get_engagements'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated_ats")

    @property
    def website(self) -> str:
        """
        Contact's website

        Different behavior based on configuration:
          - Contact's website (When action = 'read_contact')
          - Website (When action = 'read_company')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("website")

    @property
    def websites(self) -> List[str]:
        """
        List of websites

        Available: When action = 'get_contacts', When action = 'get_companies'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("websites")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationHubspotNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_snowflake")
class IntegrationSnowflakeNode(Node):
    """
    Snowflake

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### nl
        database: Select the Database on which to perform the query
        query: SQL Query to execute
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        schema: Select the schema to be used in the query
        sql_generation_model: The sql_generation_model input
        warehouse: Select the SQL Warehouse which will perform the operation
    ### raw_sql
        database: Select the Database on which to perform the query
        query: SQL Query to execute
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        schema: Select the schema to be used in the query
        sql_generation_model: The sql_generation_model input
        warehouse: Select the SQL Warehouse which will perform the operation
    ### nl_agent
        database: Select the Database on which to perform the query
        query: SQL Query to execute
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        schema: Select the schema to be used in the query
        sql_generation_model: The sql_generation_model input
        warehouse: Select the SQL Warehouse which will perform the operation

    ## Outputs
    ### Common Outputs
        output: Output of the query as Markdown table
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Snowflake>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "Output of the query as Markdown table"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "nl": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "warehouse",
                    "type": "string",
                    "value": "",
                    "label": "Warehouse",
                    "helper_text": "Select the SQL Warehouse which will perform the operation",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=warehouse&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "",
                    "label": "Database",
                    "helper_text": "Select the Database on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "schema",
                    "type": "string",
                    "value": "",
                    "label": "Schema",
                    "helper_text": "Select the schema to be used in the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=schema&database={inputs.database}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl",
            "task_name": "tasks.tables.integrations.snowflake.query",
            "description": "Generate and execute a SQL query",
            "label": "Natural Language Query",
        },
        "raw_sql": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "warehouse",
                    "type": "string",
                    "value": "",
                    "label": "Warehouse",
                    "helper_text": "Select the SQL Warehouse which will perform the operation",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=warehouse&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "",
                    "label": "Database",
                    "helper_text": "Select the Database on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "schema",
                    "type": "string",
                    "value": "",
                    "label": "Schema",
                    "helper_text": "Select the schema to be used in the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=schema&database={inputs.database}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "raw_sql",
            "task_name": "tasks.tables.integrations.snowflake.query",
            "description": "Execute a SQL query",
            "label": "Raw SQL Query",
        },
        "nl_agent": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "warehouse",
                    "type": "string",
                    "value": "",
                    "label": "Warehouse",
                    "helper_text": "Select the SQL Warehouse which will perform the operation",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=warehouse&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "",
                    "label": "Database",
                    "helper_text": "Select the Database on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "schema",
                    "type": "string",
                    "value": "",
                    "label": "Schema",
                    "helper_text": "Select the schema to be used in the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=schema&database={inputs.database}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl_agent",
            "task_name": "tasks.tables.integrations.snowflake.query",
            "description": "Let an LLM agent query the database",
            "label": "Natural Language Agent",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        database: str = "",
        query: str = "",
        query_agent_model: str = "gpt-4-turbo-preview",
        query_type: str = "Raw SQL",
        schema: str = "",
        sql_generation_model: str = "gpt-4-turbo-preview",
        warehouse: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_snowflake",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if query_type is not None:
            self.inputs["query_type"] = query_type
        if warehouse is not None:
            self.inputs["warehouse"] = warehouse
        if database is not None:
            self.inputs["database"] = database
        if schema is not None:
            self.inputs["schema"] = schema
        if sql_generation_model is not None:
            self.inputs["sql_generation_model"] = sql_generation_model
        if query_agent_model is not None:
            self.inputs["query_agent_model"] = query_agent_model
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> Any:
        """
        Output of the query as Markdown table


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationSnowflakeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_elasticsearch")
class IntegrationElasticsearchNode(Node):
    """
    Elasticsearch

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### search_index
        index: Elasticsearch index name
        query: Query to search over index in JSON format

    ## Outputs
    ### search_index
        output: Search results from the Elasticsearch index
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Elasticsearch>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "search_index": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "JSON Query",
                    "placeholder": '{"query_string": {"query": "mountain*", "fields": ["title", "description"]}}',
                    "helper_text": "Query to search over index in JSON format",
                },
                {
                    "field": "index",
                    "type": "string",
                    "value": "",
                    "label": "Index",
                    "placeholder": "my-index",
                    "helper_text": "Elasticsearch index name",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Search results from the Elasticsearch index",
                }
            ],
            "name": "search_index",
            "task_name": "tasks.elasticsearch.search_index",
            "description": "Query your Elasticsearch index",
            "label": "Search Elasticsearch index",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        index: str = "",
        query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_elasticsearch",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if index is not None:
            self.inputs["index"] = index
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Search results from the Elasticsearch index

        Available: search_index


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationElasticsearchNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_mongodb")
class IntegrationMongodbNode(Node):
    """
    MongoDB

    ## Inputs
    ### Common Inputs
        action: The action input
        integration: Connect to your account
    ### find
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records
    ### find_one
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records
    ### aggregate
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records
    ### mongodb_nl
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records
    ### mongodb_nl_aggregation
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records

    ## Outputs
    ### Common Outputs
        output: Results of the Query. Example: {“name”: “John”, “age”: 29, “height”: 185}
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "The action input",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<MongoDB>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "output",
            "helper_text": "Results of the Query. Example: {“name”: “John”, “age”: 29, “height”: 185}",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "find": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "find",
            "task_name": "tasks.document_dbs.mongo.query",
            "description": "Query MongoDB data",
            "label": "MongoDB Find",
        },
        "find_one": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "find_one",
            "task_name": "tasks.document_dbs.mongo.query",
            "description": "Query MongoDB data",
            "label": "MongoDB Find One",
        },
        "aggregate": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "aggregate",
            "task_name": "tasks.document_dbs.mongo.query",
            "description": "Run an Aggegation on MongoDB data",
            "label": "MongoDB Aggegate",
        },
        "mongodb_nl": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "mongodb_nl",
            "task_name": "tasks.document_dbs.mongo.query",
            "description": "Query MongoDB data with Natural Language",
            "label": "NL Query",
        },
        "mongodb_nl_aggregation": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "mongodb_nl_aggregation",
            "task_name": "tasks.document_dbs.mongo.query",
            "description": "Aggregate MongoDB data with Natural Language",
            "label": "NL Aggregation",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        collection: str = "",
        query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_mongodb",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if collection is not None:
            self.inputs["collection"] = collection
        if query is not None:
            self.inputs["query"] = query
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Results of the Query. Example: {“name”: “John”, “age”: 29, “height”: 185}


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMongodbNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_pinecone")
class IntegrationPineconeNode(Node):
    """
    Pinecone

    ## Inputs
    ### Common Inputs
        action: The action input
        integration: Connect to your account
    ### query_pinecone
        embedding_model: Select the embedding model to use to embed the query
        index: The Pinecone index to query
        namespace: Select the namespace to query (queries across all namespaces if left empty)
        query: Natural Language query

    ## Outputs
    ### query_pinecone
        output: Query output in Langchain-style documents
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "The action input",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Pinecone>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "query_pinecone": {
            "inputs": [
                {
                    "field": "embedding_model",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Embedding Model",
                    "helper_text": "Select the embedding model to use to embed the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {
                                "label": "OpenAI Text Embedding 3 Small",
                                "value": "openai/text-embedding-3-small",
                            },
                            {
                                "label": "OpenAI Text Embedding 3 Large",
                                "value": "openai/text-embedding-3-large",
                            },
                            {
                                "label": "OpenAI Text Embedding Ada 002",
                                "value": "openai/text-embedding-ada-002",
                            },
                            {
                                "label": "Cohere Embed English v3.0",
                                "value": "cohere/embed-english-v3.0",
                            },
                            {
                                "label": "Cohere Embed Multilingual v3.0",
                                "value": "cohere/embed-multilingual-v3.0",
                            },
                            {
                                "label": "Cohere Embed English Light v3.0",
                                "value": "cohere/embed-english-light-v3.0",
                            },
                            {
                                "label": "Cohere Embed Multilingual Light v3.0",
                                "value": "cohere/embed-multilingual-light-v3.0",
                            },
                        ],
                    },
                },
                {
                    "field": "index",
                    "type": "string",
                    "value": "",
                    "label": "Index",
                    "helper_text": "The Pinecone index to query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=index&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "namespace",
                    "type": "string",
                    "value": "",
                    "label": "Namespace",
                    "helper_text": "Select the namespace to query (queries across all namespaces if left empty)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=namespace&index={inputs.index}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "“Birthday parties in March”",
                    "helper_text": "Natural Language query",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "any",
                    "helper_text": "Query output in Langchain-style documents",
                }
            ],
            "name": "query_pinecone",
            "task_name": "tasks.vectordbs.integrations.pinecone.query",
            "description": "Query Pinecone data",
            "label": "Query Pinecone",
            "variant": "common_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        embedding_model: str = "",
        index: str = "",
        namespace: str = "",
        query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_pinecone",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if embedding_model is not None:
            self.inputs["embedding_model"] = embedding_model
        if index is not None:
            self.inputs["index"] = index
        if namespace is not None:
            self.inputs["namespace"] = namespace
        if query is not None:
            self.inputs["query"] = query
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> Any:
        """
        Query output in Langchain-style documents

        Available: query_pinecone


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationPineconeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_postgres")
class IntegrationPostgresNode(Node):
    """
    Postgres

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### nl
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input
    ### raw_sql
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input
    ### nl_agent
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input

    ## Outputs
    ### Common Outputs
        output: Query results in Markdown format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Postgres>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "Query results in Markdown format"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "nl": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "Natural language query to be converted to SQL",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl",
            "task_name": "tasks.tables.integrations.postgres.query",
            "description": "Generate and execute a SQL query",
            "label": "Natural Language Query",
        },
        "raw_sql": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "raw_sql",
            "task_name": "tasks.tables.integrations.postgres.query",
            "description": "Execute a SQL query",
            "label": "Raw SQL Query",
        },
        "nl_agent": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "Natural language query for the LLM agent to process",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl_agent",
            "task_name": "tasks.tables.integrations.postgres.query",
            "description": "Let an LLM agent query the database",
            "label": "Natural Language Agent",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        query: str = "",
        query_agent_model: str = "gpt-4-turbo-preview",
        query_type: str = "Raw SQL",
        sql_generation_model: str = "gpt-4-turbo-preview",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_postgres",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if query_type is not None:
            self.inputs["query_type"] = query_type
        if sql_generation_model is not None:
            self.inputs["sql_generation_model"] = sql_generation_model
        if query_agent_model is not None:
            self.inputs["query_agent_model"] = query_agent_model
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Query results in Markdown format


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationPostgresNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_mysql")
class IntegrationMysqlNode(Node):
    """
    MySQL

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### nl
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input
    ### raw_sql
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input
    ### nl_agent
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input

    ## Outputs
    ### Common Outputs
        output: Query results in Markdown table format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<MySQL>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "Query results in Markdown table format"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "nl": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "Natural language query to be converted to SQL",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl",
            "task_name": "tasks.tables.integrations.mysql.query",
            "description": "Generate and execute a SQL query",
            "label": "Natural Language Query",
        },
        "raw_sql": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "raw_sql",
            "task_name": "tasks.tables.integrations.mysql.query",
            "description": "Execute a SQL query",
            "label": "Raw SQL Query",
        },
        "nl_agent": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "Natural language query for the LLM agent to process",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl_agent",
            "task_name": "tasks.tables.integrations.mysql.query",
            "description": "Let an LLM agent query the database",
            "label": "Natural Language Agent",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        query: str = "",
        query_agent_model: str = "gpt-4-turbo-preview",
        query_type: str = "Raw SQL",
        sql_generation_model: str = "gpt-4-turbo-preview",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_mysql",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if query_type is not None:
            self.inputs["query_type"] = query_type
        if sql_generation_model is not None:
            self.inputs["sql_generation_model"] = sql_generation_model
        if query_agent_model is not None:
            self.inputs["query_agent_model"] = query_agent_model
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Query results in Markdown table format


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMysqlNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_wordpress")
class IntegrationWordpressNode(Node):
    """
    Wordpress

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_post
        post_content: The content of the post
        post_title: The title of the post
        wordpress_url: Wordpress domain URL

    ## Outputs
    ### create_post
        post_url: URL of the created WordPress post
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Wordpress>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "create_post": {
            "inputs": [
                {
                    "field": "wordpress_url",
                    "type": "string",
                    "value": "",
                    "label": "Wordpress URL",
                    "placeholder": "test.wordpress.com",
                    "helper_text": "Wordpress domain URL",
                    "agent_field_type": "static",
                },
                {
                    "field": "post_title",
                    "type": "string",
                    "value": "",
                    "label": "Post Title",
                    "placeholder": "An overview of Generative AI",
                    "helper_text": "The title of the post",
                },
                {
                    "field": "post_content",
                    "type": "string",
                    "value": "",
                    "label": "Post Content",
                    "placeholder": "This is an overview...",
                    "helper_text": "The content of the post",
                },
            ],
            "outputs": [
                {
                    "field": "post_url",
                    "type": "string",
                    "helper_text": "URL of the created WordPress post",
                }
            ],
            "name": "create_post",
            "task_name": "tasks.wordpress.create_post",
            "description": "Create post on Wordpress site",
            "label": "Post to Wordpress",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        post_content: str = "",
        post_title: str = "",
        wordpress_url: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_wordpress",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if wordpress_url is not None:
            self.inputs["wordpress_url"] = wordpress_url
        if post_title is not None:
            self.inputs["post_title"] = post_title
        if post_content is not None:
            self.inputs["post_content"] = post_content
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def post_url(self) -> str:
        """
        URL of the created WordPress post

        Available: create_post


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("post_url")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationWordpressNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_linkedin")
class IntegrationLinkedinNode(Node):
    """
    Linkedin

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_text_share
        post_text: Content you wanted to post on your LinkedIn

    ## Outputs
    ### create_text_share
        output: URL of the created LinkedIn post
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Linkedin>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "create_text_share": {
            "inputs": [
                {
                    "field": "post_text",
                    "type": "string",
                    "value": "",
                    "label": "Post Text",
                    "placeholder": "“I just got a new job!”",
                    "helper_text": "Content you wanted to post on your LinkedIn",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "URL of the created LinkedIn post",
                }
            ],
            "name": "create_text_share",
            "task_name": "tasks.linkedin.create_text_share",
            "description": "Create text post on LinkedIn",
            "label": "Post to LinkedIn",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        post_text: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_linkedin",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if post_text is not None:
            self.inputs["post_text"] = post_text
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        URL of the created LinkedIn post

        Available: create_text_share


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationLinkedinNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_calendar")
class IntegrationGoogleCalendarNode(Node):
    """
    Google Calendar

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'new_event'
        all_day_event: Toggle to set the event as an all-day event
        attendees: Email IDs of attendees (comma separated)
        calendar: Select the calendar to add the new event to
        description: The description of the event
        duration: The duration of the event (positive integer). Default: 30 (in minutes)
        event_name: The name of the calendar event
        location: Physical location or the meeting location (like Zoom)
        start_datetime: The start time of the calendar event (format: YYYY-MM-DD for full day event or YYYY-MM-DDTHH:MM:SS for specific time)
    ### When action = 'check_availability'
        calendar: Select the calendar to add the new event to
        end_date_and_time: The last date and end time for everyday to look for availability
        slot_duration: The duration of an individual slot to look for (in minutes). Default: 30 (in minutes)
        start_date_and_time: The first date and start time for everyday to look for availability
        timezone: IANA Time Zone code (e.g., US/Eastern)
    ### When action = 'get_events'
        calendar: Select the calendar to add the new event to
        query: Return only events that contain these keywords
        use_date: Toggle to use dates
    ### When action = 'get_events' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'get_events' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'get_events' and use_date = False
        num_messages: Specify the last n numbers of events
    ### When action = 'get_events' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'get_events'
        attendees: List of event attendees
        details: List of event details
        end_times: List of event end times
        event_ids: List of event IDs
        locations: List of event locations
        organizers: List of event organizers
        start_times: List of event start times
        summaries: List of event summaries
    ### When action = 'new_event'
        output: Calendar event link
    ### When action = 'check_availability'
        output: List of available time slots
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Calendar>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new_event**(*)**(*)": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "string",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to add the new event to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "event_name",
                    "type": "string",
                    "value": "",
                    "label": "Event Name",
                    "placeholder": "Meeting with John Doe",
                    "helper_text": "The name of the calendar event",
                    "order": 4,
                },
                {
                    "field": "all_day_event",
                    "type": "bool",
                    "value": False,
                    "label": "All Day Event",
                    "helper_text": "Toggle to set the event as an all-day event",
                    "order": 5,
                },
                {
                    "field": "start_datetime",
                    "type": "timestamp",
                    "value": -1,
                    "label": "Start Datetime",
                    "placeholder": "2024-06-24 (full day event) or 2024-06-24T19:00:00",
                    "helper_text": "The start time of the calendar event (format: YYYY-MM-DD for full day event or YYYY-MM-DDTHH:MM:SS for specific time)",
                    "order": 6,
                },
                {
                    "field": "duration",
                    "type": "int32",
                    "value": 30,
                    "label": "Duration",
                    "placeholder": "30 minutes",
                    "helper_text": "The duration of the event (positive integer). Default: 30 (in minutes)",
                    "order": 7,
                },
                {
                    "field": "attendees",
                    "type": "string",
                    "value": "",
                    "label": "Attendees",
                    "placeholder": "abc@example.com,xyz@example.com,",
                    "helper_text": "Email IDs of attendees (comma separated)",
                    "order": 8,
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "placeholder": "800 Howard St., San Francisco, CA 94103",
                    "helper_text": "Physical location or the meeting location (like Zoom)",
                    "order": 9,
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Monthly sync",
                    "helper_text": "The description of the event",
                    "order": 10,
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Calendar event link",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "new_event",
            "task_name": "tasks.google_calendar.create_event",
            "description": "Create a new event",
            "label": "New Event",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "event_name",
                "all_day_event",
                "start_datetime",
                "duration",
                "attendees",
                "location",
                "description",
            ],
        },
        "check_availability**(*)**(*)": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "string",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to check availability",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "start_date_and_time",
                    "type": "timestamp",
                    "value": -1,
                    "label": "Start Date & Start Work Time",
                    "placeholder": "2024-06-24",
                    "helper_text": "The first date and start time for everyday to look for availability",
                    "order": 4,
                },
                {
                    "field": "end_date_and_time",
                    "type": "timestamp",
                    "value": -1,
                    "label": "End Date & End Work Time",
                    "placeholder": "2024-06-24",
                    "helper_text": "The last date and end time for everyday to look for availability",
                    "order": 5,
                },
                {
                    "field": "slot_duration",
                    "type": "int32",
                    "value": 30,
                    "label": "Slot Duration",
                    "placeholder": "30 minutes",
                    "helper_text": "The duration of an individual slot to look for (in minutes). Default: 30 (in minutes)",
                    "order": 6,
                },
                {
                    "field": "timezone",
                    "type": "enum<string>",
                    "value": "US/Eastern",
                    "label": "Timezone",
                    "placeholder": "US/Eastern",
                    "helper_text": "IANA Time Zone code (e.g., US/Eastern)",
                    "component": {"type": "dropdown", "referenced_options": "timezone"},
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of available time slots",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "check_availability",
            "task_name": "tasks.google_calendar.check_availability",
            "description": "Check Google calendar availability",
            "label": "Check Availability",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "start_date_and_time",
                "end_date_and_time",
                "slot_duration",
                "timezone",
            ],
        },
        "get_events**(*)**(*)": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "string",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to read events from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "helper_text": "Return only events that contain these keywords",
                    "placeholder": "Keywords to filter events",
                },
            ],
            "outputs": [
                {
                    "field": "event_ids",
                    "type": "vec<string>",
                    "helper_text": "List of event IDs",
                },
                {
                    "field": "summaries",
                    "type": "vec<string>",
                    "helper_text": "List of event summaries",
                },
                {
                    "field": "start_times",
                    "type": "vec<string>",
                    "helper_text": "List of event start times",
                },
                {
                    "field": "end_times",
                    "type": "vec<string>",
                    "helper_text": "List of event end times",
                },
                {
                    "field": "locations",
                    "type": "vec<string>",
                    "helper_text": "List of event locations",
                },
                {
                    "field": "organizers",
                    "type": "vec<string>",
                    "helper_text": "List of event organizers",
                },
                {
                    "field": "attendees",
                    "type": "vec<vec<string>>",
                    "helper_text": "List of event attendees",
                },
                {
                    "field": "details",
                    "type": "vec<string>",
                    "helper_text": "List of event details",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_events",
            "task_name": "tasks.google_calendar.get_events",
            "description": "Get events from Google Calendar",
            "label": "Get Events",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "query",
            ],
        },
        "get_events**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Events",
                    "helper_text": "Specify the last n numbers of events",
                }
            ],
            "outputs": [],
        },
        "get_events**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_events**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "hidden": True,
                    "label": "Date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_events**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "label": "Exact date",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        all_day_event: bool = False,
        attendees: str = "",
        calendar: Optional[str] = None,
        description: str = "",
        duration: int = 30,
        end_date_and_time: Any = -1,
        event_name: str = "",
        exact_date: Any = {"start": "", "end": ""},
        location: str = "",
        num_messages: int = 10,
        query: str = "",
        slot_duration: int = 30,
        start_date_and_time: Any = -1,
        start_datetime: Any = -1,
        timezone: str = "US/Eastern",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_google_calendar",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if calendar is not None:
            self.inputs["calendar"] = calendar
        if event_name is not None:
            self.inputs["event_name"] = event_name
        if all_day_event is not None:
            self.inputs["all_day_event"] = all_day_event
        if start_datetime is not None:
            self.inputs["start_datetime"] = start_datetime
        if duration is not None:
            self.inputs["duration"] = duration
        if attendees is not None:
            self.inputs["attendees"] = attendees
        if location is not None:
            self.inputs["location"] = location
        if description is not None:
            self.inputs["description"] = description
        if start_date_and_time is not None:
            self.inputs["start_date_and_time"] = start_date_and_time
        if end_date_and_time is not None:
            self.inputs["end_date_and_time"] = end_date_and_time
        if slot_duration is not None:
            self.inputs["slot_duration"] = slot_duration
        if timezone is not None:
            self.inputs["timezone"] = timezone
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if query is not None:
            self.inputs["query"] = query
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attendees(self) -> List[List[str]]:
        """
        List of event attendees

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attendees")

    @property
    def details(self) -> List[str]:
        """
        List of event details

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("details")

    @property
    def end_times(self) -> List[str]:
        """
        List of event end times

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("end_times")

    @property
    def event_ids(self) -> List[str]:
        """
        List of event IDs

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("event_ids")

    @property
    def locations(self) -> List[str]:
        """
        List of event locations

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("locations")

    @property
    def organizers(self) -> List[str]:
        """
        List of event organizers

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("organizers")

    @property
    def output(self) -> str:
        """
        Calendar event link

        Different behavior based on configuration:
          - Calendar event link (When action = 'new_event')
          - List of available time slots (When action = 'check_availability')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @property
    def start_times(self) -> List[str]:
        """
        List of event start times

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("start_times")

    @property
    def summaries(self) -> List[str]:
        """
        List of event summaries

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("summaries")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleCalendarNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_microsoft_calendar")
class IntegrationMicrosoftCalendarNode(Node):
    """
    Microsoft Calendar

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### new_event
        all_day_event: Toggle to set the event as an all-day event
        attendees: Email IDs of attendees (comma separated)
        body: Description or agenda of the event
        calendar: Select the calendar to add the new event to
        duration: The duration of the event in minutes. Default: 30 (in minutes)
        location: The location of the meeting
        start_datetime: The start date and time of the calendar event (format: YYYY-MM-DDTHH:MM:SS)
        subject: Name/Subject of the calendar event
    ### check_availability
        end_date_and_time: The last date and end time for everyday to look for availability
        slot_duration: The duration of an individual slot to look for (in minutes). Default: 30 (in minutes)
        start_date_and_time: The first date and start time for everyday to look for availability
        timezone: IANA Time Zone code (e.g., US/Eastern)

    ## Outputs
    ### new_event
        output: Calendar event link
    ### check_availability
        output: List of available time slots with start and end datetimes
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Microsoft Calendar>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "new_event": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "string",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to add the new event to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Sprint planning",
                    "helper_text": "Name/Subject of the calendar event",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "This meeting is to discuss...",
                    "helper_text": "Description or agenda of the event",
                },
                {
                    "field": "start_datetime",
                    "type": "timestamp",
                    "value": "",
                    "label": "Start Datetime",
                    "placeholder": "2024-06-24T19:00:00",
                    "helper_text": "The start date and time of the calendar event (format: YYYY-MM-DDTHH:MM:SS)",
                },
                {
                    "field": "all_day_event",
                    "type": "bool",
                    "value": False,
                    "label": "All Day Event",
                    "helper_text": "Toggle to set the event as an all-day event",
                },
                {
                    "field": "duration",
                    "type": "int32",
                    "value": 30,
                    "label": "Duration",
                    "placeholder": "30 minutes",
                    "helper_text": "The duration of the event in minutes. Default: 30 (in minutes)",
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "placeholder": "800 Howard St., San Francisco, CA 94103",
                    "helper_text": "The location of the meeting",
                },
                {
                    "field": "attendees",
                    "type": "string",
                    "value": "",
                    "label": "Attendees",
                    "placeholder": "abc@example.com,xyz@example.com",
                    "helper_text": "Email IDs of attendees (comma separated)",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Calendar event link",
                }
            ],
            "name": "new_event",
            "task_name": "tasks.microsoft_calendar.create_event",
            "description": "Create a new calendar event",
            "label": "New Event",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "subject",
                "body",
                "all_day_event",
                "start_datetime",
                "duration",
                "location",
                "attendees",
            ],
        },
        "check_availability": {
            "inputs": [
                {
                    "field": "start_date_and_time",
                    "type": "timestamp",
                    "value": "",
                    "label": "Start Date & Start Work Time",
                    "placeholder": "2024-06-24",
                    "helper_text": "The first date and start time for everyday to look for availability",
                },
                {
                    "field": "end_date_and_time",
                    "type": "timestamp",
                    "value": "",
                    "label": "End Date & End Work Time",
                    "placeholder": "2024-06-24",
                    "helper_text": "The last date and end time for everyday to look for availability",
                },
                {
                    "field": "slot_duration",
                    "type": "int32",
                    "value": "",
                    "label": "Slot duration",
                    "placeholder": "30 minutes",
                    "helper_text": "The duration of an individual slot to look for (in minutes). Default: 30 (in minutes)",
                },
                {
                    "field": "timezone",
                    "type": "enum<string>",
                    "value": "US/Eastern",
                    "label": "Timezone",
                    "placeholder": "US/Eastern",
                    "helper_text": "IANA Time Zone code (e.g., US/Eastern)",
                    "component": {"type": "dropdown", "referenced_options": "timezone"},
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of available time slots with start and end datetimes",
                }
            ],
            "name": "check_availability",
            "task_name": "tasks.microsoft_calendar.check_availability",
            "description": "Check Microsoft calendar availability",
            "label": "Check Availability",
            "inputs_sort_order": [
                "integration",
                "action",
                "timezone",
                "start_date_and_time",
                "end_date_and_time",
                "slot_duration",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        all_day_event: bool = False,
        attendees: str = "",
        body: str = "",
        calendar: Optional[str] = None,
        duration: int = 30,
        end_date_and_time: Any = None,
        location: str = "",
        slot_duration: int = None,
        start_date_and_time: Any = None,
        start_datetime: Any = None,
        subject: str = "",
        timezone: str = "US/Eastern",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_microsoft_calendar",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if calendar is not None:
            self.inputs["calendar"] = calendar
        if subject is not None:
            self.inputs["subject"] = subject
        if body is not None:
            self.inputs["body"] = body
        if start_datetime is not None:
            self.inputs["start_datetime"] = start_datetime
        if all_day_event is not None:
            self.inputs["all_day_event"] = all_day_event
        if duration is not None:
            self.inputs["duration"] = duration
        if location is not None:
            self.inputs["location"] = location
        if attendees is not None:
            self.inputs["attendees"] = attendees
        if start_date_and_time is not None:
            self.inputs["start_date_and_time"] = start_date_and_time
        if end_date_and_time is not None:
            self.inputs["end_date_and_time"] = end_date_and_time
        if slot_duration is not None:
            self.inputs["slot_duration"] = slot_duration
        if timezone is not None:
            self.inputs["timezone"] = timezone
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Calendar event link

        Different behavior based on configuration:
          - Calendar event link (new_event)
          - List of available time slots with start and end datetimes (check_availability)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMicrosoftCalendarNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_mailgun")
class IntegrationMailgunNode(Node):
    """
    Mailgun

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### send_mail
        bcc_recipients: The email(s) of the recipient(s) you want to BCC the email to
        body: The body (message) of the email
        cc_recipients: The email(s) of the recipient(s) you want to CC the email to
        domain: Your Mailgun domain
        from_email: The email of the sender of the email
        from_name: The name of the sender of the email
        recipients: The email of the recipient you want to send the email to
        subject: The subject of the email
    ### add_contact_to_mailing_list
        email: The email of the contact to be added to the list
        list_name: The list the contact will be added to
        name: The name of contact to be added to the list

    ## Outputs
    ### send_mail
        output: Status of the email sending operation
    ### add_contact_to_mailing_list
        output: Status of the contact addition operation
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Mailgun>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "send_mail": {
            "inputs": [
                {
                    "field": "domain",
                    "type": "string",
                    "label": "Domain",
                    "agent_field_type": "static",
                    "helper_text": "Your Mailgun domain",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=domain_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Important: Your Account Update",
                    "helper_text": "The subject of the email",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Dear valued customer...",
                    "helper_text": "The body (message) of the email",
                },
                {
                    "field": "from_name",
                    "type": "string",
                    "value": "",
                    "label": "The name of the sender",
                    "placeholder": "John Smith",
                    "helper_text": "The name of the sender of the email",
                },
                {
                    "field": "from_email",
                    "type": "string",
                    "value": "",
                    "label": "The Email of the sender",
                    "placeholder": "john@company.com",
                    "helper_text": "The email of the sender of the email",
                },
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients email address",
                    "placeholder": "recipient@example.com",
                    "helper_text": "The email of the recipient you want to send the email to",
                },
                {
                    "field": "cc_recipients",
                    "type": "string",
                    "value": "",
                    "label": "CC Recipients email address",
                    "placeholder": "cc1@example.com, cc2@example.com",
                    "helper_text": "The email(s) of the recipient(s) you want to CC the email to",
                },
                {
                    "field": "bcc_recipients",
                    "type": "string",
                    "value": "",
                    "label": "BCC Recipients email address",
                    "placeholder": "bcc1@example.com, bcc2@example.com",
                    "helper_text": "The email(s) of the recipient(s) you want to BCC the email to",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Status of the email sending operation",
                }
            ],
            "name": "send_mail",
            "task_name": "tasks.mailgun.send_mail",
            "description": "Send mail ",
            "label": "Send mail",
        },
        "add_contact_to_mailing_list": {
            "inputs": [
                {
                    "field": "list_name",
                    "type": "string",
                    "value": "",
                    "label": "Name of the mailing list",
                    "placeholder": "newsletter-subscribers",
                    "helper_text": "The list the contact will be added to",
                    "agent_field_type": "static",
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name of the contact to add",
                    "placeholder": "John Smith",
                    "helper_text": "The name of contact to be added to the list",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email of the contact to add",
                    "placeholder": "john@example.com",
                    "helper_text": "The email of the contact to be added to the list",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Status of the contact addition operation",
                }
            ],
            "name": "add_contact_to_mailing_list",
            "task_name": "tasks.mailgun.add_contact_to_mailing_list",
            "description": "Adds a contact to a Mailgun Mailing list",
            "label": "Add Contact to Mailing List",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        bcc_recipients: str = "",
        body: str = "",
        cc_recipients: str = "",
        domain: Optional[str] = None,
        email: str = "",
        from_email: str = "",
        from_name: str = "",
        list_name: str = "",
        name: str = "",
        recipients: str = "",
        subject: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_mailgun",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if domain is not None:
            self.inputs["domain"] = domain
        if subject is not None:
            self.inputs["subject"] = subject
        if body is not None:
            self.inputs["body"] = body
        if from_name is not None:
            self.inputs["from_name"] = from_name
        if from_email is not None:
            self.inputs["from_email"] = from_email
        if recipients is not None:
            self.inputs["recipients"] = recipients
        if cc_recipients is not None:
            self.inputs["cc_recipients"] = cc_recipients
        if bcc_recipients is not None:
            self.inputs["bcc_recipients"] = bcc_recipients
        if list_name is not None:
            self.inputs["list_name"] = list_name
        if name is not None:
            self.inputs["name"] = name
        if email is not None:
            self.inputs["email"] = email
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Status of the email sending operation

        Different behavior based on configuration:
          - Status of the email sending operation (send_mail)
          - Status of the contact addition operation (add_contact_to_mailing_list)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMailgunNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_docs")
class IntegrationGoogleDocsNode(Node):
    """
    Google Docs

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### read_doc_url
        doc_url: Enter the public URL of the Google Doc
    ### read_doc
        file_id: Select a File to read
    ### write_to_doc
        file_id: Select a File to read
        text: The text that will be added to the File

    ## Outputs
    ### read_doc_url
        content: HTML body of the Google Doc
    ### read_doc
        text: The text content of the selected file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Docs>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_file_nodes",
        },
        "read_doc": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select a File to read",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The text content of the selected file",
                }
            ],
            "name": "read_doc",
            "task_name": "tasks.google_docs.read_doc",
            "description": "Retrieves and returns the plain text content of a user-selected Google Doc.",
            "label": "Read Google Doc",
        },
        "write_to_doc": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select a File to append the text to",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Text",
                    "placeholder": "Hello World!",
                    "helper_text": "The text that will be added to the File",
                },
            ],
            "outputs": [],
            "name": "write_to_doc",
            "task_name": "tasks.google_docs.write_to_doc",
            "description": "Append text to an existing document",
            "label": "Append Text to Document",
        },
        "read_doc_url": {
            "inputs": [
                {
                    "field": "doc_url",
                    "type": "string",
                    "value": "",
                    "label": "Google Doc URL",
                    "helper_text": "Enter the public URL of the Google Doc",
                    "placeholder": "Enter the public URL of the Google Doc",
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "content",
                    "type": "string",
                    "helper_text": "HTML body of the Google Doc",
                }
            ],
            "variant": "default_integration_nodes",
            "banner_text": 'Ensure that the Google Docs\'s permissions is set to "Anyone with the Link"',
            "name": "read_doc_url",
            "task_name": "tasks.google_docs.read_doc_url",
            "description": "Download the contents of a publicly accessible Google Docs file using its shared URL",
            "label": "Read from Doc URL",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        doc_url: str = "",
        file_id: Optional[str] = None,
        text: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_google_docs",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if file_id is not None:
            self.inputs["file_id"] = file_id
        if text is not None:
            self.inputs["text"] = text
        if doc_url is not None:
            self.inputs["doc_url"] = doc_url
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def content(self) -> str:
        """
        HTML body of the Google Doc

        Available: read_doc_url


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("content")

    @property
    def text(self) -> str:
        """
        The text content of the selected file

        Available: read_doc


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleDocsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_microsoft")
class IntegrationMicrosoftNode(Node):
    """
    One Drive

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### add_file
        file: Select or Upload a file
        item_id: Select the folder within your OneDrive to add the file
    ### read_file
        item_id: Select the folder within your OneDrive to add the file

    ## Outputs
    ### read_file
        output: The content of the selected file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Microsoft>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_file_nodes",
        },
        "add_file": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder within your OneDrive to add the file",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "file",
                    "type": "file",
                    "value": "",
                    "label": "File",
                    "placeholder": "Select a file",
                    "helper_text": "Select or Upload a file",
                },
            ],
            "outputs": [],
            "name": "add_file",
            "task_name": "tasks.microsoft.add_file",
            "description": "Add file to OneDrive",
            "label": "Add File",
        },
        "read_file": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to read from OneDrive",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "endpoint": "",
                            "query": {"field": "parent_id"},
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "The content of the selected file",
                }
            ],
            "name": "read_file",
            "task_name": "tasks.microsoft.read_file",
            "description": "Read file from OneDrive",
            "label": "Read File",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        file: str = "",
        item_id: Optional[str] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_microsoft",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if file is not None:
            self.inputs["file"] = file
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The content of the selected file

        Available: read_file


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMicrosoftNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_typeform")
class IntegrationTypeformNode(Node):
    """
    Typeform

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### get_responses
        form_id: Select the form from which to get the responses
        number_of_responses: The number of responses to fetch

    ## Outputs
    ### get_responses
        list_of_responses: The responses in list format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Typeform>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "get_responses": {
            "inputs": [
                {
                    "field": "form_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Form",
                    "helper_text": "Select the form from which to get the responses",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "number_of_responses",
                    "type": "string",
                    "value": "",
                    "label": "Number of responses",
                    "placeholder": "5",
                    "helper_text": "The number of responses to fetch",
                },
            ],
            "outputs": [
                {
                    "field": "list_of_responses",
                    "type": "vec<string>",
                    "helper_text": "The responses in list format",
                }
            ],
            "name": "get_responses",
            "task_name": "tasks.typeform.get_responses",
            "description": "Get Form Responses From Typeform",
            "label": "Get Form Responses",
            "variant": "common_integration_file_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        form_id: str = "",
        number_of_responses: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_typeform",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if form_id is not None:
            self.inputs["form_id"] = form_id
        if number_of_responses is not None:
            self.inputs["number_of_responses"] = number_of_responses
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def list_of_responses(self) -> List[str]:
        """
        The responses in list format

        Available: get_responses


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("list_of_responses")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationTypeformNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_dropbox")
class IntegrationDropboxNode(Node):
    """
    Dropbox

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### post_file
        file: Select or Upload a file
        folder_id: Select the folder where you want to post the file to

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Dropbox>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "post_file": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder where you want to post the file to",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "file",
                    "type": "file",
                    "value": "",
                    "label": "File",
                    "placeholder": "Select a file",
                    "helper_text": "Select or Upload a file",
                },
            ],
            "outputs": [],
            "name": "post_file",
            "task_name": "tasks.dropbox.post_file",
            "description": "Post file to Dropbox",
            "label": "Post file",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "folder_id", "file"],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        file: str = "",
        folder_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_dropbox",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if folder_id is not None:
            self.inputs["folder_id"] = folder_id
        if file is not None:
            self.inputs["file"] = file
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationDropboxNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_box")
class IntegrationBoxNode(Node):
    """
    Box

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### upload_files
        files: The number of files to be appended. Files will be appended in successive fashion (e.g., file-1 first, then file-2, etc.)
        folder_id: Select the Folder to upload files to

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Box>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "upload_files": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the Folder to upload files to",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "files",
                    "type": "vec<file>",
                    "value": [""],
                    "label": "Files",
                    "placeholder": "Files",
                    "helper_text": "The number of files to be appended. Files will be appended in successive fashion (e.g., file-1 first, then file-2, etc.)",
                },
            ],
            "outputs": [],
            "name": "upload_files",
            "task_name": "tasks.box.upload_files",
            "description": "Upload files to Box",
            "label": "Upload files",
            "variant": "common_integration_file_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        files: List[str] = [""],
        folder_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_box",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if folder_id is not None:
            self.inputs["folder_id"] = folder_id
        if files is not None:
            self.inputs["files"] = files
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationBoxNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_drive")
class IntegrationGoogleDriveNode(Node):
    """
    Google Drive

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'get_files'
        corpora: Scope to search in: 'user' (files owned/shared to user) or 'domain' (files shared to user's domain)
        drive_id: ID of the shared drive to search
        fields: Comma-separated list of fields to include in the response
        include_items_from_all_drives: Whether to include items from all drives, including shared drives
        include_labels: Comma-separated list of label IDs to include in the response
        include_permissions_for_view: Additional view's permissions to include (only 'published' supported)
        order_by: Sort order for files (e.g., 'folder,name,modifiedTime desc')
        query: Search query for filtering files (see Drive API documentation for syntax)
        spaces: Comma-separated list of spaces to search ('drive', 'appDataFolder')
        supports_all_drives: Whether the application supports both My Drives and shared drives
        use_date: Toggle to use dates
    ### When action = 'get_files' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'read_file_url'
        drive_file_url: The URL of the drive file to read.
    ### When action = 'get_files' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'save_drive'
        file: Select or Upload a file
        folder_id: Select the folder within your Google Drive to save the file
    ### When action = 'read_drive'
        file_id: Select the file to read
    ### When action = 'get_files' and use_date = False
        num_messages: Specify the number of files to fetch
    ### When action = 'get_files' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_file_url'
        file: The file fetched from the URL.
    ### When action = 'get_files'
        files: The files of the retrieved files
    ### When action = 'read_drive'
        text: The text content of the selected file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Drive>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_file_nodes",
        },
        "read_drive**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to read",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The text content of the selected file",
                }
            ],
            "name": "read_drive",
            "task_name": "tasks.google_drive.read_drive",
            "description": "Download a user-selected file from their Google Drive using its file ID",
            "label": "Read file",
            "inputs_sort_order": ["integration", "action", "file_id"],
        },
        "save_drive**(*)**(*)": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder within your Google Drive to save the file",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "file",
                    "type": "file",
                    "value": "",
                    "label": "File",
                    "placeholder": "Select a file",
                    "helper_text": "Select or Upload a file",
                },
            ],
            "outputs": [],
            "name": "save_drive",
            "task_name": "tasks.google_drive.save_drive",
            "description": "Save a file to Google Drive",
            "label": "Save file",
            "inputs_sort_order": ["integration", "action", "folder_id", "file"],
        },
        "read_file_url**(*)**(*)": {
            "inputs": [
                {
                    "field": "drive_file_url",
                    "type": "string",
                    "value": "",
                    "helper_text": "The URL of the drive file to read.",
                    "label": "File URL",
                    "placeholder": "Enter the URL of the drive file to read.",
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "file",
                    "type": "file",
                    "label": "File",
                    "helper_text": "The file fetched from the URL.",
                }
            ],
            "variant": "default_integration_nodes",
            "banner_text": 'Ensure that the Google Drive\'s permissions is set to "Anyone with the Link"',
            "name": "read_file_url",
            "task_name": "tasks.google_drive.read_file_url",
            "description": "Download the contents of a publicly accessible Google Drive file using its shared URL",
            "label": "Read file from URL",
            "inputs_sort_order": ["integration", "action", "drive_file_url"],
        },
        "get_files**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "order": 4,
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "helper_text": "Search query for filtering files (see Drive API documentation for syntax)",
                    "placeholder": "",
                },
                {
                    "field": "order_by",
                    "type": "string",
                    "value": "",
                    "label": "Order By",
                    "helper_text": "Sort order for files (e.g., 'folder,name,modifiedTime desc')",
                    "placeholder": "",
                },
                {
                    "field": "corpora",
                    "type": "string",
                    "value": "",
                    "label": "Search Scope",
                    "helper_text": "Scope to search in: 'user' (files owned/shared to user) or 'domain' (files shared to user's domain)",
                    "placeholder": "Eg. User or Domain",
                },
                {
                    "field": "drive_id",
                    "type": "string",
                    "value": "",
                    "label": "Drive ID",
                    "helper_text": "ID of the shared drive to search",
                },
                {
                    "field": "fields",
                    "type": "string",
                    "value": "",
                    "label": "Fields to Include",
                    "helper_text": "Comma-separated list of fields to include in the response",
                    "placeholder": "Eg. name, id, size, etc.",
                },
                {
                    "field": "include_items_from_all_drives",
                    "type": "bool",
                    "value": True,
                    "label": "Include All Drives",
                    "helper_text": "Whether to include items from all drives, including shared drives",
                },
                {
                    "field": "include_labels",
                    "type": "string",
                    "value": "",
                    "label": "Include Labels",
                    "helper_text": "Comma-separated list of label IDs to include in the response",
                    "placeholder": "",
                },
                {
                    "field": "spaces",
                    "type": "string",
                    "value": "",
                    "label": "Spaces",
                    "helper_text": "Comma-separated list of spaces to search ('drive', 'appDataFolder')",
                    "placeholder": "Eg. drive, appDataFolder",
                },
                {
                    "field": "supports_all_drives",
                    "type": "bool",
                    "value": True,
                    "label": "Supports All Drives",
                    "helper_text": "Whether the application supports both My Drives and shared drives",
                    "placeholder": "",
                },
                {
                    "field": "include_permissions_for_view",
                    "type": "string",
                    "value": "",
                    "label": "Include Permissions View",
                    "helper_text": "Additional view's permissions to include (only 'published' supported)",
                    "placeholder": "",
                },
            ],
            "outputs": [
                {
                    "field": "files",
                    "type": "vec<file>",
                    "helper_text": "The files of the retrieved files",
                    "label": "Files",
                }
            ],
            "variant": "get_integration_nodes",
            "name": "get_files",
            "task_name": "tasks.google_drive.get_files",
            "description": "Search for and return a list of files from the user's Google Drive that match the specified filters",
            "label": "Get Files",
            "inputs_sort_order": [
                "integration",
                "action",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "query",
                "order_by",
                "corpora",
                "drive_id",
                "fields",
                "include_items_from_all_drives",
                "include_labels",
                "spaces",
                "supports_all_drives",
                "include_permissions_for_view",
            ],
        },
        "get_files**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Files",
                    "helper_text": "Specify the number of files to fetch",
                }
            ],
            "outputs": [],
        },
        "get_files**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_files**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "label": "Date range",
                    "component": {"type": "date_range"},
                    "order": 6,
                }
            ],
            "outputs": [],
        },
        "get_files**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "label": "Exact date",
                    "component": {"type": "date_range"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        corpora: str = "",
        drive_file_url: str = "",
        drive_id: str = "",
        exact_date: Any = {"start": "", "end": ""},
        fields: str = "",
        file: str = "",
        file_id: str = "",
        folder_id: str = "",
        include_items_from_all_drives: bool = True,
        include_labels: str = "",
        include_permissions_for_view: str = "",
        num_messages: int = 10,
        order_by: str = "",
        query: str = "",
        spaces: str = "",
        supports_all_drives: bool = True,
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_google_drive",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if file_id is not None:
            self.inputs["file_id"] = file_id
        if folder_id is not None:
            self.inputs["folder_id"] = folder_id
        if file is not None:
            self.inputs["file"] = file
        if drive_file_url is not None:
            self.inputs["drive_file_url"] = drive_file_url
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if query is not None:
            self.inputs["query"] = query
        if order_by is not None:
            self.inputs["order_by"] = order_by
        if corpora is not None:
            self.inputs["corpora"] = corpora
        if drive_id is not None:
            self.inputs["drive_id"] = drive_id
        if fields is not None:
            self.inputs["fields"] = fields
        if include_items_from_all_drives is not None:
            self.inputs["include_items_from_all_drives"] = include_items_from_all_drives
        if include_labels is not None:
            self.inputs["include_labels"] = include_labels
        if spaces is not None:
            self.inputs["spaces"] = spaces
        if supports_all_drives is not None:
            self.inputs["supports_all_drives"] = supports_all_drives
        if include_permissions_for_view is not None:
            self.inputs["include_permissions_for_view"] = include_permissions_for_view
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def file(self) -> str:
        """
        The file fetched from the URL.

        Available: When action = 'read_file_url'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file")

    @property
    def files(self) -> List[str]:
        """
        The files of the retrieved files

        Available: When action = 'get_files'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("files")

    @property
    def text(self) -> str:
        """
        The text content of the selected file

        Available: When action = 'read_drive'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleDriveNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_sheets")
class IntegrationGoogleSheetsNode(Node):
    """
    Google Sheets

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: The integration input
    ### When action = 'write_to_sheet' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'write_list_to_column' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'update_rows' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'extract_to_table'
        add_columns_manually: Add data points for some columns manually instead of having them extracted by the AI model.
        additional_context: Additional context for the AI model to extract the table.
        extract_multiple_rows: If checked, it will extract multiple rows of data. If unchecked, it will extract a single row.
        model: The model to use for the Google Sheets integration
        provider: The provider to use for the Google Sheets integration
        sheet_id: Select the Sheet to read from
        text_for_extraction: The text to extract the table from
    ### When action = 'update_rows'
        condition: Conditional Operator
        sheet_id: Select the Sheet to read from
    ### When action = 'extract_to_table' and add_columns_manually = True
        manual_columns: Pass in data to column names manually.
    ### When action = 'read_sheet'
        sheet_id: Select the Sheet to read from
    ### When action = 'read_sheet_url'
        sheet_id: Select the Sheet to read from
        sheet_url: Enter the URL of your Google Spreadsheet
    ### When action = 'write_to_sheet'
        sheet_id: Select the Sheet to read from
    ### When action = 'write_list_to_column'
        sheet_id: Select the Sheet to read from

    ## Outputs
    ### When action = 'read_sheet' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.outputs]: The [<A>.outputs] output
    ### When action = 'read_sheet_url' and endpoint_1 = '[endpoint_1.<B>]'
        [<B>.outputs]: The [<B>.outputs] output
    ### When action = 'extract_to_table'
        table: The table extracted from the text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Google Sheets>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "read_sheet**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "agent_field_type": "static",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                }
            ],
            "outputs": [],
            "name": "read_sheet",
            "task_name": "tasks.google_sheets.read_sheet",
            "description": "Read specified columns from the selected sheet",
            "label": "Read from Sheet",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "sheet_id"],
        },
        "read_sheet**(*)**[endpoint_0.<A>]**(*)": {
            "inputs": [],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        },
        "read_sheet_url**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_url",
                    "type": "string",
                    "value": "",
                    "agent_field_type": "static",
                    "label": "Workbook URL",
                    "helper_text": "Enter the URL of your Google Spreadsheet",
                    "order": 3,
                },
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "agent_field_type": "static",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations/item/{inputs.integration.object_id}?field=read_sheet_url&parent_id={inputs.sheet_url}"
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [],
            "banner_text": 'Ensure that the Google Sheet\'s permissions is set to "Anyone with the Link"',
            "name": "read_sheet_url",
            "task_name": "tasks.google_sheets.read_sheet_url",
            "description": "Read specified columns from the provided sheet URL",
            "label": "Read from Sheet URL",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "sheet_url", "sheet_id"],
        },
        "read_sheet_url**(*)**(*)**[endpoint_1.<B>]": {
            "inputs": [],
            "outputs": [{"field": "[<B>.outputs]", "type": ""}],
        },
        "write_to_sheet**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "agent_field_type": "static",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                }
            ],
            "outputs": [],
            "name": "write_to_sheet",
            "task_name": "tasks.google_sheets.write_to_sheet",
            "description": "Add a new row in the selected sheet",
            "label": "Add New Row",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "sheet_id"],
        },
        "write_to_sheet**(*)**[endpoint_0.<A>]**(*)": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "write_list_to_column**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "agent_field_type": "static",
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                }
            ],
            "outputs": [],
            "name": "write_list_to_column",
            "task_name": "tasks.google_sheets.write_list_to_column",
            "description": "Fill specified columns with the input values (inputs can be list)",
            "label": "Column List Writer",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "sheet_id"],
        },
        "write_list_to_column**(*)**[endpoint_0.<A>]**(*)": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "update_rows**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Sheet",
                    "agent_field_type": "static",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "condition",
                    "type": "string",
                    "value": "",
                    "label": "Conditional Operator",
                    "placeholder": "",
                    "helper_text": "Conditional Operator",
                },
            ],
            "outputs": [],
            "name": "update_rows",
            "task_name": "tasks.google_sheets.update_rows",
            "description": "Update the rows matching the specified search values",
            "label": "Update Rows",
            "operation": "update",
            "variant": "google_sheet",
            "inputs_sort_order": ["integration", "action", "sheet_id", "condition"],
        },
        "update_rows**(*)**[endpoint_0.<A>]**(*)": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "extract_to_table**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "provider",
                    "type": "enum<string>",
                    "value": "openai",
                    "label": "Provider",
                    "placeholder": "OpenAI",
                    "helper_text": "The provider to use for the Google Sheets integration",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "OpenAI", "value": "openai"},
                            {"label": "Anthropic", "value": "anthropic"},
                            {"label": "Cohere", "value": "cohere"},
                            {"label": "Perplexity", "value": "perplexity"},
                            {"label": "Google", "value": "google"},
                            {"label": "Open Source", "value": "together"},
                            {"label": "AWS", "value": "bedrock"},
                            {"label": "Azure", "value": "azure"},
                            {"label": "xAI", "value": "xai"},
                            {"label": "Custom", "value": "custom"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "model",
                    "type": "enum<string>",
                    "value": "gpt-4o",
                    "label": "Model",
                    "placeholder": "GPT-4o",
                    "helper_text": "The model to use for the Google Sheets integration",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "llm_models",
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "text_for_extraction",
                    "type": "string",
                    "value": "",
                    "label": "Text for Extraction",
                    "placeholder": "Extract the table from the following text",
                    "helper_text": "The text to extract the table from",
                },
                {
                    "field": "extract_multiple_rows",
                    "type": "bool",
                    "value": True,
                    "label": "Extract Multiple Rows",
                    "helper_text": "If checked, it will extract multiple rows of data. If unchecked, it will extract a single row.",
                },
                {
                    "field": "add_columns_manually",
                    "type": "bool",
                    "value": False,
                    "label": "Add Columns Manually",
                    "helper_text": "Add data points for some columns manually instead of having them extracted by the AI model.",
                },
                {
                    "field": "additional_context",
                    "type": "string",
                    "value": "",
                    "label": "Additional Context",
                    "placeholder": "Additional context for the AI model to extract the table.",
                    "helper_text": "Additional context for the AI model to extract the table.",
                },
            ],
            "outputs": [
                {
                    "field": "table",
                    "type": "file",
                    "helper_text": "The table extracted from the text",
                }
            ],
            "name": "extract_to_table",
            "task_name": "tasks.google_sheets.extract_to_table",
            "description": "Extract data from text to a table with AI",
            "label": "Extract to Table",
            "variant": "google_sheet",
            "inputs_sort_order": [
                "integration",
                "action",
                "sheet_id",
                "text_for_extraction",
                "additional_context",
                "extract_multiple_rows",
                "add_columns_manually",
                "manual_columns",
                "provider",
                "model",
            ],
        },
        "extract_to_table**false**(*)**(*)": {"inputs": [], "outputs": []},
        "extract_to_table**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "manual_columns",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                    "label": "Manual Columns",
                    "placeholder": "Manual Columns",
                    "helper_text": "Pass in data to column names manually.",
                    "component": {"type": "table"},
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "add_columns_manually", "endpoint_0", "endpoint_1"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        add_columns_manually: bool = False,
        additional_context: str = "",
        condition: str = "",
        extract_multiple_rows: bool = True,
        manual_columns: List[Any] = [],
        model: str = "gpt-4o",
        provider: str = "openai",
        sheet_id: str = "",
        sheet_url: str = "",
        text_for_extraction: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["add_columns_manually"] = add_columns_manually

        super().__init__(
            node_type="integration_google_sheets",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if sheet_id is not None:
            self.inputs["sheet_id"] = sheet_id
        if sheet_url is not None:
            self.inputs["sheet_url"] = sheet_url
        if condition is not None:
            self.inputs["condition"] = condition
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if text_for_extraction is not None:
            self.inputs["text_for_extraction"] = text_for_extraction
        if extract_multiple_rows is not None:
            self.inputs["extract_multiple_rows"] = extract_multiple_rows
        if add_columns_manually is not None:
            self.inputs["add_columns_manually"] = add_columns_manually
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if manual_columns is not None:
            self.inputs["manual_columns"] = manual_columns
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def table(self) -> str:
        """
        The table extracted from the text

        Available: When action = 'extract_to_table'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("table")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleSheetsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_airtable")
class IntegrationAirtableNode(Node):
    """
    Airtable

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        base_id: Name of the Airtable base
        integration: The integration input
        table_id: Name of the table in the selected base
    ### When action = 'new_record' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'write_list_to_column' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'update_records' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'update_records'
        condition: Conditional Operator

    ## Outputs
    ### When action = 'read_table' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.outputs]: The [<A>.outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "base_id",
            "helper_text": "Name of the Airtable base",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Airtable>",
        },
        {
            "field": "table_id",
            "helper_text": "Name of the table in the selected base",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_nodes",
        },
        "read_table**(*)": {
            "inputs": [],
            "outputs": [],
            "name": "read_table",
            "task_name": "tasks.airtable.read_table",
            "description": "Read specified columns from the selected table",
            "label": "Read Table",
            "inputs_sort_order": ["integration", "action", "base_id", "table_id"],
        },
        "read_table**[endpoint_0.<A>]": {
            "inputs": [],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        },
        "new_record**(*)": {
            "inputs": [],
            "outputs": [],
            "name": "new_record",
            "task_name": "tasks.airtable.write_to_table",
            "description": "Add new record in an Airtable database",
            "label": "Add New Record",
            "inputs_sort_order": ["integration", "action", "base_id", "table_id"],
        },
        "new_record**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "write_list_to_column**(*)": {
            "inputs": [],
            "outputs": [],
            "name": "write_list_to_column",
            "task_name": "tasks.airtable.write_list_to_column",
            "description": "Fill specified columns empty cells with the input values (inputs can be list)",
            "label": "Column List Writer",
            "inputs_sort_order": ["integration", "action", "base_id", "table_id"],
        },
        "write_list_to_column**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "update_records**(*)": {
            "inputs": [
                {
                    "field": "condition",
                    "type": "string",
                    "value": "",
                    "label": "Conditional Operator",
                    "placeholder": "",
                    "helper_text": "Conditional Operator",
                }
            ],
            "outputs": [],
            "name": "update_records",
            "task_name": "tasks.airtable.update_records",
            "description": "Update the records matching the specified search values in a table",
            "label": "Update Records",
            "operation": "update",
            "inputs_sort_order": [
                "integration",
                "action",
                "base_id",
                "table_id",
                "condition",
            ],
        },
        "update_records**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "endpoint_0"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        base_id: str = "",
        condition: str = "",
        table_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_airtable",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if base_id is not None:
            self.inputs["base_id"] = base_id
        if table_id is not None:
            self.inputs["table_id"] = table_id
        if condition is not None:
            self.inputs["condition"] = condition
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationAirtableNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_notion")
class IntegrationNotionNode(Node):
    """
    Notion

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'write_to_database' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'create_new_page' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'create_new_block' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'update_database' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'update_database'
        condition: Conditional Operator
        item_id: Select the page to read
    ### When action = 'read_page'
        item_id: Select the page to read
    ### When action = 'write_to_database'
        item_id: Select the page to read
    ### When action = 'create_new_page'
        item_id: Select the page to read
    ### When action = 'create_new_block'
        item_id: Select the page to read
    ### When action = 'read_database'
        item_id: Select the page to read

    ## Outputs
    ### When action = 'read_page' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.outputs]: The [<A>.outputs] output
    ### When action = 'read_database' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.outputs]: The [<A>.outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Notion>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "read_page**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Page",
                    "placeholder": "Choose a page",
                    "helper_text": "Select the page to read",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=page&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [],
            "name": "read_page",
            "task_name": "tasks.notion.read_page",
            "description": "Read an existing Notion page",
            "label": "Read Notion page",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "item_id"],
        },
        "read_page**[endpoint_0.<A>]": {
            "inputs": [],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        },
        "write_to_database**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Database",
                    "placeholder": "Choose a database",
                    "helper_text": "Select Notion Database",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [],
            "name": "write_to_database",
            "task_name": "tasks.notion.write_to_database",
            "description": "Add a page to an existing Notion database",
            "label": "Write to Database",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "item_id"],
        },
        "write_to_database**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "create_new_page**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Page",
                    "placeholder": "Choose a Page",
                    "helper_text": "Select Notion Database",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=page&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [],
            "name": "create_new_page",
            "task_name": "tasks.notion.create_new_page",
            "description": "Create a new page on an existing Notion page",
            "label": "Create New Page",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "item_id"],
        },
        "create_new_page**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "create_new_block**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Page",
                    "placeholder": "Choose a Page",
                    "helper_text": "Select Notion Page",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=page&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [],
            "name": "create_new_block",
            "task_name": "tasks.notion.create_new_block",
            "description": "Write to an existing Notion page",
            "label": "Create New Block",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "item_id"],
        },
        "create_new_block**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "update_database**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Database",
                    "placeholder": "Choose a database",
                    "helper_text": "Select Notion Database",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "condition",
                    "type": "string",
                    "value": "",
                    "label": "Conditional Operator",
                    "placeholder": "",
                    "helper_text": "Conditional Operator",
                },
            ],
            "outputs": [],
            "name": "update_database",
            "task_name": "tasks.notion.update_database",
            "description": "Update a Notion database",
            "label": "Database Updater",
            "operation": "update",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "item_id", "condition"],
        },
        "update_database**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "read_database**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Database",
                    "placeholder": "Choose a database",
                    "helper_text": "Select Notion Database",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [],
            "name": "read_database",
            "task_name": "tasks.notion.read_database",
            "description": "Read pages from a Notion database",
            "label": "Database Reader",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "item_id"],
        },
        "read_database**[endpoint_0.<A>]": {
            "inputs": [],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "endpoint_0"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        condition: str = "",
        item_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_notion",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if condition is not None:
            self.inputs["condition"] = condition
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationNotionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_databricks")
class IntegrationDatabricksNode(Node):
    """
    Databricks

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'insert_row' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'create_cluster'
        autotermination_minutes: Auto-termination time in minutes ( Set to 0 to disable auto-termination )
        cluster_name: Name of the cluster
        enable_elastic_disk: Enable elastic disk for the cluster
        node_type_id: Node type for cluster instances
        num_workers: Number of worker nodes
        spark_version: Spark version for the cluster
    ### When action = 'insert_row'
        catalog_name: Select the name of the Catalog
        schema_name: Select the name of the Schema
        table_name: Select the name of Table to insert the row
        warehouse_id: Select the ID of the Warehouse to perform the action
    ### When action = 'execute_query'
        catalog_name: Select the name of the Catalog
        on_wait_timeout: Action to take when timeout is reached
        query: SQL query to execute against the Databricks SQL Warehouse
        schema_name: Select the name of the Schema
        wait_timeout: Timeout for waiting for query completion (e.g., 30s, 1m, 5m)
        warehouse_id: Select the ID of the Warehouse to perform the action
    ### When action = 'delete_cluster'
        cluster_id: ID of the cluster to delete
    ### When action = 'read_cluster'
        cluster_id: ID of the cluster to delete
    ### When action = 'create_job'
        cluster_id: ID of the cluster to delete
        job_name: Name of the job
        max_concurrent_runs: Maximum number of concurrent runs
        notebook_path: Path to the notebook
        timeout_seconds: Timeout in seconds
    ### When action = 'upload_file'
        file: File to upload
        overwrite: Overwrite existing file
        path: Path of the directory to create
    ### When action = 'get_clusters'
        num_messages: Maximum number of clusters to retrieve
    ### When action = 'get_groups'
        num_messages: Maximum number of clusters to retrieve
    ### When action = 'create_directory'
        path: Path of the directory to create
    ### When action = 'get_directory_contents'
        path: Path of the directory to create
    ### When action = 'delete_file'
        path: Path of the directory to create
    ### When action = 'delete_directory'
        path: Path of the directory to create
        recursive: Delete directory recursively

    ## Outputs
    ### When action = 'get_clusters'
        cluster_details: Complete cluster details in JSON format
        cluster_ids: List of cluster IDs
        cluster_names: List of cluster names
        cluster_states: List of cluster states
        creator_user_names: List of cluster creator usernames
        raw_data: Raw response data in JSON format
        spark_versions: List of spark versions
    ### When action = 'create_cluster'
        cluster_id: ID of the created cluster
        cluster_name: Name of the created cluster
        creator_user_name: Username of the cluster creator
        raw_data: Complete cluster details in JSON format
        spark_version: Spark version of the cluster
        state: Current state of the cluster
    ### When action = 'delete_cluster'
        cluster_id: ID of the deleted cluster
        message: Status message
        success: Whether the deletion was successful
    ### When action = 'read_cluster'
        cluster_id: ID of the cluster
        cluster_name: Name of the cluster
        creator_user_name: Username of the cluster creator
        node_type_id: Node type of the cluster
        num_workers: Number of workers in the cluster
        raw_data: Complete cluster details in JSON format
        spark_version: Spark version of the cluster
        start_time: Start time of the cluster
        state: Current state of the cluster
        terminated_time: Termination time of the cluster
    ### When action = 'execute_query'
        column_names: Names of the columns in the result set
        column_types: Data types of the columns in the result set
        data: Query results as array of rows
        manifest: Query manifest information in JSON format
        raw_response: Complete API response in JSON format
        result: Complete result data in JSON format
        row_count: Number of rows returned by the query
        statement_id: ID of the executed statement
        status: Status of the query execution
    ### When action = 'create_job'
        created_time: Creation time of the job
        creator_user_name: Username of the job creator
        job_id: ID of the created job
        job_name: Name of the created job
        raw_data: Complete job details in JSON format
    ### When action = 'get_directory_contents'
        file_details: Complete file details in JSON format
        file_names: List of file names
        file_paths: List of file paths
        file_sizes: List of file sizes
        file_types: List of file types (file/directory)
        modification_times: List of modification times
        raw_data: Raw response data in JSON format
    ### When action = 'upload_file'
        file_size: Size of the uploaded file
        message: Status message
        path: Path of the uploaded file
        success: Whether the upload was successful
    ### When action = 'get_groups'
        group_details: Complete group details in JSON format
        group_ids: List of group IDs
        group_names: List of group names
        member_counts: List of member counts for each group
        raw_data: Raw response data in JSON format
    ### When action = 'create_directory'
        message: Status message
        path: Path of the created directory
        success: Whether the creation was successful
    ### When action = 'delete_file'
        message: Status message
        path: Path of the deleted file
        success: Whether the deletion was successful
    ### When action = 'delete_directory'
        message: Status message
        path: Path of the deleted directory
        success: Whether the deletion was successful
    ### When action = 'insert_row'
        operation_status: Status of the insert operation
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Databricks>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "insert_row**(*)": {
            "inputs": [
                {
                    "field": "warehouse_id",
                    "type": "string",
                    "value": "",
                    "label": "Warehouse",
                    "agent_field_type": "static",
                    "placeholder": "Select Warehouse",
                    "helper_text": "Select the ID of the Warehouse to perform the action",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=warehouse_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "catalog_name",
                    "type": "string",
                    "value": "",
                    "label": "Catalog",
                    "agent_field_type": "static",
                    "placeholder": "Select Catalog",
                    "helper_text": "Select the name of the Catalog",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=catalog_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "schema_name",
                    "type": "string",
                    "value": "",
                    "label": "Schema",
                    "agent_field_type": "static",
                    "placeholder": "Select Schema",
                    "helper_text": "Select the name of the Schema",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=schema_name&catalog_name={inputs.catalog_name}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "table_name",
                    "type": "string",
                    "value": "",
                    "label": "Table",
                    "agent_field_type": "static",
                    "placeholder": "Select Table",
                    "helper_text": "Select the name of Table to insert the row",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=table_name&catalog_name={inputs.catalog_name}&schema_name={inputs.schema_name}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "operation_status",
                    "type": "string",
                    "helper_text": "Status of the insert operation",
                }
            ],
            "name": "insert_row",
            "task_name": "tasks.databricks.insert_row",
            "description": "Insert a new row into a Databricks Table",
            "label": "Insert A Row",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "warehouse_id",
                "catalog_name",
                "schema_name",
                "table_name",
            ],
            "required": ["warehouse_id", "catalog_name", "schema_name", "table_name"],
        },
        "insert_row**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "execute_query**(*)": {
            "inputs": [
                {
                    "field": "warehouse_id",
                    "type": "string",
                    "value": "",
                    "label": "Warehouse",
                    "agent_field_type": "static",
                    "placeholder": "Select Warehouse",
                    "helper_text": "Select the ID of the Warehouse to execute the query",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=warehouse_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "catalog_name",
                    "type": "string",
                    "value": "",
                    "label": "Catalog",
                    "agent_field_type": "static",
                    "placeholder": "Select Catalog",
                    "helper_text": "Optional: Select the catalog name",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=catalog_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "schema_name",
                    "type": "string",
                    "value": "",
                    "label": "Schema",
                    "agent_field_type": "static",
                    "placeholder": "Select Schema",
                    "helper_text": "Optional: Select the schema name",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=schema_name&catalog_name={inputs.catalog_name}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "SELECT * FROM my_table LIMIT 10",
                    "helper_text": "SQL query to execute against the Databricks SQL Warehouse",
                },
                {
                    "field": "wait_timeout",
                    "type": "string",
                    "value": "50s",
                    "label": "Wait Timeout",
                    "placeholder": "50s",
                    "helper_text": "Timeout for waiting for query completion (e.g., 30s, 1m, 5m)",
                },
                {
                    "field": "on_wait_timeout",
                    "type": "enum<string>",
                    "value": "CONTINUE",
                    "label": "On Wait Timeout",
                    "helper_text": "Action to take when timeout is reached",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Continue", "value": "CONTINUE"},
                            {"label": "Cancel", "value": "CANCEL"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "statement_id",
                    "type": "string",
                    "helper_text": "ID of the executed statement",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Status of the query execution",
                },
                {
                    "field": "column_names",
                    "type": "vec<string>",
                    "helper_text": "Names of the columns in the result set",
                },
                {
                    "field": "column_types",
                    "type": "vec<string>",
                    "helper_text": "Data types of the columns in the result set",
                },
                {
                    "field": "data",
                    "type": "vec<vec<any>>",
                    "helper_text": "Query results as array of rows",
                },
                {
                    "field": "row_count",
                    "type": "int32",
                    "helper_text": "Number of rows returned by the query",
                },
                {
                    "field": "result",
                    "type": "string",
                    "helper_text": "Complete result data in JSON format",
                },
                {
                    "field": "manifest",
                    "type": "string",
                    "helper_text": "Query manifest information in JSON format",
                },
                {
                    "field": "raw_response",
                    "type": "string",
                    "helper_text": "Complete API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "execute_query",
            "task_name": "tasks.databricks.execute_query",
            "description": "Execute SQL queries against Databricks SQL Warehouses",
            "label": "Execute SQL Query",
            "inputs_sort_order": [
                "integration",
                "action",
                "warehouse_id",
                "query",
                "catalog_name_optional",
                "schema_name_optional",
                "wait_timeout",
                "on_wait_timeout",
            ],
        },
        "create_cluster**(*)": {
            "inputs": [
                {
                    "field": "cluster_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the cluster",
                    "label": "Cluster Name",
                    "placeholder": "my-cluster",
                },
                {
                    "field": "spark_version",
                    "type": "string",
                    "value": "",
                    "helper_text": "Spark version for the cluster",
                    "label": "Spark Version",
                    "placeholder": "13.3.x-scala2.12",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=spark_version&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "node_type_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Node type for cluster instances",
                    "label": "Node Type",
                    "placeholder": "i3.xlarge",
                },
                {
                    "field": "num_workers",
                    "type": "int32",
                    "value": 2,
                    "helper_text": "Number of worker nodes",
                    "label": "Number of Workers",
                    "placeholder": "2",
                },
                {
                    "field": "autotermination_minutes",
                    "type": "int32",
                    "value": 120,
                    "helper_text": "Auto-termination time in minutes ( Set to 0 to disable auto-termination )",
                    "label": "Auto-termination (minutes)",
                    "placeholder": "120",
                },
                {
                    "field": "enable_elastic_disk",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Enable elastic disk for the cluster",
                    "label": "Enable Elastic Disk",
                },
            ],
            "outputs": [
                {
                    "field": "cluster_id",
                    "type": "string",
                    "helper_text": "ID of the created cluster",
                },
                {
                    "field": "cluster_name",
                    "type": "string",
                    "helper_text": "Name of the created cluster",
                },
                {
                    "field": "state",
                    "type": "string",
                    "helper_text": "Current state of the cluster",
                },
                {
                    "field": "spark_version",
                    "type": "string",
                    "helper_text": "Spark version of the cluster",
                },
                {
                    "field": "creator_user_name",
                    "type": "string",
                    "helper_text": "Username of the cluster creator",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete cluster details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_cluster",
            "task_name": "tasks.databricks.create_cluster",
            "description": "Create a new Databricks cluster",
            "label": "Create Cluster",
            "inputs_sort_order": [
                "integration",
                "action",
                "cluster_name",
                "spark_version",
                "node_type_id",
                "num_workers",
                "autotermination_minutes",
                "enable_elastic_disk",
            ],
        },
        "delete_cluster**(*)": {
            "inputs": [
                {
                    "field": "cluster_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the cluster to delete",
                    "label": "Cluster ID",
                    "placeholder": "cluster-123",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=cluster_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
                {
                    "field": "cluster_id",
                    "type": "string",
                    "helper_text": "ID of the deleted cluster",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "delete_cluster",
            "task_name": "tasks.databricks.delete_cluster",
            "description": "Delete a Databricks cluster",
            "label": "Delete Cluster",
            "inputs_sort_order": ["integration", "action", "cluster_id"],
        },
        "get_clusters**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of clusters to retrieve",
                    "label": "Limit",
                    "placeholder": "10",
                }
            ],
            "outputs": [
                {
                    "field": "cluster_ids",
                    "type": "vec<string>",
                    "helper_text": "List of cluster IDs",
                },
                {
                    "field": "cluster_names",
                    "type": "vec<string>",
                    "helper_text": "List of cluster names",
                },
                {
                    "field": "cluster_states",
                    "type": "vec<string>",
                    "helper_text": "List of cluster states",
                },
                {
                    "field": "spark_versions",
                    "type": "vec<string>",
                    "helper_text": "List of spark versions",
                },
                {
                    "field": "creator_user_names",
                    "type": "vec<string>",
                    "helper_text": "List of cluster creator usernames",
                },
                {
                    "field": "cluster_details",
                    "type": "string",
                    "helper_text": "Complete cluster details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data in JSON format",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_clusters",
            "task_name": "tasks.databricks.get_clusters",
            "description": "Get a list of Databricks clusters",
            "label": "Get Clusters",
            "inputs_sort_order": ["integration", "action", "num_messages"],
        },
        "read_cluster**(*)": {
            "inputs": [
                {
                    "field": "cluster_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the cluster to read",
                    "label": "Cluster ID",
                    "placeholder": "cluster-123",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=cluster_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "cluster_id",
                    "type": "string",
                    "helper_text": "ID of the cluster",
                },
                {
                    "field": "cluster_name",
                    "type": "string",
                    "helper_text": "Name of the cluster",
                },
                {
                    "field": "state",
                    "type": "string",
                    "helper_text": "Current state of the cluster",
                },
                {
                    "field": "spark_version",
                    "type": "string",
                    "helper_text": "Spark version of the cluster",
                },
                {
                    "field": "node_type_id",
                    "type": "string",
                    "helper_text": "Node type of the cluster",
                },
                {
                    "field": "num_workers",
                    "type": "int32",
                    "helper_text": "Number of workers in the cluster",
                },
                {
                    "field": "creator_user_name",
                    "type": "string",
                    "helper_text": "Username of the cluster creator",
                },
                {
                    "field": "start_time",
                    "type": "string",
                    "helper_text": "Start time of the cluster",
                },
                {
                    "field": "terminated_time",
                    "type": "string",
                    "helper_text": "Termination time of the cluster",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete cluster details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_cluster",
            "task_name": "tasks.databricks.read_cluster",
            "description": "Read details of a specific Databricks cluster",
            "label": "Read Cluster",
            "inputs_sort_order": ["integration", "action", "cluster_id"],
        },
        "create_job**(*)": {
            "inputs": [
                {
                    "field": "job_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the job",
                    "label": "Job Name",
                    "placeholder": "my-job",
                },
                {
                    "field": "notebook_path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path to the notebook",
                    "label": "Notebook Path",
                    "placeholder": "/Users/user@company.com/my-notebook",
                },
                {
                    "field": "cluster_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the cluster to run the job on",
                    "label": "Cluster ID",
                    "placeholder": "cluster-123",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=cluster_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "max_concurrent_runs",
                    "type": "int32",
                    "value": 1,
                    "helper_text": "Maximum number of concurrent runs",
                    "label": "Max Concurrent Runs",
                    "placeholder": "1",
                },
                {
                    "field": "timeout_seconds",
                    "type": "int32",
                    "value": 3600,
                    "helper_text": "Timeout in seconds",
                    "label": "Timeout (seconds)",
                    "placeholder": "3600",
                },
            ],
            "outputs": [
                {
                    "field": "job_id",
                    "type": "string",
                    "helper_text": "ID of the created job",
                },
                {
                    "field": "job_name",
                    "type": "string",
                    "helper_text": "Name of the created job",
                },
                {
                    "field": "creator_user_name",
                    "type": "string",
                    "helper_text": "Username of the job creator",
                },
                {
                    "field": "created_time",
                    "type": "string",
                    "helper_text": "Creation time of the job",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete job details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_job",
            "task_name": "tasks.databricks.create_job",
            "description": "Create a new Databricks job",
            "label": "Create Job",
            "inputs_sort_order": [
                "integration",
                "action",
                "job_name",
                "notebook_path",
                "cluster_id",
                "max_concurrent_runs",
                "timeout_seconds",
            ],
        },
        "create_directory**(*)": {
            "inputs": [
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the directory to create",
                    "label": "Directory Path",
                    "placeholder": "/my-directory",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the creation was successful",
                },
                {
                    "field": "path",
                    "type": "string",
                    "helper_text": "Path of the created directory",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "variant": "default_integration_nodes",
            "name": "create_directory",
            "task_name": "tasks.databricks.create_directory",
            "description": "Create a new directory in Databricks",
            "label": "Create Directory",
            "inputs_sort_order": ["integration", "action", "path"],
        },
        "upload_file**(*)": {
            "inputs": [
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path where the file should be uploaded",
                    "label": "File Path",
                    "placeholder": "/my-file.txt",
                },
                {
                    "field": "file",
                    "type": "file",
                    "value": "",
                    "helper_text": "File to upload",
                    "label": "File",
                },
                {
                    "field": "overwrite",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Overwrite existing file",
                    "label": "Overwrite",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the upload was successful",
                },
                {
                    "field": "path",
                    "type": "string",
                    "helper_text": "Path of the uploaded file",
                },
                {
                    "field": "file_size",
                    "type": "string",
                    "helper_text": "Size of the uploaded file",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "variant": "common_integration_nodes",
            "name": "upload_file",
            "task_name": "tasks.databricks.upload_file",
            "description": "Upload a file to Databricks",
            "label": "Upload File",
            "inputs_sort_order": ["integration", "action", "path", "file", "overwrite"],
        },
        "get_directory_contents**(*)": {
            "inputs": [
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the directory to list",
                    "label": "Directory Path",
                    "placeholder": "/my-directory",
                }
            ],
            "outputs": [
                {
                    "field": "file_names",
                    "type": "vec<string>",
                    "helper_text": "List of file names",
                },
                {
                    "field": "file_paths",
                    "type": "vec<string>",
                    "helper_text": "List of file paths",
                },
                {
                    "field": "file_sizes",
                    "type": "vec<string>",
                    "helper_text": "List of file sizes",
                },
                {
                    "field": "file_types",
                    "type": "vec<string>",
                    "helper_text": "List of file types (file/directory)",
                },
                {
                    "field": "modification_times",
                    "type": "vec<string>",
                    "helper_text": "List of modification times",
                },
                {
                    "field": "file_details",
                    "type": "string",
                    "helper_text": "Complete file details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data in JSON format",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_directory_contents",
            "task_name": "tasks.databricks.get_directory_contents",
            "description": "Get contents of a directory in Databricks",
            "label": "Get Directory Contents",
            "inputs_sort_order": ["integration", "action", "path"],
        },
        "delete_file**(*)": {
            "inputs": [
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the file to delete",
                    "label": "File Path",
                    "placeholder": "/my-file.txt",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "path",
                    "type": "string",
                    "helper_text": "Path of the deleted file",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "variant": "default_integration_nodes",
            "name": "delete_file",
            "task_name": "tasks.databricks.delete_file",
            "description": "Delete a file from Databricks",
            "label": "Delete File",
            "inputs_sort_order": ["integration", "action", "path"],
        },
        "delete_directory**(*)": {
            "inputs": [
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the directory to delete",
                    "label": "Directory Path",
                    "placeholder": "/my-directory",
                },
                {
                    "field": "recursive",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Delete directory recursively",
                    "label": "Recursive",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "path",
                    "type": "string",
                    "helper_text": "Path of the deleted directory",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "variant": "default_integration_nodes",
            "name": "delete_directory",
            "task_name": "tasks.databricks.delete_directory",
            "description": "Delete a directory from Databricks",
            "label": "Delete Directory",
            "inputs_sort_order": ["integration", "action", "path", "recursive"],
        },
        "get_groups**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of groups to retrieve",
                    "label": "Limit",
                    "placeholder": "10",
                }
            ],
            "outputs": [
                {
                    "field": "group_ids",
                    "type": "vec<string>",
                    "helper_text": "List of group IDs",
                },
                {
                    "field": "group_names",
                    "type": "vec<string>",
                    "helper_text": "List of group names",
                },
                {
                    "field": "member_counts",
                    "type": "vec<string>",
                    "helper_text": "List of member counts for each group",
                },
                {
                    "field": "group_details",
                    "type": "string",
                    "helper_text": "Complete group details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data in JSON format",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_groups",
            "task_name": "tasks.databricks.get_groups",
            "description": "Get a list of Databricks groups",
            "label": "Get Groups",
            "inputs_sort_order": ["integration", "action", "num_messages"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "endpoint_0"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        autotermination_minutes: int = 120,
        catalog_name: str = "",
        cluster_id: str = "",
        cluster_name: str = "",
        enable_elastic_disk: bool = True,
        file: str = "",
        job_name: str = "",
        max_concurrent_runs: int = 1,
        node_type_id: str = "",
        notebook_path: str = "",
        num_messages: int = 10,
        num_workers: int = 2,
        on_wait_timeout: str = "CONTINUE",
        overwrite: bool = False,
        path: str = "",
        query: str = "",
        recursive: bool = False,
        schema_name: str = "",
        spark_version: str = "",
        table_name: str = "",
        timeout_seconds: int = 3600,
        wait_timeout: str = "50s",
        warehouse_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_databricks",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if warehouse_id is not None:
            self.inputs["warehouse_id"] = warehouse_id
        if catalog_name is not None:
            self.inputs["catalog_name"] = catalog_name
        if schema_name is not None:
            self.inputs["schema_name"] = schema_name
        if table_name is not None:
            self.inputs["table_name"] = table_name
        if query is not None:
            self.inputs["query"] = query
        if wait_timeout is not None:
            self.inputs["wait_timeout"] = wait_timeout
        if on_wait_timeout is not None:
            self.inputs["on_wait_timeout"] = on_wait_timeout
        if cluster_name is not None:
            self.inputs["cluster_name"] = cluster_name
        if spark_version is not None:
            self.inputs["spark_version"] = spark_version
        if node_type_id is not None:
            self.inputs["node_type_id"] = node_type_id
        if num_workers is not None:
            self.inputs["num_workers"] = num_workers
        if autotermination_minutes is not None:
            self.inputs["autotermination_minutes"] = autotermination_minutes
        if enable_elastic_disk is not None:
            self.inputs["enable_elastic_disk"] = enable_elastic_disk
        if cluster_id is not None:
            self.inputs["cluster_id"] = cluster_id
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if job_name is not None:
            self.inputs["job_name"] = job_name
        if notebook_path is not None:
            self.inputs["notebook_path"] = notebook_path
        if max_concurrent_runs is not None:
            self.inputs["max_concurrent_runs"] = max_concurrent_runs
        if timeout_seconds is not None:
            self.inputs["timeout_seconds"] = timeout_seconds
        if path is not None:
            self.inputs["path"] = path
        if file is not None:
            self.inputs["file"] = file
        if overwrite is not None:
            self.inputs["overwrite"] = overwrite
        if recursive is not None:
            self.inputs["recursive"] = recursive
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def cluster_details(self) -> str:
        """
        Complete cluster details in JSON format

        Available: When action = 'get_clusters'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("cluster_details")

    @property
    def cluster_id(self) -> str:
        """
        ID of the created cluster

        Different behavior based on configuration:
          - ID of the created cluster (When action = 'create_cluster')
          - ID of the deleted cluster (When action = 'delete_cluster')
          - ID of the cluster (When action = 'read_cluster')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("cluster_id")

    @property
    def cluster_ids(self) -> List[str]:
        """
        List of cluster IDs

        Available: When action = 'get_clusters'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("cluster_ids")

    @property
    def cluster_name(self) -> str:
        """
        Name of the created cluster

        Different behavior based on configuration:
          - Name of the created cluster (When action = 'create_cluster')
          - Name of the cluster (When action = 'read_cluster')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("cluster_name")

    @property
    def cluster_names(self) -> List[str]:
        """
        List of cluster names

        Available: When action = 'get_clusters'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("cluster_names")

    @property
    def cluster_states(self) -> List[str]:
        """
        List of cluster states

        Available: When action = 'get_clusters'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("cluster_states")

    @property
    def column_names(self) -> List[str]:
        """
        Names of the columns in the result set

        Available: When action = 'execute_query'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("column_names")

    @property
    def column_types(self) -> List[str]:
        """
        Data types of the columns in the result set

        Available: When action = 'execute_query'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("column_types")

    @property
    def created_time(self) -> str:
        """
        Creation time of the job

        Available: When action = 'create_job'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_time")

    @property
    def creator_user_name(self) -> str:
        """
        Username of the cluster creator

        Different behavior based on configuration:
          - Username of the cluster creator (When action = 'create_cluster', When action = 'read_cluster')
          - Username of the job creator (When action = 'create_job')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("creator_user_name")

    @property
    def creator_user_names(self) -> List[str]:
        """
        List of cluster creator usernames

        Available: When action = 'get_clusters'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("creator_user_names")

    @property
    def data(self) -> List[List[Any]]:
        """
        Query results as array of rows

        Available: When action = 'execute_query'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("data")

    @property
    def file_details(self) -> str:
        """
        Complete file details in JSON format

        Available: When action = 'get_directory_contents'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_details")

    @property
    def file_names(self) -> List[str]:
        """
        List of file names

        Available: When action = 'get_directory_contents'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_names")

    @property
    def file_paths(self) -> List[str]:
        """
        List of file paths

        Available: When action = 'get_directory_contents'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_paths")

    @property
    def file_size(self) -> str:
        """
        Size of the uploaded file

        Available: When action = 'upload_file'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_size")

    @property
    def file_sizes(self) -> List[str]:
        """
        List of file sizes

        Available: When action = 'get_directory_contents'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_sizes")

    @property
    def file_types(self) -> List[str]:
        """
        List of file types (file/directory)

        Available: When action = 'get_directory_contents'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_types")

    @property
    def group_details(self) -> str:
        """
        Complete group details in JSON format

        Available: When action = 'get_groups'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("group_details")

    @property
    def group_ids(self) -> List[str]:
        """
        List of group IDs

        Available: When action = 'get_groups'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("group_ids")

    @property
    def group_names(self) -> List[str]:
        """
        List of group names

        Available: When action = 'get_groups'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("group_names")

    @property
    def job_id(self) -> str:
        """
        ID of the created job

        Available: When action = 'create_job'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("job_id")

    @property
    def job_name(self) -> str:
        """
        Name of the created job

        Available: When action = 'create_job'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("job_name")

    @property
    def manifest(self) -> str:
        """
        Query manifest information in JSON format

        Available: When action = 'execute_query'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("manifest")

    @property
    def member_counts(self) -> List[str]:
        """
        List of member counts for each group

        Available: When action = 'get_groups'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("member_counts")

    @property
    def message(self) -> str:
        """
        Status message

        Available: When action = 'delete_cluster', When action = 'create_directory', When action = 'upload_file', When action = 'delete_file', When action = 'delete_directory'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("message")

    @property
    def modification_times(self) -> List[str]:
        """
        List of modification times

        Available: When action = 'get_directory_contents'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("modification_times")

    @property
    def node_type_id(self) -> str:
        """
        Node type of the cluster

        Available: When action = 'read_cluster'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("node_type_id")

    @property
    def num_workers(self) -> int:
        """
        Number of workers in the cluster

        Available: When action = 'read_cluster'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("num_workers")

    @property
    def operation_status(self) -> str:
        """
        Status of the insert operation

        Available: When action = 'insert_row'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("operation_status")

    @property
    def path(self) -> str:
        """
        Path of the created directory

        Different behavior based on configuration:
          - Path of the created directory (When action = 'create_directory')
          - Path of the uploaded file (When action = 'upload_file')
          - Path of the deleted file (When action = 'delete_file')
          - Path of the deleted directory (When action = 'delete_directory')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("path")

    @property
    def raw_data(self) -> str:
        """
        Complete cluster details in JSON format

        Different behavior based on configuration:
          - Complete cluster details in JSON format (When action = 'create_cluster', When action = 'read_cluster')
          - Raw response data in JSON format (When action = 'get_clusters', When action = 'get_directory_contents', When action = 'get_groups')
          - Complete job details in JSON format (When action = 'create_job')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("raw_data")

    @property
    def raw_response(self) -> str:
        """
        Complete API response in JSON format

        Available: When action = 'execute_query'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("raw_response")

    @property
    def result(self) -> str:
        """
        Complete result data in JSON format

        Available: When action = 'execute_query'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("result")

    @property
    def row_count(self) -> int:
        """
        Number of rows returned by the query

        Available: When action = 'execute_query'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("row_count")

    @property
    def spark_version(self) -> str:
        """
        Spark version of the cluster

        Available: When action = 'create_cluster', When action = 'read_cluster'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("spark_version")

    @property
    def spark_versions(self) -> List[str]:
        """
        List of spark versions

        Available: When action = 'get_clusters'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("spark_versions")

    @property
    def start_time(self) -> str:
        """
        Start time of the cluster

        Available: When action = 'read_cluster'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("start_time")

    @property
    def state(self) -> str:
        """
        Current state of the cluster

        Available: When action = 'create_cluster', When action = 'read_cluster'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("state")

    @property
    def statement_id(self) -> str:
        """
        ID of the executed statement

        Available: When action = 'execute_query'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("statement_id")

    @property
    def status(self) -> str:
        """
        Status of the query execution

        Available: When action = 'execute_query'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("status")

    @property
    def success(self) -> bool:
        """
        Whether the deletion was successful

        Different behavior based on configuration:
          - Whether the deletion was successful (When action = 'delete_cluster', When action = 'delete_file', When action = 'delete_directory')
          - Whether the creation was successful (When action = 'create_directory')
          - Whether the upload was successful (When action = 'upload_file')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("success")

    @property
    def terminated_time(self) -> str:
        """
        Termination time of the cluster

        Available: When action = 'read_cluster'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("terminated_time")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationDatabricksNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_weaviate")
class IntegrationWeaviateNode(Node):
    """
    Weaviate

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### query_weaviate
        collection: Select the Weaviate collection to query
        embedding_model: Select the embedding model to use to embed the query
        properties: Comma-separated list of keywords to use
        query: Natural Language Query

    ## Outputs
    ### Common Outputs
        output: Output of the Query. Example: “Salmon…”
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Weaviate>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "Output of the Query. Example: “Salmon…”"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "query_weaviate": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "“Fish species in the South Pacific Ocean”",
                    "helper_text": "Natural Language Query",
                },
                {
                    "field": "embedding_model",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Embedding Model",
                    "placeholder": "Select Embedding Model",
                    "helper_text": "Select the embedding model to use to embed the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {
                                "label": "OpenAI Text Embedding 3 Small",
                                "value": "openai/text-embedding-3-small",
                            },
                            {
                                "label": "OpenAI Text Embedding 3 Large",
                                "value": "openai/text-embedding-3-large",
                            },
                            {
                                "label": "OpenAI Text Embedding Ada 002",
                                "value": "openai/text-embedding-ada-002",
                            },
                            {
                                "label": "Cohere Embed English v3.0",
                                "value": "cohere/embed-english-v3.0",
                            },
                            {
                                "label": "Cohere Embed Multilingual v3.0",
                                "value": "cohere/embed-multilingual-v3.0",
                            },
                            {
                                "label": "Cohere Embed English Light v3.0",
                                "value": "cohere/embed-english-light-v3.0",
                            },
                            {
                                "label": "Cohere Embed Multilingual Light v3.0",
                                "value": "cohere/embed-multilingual-light-v3.0",
                            },
                        ],
                    },
                },
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "placeholder": "Collection",
                    "helper_text": "Select the Weaviate collection to query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "placeholder": "Properties",
                    "helper_text": "Comma-separated list of keywords to use",
                },
            ],
            "outputs": [],
            "name": "query_weaviate",
            "task_name": "tasks.vectordbs.integrations.weaviate.query",
            "description": "Query Weaviate data",
            "label": "Query Weaviate",
            "variant": "common_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        collection: str = "",
        embedding_model: str = "",
        properties: str = "",
        query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_weaviate",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if embedding_model is not None:
            self.inputs["embedding_model"] = embedding_model
        if collection is not None:
            self.inputs["collection"] = collection
        if properties is not None:
            self.inputs["properties"] = properties
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Output of the Query. Example: “Salmon…”


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationWeaviateNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_bland_ai")
class IntegrationBlandAiNode(Node):
    """
    Bland AI

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### call_a_number
        first_sentence: The first sentence the AI should speak during the call
        model: LLM model that the AI should use
        pathway_id: This is the pathway ID for the pathway you have created on your dev portal.
        phone_number: The phone number of the contact you want to call
        task: The objective you want the AI to accomplish during the call
        temperature: A value between 0 and 1 that controls the randomness of the LLM. 0 will cause more deterministic outputs while 1 will cause more random
        transfer_number: A phone number that the agent can transfer to under specific conditions - such as being asked to speak to a human or supervisor
        wait_for_greeting: When checked, the agent will wait for the call recipient to speak first before responding

    ## Outputs
    ### Common Outputs
        answered_by: Possible values: Human: The call was answered by a human, Voicemail: The call was sent to voicemail, Unknown: There was not enough audio at the start of the call to make a determination, No-answer: The call was not answered, Null: Not enabled, or still processing the result
        transcript: The transcript of the call
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Bland AI>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "answered_by",
            "helper_text": "Possible values: Human: The call was answered by a human, Voicemail: The call was sent to voicemail, Unknown: There was not enough audio at the start of the call to make a determination, No-answer: The call was not answered, Null: Not enabled, or still processing the result",
        },
        {"field": "transcript", "helper_text": "The transcript of the call"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "call_a_number": {
            "inputs": [
                {
                    "field": "phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Phone Number",
                    "placeholder": "+1 6173149183",
                    "helper_text": "The phone number of the contact you want to call",
                },
                {
                    "field": "task",
                    "type": "string",
                    "value": "",
                    "label": "Task",
                    "placeholder": "Get the user's name and email",
                    "helper_text": "The objective you want the AI to accomplish during the call",
                },
                {
                    "field": "first_sentence",
                    "type": "string",
                    "value": "",
                    "label": "Enter First Sentence (Optional)",
                    "placeholder": "Hello, this is...",
                    "helper_text": "The first sentence the AI should speak during the call",
                },
                {
                    "field": "model",
                    "type": "enum<string>",
                    "value": "enhanced",
                    "label": "Select Model",
                    "placeholder": "enhanced",
                    "helper_text": "LLM model that the AI should use",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "pathway_id",
                    "type": "string",
                    "value": "",
                    "label": "Enter Pathway ID (Optional)",
                    "placeholder": "pathway_123",
                    "helper_text": "This is the pathway ID for the pathway you have created on your dev portal.",
                },
                {
                    "field": "temperature",
                    "type": "string",
                    "value": "",
                    "label": "Enter Temperature",
                    "placeholder": "0.7",
                    "helper_text": "A value between 0 and 1 that controls the randomness of the LLM. 0 will cause more deterministic outputs while 1 will cause more random",
                },
                {
                    "field": "transfer_number",
                    "type": "string",
                    "value": "",
                    "label": "Enter Transfer Number (Optional)",
                    "placeholder": "+12223334444",
                    "helper_text": "A phone number that the agent can transfer to under specific conditions - such as being asked to speak to a human or supervisor",
                },
                {
                    "field": "wait_for_greeting",
                    "type": "bool",
                    "value": False,
                    "label": "Select Wait for Greeting",
                    "placeholder": "false",
                    "helper_text": "When checked, the agent will wait for the call recipient to speak first before responding",
                },
            ],
            "outputs": [],
            "name": "call_a_number",
            "task_name": "tasks.bland_ai.call_a_number",
            "description": "Call a number using AI phone caller",
            "label": "Call a number",
            "variant": "bland_ai",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        first_sentence: str = "",
        model: str = "enhanced",
        pathway_id: str = "",
        phone_number: str = "",
        task: str = "",
        temperature: str = "",
        transfer_number: str = "",
        wait_for_greeting: bool = False,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_bland_ai",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if phone_number is not None:
            self.inputs["phone_number"] = phone_number
        if task is not None:
            self.inputs["task"] = task
        if first_sentence is not None:
            self.inputs["first_sentence"] = first_sentence
        if model is not None:
            self.inputs["model"] = model
        if pathway_id is not None:
            self.inputs["pathway_id"] = pathway_id
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if transfer_number is not None:
            self.inputs["transfer_number"] = transfer_number
        if wait_for_greeting is not None:
            self.inputs["wait_for_greeting"] = wait_for_greeting
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def answered_by(self) -> str:
        """
        Possible values: Human: The call was answered by a human, Voicemail: The call was sent to voicemail, Unknown: There was not enough audio at the start of the call to make a determination, No-answer: The call was not answered, Null: Not enabled, or still processing the result


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("answered_by")

    @property
    def transcript(self) -> str:
        """
        The transcript of the call


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("transcript")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationBlandAiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_algolia")
class IntegrationAlgoliaNode(Node):
    """
    Algolia

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### search_index
        index: An index where the data used by Algolia is stored
        query: Keyword to be searched in the index
        return_mode: Choose between returning as chunks or JSON

    ## Outputs
    ### Common Outputs
        output: Search results from the Algolia index in the specified format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Algolia>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "output",
            "helper_text": "Search results from the Algolia index in the specified format",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "search_index": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "“iPhone 16”",
                    "helper_text": "Keyword to be searched in the index",
                },
                {
                    "field": "index",
                    "type": "string",
                    "value": "",
                    "label": "Index",
                    "placeholder": "database",
                    "helper_text": "An index where the data used by Algolia is stored",
                },
                {
                    "field": "return_mode",
                    "type": "enum<string>",
                    "value": "json",
                    "label": "Return Mode",
                    "agent_field_type": "static",
                    "placeholder": "Choose between returning as chunks or JSON",
                    "helper_text": "Choose between returning as chunks or JSON",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "JSON", "value": "json"},
                            {"label": "Chunks", "value": "chunks"},
                        ],
                    },
                },
            ],
            "outputs": [],
            "name": "search_index",
            "task_name": "tasks.algolia.search_index",
            "description": "Query your Algolia index",
            "label": "Search Algolia index",
            "variant": "common_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        index: str = "",
        query: str = "",
        return_mode: str = "json",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_algolia",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if index is not None:
            self.inputs["index"] = index
        if return_mode is not None:
            self.inputs["return_mode"] = return_mode
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> Any:
        """
        Search results from the Algolia index in the specified format


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationAlgoliaNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_apollo")
class IntegrationApolloNode(Node):
    """
    Apollo

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### fetch_companies
        company_name: Name of the company to search
        keywords: Comma separated list of keywords the company should be associated with
        location: Location of the company headquarters
        max_size: Maximum number of employees in the company
        min_size: Minimum number of employees in the company
        num_results: Limit number of results
    ### enrich_contact
        company_name: Name of the company to search
        domain: Company domain
        first_name_input: Contact's first name
        last_name_input: Contact's last name
        linkedin_url_input: Contact's LinkedIn URL
    ### enrich_company
        domain: Company domain

    ## Outputs
    ### enrich_company
        annual_revenue: The company’s annual revenue e.g., 766400000000.0
        company_name: The company name e.g., Google
        country: The company’s headquartered country e.g., United States
        industry: The company’s industry e.g., information technology & services
        linkedin_url: The company’s Linkedin URL e.g., http://www.linkedin.com/company/google
        num_employees: The total number of employees e.g., 289000
        total_funding: The company’s total funding e.g., 3000000000000.0
        website: The company’s website e.g., http://www.google.com
    ### fetch_companies
        company_names: A list of company names e.g., ["VectorShift","VectorShift Studios"]
        domains: A list of domains e.g., ["vectorshift.ai","vectorshiftstudios.com"]
        linkedin_urls: A list of Linkedin URLs e.g., ["http://www.linkedin.com/company/vectorshift","http://www.linkedin.com/company/vectorshift-studios"]
        websites: A list of websites e.g., ["http://www.vectorshift.ai","http://www.vectorshiftstudios.com"]
    ### enrich_contact
        email: The person’s email address e.g., sundar@google.com
        first_name: The first name e.g., Sundar
        job_title: The person’s title e.g., CEO
        last_name: The last name e.g., Pichai
        linkedin_url: The person’s Linkedin e.g., https://www.linkedin.com/in/sundarpichai
        phone_number: The person’s phone number+10000000000
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Apollo>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "fetch_companies": {
            "inputs": [
                {
                    "field": "company_name",
                    "type": "string",
                    "value": "",
                    "label": "Company Name",
                    "placeholder": "VectorShift",
                    "helper_text": "Name of the company to search",
                },
                {
                    "field": "keywords",
                    "type": "string",
                    "value": "",
                    "label": "Keywords",
                    "placeholder": "AI, automation",
                    "helper_text": "Comma separated list of keywords the company should be associated with",
                },
                {
                    "field": "min_size",
                    "type": "string",
                    "value": "",
                    "label": "Min Size",
                    "placeholder": "10",
                    "helper_text": "Minimum number of employees in the company",
                },
                {
                    "field": "max_size",
                    "type": "string",
                    "value": "",
                    "label": "Max Size",
                    "placeholder": "100",
                    "helper_text": "Maximum number of employees in the company",
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "placeholder": "California, US",
                    "helper_text": "Location of the company headquarters",
                },
                {
                    "field": "num_results",
                    "type": "string",
                    "value": "",
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Limit number of results",
                },
            ],
            "outputs": [
                {
                    "field": "company_names",
                    "type": "string",
                    "helper_text": 'A list of company names e.g., ["VectorShift","VectorShift Studios"]',
                },
                {
                    "field": "websites",
                    "type": "string",
                    "helper_text": 'A list of websites e.g., ["http://www.vectorshift.ai","http://www.vectorshiftstudios.com"]',
                },
                {
                    "field": "domains",
                    "type": "string",
                    "helper_text": 'A list of domains e.g., ["vectorshift.ai","vectorshiftstudios.com"]',
                },
                {
                    "field": "linkedin_urls",
                    "type": "string",
                    "helper_text": 'A list of Linkedin URLs e.g., ["http://www.linkedin.com/company/vectorshift","http://www.linkedin.com/company/vectorshift-studios"]',
                },
            ],
            "name": "fetch_companies",
            "task_name": "tasks.apollo.fetch_companies",
            "description": "Search for companies via Apollo api",
            "label": "Search Companies",
        },
        "enrich_company": {
            "inputs": [
                {
                    "field": "domain",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "placeholder": "google.com",
                    "helper_text": "Company domain",
                }
            ],
            "outputs": [
                {
                    "field": "company_name",
                    "type": "string",
                    "helper_text": "The company name e.g., Google",
                },
                {
                    "field": "country",
                    "type": "string",
                    "helper_text": "The company’s headquartered country e.g., United States",
                },
                {
                    "field": "website",
                    "type": "string",
                    "helper_text": "The company’s website e.g., http://www.google.com",
                },
                {
                    "field": "industry",
                    "type": "string",
                    "helper_text": "The company’s industry e.g., information technology & services",
                },
                {
                    "field": "annual_revenue",
                    "type": "string",
                    "helper_text": "The company’s annual revenue e.g., 766400000000.0",
                },
                {
                    "field": "total_funding",
                    "type": "string",
                    "helper_text": "The company’s total funding e.g., 3000000000000.0",
                },
                {
                    "field": "num_employees",
                    "type": "string",
                    "helper_text": "The total number of employees e.g., 289000",
                },
                {
                    "field": "linkedin_url",
                    "type": "string",
                    "helper_text": "The company’s Linkedin URL e.g., http://www.linkedin.com/company/google",
                },
            ],
            "name": "enrich_company",
            "task_name": "tasks.apollo.enrich_company",
            "description": "Enrich company information via Apollo api",
            "label": "Enrich Company Information",
        },
        "enrich_contact": {
            "inputs": [
                {
                    "field": "domain",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "placeholder": "google.com",
                    "helper_text": "Contact's company domain",
                },
                {
                    "field": "first_name_input",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "Sundar",
                    "helper_text": "Contact's first name",
                },
                {
                    "field": "last_name_input",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Pichai",
                    "helper_text": "Contact's last name",
                },
                {
                    "field": "company_name",
                    "type": "string",
                    "value": "",
                    "label": "Company Name",
                    "placeholder": "Google",
                    "helper_text": "Contact's company name",
                },
                {
                    "field": "linkedin_url_input",
                    "type": "string",
                    "value": "",
                    "label": "LinkedIn URL",
                    "placeholder": "https://www.linkedin.com/in/sundarpichai",
                    "helper_text": "Contact's LinkedIn URL",
                },
            ],
            "outputs": [
                {
                    "field": "first_name",
                    "type": "string",
                    "helper_text": "The first name e.g., Sundar",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "helper_text": "The last name e.g., Pichai",
                },
                {
                    "field": "job_title",
                    "type": "string",
                    "helper_text": "The person’s title e.g., CEO",
                },
                {
                    "field": "phone_number",
                    "type": "string",
                    "helper_text": "The person’s phone number+10000000000",
                },
                {
                    "field": "email",
                    "type": "string",
                    "helper_text": "The person’s email address e.g., sundar@google.com",
                },
                {
                    "field": "linkedin_url",
                    "type": "string",
                    "helper_text": "The person’s Linkedin e.g., https://www.linkedin.com/in/sundarpichai",
                },
            ],
            "name": "enrich_contact",
            "task_name": "tasks.apollo.enrich_contact",
            "description": "Enrich a contact via Apollo api",
            "label": "Enrich Contact Details",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        company_name: str = "",
        domain: str = "",
        first_name_input: str = "",
        keywords: str = "",
        last_name_input: str = "",
        linkedin_url_input: str = "",
        location: str = "",
        max_size: str = "",
        min_size: str = "",
        num_results: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_apollo",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if company_name is not None:
            self.inputs["company_name"] = company_name
        if keywords is not None:
            self.inputs["keywords"] = keywords
        if min_size is not None:
            self.inputs["min_size"] = min_size
        if max_size is not None:
            self.inputs["max_size"] = max_size
        if location is not None:
            self.inputs["location"] = location
        if num_results is not None:
            self.inputs["num_results"] = num_results
        if domain is not None:
            self.inputs["domain"] = domain
        if first_name_input is not None:
            self.inputs["first_name_input"] = first_name_input
        if last_name_input is not None:
            self.inputs["last_name_input"] = last_name_input
        if linkedin_url_input is not None:
            self.inputs["linkedin_url_input"] = linkedin_url_input
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def annual_revenue(self) -> str:
        """
        The company’s annual revenue e.g., 766400000000.0

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("annual_revenue")

    @property
    def company_name(self) -> str:
        """
        The company name e.g., Google

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("company_name")

    @property
    def company_names(self) -> str:
        """
        A list of company names e.g., ["VectorShift","VectorShift Studios"]

        Available: fetch_companies


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("company_names")

    @property
    def country(self) -> str:
        """
        The company’s headquartered country e.g., United States

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("country")

    @property
    def domains(self) -> str:
        """
        A list of domains e.g., ["vectorshift.ai","vectorshiftstudios.com"]

        Available: fetch_companies


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("domains")

    @property
    def email(self) -> str:
        """
        The person’s email address e.g., sundar@google.com

        Available: enrich_contact


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email")

    @property
    def first_name(self) -> str:
        """
        The first name e.g., Sundar

        Available: enrich_contact


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("first_name")

    @property
    def industry(self) -> str:
        """
        The company’s industry e.g., information technology & services

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("industry")

    @property
    def job_title(self) -> str:
        """
        The person’s title e.g., CEO

        Available: enrich_contact


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("job_title")

    @property
    def last_name(self) -> str:
        """
        The last name e.g., Pichai

        Available: enrich_contact


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("last_name")

    @property
    def linkedin_url(self) -> str:
        """
        The company’s Linkedin URL e.g., http://www.linkedin.com/company/google

        Different behavior based on configuration:
          - The company’s Linkedin URL e.g., http://www.linkedin.com/company/google (enrich_company)
          - The person’s Linkedin e.g., https://www.linkedin.com/in/sundarpichai (enrich_contact)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("linkedin_url")

    @property
    def linkedin_urls(self) -> str:
        """
        A list of Linkedin URLs e.g., ["http://www.linkedin.com/company/vectorshift","http://www.linkedin.com/company/vectorshift-studios"]

        Available: fetch_companies


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("linkedin_urls")

    @property
    def num_employees(self) -> str:
        """
        The total number of employees e.g., 289000

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("num_employees")

    @property
    def phone_number(self) -> str:
        """
        The person’s phone number+10000000000

        Available: enrich_contact


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("phone_number")

    @property
    def total_funding(self) -> str:
        """
        The company’s total funding e.g., 3000000000000.0

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("total_funding")

    @property
    def website(self) -> str:
        """
        The company’s website e.g., http://www.google.com

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("website")

    @property
    def websites(self) -> str:
        """
        A list of websites e.g., ["http://www.vectorshift.ai","http://www.vectorshiftstudios.com"]

        Available: fetch_companies


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("websites")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationApolloNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_clickup")
class IntegrationClickupNode(Node):
    """
    ClickUp

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'get_tasks'
        archived: Include archived tasks
        assignees: Filter by assignee user IDs
        custom_fields: Custom field filters in JSON format: {"field_id": "value"}
        date_updated_gt: Tasks updated after this date (YYYY-MM-DD)
        date_updated_lt: Tasks updated before this date (YYYY-MM-DD)
        due_date_gt: Tasks due after this date (YYYY-MM-DD)
        due_date_lt: Tasks due before this date (YYYY-MM-DD)
        folder_id: The ID of the folder
        include_closed: Include closed tasks
        include_markdown_description: Include markdown description
        list_id: The ID of the list where task will be created
        order_by: Sort tasks by field (created, updated, due_date, etc.)
        reverse: Reverse the sort order
        space_id: The ID of the space
        statuses: Filter by specific task statuses
        subtasks: Include subtasks
        tags: Filter by tag names
        team_id: The ID of the team
        use_date: Toggle to use dates
    ### When action = 'create_comment'
        assign_user: User ID to assign to this comment
        comment_text: Content of the comment
        notify_all: Notify all members
        task_id: The ID of the task to update
    ### When action = 'get_time_entries'
        assignee: Filter by assignee user ID
        folder_id: The ID of the folder
        include_location_names: Include location names
        list_id: The ID of the list where task will be created
        num_messages: Specify the number of tasks to fetch
        space_id: The ID of the space
        task_id: The ID of the task to update
        team_id: The ID of the team
        use_date: Toggle to use dates
    ### When action = 'delete_checklist'
        checklist_id: The ID of the checklist to delete
    ### When action = 'update_checklist'
        checklist_id: The ID of the checklist to delete
        update_checklist_name: New name for the checklist
        update_checklist_position: New position for the checklist
    ### When action = 'create_checklist_item'
        checklist_id: The ID of the checklist to delete
        checklist_item_assignee: User ID to assign to this checklist item
        checklist_item_name: Name of the checklist item
    ### When action = 'delete_checklist_item'
        checklist_id: The ID of the checklist to delete
        checklist_item_id: The ID of the checklist item to delete
    ### When action = 'update_checklist_item'
        checklist_id: The ID of the checklist to delete
        checklist_item_id: The ID of the checklist item to delete
        update_checklist_item_assignee: New assignee for the checklist item
        update_checklist_item_name: New name for the checklist item
        update_checklist_item_parent: New parent for the checklist item
        update_checklist_item_resolved: Mark checklist item as resolved
    ### When action = 'create_checklist'
        checklist_name: Name of the checklist
        task_id: The ID of the task to update
    ### When action = 'add_task_tag'
        custom_task_ids: Use custom task IDs
        tag_name: Name of the tag
        task_id: The ID of the task to update
        team_id: The ID of the team
    ### When action = 'remove_task_tag'
        custom_task_ids: Use custom task IDs
        tag_name: Name of the tag
        task_id: The ID of the task to update
        team_id: The ID of the team
    ### When action = 'get_tasks' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'create_task_dependency'
        depends_on_task_id: The ID of the task that this task depends on
        task_id: The ID of the task to update
    ### When action = 'delete_task_dependency'
        depends_on_task_id: The ID of the task that this task depends on
        task_id: The ID of the task to update
    ### When action = 'create_time_entry'
        duration_minutes: Duration in minutes
        start_time: Start time for the time entry (RFC3339 format)
        task_id: The ID of the task to update
        team_id: The ID of the team
        time_entry_assignee: Assignee user ID for the time entry
        time_entry_billable: Mark time entry as billable
        time_entry_description: Description of the time entry
        time_entry_tags: Comma-separated list of tags or JSON objects
    ### When action = 'get_tasks' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'create_task'
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        task_assignees: List of assignee IDs
        task_description: Description of the task
        task_due_date: Due date for the task (timestamp)
        task_name: Name of the task
        task_priority: Priority of the task (1=Urgent, 2=High, 3=Normal, 4=Low)
        task_start_date: Start date for the task (timestamp)
        task_status: Status of the task
        task_tags: List of tags for the task
        team_id: The ID of the team
    ### When action = 'create_list'
        folder_id: The ID of the folder
        list_content: Description of the list
        list_name: Name of the list
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'get_lists'
        folder_id: The ID of the folder
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'read_folder'
        folder_id: The ID of the folder
    ### When action = 'create_folder'
        folder_name: Name of the folder
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'get_time_entry'
        get_running: Get currently running time entry
        team_id: The ID of the team
        time_entry_id: The ID of the time entry to delete
    ### When action = 'create_goal'
        goal_color: Color for the goal
        goal_description: Description of the goal
        goal_due_date: Due date for the goal (YYYY-MM-DD or RFC3339)
        goal_multiple_owners: Allow multiple owners
        goal_name: Name of the goal
        goal_owners: Comma-separated list of owner user IDs
        team_id: The ID of the team
    ### When action = 'delete_goal'
        goal_id: The ID of the goal to delete
    ### When action = 'get_goal'
        goal_id: The ID of the goal to delete
    ### When action = 'update_goal'
        goal_id: The ID of the goal to delete
        update_goal_add_owners: Comma-separated list of owner user IDs to add
        update_goal_color: New color for the goal
        update_goal_description: New description for the goal
        update_goal_due_date: New due date for the goal (YYYY-MM-DD or RFC3339)
        update_goal_name: New name for the goal
        update_goal_remove_owners: Comma-separated list of owner user IDs to remove
    ### When action = 'create_goal_key_result'
        goal_id: The ID of the goal to delete
        key_result_list_ids: Comma-separated list of list IDs
        key_result_name: Name of the key result
        key_result_owners: Comma-separated list of owner user IDs
        key_result_steps_end: Target value for the key result
        key_result_steps_start: Starting value for the key result
        key_result_task_ids: Comma-separated list of task IDs
        key_result_type: Type of key result (number, currency, boolean, percentage, automatic)
        key_result_unit: Unit for the key result
    ### When action = 'get_goals'
        include_completed: Include completed goals
        team_id: The ID of the team
    ### When action = 'delete_goal_key_result'
        key_result_id: The ID of the key result to delete
    ### When action = 'update_goal_key_result'
        key_result_id: The ID of the key result to delete
        update_key_result_name: New name for the key result
        update_key_result_note: New note for the key result
        update_key_result_steps_current: Current progress value
        update_key_result_steps_end: New target value
        update_key_result_steps_start: New starting value
        update_key_result_unit: New unit for the key result
    ### When action = 'read_list'
        list_id: The ID of the list where task will be created
    ### When action = 'add_task_to_list'
        list_id: The ID of the list where task will be created
        task_id: The ID of the task to update
    ### When action = 'remove_task_from_list'
        list_id: The ID of the list where task will be created
        task_id: The ID of the task to update
    ### When action = 'update_space_tag'
        new_tag_name: New name for the tag
        space_id: The ID of the space
        tag_background_color: Background color for the tag
        tag_foreground_color: Foreground color for the tag
        tag_name: Name of the tag
        team_id: The ID of the team
    ### When action = 'get_tasks' and use_date = False
        num_messages: Specify the number of tasks to fetch
    ### When action = 'get_space_tags'
        num_messages: Specify the number of tasks to fetch
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'create_space'
        space_features: Space features configuration
        space_multiple_assignees: Allow multiple assignees
        space_name: Name of the space
        team_id: The ID of the team
    ### When action = 'get_folders'
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'read_space'
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'create_space_tag'
        space_id: The ID of the space
        tag_background_color: Background color for the tag
        tag_foreground_color: Foreground color for the tag
        tag_name: Name of the tag
        team_id: The ID of the team
    ### When action = 'delete_space_tag'
        space_id: The ID of the space
        tag_name: Name of the tag
        team_id: The ID of the team
    ### When action = 'update_task'
        task_id: The ID of the task to update
        update_task_assignees: New list of assignee IDs
        update_task_description: New description for the task
        update_task_due_date: New due date for the task (timestamp)
        update_task_name: New name for the task
        update_task_priority: New priority for the task (1=Urgent, 2=High, 3=Normal, 4=Low)
        update_task_start_date: New start date for the task (timestamp)
        update_task_status: New status for the task
    ### When action = 'read_task'
        task_id: The ID of the task to update
    ### When action = 'delete_task'
        task_id: The ID of the task to update
    ### When action = 'get_comments'
        task_id: The ID of the task to update
    ### When action = 'start_time_entry'
        task_id: The ID of the task to update
        team_id: The ID of the team
        time_entry_billable: Mark time entry as billable
        time_entry_description: Description of the time entry
    ### When action = 'delete_time_entry'
        team_id: The ID of the team
        time_entry_id: The ID of the time entry to delete
    ### When action = 'stop_time_entry'
        team_id: The ID of the team
    ### When action = 'update_time_entry'
        team_id: The ID of the team
        time_entry_id: The ID of the time entry to delete
        update_time_entry_billable: Mark time entry as billable
        update_time_entry_description: New description for the time entry
        update_time_entry_duration_minutes: New duration in minutes
        update_time_entry_start: New start time (RFC3339 format)
        update_time_entry_task_id: New task ID for the time entry
    ### When action = 'get_tasks' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_task'
        assignees: List of assignees for the task
        created_at: Creation timestamp of the task
        description: Description of the task
        due_date: Due date of the task
        priority: Priority of the task
        start_date: Start date of the task
        status: Status of the task
        tags: List of tags for the task
        task_details: Task details in JSON format
        task_id: ID of the task
        task_name: Name of the task
        task_url: URL of the task
        updated_at: Last update timestamp of the task
    ### When action = 'create_checklist'
        checklist_details: Checklist details in JSON format
        checklist_id: ID of the created checklist
        checklist_name: Name of the created checklist
    ### When action = 'update_checklist'
        checklist_details: Checklist details in JSON format
        checklist_id: ID of the updated checklist
        checklist_name: Name of the updated checklist
    ### When action = 'create_checklist_item'
        checklist_details: Checklist details in JSON format
        checklist_id: ID of the checklist
    ### When action = 'update_checklist_item'
        checklist_details: Checklist details in JSON format
        checklist_id: ID of the checklist
    ### When action = 'delete_checklist'
        checklist_id: ID of the deleted checklist
        message: Success message
        success: Whether the checklist was successfully deleted
    ### When action = 'delete_checklist_item'
        checklist_id: ID of the checklist
        checklist_item_id: ID of the deleted checklist item
        message: Success message
        success: Whether the checklist item was successfully deleted
    ### When action = 'create_comment'
        comment_details: Comment details in JSON format
        comment_id: ID of the created comment
        comment_text: Text of the created comment
        created_at: Creation timestamp of the comment
        user: User who created the comment
    ### When action = 'get_comments'
        comment_details: Comments details in JSON format
        comment_ids: List of comment IDs
        comment_texts: List of comment texts
        comment_users: List of comment authors
    ### When action = 'create_task'
        created_at: Creation timestamp of the task
        status: Status of the created task
        task_details: Task details in JSON format
        task_id: ID of the created task
        task_name: Name of the created task
        task_url: URL of the created task
    ### When action = 'create_task_dependency'
        depends_on_task_id: ID of the task this depends on
        message: Success message
        success: Whether the dependency was successfully created
        task_id: ID of the dependent task
    ### When action = 'delete_task_dependency'
        depends_on_task_id: ID of the task this depends on
        message: Success message
        success: Whether the dependency was successfully deleted
        task_id: ID of the dependent task
    ### When action = 'create_folder'
        folder_details: Folder details in JSON format
        folder_id: ID of the created folder
        folder_name: Name of the created folder
    ### When action = 'read_folder'
        folder_details: Folder details in JSON format
        folder_id: ID of the folder
        folder_name: Name of the folder
    ### When action = 'get_folders'
        folder_details: Folders details in JSON format
        folder_ids: List of folder IDs
        folder_names: List of folder names
    ### When action = 'create_goal'
        goal_details: Goal details in JSON format
        goal_id: ID of the created goal
        goal_name: Name of the created goal
    ### When action = 'get_goal'
        goal_details: Goal details in JSON format
        goal_id: ID of the goal
        goal_name: Name of the goal
    ### When action = 'get_goals'
        goal_details: Goals details in JSON format
        goal_ids: List of goal IDs
        goal_names: List of goal names
    ### When action = 'update_goal'
        goal_details: Goal details in JSON format
        goal_id: ID of the updated goal
        goal_name: Name of the updated goal
    ### When action = 'delete_goal'
        goal_id: ID of the deleted goal
        message: Success message
        success: Whether the goal was successfully deleted
    ### When action = 'create_goal_key_result'
        key_result_details: Key result details in JSON format
        key_result_id: ID of the created key result
        key_result_name: Name of the created key result
    ### When action = 'update_goal_key_result'
        key_result_details: Key result details in JSON format
        key_result_id: ID of the updated key result
        key_result_name: Name of the updated key result
    ### When action = 'delete_goal_key_result'
        key_result_id: ID of the deleted key result
        message: Success message
        success: Whether the key result was successfully deleted
    ### When action = 'create_list'
        list_details: List details in JSON format
        list_id: ID of the created list
        list_name: Name of the created list
    ### When action = 'read_list'
        list_details: List details in JSON format
        list_id: ID of the list
        list_name: Name of the list
    ### When action = 'get_lists'
        list_details: Lists details in JSON format
        list_ids: List of list IDs
        list_names: List of list names
    ### When action = 'add_task_to_list'
        list_id: ID of the list
        message: Success message
        success: Whether the task was successfully added to the list
        task_id: ID of the task
    ### When action = 'remove_task_from_list'
        list_id: ID of the list
        message: Success message
        success: Whether the task was successfully removed from the list
        task_id: ID of the task
    ### When action = 'delete_task'
        message: Success message
        success: Whether the task was successfully deleted
        task_id: ID of the deleted task
    ### When action = 'delete_time_entry'
        message: Success message
        response_data: Response data from the API
        success: Whether the time entry was successfully deleted
        time_entry_id: ID of the deleted time entry
    ### When action = 'start_time_entry'
        message: Success message
        time_entry_details: Time entry details in JSON format
        time_entry_id: ID of the started time entry
    ### When action = 'stop_time_entry'
        message: Success message
        time_entry_details: Time entry details in JSON format
        time_entry_id: ID of the stopped time entry
    ### When action = 'create_space_tag'
        message: Success message
        space_id: ID of the space
        success: Whether the tag was successfully created
        tag_name: Name of the created tag
    ### When action = 'delete_space_tag'
        message: Success message
        space_id: ID of the space
        success: Whether the tag was successfully deleted
        tag_name: Name of the deleted tag
    ### When action = 'update_space_tag'
        message: Success message
        new_tag_name: New name of the tag
        old_tag_name: Previous name of the tag
        space_id: ID of the space
        success: Whether the tag was successfully updated
    ### When action = 'add_task_tag'
        message: Success message
        success: Whether the tag was successfully added
        tag_name: Name of the added tag
        task_id: ID of the task
    ### When action = 'remove_task_tag'
        message: Success message
        success: Whether the tag was successfully removed
        tag_name: Name of the removed tag
        task_id: ID of the task
    ### When action = 'get_tasks'
        raw_data: Raw API response data in JSON format
        task_assignees: Task assignees in JSON format
        task_created_dates: List of task creation dates
        task_descriptions: List of task descriptions
        task_details: Tasks details in JSON format
        task_due_dates: List of task due dates
        task_ids: List of task IDs
        task_names: List of task names
        task_priorities: Task priorities in JSON format
        task_start_dates: List of task start dates
        task_statuses: List of task statuses
        task_tags: Task tags in JSON format
        task_updated_dates: List of task update dates
        task_urls: List of task URLs
    ### When action = 'create_space'
        space_details: Space details in JSON format
        space_id: ID of the created space
        space_name: Name of the created space
    ### When action = 'read_space'
        space_details: Space details in JSON format
        space_id: ID of the space
        space_name: Name of the space
    ### When action = 'get_space_tags'
        space_id: ID of the space
        tag_details: Tags details in JSON format
        tag_names: List of tag names
    ### When action = 'update_task'
        status: Status of the updated task
        task_details: Task details in JSON format
        task_id: ID of the updated task
        task_name: Name of the updated task
        task_url: URL of the updated task
        updated_at: Update timestamp of the task
    ### When action = 'create_time_entry'
        time_entry_details: Time entry details in JSON format
        time_entry_id: ID of the created time entry
    ### When action = 'get_time_entry'
        time_entry_details: Time entry details in JSON format
        time_entry_id: ID of the time entry
    ### When action = 'get_time_entries'
        time_entry_details: Time entries details in JSON format
        time_entry_ids: List of time entry IDs
    ### When action = 'update_time_entry'
        time_entry_details: Time entry details in JSON format
        time_entry_id: ID of the updated time entry
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Clickup>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_task**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list where task will be created",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "task_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the task",
                    "label": "Task Name",
                    "placeholder": "Complete project documentation",
                },
                {
                    "field": "task_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the task",
                    "label": "Task Description",
                    "placeholder": "Write comprehensive documentation for the project",
                },
                {
                    "field": "task_priority",
                    "type": "int32",
                    "value": 3,
                    "helper_text": "Priority of the task (1=Urgent, 2=High, 3=Normal, 4=Low)",
                    "label": "Priority",
                    "placeholder": "3",
                },
                {
                    "field": "task_status",
                    "type": "string",
                    "value": "",
                    "helper_text": "Status of the task",
                    "label": "Status",
                    "placeholder": "to do",
                },
                {
                    "field": "task_assignees",
                    "type": "string",
                    "value": "",
                    "helper_text": "List of assignee IDs",
                    "label": "Assignees",
                    "placeholder": "User IDs",
                },
                {
                    "field": "task_tags",
                    "type": "string",
                    "value": "",
                    "helper_text": "List of tags for the task",
                    "label": "Tags",
                    "placeholder": "Tags",
                },
                {
                    "field": "task_due_date",
                    "type": "string",
                    "value": "",
                    "helper_text": "Due date for the task (timestamp)",
                    "label": "Due Date",
                    "placeholder": "1635724800000",
                },
                {
                    "field": "task_start_date",
                    "type": "string",
                    "value": "",
                    "helper_text": "Start date for the task (timestamp)",
                    "label": "Start Date",
                    "placeholder": "1635638400000",
                },
            ],
            "outputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the created task",
                },
                {
                    "field": "task_name",
                    "type": "string",
                    "helper_text": "Name of the created task",
                },
                {
                    "field": "task_url",
                    "type": "string",
                    "helper_text": "URL of the created task",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Status of the created task",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp of the task",
                },
                {
                    "field": "task_details",
                    "type": "string",
                    "helper_text": "Task details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_task",
            "task_name": "tasks.clickup.create_task",
            "description": "Create a new task in ClickUp",
            "label": "Create Task",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_name",
                "task_description",
                "task_priority",
                "task_status",
                "task_assignees",
                "task_tags",
                "task_due_date",
                "task_start_date",
            ],
        },
        "update_task**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to update",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "update_task_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the task",
                    "label": "Task Name",
                    "placeholder": "Updated task name",
                },
                {
                    "field": "update_task_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the task",
                    "label": "Task Description",
                    "placeholder": "Updated description",
                },
                {
                    "field": "update_task_priority",
                    "type": "int32",
                    "value": 3,
                    "helper_text": "New priority for the task (1=Urgent, 2=High, 3=Normal, 4=Low)",
                    "label": "Priority",
                    "placeholder": "3",
                },
                {
                    "field": "update_task_status",
                    "type": "string",
                    "value": "",
                    "helper_text": "New status for the task",
                    "label": "Status",
                    "placeholder": "in progress",
                },
                {
                    "field": "update_task_assignees",
                    "type": "string",
                    "value": "",
                    "helper_text": "New list of assignee IDs",
                    "label": "Assignees",
                    "placeholder": "User IDs",
                },
                {
                    "field": "update_task_due_date",
                    "type": "string",
                    "value": "",
                    "helper_text": "New due date for the task (timestamp)",
                    "label": "Due Date",
                    "placeholder": "1635724800000",
                },
                {
                    "field": "update_task_start_date",
                    "type": "string",
                    "value": "",
                    "helper_text": "New start date for the task (timestamp)",
                    "label": "Start Date",
                    "placeholder": "1635638400000",
                },
            ],
            "outputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the updated task",
                },
                {
                    "field": "task_name",
                    "type": "string",
                    "helper_text": "Name of the updated task",
                },
                {
                    "field": "task_url",
                    "type": "string",
                    "helper_text": "URL of the updated task",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Status of the updated task",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Update timestamp of the task",
                },
                {
                    "field": "task_details",
                    "type": "string",
                    "helper_text": "Task details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_task",
            "task_name": "tasks.clickup.update_task",
            "description": "Update an existing task in ClickUp",
            "label": "Update Task",
            "inputs_sort_order": [
                "integration",
                "action",
                "task_id",
                "update_task_name",
                "update_task_description",
                "update_task_priority",
                "update_task_status",
                "update_task_assignees",
                "update_task_due_date",
                "update_task_start_date",
            ],
        },
        "read_task**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to read",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                }
            ],
            "outputs": [
                {"field": "task_id", "type": "string", "helper_text": "ID of the task"},
                {
                    "field": "task_name",
                    "type": "string",
                    "helper_text": "Name of the task",
                },
                {
                    "field": "task_url",
                    "type": "string",
                    "helper_text": "URL of the task",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Description of the task",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Status of the task",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp of the task",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Last update timestamp of the task",
                },
                {
                    "field": "assignees",
                    "type": "vec<string>",
                    "helper_text": "List of assignees for the task",
                },
                {
                    "field": "tags",
                    "type": "vec<string>",
                    "helper_text": "List of tags for the task",
                },
                {
                    "field": "priority",
                    "type": "string",
                    "helper_text": "Priority of the task",
                },
                {
                    "field": "due_date",
                    "type": "string",
                    "helper_text": "Due date of the task",
                },
                {
                    "field": "start_date",
                    "type": "string",
                    "helper_text": "Start date of the task",
                },
                {
                    "field": "task_details",
                    "type": "string",
                    "helper_text": "Task details in JSON format",
                },
            ],
            "name": "read_task",
            "task_name": "tasks.clickup.read_task",
            "description": "Read details of an existing task in ClickUp",
            "label": "Read Task",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "task_id"],
        },
        "delete_task**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to delete",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the task was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the deleted task",
                },
            ],
            "name": "delete_task",
            "task_name": "tasks.clickup.delete_task",
            "description": "Delete an existing task in ClickUp",
            "label": "Delete Task",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "task_id"],
        },
        "get_tasks**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to get tasks from",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "archived",
                    "type": "bool",
                    "value": False,
                    "hidden": True,
                    "helper_text": "Include archived tasks",
                    "label": "Include Archived",
                },
                {
                    "field": "include_markdown_description",
                    "type": "bool",
                    "value": False,
                    "hidden": True,
                    "helper_text": "Include markdown description",
                    "label": "Include Markdown Description",
                },
                {
                    "field": "include_closed",
                    "type": "bool",
                    "value": False,
                    "hidden": True,
                    "helper_text": "Include closed tasks",
                    "label": "Include Closed",
                },
                {
                    "field": "subtasks",
                    "type": "bool",
                    "value": False,
                    "hidden": True,
                    "helper_text": "Include subtasks",
                    "label": "Include Subtasks",
                },
                {
                    "field": "reverse",
                    "type": "bool",
                    "value": False,
                    "hidden": True,
                    "helper_text": "Reverse the sort order",
                    "label": "Reverse Sort",
                },
                {
                    "field": "order_by",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort tasks by field (created, updated, due_date, etc.)",
                    "label": "Order By",
                    "placeholder": "created",
                },
                {
                    "field": "statuses",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by specific task statuses",
                    "label": "Statuses",
                    "placeholder": "Select statuses",
                },
                {
                    "field": "assignees",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by assignee user IDs",
                    "label": "Assignees",
                    "placeholder": "Enter assignee IDs",
                },
                {
                    "field": "tags",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by tag names",
                    "label": "Tags",
                    "placeholder": "Enter tag names",
                },
                {
                    "field": "due_date_gt",
                    "type": "string",
                    "value": "",
                    "helper_text": "Tasks due after this date (YYYY-MM-DD)",
                    "label": "Due Date After",
                    "placeholder": "2024-01-01",
                },
                {
                    "field": "due_date_lt",
                    "type": "string",
                    "value": "",
                    "helper_text": "Tasks due before this date (YYYY-MM-DD)",
                    "label": "Due Date Before",
                    "placeholder": "2024-12-31",
                },
                {
                    "field": "date_updated_gt",
                    "type": "string",
                    "value": "",
                    "helper_text": "Tasks updated after this date (YYYY-MM-DD)",
                    "label": "Updated After",
                    "placeholder": "2024-01-01",
                },
                {
                    "field": "date_updated_lt",
                    "type": "string",
                    "value": "",
                    "helper_text": "Tasks updated before this date (YYYY-MM-DD)",
                    "label": "Updated Before",
                    "placeholder": "2024-12-31",
                },
                {
                    "field": "custom_fields",
                    "type": "string",
                    "value": "",
                    "helper_text": 'Custom field filters in JSON format: {"field_id": "value"}',
                    "label": "Custom Fields",
                    "placeholder": '{"cf_123": "value"}',
                },
            ],
            "outputs": [
                {
                    "field": "task_ids",
                    "type": "vec<string>",
                    "helper_text": "List of task IDs",
                },
                {
                    "field": "task_names",
                    "type": "vec<string>",
                    "helper_text": "List of task names",
                },
                {
                    "field": "task_urls",
                    "type": "vec<string>",
                    "helper_text": "List of task URLs",
                },
                {
                    "field": "task_statuses",
                    "type": "vec<string>",
                    "helper_text": "List of task statuses",
                },
                {
                    "field": "task_details",
                    "type": "string",
                    "helper_text": "Tasks details in JSON format",
                },
                {
                    "field": "task_assignees",
                    "type": "string",
                    "helper_text": "Task assignees in JSON format",
                },
                {
                    "field": "task_tags",
                    "type": "string",
                    "helper_text": "Task tags in JSON format",
                },
                {
                    "field": "task_priorities",
                    "type": "string",
                    "helper_text": "Task priorities in JSON format",
                },
                {
                    "field": "task_due_dates",
                    "type": "vec<string>",
                    "helper_text": "List of task due dates",
                },
                {
                    "field": "task_start_dates",
                    "type": "vec<string>",
                    "helper_text": "List of task start dates",
                },
                {
                    "field": "task_created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of task creation dates",
                },
                {
                    "field": "task_updated_dates",
                    "type": "vec<string>",
                    "helper_text": "List of task update dates",
                },
                {
                    "field": "task_descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of task descriptions",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_tasks",
            "task_name": "tasks.clickup.get_tasks",
            "description": "Get a list of tasks from ClickUp with advanced filtering options",
            "label": "Get Tasks",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "archived",
                "include_markdown_description",
                "include_closed",
                "subtasks",
                "reverse",
                "order_by",
                "statuses",
                "assignees",
                "tags",
                "due_date_gt",
                "due_date_lt",
                "date_updated_gt",
                "date_updated_lt",
                "custom_fields",
            ],
        },
        "get_tasks**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Tasks",
                    "helper_text": "Specify the number of tasks to fetch",
                }
            ],
            "outputs": [],
        },
        "get_tasks**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_tasks**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_tasks**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to add comment to",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "comment_text",
                    "type": "string",
                    "value": "",
                    "helper_text": "Content of the comment",
                    "label": "Comment Text",
                    "placeholder": "This is a comment on the task",
                },
                {
                    "field": "assign_user",
                    "type": "string",
                    "value": "",
                    "helper_text": "User ID to assign to this comment",
                    "label": "Assign User",
                    "placeholder": "123456",
                },
                {
                    "field": "notify_all",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Notify all members",
                    "label": "Notify All",
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "ID of the created comment",
                },
                {
                    "field": "comment_text",
                    "type": "string",
                    "helper_text": "Text of the created comment",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp of the comment",
                },
                {
                    "field": "user",
                    "type": "string",
                    "helper_text": "User who created the comment",
                },
                {
                    "field": "comment_details",
                    "type": "string",
                    "helper_text": "Comment details in JSON format",
                },
            ],
            "name": "create_comment",
            "task_name": "tasks.clickup.create_comment",
            "description": "Create a new comment on a ClickUp task",
            "label": "Create Comment",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "task_id",
                "comment_text",
                "assign_user",
                "notify_all",
            ],
        },
        "get_comments**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to get comments from",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                }
            ],
            "outputs": [
                {
                    "field": "comment_ids",
                    "type": "vec<string>",
                    "helper_text": "List of comment IDs",
                },
                {
                    "field": "comment_texts",
                    "type": "vec<string>",
                    "helper_text": "List of comment texts",
                },
                {
                    "field": "comment_users",
                    "type": "vec<string>",
                    "helper_text": "List of comment authors",
                },
                {
                    "field": "comment_details",
                    "type": "string",
                    "helper_text": "Comments details in JSON format",
                },
            ],
            "name": "get_comments",
            "task_name": "tasks.clickup.get_comments",
            "description": "Get comments from a ClickUp task",
            "label": "Get Comments",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "task_id"],
        },
        "create_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder where list will be created",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the list",
                    "label": "List Name",
                    "placeholder": "My New List",
                },
                {
                    "field": "list_content",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the list",
                    "label": "List Description",
                    "placeholder": "Description for the new list",
                },
            ],
            "outputs": [
                {
                    "field": "list_id",
                    "type": "string",
                    "helper_text": "ID of the created list",
                },
                {
                    "field": "list_name",
                    "type": "string",
                    "helper_text": "Name of the created list",
                },
                {
                    "field": "list_details",
                    "type": "string",
                    "helper_text": "List details in JSON format",
                },
            ],
            "name": "create_list",
            "task_name": "tasks.clickup.create_list",
            "description": "Create a new list in ClickUp",
            "label": "Create List",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_name",
                "list_content",
            ],
        },
        "read_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to read",
                    "label": "List ID",
                    "placeholder": "123456789",
                }
            ],
            "outputs": [
                {"field": "list_id", "type": "string", "helper_text": "ID of the list"},
                {
                    "field": "list_name",
                    "type": "string",
                    "helper_text": "Name of the list",
                },
                {
                    "field": "list_details",
                    "type": "string",
                    "helper_text": "List details in JSON format",
                },
            ],
            "name": "read_list",
            "task_name": "tasks.clickup.read_list",
            "description": "Read details of an existing list in ClickUp",
            "label": "Read List",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "list_id"],
        },
        "get_lists**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder to get lists from",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "list_ids",
                    "type": "vec<string>",
                    "helper_text": "List of list IDs",
                },
                {
                    "field": "list_names",
                    "type": "vec<string>",
                    "helper_text": "List of list names",
                },
                {
                    "field": "list_details",
                    "type": "string",
                    "helper_text": "Lists details in JSON format",
                },
            ],
            "name": "get_lists",
            "task_name": "tasks.clickup.get_lists",
            "description": "Get a list of lists from ClickUp",
            "label": "Get Lists",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
            ],
        },
        "create_folder**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space where folder will be created",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the folder",
                    "label": "Folder Name",
                    "placeholder": "My New Folder",
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the created folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the created folder",
                },
                {
                    "field": "folder_details",
                    "type": "string",
                    "helper_text": "Folder details in JSON format",
                },
            ],
            "name": "create_folder",
            "task_name": "tasks.clickup.create_folder",
            "description": "Create a new folder in ClickUp",
            "label": "Create Folder",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_name",
            ],
        },
        "read_folder**(*)**(*)": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder to read",
                    "label": "Folder ID",
                    "placeholder": "123456789",
                }
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the folder",
                },
                {
                    "field": "folder_details",
                    "type": "string",
                    "helper_text": "Folder details in JSON format",
                },
            ],
            "name": "read_folder",
            "task_name": "tasks.clickup.read_folder",
            "description": "Read details of an existing folder in ClickUp",
            "label": "Read Folder",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "folder_id"],
        },
        "get_folders**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space to get folders from",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "folder_ids",
                    "type": "vec<string>",
                    "helper_text": "List of folder IDs",
                },
                {
                    "field": "folder_names",
                    "type": "vec<string>",
                    "helper_text": "List of folder names",
                },
                {
                    "field": "folder_details",
                    "type": "string",
                    "helper_text": "Folders details in JSON format",
                },
            ],
            "name": "get_folders",
            "task_name": "tasks.clickup.get_folders",
            "description": "Get a list of folders from ClickUp",
            "label": "Get Folders",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "team_id", "space_id"],
        },
        "create_space**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team where space will be created",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the space",
                    "label": "Space Name",
                    "placeholder": "My New Space",
                },
                {
                    "field": "space_multiple_assignees",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Allow multiple assignees",
                    "label": "Multiple Assignees",
                },
                {
                    "field": "space_features",
                    "type": "string",
                    "value": "",
                    "helper_text": "Space features configuration",
                    "label": "Features",
                },
            ],
            "outputs": [
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the created space",
                },
                {
                    "field": "space_name",
                    "type": "string",
                    "helper_text": "Name of the created space",
                },
                {
                    "field": "space_details",
                    "type": "string",
                    "helper_text": "Space details in JSON format",
                },
            ],
            "name": "create_space",
            "task_name": "tasks.clickup.create_space",
            "description": "Create a new space in ClickUp",
            "label": "Create Space",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_name",
                "space_multiple_assignees",
                "space_features",
            ],
        },
        "read_space**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space to read",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the space",
                },
                {
                    "field": "space_name",
                    "type": "string",
                    "helper_text": "Name of the space",
                },
                {
                    "field": "space_details",
                    "type": "string",
                    "helper_text": "Space details in JSON format",
                },
            ],
            "name": "read_space",
            "task_name": "tasks.clickup.read_space",
            "description": "Read details of an existing space in ClickUp",
            "label": "Read Space",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "team_id", "space_id"],
        },
        "create_checklist**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to add checklist to",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "checklist_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the checklist",
                    "label": "Checklist Name",
                    "placeholder": "My Checklist",
                },
            ],
            "outputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "helper_text": "ID of the created checklist",
                },
                {
                    "field": "checklist_name",
                    "type": "string",
                    "helper_text": "Name of the created checklist",
                },
                {
                    "field": "checklist_details",
                    "type": "string",
                    "helper_text": "Checklist details in JSON format",
                },
            ],
            "name": "create_checklist",
            "task_name": "tasks.clickup.create_checklist",
            "description": "Create a new checklist in a ClickUp task",
            "label": "Create Checklist",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "task_id", "checklist_name"],
        },
        "delete_checklist**(*)**(*)": {
            "inputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist to delete",
                    "label": "Checklist ID",
                    "placeholder": "abc123def456",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the checklist was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "checklist_id",
                    "type": "string",
                    "helper_text": "ID of the deleted checklist",
                },
            ],
            "name": "delete_checklist",
            "task_name": "tasks.clickup.delete_checklist",
            "description": "Delete an existing checklist in ClickUp",
            "label": "Delete Checklist",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "checklist_id"],
        },
        "update_checklist**(*)**(*)": {
            "inputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist to update",
                    "label": "Checklist ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "update_checklist_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the checklist",
                    "label": "Checklist Name",
                    "placeholder": "Updated checklist name",
                },
                {
                    "field": "update_checklist_position",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "New position for the checklist",
                    "label": "Position",
                    "placeholder": "0",
                },
            ],
            "outputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "helper_text": "ID of the updated checklist",
                },
                {
                    "field": "checklist_name",
                    "type": "string",
                    "helper_text": "Name of the updated checklist",
                },
                {
                    "field": "checklist_details",
                    "type": "string",
                    "helper_text": "Checklist details in JSON format",
                },
            ],
            "name": "update_checklist",
            "task_name": "tasks.clickup.update_checklist",
            "description": "Update an existing checklist in ClickUp",
            "label": "Update Checklist",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "checklist_id",
                "update_checklist_name",
                "update_checklist_position",
            ],
        },
        "create_checklist_item**(*)**(*)": {
            "inputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist to add item to",
                    "label": "Checklist ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "checklist_item_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the checklist item",
                    "label": "Item Name",
                    "placeholder": "Checklist item name",
                },
                {
                    "field": "checklist_item_assignee",
                    "type": "string",
                    "value": "",
                    "helper_text": "User ID to assign to this checklist item",
                    "label": "Assignee",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "helper_text": "ID of the checklist",
                },
                {
                    "field": "checklist_details",
                    "type": "string",
                    "helper_text": "Checklist details in JSON format",
                },
            ],
            "name": "create_checklist_item",
            "task_name": "tasks.clickup.create_checklist_item",
            "description": "Create a new item in a ClickUp checklist",
            "label": "Create Checklist Item",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "checklist_id",
                "checklist_item_name",
                "checklist_item_assignee",
            ],
        },
        "delete_checklist_item**(*)**(*)": {
            "inputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist",
                    "label": "Checklist ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "checklist_item_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist item to delete",
                    "label": "Checklist Item ID",
                    "placeholder": "item123",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the checklist item was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "checklist_id",
                    "type": "string",
                    "helper_text": "ID of the checklist",
                },
                {
                    "field": "checklist_item_id",
                    "type": "string",
                    "helper_text": "ID of the deleted checklist item",
                },
            ],
            "name": "delete_checklist_item",
            "task_name": "tasks.clickup.delete_checklist_item",
            "description": "Delete an existing item from a ClickUp checklist",
            "label": "Delete Checklist Item",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "checklist_id",
                "checklist_item_id",
            ],
        },
        "update_checklist_item**(*)**(*)": {
            "inputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist",
                    "label": "Checklist ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "checklist_item_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist item to update",
                    "label": "Checklist Item ID",
                    "placeholder": "item123",
                },
                {
                    "field": "update_checklist_item_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the checklist item",
                    "label": "Item Name",
                    "placeholder": "Updated item name",
                },
                {
                    "field": "update_checklist_item_parent",
                    "type": "string",
                    "value": "",
                    "helper_text": "New parent for the checklist item",
                    "label": "Parent",
                    "placeholder": "parent123",
                },
                {
                    "field": "update_checklist_item_assignee",
                    "type": "string",
                    "value": "",
                    "helper_text": "New assignee for the checklist item",
                    "label": "Assignee",
                    "placeholder": "123456",
                },
                {
                    "field": "update_checklist_item_resolved",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Mark checklist item as resolved",
                    "label": "Resolved",
                },
            ],
            "outputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "helper_text": "ID of the checklist",
                },
                {
                    "field": "checklist_details",
                    "type": "string",
                    "helper_text": "Checklist details in JSON format",
                },
            ],
            "name": "update_checklist_item",
            "task_name": "tasks.clickup.update_checklist_item",
            "description": "Update an existing item in a ClickUp checklist",
            "label": "Update Checklist Item",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "checklist_id",
                "checklist_item_id",
                "update_checklist_item_name",
                "update_checklist_item_parent",
                "update_checklist_item_assignee",
                "update_checklist_item_resolved",
            ],
        },
        "create_goal**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "goal_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the goal",
                    "label": "Goal Name",
                    "placeholder": "Complete project by Q4",
                },
                {
                    "field": "goal_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the goal",
                    "label": "Goal Description",
                    "placeholder": "Complete the entire project with all deliverables",
                },
                {
                    "field": "goal_due_date",
                    "type": "string",
                    "value": "",
                    "helper_text": "Due date for the goal (YYYY-MM-DD or RFC3339)",
                    "label": "Due Date",
                    "placeholder": "2024-12-31",
                },
                {
                    "field": "goal_color",
                    "type": "string",
                    "value": "",
                    "helper_text": "Color for the goal",
                    "label": "Color",
                    "placeholder": "#ff0000",
                },
                {
                    "field": "goal_multiple_owners",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Allow multiple owners",
                    "label": "Multiple Owners",
                },
                {
                    "field": "goal_owners",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of owner user IDs",
                    "label": "Owners",
                    "placeholder": "123456,789012",
                },
            ],
            "outputs": [
                {
                    "field": "goal_id",
                    "type": "string",
                    "helper_text": "ID of the created goal",
                },
                {
                    "field": "goal_name",
                    "type": "string",
                    "helper_text": "Name of the created goal",
                },
                {
                    "field": "goal_details",
                    "type": "string",
                    "helper_text": "Goal details in JSON format",
                },
            ],
            "name": "create_goal",
            "task_name": "tasks.clickup.create_goal",
            "description": "Create a new goal in ClickUp",
            "label": "Create Goal",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "goal_name",
                "goal_description",
                "goal_due_date",
                "goal_color",
                "goal_multiple_owners",
                "goal_owners",
            ],
        },
        "delete_goal**(*)**(*)": {
            "inputs": [
                {
                    "field": "goal_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the goal to delete",
                    "label": "Goal ID",
                    "placeholder": "abc123def456",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the goal was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "goal_id",
                    "type": "string",
                    "helper_text": "ID of the deleted goal",
                },
            ],
            "name": "delete_goal",
            "task_name": "tasks.clickup.delete_goal",
            "description": "Delete an existing goal in ClickUp",
            "label": "Delete Goal",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "goal_id"],
        },
        "get_goal**(*)**(*)": {
            "inputs": [
                {
                    "field": "goal_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the goal to read",
                    "label": "Goal ID",
                    "placeholder": "abc123def456",
                }
            ],
            "outputs": [
                {"field": "goal_id", "type": "string", "helper_text": "ID of the goal"},
                {
                    "field": "goal_name",
                    "type": "string",
                    "helper_text": "Name of the goal",
                },
                {
                    "field": "goal_details",
                    "type": "string",
                    "helper_text": "Goal details in JSON format",
                },
            ],
            "name": "get_goal",
            "task_name": "tasks.clickup.get_goal",
            "description": "Get details of an existing goal in ClickUp",
            "label": "Get Goal",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "goal_id"],
        },
        "get_goals**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "include_completed",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include completed goals",
                    "label": "Include Completed",
                },
            ],
            "outputs": [
                {
                    "field": "goal_ids",
                    "type": "vec<string>",
                    "helper_text": "List of goal IDs",
                },
                {
                    "field": "goal_names",
                    "type": "vec<string>",
                    "helper_text": "List of goal names",
                },
                {
                    "field": "goal_details",
                    "type": "string",
                    "helper_text": "Goals details in JSON format",
                },
            ],
            "name": "get_goals",
            "task_name": "tasks.clickup.get_goals",
            "description": "Get a list of goals from ClickUp",
            "label": "Get Goals",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "include_completed",
            ],
        },
        "update_goal**(*)**(*)": {
            "inputs": [
                {
                    "field": "goal_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the goal to update",
                    "label": "Goal ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "update_goal_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the goal",
                    "label": "Goal Name",
                    "placeholder": "Updated goal name",
                },
                {
                    "field": "update_goal_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the goal",
                    "label": "Goal Description",
                    "placeholder": "Updated description",
                },
                {
                    "field": "update_goal_due_date",
                    "type": "string",
                    "value": "",
                    "helper_text": "New due date for the goal (YYYY-MM-DD or RFC3339)",
                    "label": "Due Date",
                    "placeholder": "2024-12-31",
                },
                {
                    "field": "update_goal_color",
                    "type": "string",
                    "value": "",
                    "helper_text": "New color for the goal",
                    "label": "Color",
                    "placeholder": "#ff0000",
                },
                {
                    "field": "update_goal_add_owners",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of owner user IDs to add",
                    "label": "Add Owners",
                    "placeholder": "123456,789012",
                },
                {
                    "field": "update_goal_remove_owners",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of owner user IDs to remove",
                    "label": "Remove Owners",
                    "placeholder": "123456,789012",
                },
            ],
            "outputs": [
                {
                    "field": "goal_id",
                    "type": "string",
                    "helper_text": "ID of the updated goal",
                },
                {
                    "field": "goal_name",
                    "type": "string",
                    "helper_text": "Name of the updated goal",
                },
                {
                    "field": "goal_details",
                    "type": "string",
                    "helper_text": "Goal details in JSON format",
                },
            ],
            "name": "update_goal",
            "task_name": "tasks.clickup.update_goal",
            "description": "Update an existing goal in ClickUp",
            "label": "Update Goal",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "goal_id",
                "update_goal_name",
                "update_goal_description",
                "update_goal_due_date",
                "update_goal_color",
                "update_goal_add_owners",
                "update_goal_remove_owners",
            ],
        },
        "create_goal_key_result**(*)**(*)": {
            "inputs": [
                {
                    "field": "goal_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the goal to add key result to",
                    "label": "Goal ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "key_result_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the key result",
                    "label": "Key Result Name",
                    "placeholder": "Increase revenue by 20%",
                },
                {
                    "field": "key_result_type",
                    "type": "string",
                    "value": "",
                    "helper_text": "Type of key result (number, currency, boolean, percentage, automatic)",
                    "label": "Type",
                    "placeholder": "percentage",
                },
                {
                    "field": "key_result_unit",
                    "type": "string",
                    "value": "",
                    "helper_text": "Unit for the key result",
                    "label": "Unit",
                    "placeholder": "%",
                },
                {
                    "field": "key_result_steps_start",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Starting value for the key result",
                    "label": "Start Value",
                    "placeholder": "0",
                },
                {
                    "field": "key_result_steps_end",
                    "type": "int32",
                    "value": 100,
                    "helper_text": "Target value for the key result",
                    "label": "Target Value",
                    "placeholder": "100",
                },
                {
                    "field": "key_result_task_ids",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of task IDs",
                    "label": "Task IDs",
                    "placeholder": "task1,task2",
                },
                {
                    "field": "key_result_list_ids",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of list IDs",
                    "label": "List IDs",
                    "placeholder": "list1,list2",
                },
                {
                    "field": "key_result_owners",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of owner user IDs",
                    "label": "Owners",
                    "placeholder": "123456,789012",
                },
            ],
            "outputs": [
                {
                    "field": "key_result_id",
                    "type": "string",
                    "helper_text": "ID of the created key result",
                },
                {
                    "field": "key_result_name",
                    "type": "string",
                    "helper_text": "Name of the created key result",
                },
                {
                    "field": "key_result_details",
                    "type": "string",
                    "helper_text": "Key result details in JSON format",
                },
            ],
            "name": "create_goal_key_result",
            "task_name": "tasks.clickup.create_goal_key_result",
            "description": "Create a new key result for a goal in ClickUp",
            "label": "Create Goal Key Result",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "goal_id",
                "key_result_name",
                "key_result_type",
                "key_result_unit",
                "key_result_steps_start",
                "key_result_steps_end",
                "key_result_task_ids",
                "key_result_list_ids",
                "key_result_owners",
            ],
        },
        "delete_goal_key_result**(*)**(*)": {
            "inputs": [
                {
                    "field": "key_result_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the key result to delete",
                    "label": "Key Result ID",
                    "placeholder": "abc123def456",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the key result was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "key_result_id",
                    "type": "string",
                    "helper_text": "ID of the deleted key result",
                },
            ],
            "name": "delete_goal_key_result",
            "task_name": "tasks.clickup.delete_goal_key_result",
            "description": "Delete an existing key result in ClickUp",
            "label": "Delete Goal Key Result",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "key_result_id"],
        },
        "update_goal_key_result**(*)**(*)": {
            "inputs": [
                {
                    "field": "key_result_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the key result to update",
                    "label": "Key Result ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "update_key_result_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the key result",
                    "label": "Key Result Name",
                    "placeholder": "Updated key result name",
                },
                {
                    "field": "update_key_result_note",
                    "type": "string",
                    "value": "",
                    "helper_text": "New note for the key result",
                    "label": "Note",
                    "placeholder": "Updated note",
                },
                {
                    "field": "update_key_result_steps_current",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Current progress value",
                    "label": "Current Value",
                    "placeholder": "50",
                },
                {
                    "field": "update_key_result_steps_start",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "New starting value",
                    "label": "Start Value",
                    "placeholder": "0",
                },
                {
                    "field": "update_key_result_steps_end",
                    "type": "int32",
                    "value": 100,
                    "helper_text": "New target value",
                    "label": "Target Value",
                    "placeholder": "100",
                },
                {
                    "field": "update_key_result_unit",
                    "type": "string",
                    "value": "",
                    "helper_text": "New unit for the key result",
                    "label": "Unit",
                    "placeholder": "%",
                },
            ],
            "outputs": [
                {
                    "field": "key_result_id",
                    "type": "string",
                    "helper_text": "ID of the updated key result",
                },
                {
                    "field": "key_result_name",
                    "type": "string",
                    "helper_text": "Name of the updated key result",
                },
                {
                    "field": "key_result_details",
                    "type": "string",
                    "helper_text": "Key result details in JSON format",
                },
            ],
            "name": "update_goal_key_result",
            "task_name": "tasks.clickup.update_goal_key_result",
            "description": "Update an existing key result in ClickUp",
            "label": "Update Goal Key Result",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "key_result_id",
                "update_key_result_name",
                "update_key_result_note",
                "update_key_result_steps_current",
                "update_key_result_steps_start",
                "update_key_result_steps_end",
                "update_key_result_unit",
            ],
        },
        "create_time_entry**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "start_time",
                    "type": "string",
                    "value": "",
                    "helper_text": "Start time for the time entry (RFC3339 format)",
                    "label": "Start Time",
                    "placeholder": "2024-01-01T09:00:00Z",
                },
                {
                    "field": "duration_minutes",
                    "type": "int32",
                    "value": 60,
                    "helper_text": "Duration in minutes",
                    "label": "Duration (minutes)",
                    "placeholder": "60",
                },
                {
                    "field": "time_entry_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the time entry",
                    "label": "Description",
                    "placeholder": "Working on feature implementation",
                },
                {
                    "field": "time_entry_billable",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Mark time entry as billable",
                    "label": "Billable",
                },
                {
                    "field": "time_entry_assignee",
                    "type": "string",
                    "value": "",
                    "helper_text": "Assignee user ID for the time entry",
                    "label": "Assignee",
                    "placeholder": "123456",
                },
                {
                    "field": "time_entry_tags",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of tags or JSON objects",
                    "label": "Tags",
                    "placeholder": "development,feature",
                },
            ],
            "outputs": [
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the created time entry",
                },
                {
                    "field": "time_entry_details",
                    "type": "string",
                    "helper_text": "Time entry details in JSON format",
                },
            ],
            "name": "create_time_entry",
            "task_name": "tasks.clickup.create_time_entry",
            "description": "Create a new time entry in ClickUp",
            "label": "Create Time Entry",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "task_id",
                "start_time",
                "duration_minutes",
                "time_entry_description",
                "time_entry_billable",
                "time_entry_assignee",
                "time_entry_tags",
            ],
        },
        "delete_time_entry**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the time entry to delete",
                    "label": "Time Entry ID",
                    "placeholder": "abc123def456",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the time entry was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the deleted time entry",
                },
                {
                    "field": "response_data",
                    "type": "string",
                    "helper_text": "Response data from the API",
                },
            ],
            "name": "delete_time_entry",
            "task_name": "tasks.clickup.delete_time_entry",
            "description": "Delete an existing time entry in ClickUp",
            "label": "Delete Time Entry",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "team_id", "time_entry_id"],
        },
        "get_time_entry**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the time entry to get (leave empty if getting running time entry)",
                    "label": "Time Entry ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "get_running",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Get currently running time entry",
                    "label": "Get Running Time Entry",
                },
            ],
            "outputs": [
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the time entry",
                },
                {
                    "field": "time_entry_details",
                    "type": "string",
                    "helper_text": "Time entry details in JSON format",
                },
            ],
            "name": "get_time_entry",
            "task_name": "tasks.clickup.get_time_entry",
            "description": "Get details of a time entry in ClickUp",
            "label": "Get Time Entry",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "time_entry_id",
                "get_running",
            ],
        },
        "get_time_entries**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "assignee",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by assignee user ID",
                    "label": "Assignee",
                    "placeholder": "123456",
                },
                {
                    "field": "include_location_names",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include location names",
                    "label": "Include Location Names",
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by space ID",
                    "label": "Space ID",
                    "placeholder": "space123",
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by folder ID",
                    "label": "Folder ID",
                    "placeholder": "folder123",
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by list ID",
                    "label": "List ID",
                    "placeholder": "list123",
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by task ID",
                    "label": "Task ID",
                    "placeholder": "task123",
                },
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 100,
                    "helper_text": "Maximum number of time entries to fetch",
                    "label": "Max Results",
                    "placeholder": "100",
                },
            ],
            "outputs": [
                {
                    "field": "time_entry_ids",
                    "type": "vec<string>",
                    "helper_text": "List of time entry IDs",
                },
                {
                    "field": "time_entry_details",
                    "type": "string",
                    "helper_text": "Time entries details in JSON format",
                },
            ],
            "name": "get_time_entries",
            "task_name": "tasks.clickup.get_time_entries",
            "description": "Get a list of time entries from ClickUp",
            "label": "Get Time Entries",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "use_date",
                "assignee",
                "include_location_names",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "num_messages",
            ],
        },
        "start_time_entry**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "time_entry_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the time entry",
                    "label": "Description",
                    "placeholder": "Working on feature implementation",
                },
                {
                    "field": "time_entry_billable",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Mark time entry as billable",
                    "label": "Billable",
                },
            ],
            "outputs": [
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the started time entry",
                },
                {
                    "field": "time_entry_details",
                    "type": "string",
                    "helper_text": "Time entry details in JSON format",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
            ],
            "name": "start_time_entry",
            "task_name": "tasks.clickup.start_time_entry",
            "description": "Start a new time entry in ClickUp",
            "label": "Start Time Entry",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "task_id",
                "time_entry_description",
                "time_entry_billable",
            ],
        },
        "stop_time_entry**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                }
            ],
            "outputs": [
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the stopped time entry",
                },
                {
                    "field": "time_entry_details",
                    "type": "string",
                    "helper_text": "Time entry details in JSON format",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
            ],
            "name": "stop_time_entry",
            "task_name": "tasks.clickup.stop_time_entry",
            "description": "Stop the currently running time entry in ClickUp",
            "label": "Stop Time Entry",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "team_id"],
        },
        "update_time_entry**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the time entry to update",
                    "label": "Time Entry ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "update_time_entry_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the time entry",
                    "label": "Description",
                    "placeholder": "Updated description",
                },
                {
                    "field": "update_time_entry_billable",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Mark time entry as billable",
                    "label": "Billable",
                },
                {
                    "field": "update_time_entry_start",
                    "type": "string",
                    "value": "",
                    "helper_text": "New start time (RFC3339 format)",
                    "label": "Start Time",
                    "placeholder": "2024-01-01T09:00:00Z",
                },
                {
                    "field": "update_time_entry_duration_minutes",
                    "type": "int32",
                    "value": 60,
                    "helper_text": "New duration in minutes",
                    "label": "Duration (minutes)",
                    "placeholder": "60",
                },
                {
                    "field": "update_time_entry_task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "New task ID for the time entry",
                    "label": "Task ID",
                    "placeholder": "task123",
                },
            ],
            "outputs": [
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the updated time entry",
                },
                {
                    "field": "time_entry_details",
                    "type": "string",
                    "helper_text": "Time entry details in JSON format",
                },
            ],
            "name": "update_time_entry",
            "task_name": "tasks.clickup.update_time_entry",
            "description": "Update an existing time entry in ClickUp",
            "label": "Update Time Entry",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "time_entry_id",
                "update_time_entry_description",
                "update_time_entry_billable",
                "update_time_entry_start",
                "update_time_entry_duration_minutes",
                "update_time_entry_task_id",
            ],
        },
        "create_space_tag**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the tag",
                    "label": "Tag Name",
                    "placeholder": "urgent",
                },
                {
                    "field": "tag_foreground_color",
                    "type": "string",
                    "value": "#000000",
                    "helper_text": "Foreground color for the tag",
                    "label": "Foreground Color",
                    "placeholder": "#000000",
                },
                {
                    "field": "tag_background_color",
                    "type": "string",
                    "value": "#ffffff",
                    "helper_text": "Background color for the tag",
                    "label": "Background Color",
                    "placeholder": "#ffffff",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag was successfully created",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Name of the created tag",
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the space",
                },
            ],
            "name": "create_space_tag",
            "task_name": "tasks.clickup.create_space_tag",
            "description": "Create a new tag in a ClickUp space",
            "label": "Create Space Tag",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "tag_name",
                "tag_foreground_color",
                "tag_background_color",
            ],
        },
        "delete_space_tag**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the tag to delete",
                    "label": "Tag Name",
                    "placeholder": "urgent",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Name of the deleted tag",
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the space",
                },
            ],
            "name": "delete_space_tag",
            "task_name": "tasks.clickup.delete_space_tag",
            "description": "Delete an existing tag from a ClickUp space",
            "label": "Delete Space Tag",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "tag_name",
            ],
        },
        "get_space_tags**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 100,
                    "helper_text": "Maximum number of tags to fetch",
                    "label": "Max Results",
                    "placeholder": "100",
                },
            ],
            "outputs": [
                {
                    "field": "tag_names",
                    "type": "vec<string>",
                    "helper_text": "List of tag names",
                },
                {
                    "field": "tag_details",
                    "type": "string",
                    "helper_text": "Tags details in JSON format",
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the space",
                },
            ],
            "name": "get_space_tags",
            "task_name": "tasks.clickup.get_space_tags",
            "description": "Get a list of tags from a ClickUp space",
            "label": "Get Space Tags",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "num_messages",
            ],
        },
        "update_space_tag**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Current name of the tag to update",
                    "label": "Current Tag Name",
                    "placeholder": "urgent",
                },
                {
                    "field": "new_tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the tag",
                    "label": "New Tag Name",
                    "placeholder": "high-priority",
                },
                {
                    "field": "tag_foreground_color",
                    "type": "string",
                    "value": "#000000",
                    "helper_text": "New foreground color for the tag",
                    "label": "Foreground Color",
                    "placeholder": "#000000",
                },
                {
                    "field": "tag_background_color",
                    "type": "string",
                    "value": "#ffffff",
                    "helper_text": "New background color for the tag",
                    "label": "Background Color",
                    "placeholder": "#ffffff",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag was successfully updated",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "old_tag_name",
                    "type": "string",
                    "helper_text": "Previous name of the tag",
                },
                {
                    "field": "new_tag_name",
                    "type": "string",
                    "helper_text": "New name of the tag",
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the space",
                },
            ],
            "name": "update_space_tag",
            "task_name": "tasks.clickup.update_space_tag",
            "description": "Update an existing tag in a ClickUp space",
            "label": "Update Space Tag",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "tag_name",
                "new_tag_name",
                "tag_foreground_color",
                "tag_background_color",
            ],
        },
        "add_task_tag**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the tag to add",
                    "label": "Tag Name",
                    "placeholder": "urgent",
                },
                {
                    "field": "custom_task_ids",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Use custom task IDs",
                    "label": "Custom Task IDs",
                },
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team (required if using custom task IDs)",
                    "label": "Team ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag was successfully added",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {"field": "task_id", "type": "string", "helper_text": "ID of the task"},
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Name of the added tag",
                },
            ],
            "name": "add_task_tag",
            "task_name": "tasks.clickup.add_task_tag",
            "description": "Add a tag to a ClickUp task",
            "label": "Add Task Tag",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "task_id",
                "tag_name",
                "custom_task_ids",
                "team_id",
            ],
        },
        "remove_task_tag**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the tag to remove",
                    "label": "Tag Name",
                    "placeholder": "urgent",
                },
                {
                    "field": "custom_task_ids",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Use custom task IDs",
                    "label": "Custom Task IDs",
                },
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team (required if using custom task IDs)",
                    "label": "Team ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag was successfully removed",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {"field": "task_id", "type": "string", "helper_text": "ID of the task"},
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Name of the removed tag",
                },
            ],
            "name": "remove_task_tag",
            "task_name": "tasks.clickup.remove_task_tag",
            "description": "Remove a tag from a ClickUp task",
            "label": "Remove Task Tag",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "task_id",
                "tag_name",
                "custom_task_ids",
                "team_id",
            ],
        },
        "create_task_dependency**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task that depends on another",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "depends_on_task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task that this task depends on",
                    "label": "Depends On Task ID",
                    "placeholder": "xyz789abc123",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the dependency was successfully created",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the dependent task",
                },
                {
                    "field": "depends_on_task_id",
                    "type": "string",
                    "helper_text": "ID of the task this depends on",
                },
            ],
            "name": "create_task_dependency",
            "task_name": "tasks.clickup.create_task_dependency",
            "description": "Create a dependency between two ClickUp tasks",
            "label": "Create Task Dependency",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "task_id",
                "depends_on_task_id",
            ],
        },
        "delete_task_dependency**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task that depends on another",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "depends_on_task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task that this task depends on",
                    "label": "Depends On Task ID",
                    "placeholder": "xyz789abc123",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the dependency was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the dependent task",
                },
                {
                    "field": "depends_on_task_id",
                    "type": "string",
                    "helper_text": "ID of the task this depends on",
                },
            ],
            "name": "delete_task_dependency",
            "task_name": "tasks.clickup.delete_task_dependency",
            "description": "Delete a dependency between two ClickUp tasks",
            "label": "Delete Task Dependency",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "task_id",
                "depends_on_task_id",
            ],
        },
        "add_task_to_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to add",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to add the task to",
                    "label": "List ID",
                    "placeholder": "123456789",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the task was successfully added to the list",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {"field": "task_id", "type": "string", "helper_text": "ID of the task"},
                {"field": "list_id", "type": "string", "helper_text": "ID of the list"},
            ],
            "name": "add_task_to_list",
            "task_name": "tasks.clickup.add_task_to_list",
            "description": "Add a task to an additional ClickUp list",
            "label": "Add Task to List",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "task_id", "list_id"],
        },
        "remove_task_from_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to remove",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to remove the task from",
                    "label": "List ID",
                    "placeholder": "123456789",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the task was successfully removed from the list",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {"field": "task_id", "type": "string", "helper_text": "ID of the task"},
                {"field": "list_id", "type": "string", "helper_text": "ID of the list"},
            ],
            "name": "remove_task_from_list",
            "task_name": "tasks.clickup.remove_task_from_list",
            "description": "Remove a task from a ClickUp list",
            "label": "Remove Task from List",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "task_id", "list_id"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        archived: bool = False,
        assign_user: str = "",
        assignee: str = "",
        assignees: str = "",
        checklist_id: str = "",
        checklist_item_assignee: str = "",
        checklist_item_id: str = "",
        checklist_item_name: str = "",
        checklist_name: str = "",
        comment_text: str = "",
        custom_fields: str = "",
        custom_task_ids: bool = False,
        date_updated_gt: str = "",
        date_updated_lt: str = "",
        depends_on_task_id: str = "",
        due_date_gt: str = "",
        due_date_lt: str = "",
        duration_minutes: int = 60,
        exact_date: Any = {"start": "", "end": ""},
        folder_id: str = "",
        folder_name: str = "",
        get_running: bool = False,
        goal_color: str = "",
        goal_description: str = "",
        goal_due_date: str = "",
        goal_id: str = "",
        goal_multiple_owners: bool = False,
        goal_name: str = "",
        goal_owners: str = "",
        include_closed: bool = False,
        include_completed: bool = False,
        include_location_names: bool = False,
        include_markdown_description: bool = False,
        key_result_id: str = "",
        key_result_list_ids: str = "",
        key_result_name: str = "",
        key_result_owners: str = "",
        key_result_steps_end: int = 100,
        key_result_steps_start: int = 0,
        key_result_task_ids: str = "",
        key_result_type: str = "",
        key_result_unit: str = "",
        list_content: str = "",
        list_id: str = "",
        list_name: str = "",
        new_tag_name: str = "",
        notify_all: bool = False,
        num_messages: int = 10,
        order_by: str = "",
        reverse: bool = False,
        space_features: str = "",
        space_id: str = "",
        space_multiple_assignees: bool = True,
        space_name: str = "",
        start_time: str = "",
        statuses: str = "",
        subtasks: bool = False,
        tag_background_color: str = "#ffffff",
        tag_foreground_color: str = "#000000",
        tag_name: str = "",
        tags: str = "",
        task_assignees: str = "",
        task_description: str = "",
        task_due_date: str = "",
        task_id: str = "",
        task_name: str = "",
        task_priority: int = 3,
        task_start_date: str = "",
        task_status: str = "",
        task_tags: str = "",
        team_id: str = "",
        time_entry_assignee: str = "",
        time_entry_billable: bool = False,
        time_entry_description: str = "",
        time_entry_id: str = "",
        time_entry_tags: str = "",
        update_checklist_item_assignee: str = "",
        update_checklist_item_name: str = "",
        update_checklist_item_parent: str = "",
        update_checklist_item_resolved: bool = False,
        update_checklist_name: str = "",
        update_checklist_position: int = 0,
        update_goal_add_owners: str = "",
        update_goal_color: str = "",
        update_goal_description: str = "",
        update_goal_due_date: str = "",
        update_goal_name: str = "",
        update_goal_remove_owners: str = "",
        update_key_result_name: str = "",
        update_key_result_note: str = "",
        update_key_result_steps_current: int = 0,
        update_key_result_steps_end: int = 100,
        update_key_result_steps_start: int = 0,
        update_key_result_unit: str = "",
        update_task_assignees: str = "",
        update_task_description: str = "",
        update_task_due_date: str = "",
        update_task_name: str = "",
        update_task_priority: int = 3,
        update_task_start_date: str = "",
        update_task_status: str = "",
        update_time_entry_billable: bool = False,
        update_time_entry_description: str = "",
        update_time_entry_duration_minutes: int = 60,
        update_time_entry_start: str = "",
        update_time_entry_task_id: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_clickup",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if team_id is not None:
            self.inputs["team_id"] = team_id
        if space_id is not None:
            self.inputs["space_id"] = space_id
        if folder_id is not None:
            self.inputs["folder_id"] = folder_id
        if list_id is not None:
            self.inputs["list_id"] = list_id
        if task_name is not None:
            self.inputs["task_name"] = task_name
        if task_description is not None:
            self.inputs["task_description"] = task_description
        if task_priority is not None:
            self.inputs["task_priority"] = task_priority
        if task_status is not None:
            self.inputs["task_status"] = task_status
        if task_assignees is not None:
            self.inputs["task_assignees"] = task_assignees
        if task_tags is not None:
            self.inputs["task_tags"] = task_tags
        if task_due_date is not None:
            self.inputs["task_due_date"] = task_due_date
        if task_start_date is not None:
            self.inputs["task_start_date"] = task_start_date
        if task_id is not None:
            self.inputs["task_id"] = task_id
        if update_task_name is not None:
            self.inputs["update_task_name"] = update_task_name
        if update_task_description is not None:
            self.inputs["update_task_description"] = update_task_description
        if update_task_priority is not None:
            self.inputs["update_task_priority"] = update_task_priority
        if update_task_status is not None:
            self.inputs["update_task_status"] = update_task_status
        if update_task_assignees is not None:
            self.inputs["update_task_assignees"] = update_task_assignees
        if update_task_due_date is not None:
            self.inputs["update_task_due_date"] = update_task_due_date
        if update_task_start_date is not None:
            self.inputs["update_task_start_date"] = update_task_start_date
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if archived is not None:
            self.inputs["archived"] = archived
        if include_markdown_description is not None:
            self.inputs["include_markdown_description"] = include_markdown_description
        if include_closed is not None:
            self.inputs["include_closed"] = include_closed
        if subtasks is not None:
            self.inputs["subtasks"] = subtasks
        if reverse is not None:
            self.inputs["reverse"] = reverse
        if order_by is not None:
            self.inputs["order_by"] = order_by
        if statuses is not None:
            self.inputs["statuses"] = statuses
        if assignees is not None:
            self.inputs["assignees"] = assignees
        if tags is not None:
            self.inputs["tags"] = tags
        if due_date_gt is not None:
            self.inputs["due_date_gt"] = due_date_gt
        if due_date_lt is not None:
            self.inputs["due_date_lt"] = due_date_lt
        if date_updated_gt is not None:
            self.inputs["date_updated_gt"] = date_updated_gt
        if date_updated_lt is not None:
            self.inputs["date_updated_lt"] = date_updated_lt
        if custom_fields is not None:
            self.inputs["custom_fields"] = custom_fields
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if comment_text is not None:
            self.inputs["comment_text"] = comment_text
        if assign_user is not None:
            self.inputs["assign_user"] = assign_user
        if notify_all is not None:
            self.inputs["notify_all"] = notify_all
        if list_name is not None:
            self.inputs["list_name"] = list_name
        if list_content is not None:
            self.inputs["list_content"] = list_content
        if folder_name is not None:
            self.inputs["folder_name"] = folder_name
        if space_name is not None:
            self.inputs["space_name"] = space_name
        if space_multiple_assignees is not None:
            self.inputs["space_multiple_assignees"] = space_multiple_assignees
        if space_features is not None:
            self.inputs["space_features"] = space_features
        if checklist_name is not None:
            self.inputs["checklist_name"] = checklist_name
        if checklist_id is not None:
            self.inputs["checklist_id"] = checklist_id
        if update_checklist_name is not None:
            self.inputs["update_checklist_name"] = update_checklist_name
        if update_checklist_position is not None:
            self.inputs["update_checklist_position"] = update_checklist_position
        if checklist_item_name is not None:
            self.inputs["checklist_item_name"] = checklist_item_name
        if checklist_item_assignee is not None:
            self.inputs["checklist_item_assignee"] = checklist_item_assignee
        if checklist_item_id is not None:
            self.inputs["checklist_item_id"] = checklist_item_id
        if update_checklist_item_name is not None:
            self.inputs["update_checklist_item_name"] = update_checklist_item_name
        if update_checklist_item_parent is not None:
            self.inputs["update_checklist_item_parent"] = update_checklist_item_parent
        if update_checklist_item_assignee is not None:
            self.inputs["update_checklist_item_assignee"] = (
                update_checklist_item_assignee
            )
        if update_checklist_item_resolved is not None:
            self.inputs["update_checklist_item_resolved"] = (
                update_checklist_item_resolved
            )
        if goal_name is not None:
            self.inputs["goal_name"] = goal_name
        if goal_description is not None:
            self.inputs["goal_description"] = goal_description
        if goal_due_date is not None:
            self.inputs["goal_due_date"] = goal_due_date
        if goal_color is not None:
            self.inputs["goal_color"] = goal_color
        if goal_multiple_owners is not None:
            self.inputs["goal_multiple_owners"] = goal_multiple_owners
        if goal_owners is not None:
            self.inputs["goal_owners"] = goal_owners
        if goal_id is not None:
            self.inputs["goal_id"] = goal_id
        if include_completed is not None:
            self.inputs["include_completed"] = include_completed
        if update_goal_name is not None:
            self.inputs["update_goal_name"] = update_goal_name
        if update_goal_description is not None:
            self.inputs["update_goal_description"] = update_goal_description
        if update_goal_due_date is not None:
            self.inputs["update_goal_due_date"] = update_goal_due_date
        if update_goal_color is not None:
            self.inputs["update_goal_color"] = update_goal_color
        if update_goal_add_owners is not None:
            self.inputs["update_goal_add_owners"] = update_goal_add_owners
        if update_goal_remove_owners is not None:
            self.inputs["update_goal_remove_owners"] = update_goal_remove_owners
        if key_result_name is not None:
            self.inputs["key_result_name"] = key_result_name
        if key_result_type is not None:
            self.inputs["key_result_type"] = key_result_type
        if key_result_unit is not None:
            self.inputs["key_result_unit"] = key_result_unit
        if key_result_steps_start is not None:
            self.inputs["key_result_steps_start"] = key_result_steps_start
        if key_result_steps_end is not None:
            self.inputs["key_result_steps_end"] = key_result_steps_end
        if key_result_task_ids is not None:
            self.inputs["key_result_task_ids"] = key_result_task_ids
        if key_result_list_ids is not None:
            self.inputs["key_result_list_ids"] = key_result_list_ids
        if key_result_owners is not None:
            self.inputs["key_result_owners"] = key_result_owners
        if key_result_id is not None:
            self.inputs["key_result_id"] = key_result_id
        if update_key_result_name is not None:
            self.inputs["update_key_result_name"] = update_key_result_name
        if update_key_result_note is not None:
            self.inputs["update_key_result_note"] = update_key_result_note
        if update_key_result_steps_current is not None:
            self.inputs["update_key_result_steps_current"] = (
                update_key_result_steps_current
            )
        if update_key_result_steps_start is not None:
            self.inputs["update_key_result_steps_start"] = update_key_result_steps_start
        if update_key_result_steps_end is not None:
            self.inputs["update_key_result_steps_end"] = update_key_result_steps_end
        if update_key_result_unit is not None:
            self.inputs["update_key_result_unit"] = update_key_result_unit
        if start_time is not None:
            self.inputs["start_time"] = start_time
        if duration_minutes is not None:
            self.inputs["duration_minutes"] = duration_minutes
        if time_entry_description is not None:
            self.inputs["time_entry_description"] = time_entry_description
        if time_entry_billable is not None:
            self.inputs["time_entry_billable"] = time_entry_billable
        if time_entry_assignee is not None:
            self.inputs["time_entry_assignee"] = time_entry_assignee
        if time_entry_tags is not None:
            self.inputs["time_entry_tags"] = time_entry_tags
        if time_entry_id is not None:
            self.inputs["time_entry_id"] = time_entry_id
        if get_running is not None:
            self.inputs["get_running"] = get_running
        if assignee is not None:
            self.inputs["assignee"] = assignee
        if include_location_names is not None:
            self.inputs["include_location_names"] = include_location_names
        if update_time_entry_description is not None:
            self.inputs["update_time_entry_description"] = update_time_entry_description
        if update_time_entry_billable is not None:
            self.inputs["update_time_entry_billable"] = update_time_entry_billable
        if update_time_entry_start is not None:
            self.inputs["update_time_entry_start"] = update_time_entry_start
        if update_time_entry_duration_minutes is not None:
            self.inputs["update_time_entry_duration_minutes"] = (
                update_time_entry_duration_minutes
            )
        if update_time_entry_task_id is not None:
            self.inputs["update_time_entry_task_id"] = update_time_entry_task_id
        if tag_name is not None:
            self.inputs["tag_name"] = tag_name
        if tag_foreground_color is not None:
            self.inputs["tag_foreground_color"] = tag_foreground_color
        if tag_background_color is not None:
            self.inputs["tag_background_color"] = tag_background_color
        if new_tag_name is not None:
            self.inputs["new_tag_name"] = new_tag_name
        if custom_task_ids is not None:
            self.inputs["custom_task_ids"] = custom_task_ids
        if depends_on_task_id is not None:
            self.inputs["depends_on_task_id"] = depends_on_task_id
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def assignees(self) -> List[str]:
        """
        List of assignees for the task

        Available: When action = 'read_task'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignees")

    @property
    def checklist_details(self) -> str:
        """
        Checklist details in JSON format

        Available: When action = 'create_checklist', When action = 'update_checklist', When action = 'create_checklist_item', When action = 'update_checklist_item'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("checklist_details")

    @property
    def checklist_id(self) -> str:
        """
        ID of the created checklist

        Different behavior based on configuration:
          - ID of the created checklist (When action = 'create_checklist')
          - ID of the deleted checklist (When action = 'delete_checklist')
          - ID of the updated checklist (When action = 'update_checklist')
          - ID of the checklist (When action = 'create_checklist_item', When action = 'delete_checklist_item', When action = 'update_checklist_item')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("checklist_id")

    @property
    def checklist_item_id(self) -> str:
        """
        ID of the deleted checklist item

        Available: When action = 'delete_checklist_item'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("checklist_item_id")

    @property
    def checklist_name(self) -> str:
        """
        Name of the created checklist

        Different behavior based on configuration:
          - Name of the created checklist (When action = 'create_checklist')
          - Name of the updated checklist (When action = 'update_checklist')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("checklist_name")

    @property
    def comment_details(self) -> str:
        """
        Comment details in JSON format

        Different behavior based on configuration:
          - Comment details in JSON format (When action = 'create_comment')
          - Comments details in JSON format (When action = 'get_comments')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_details")

    @property
    def comment_id(self) -> str:
        """
        ID of the created comment

        Available: When action = 'create_comment'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_id")

    @property
    def comment_ids(self) -> List[str]:
        """
        List of comment IDs

        Available: When action = 'get_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_ids")

    @property
    def comment_text(self) -> str:
        """
        Text of the created comment

        Available: When action = 'create_comment'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_text")

    @property
    def comment_texts(self) -> List[str]:
        """
        List of comment texts

        Available: When action = 'get_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_texts")

    @property
    def comment_users(self) -> List[str]:
        """
        List of comment authors

        Available: When action = 'get_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_users")

    @property
    def created_at(self) -> str:
        """
        Creation timestamp of the task

        Different behavior based on configuration:
          - Creation timestamp of the task (When action = 'create_task', When action = 'read_task')
          - Creation timestamp of the comment (When action = 'create_comment')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_at")

    @property
    def depends_on_task_id(self) -> str:
        """
        ID of the task this depends on

        Available: When action = 'create_task_dependency', When action = 'delete_task_dependency'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("depends_on_task_id")

    @property
    def description(self) -> str:
        """
        Description of the task

        Available: When action = 'read_task'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("description")

    @property
    def due_date(self) -> str:
        """
        Due date of the task

        Available: When action = 'read_task'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("due_date")

    @property
    def folder_details(self) -> str:
        """
        Folder details in JSON format

        Different behavior based on configuration:
          - Folder details in JSON format (When action = 'create_folder', When action = 'read_folder')
          - Folders details in JSON format (When action = 'get_folders')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("folder_details")

    @property
    def folder_id(self) -> str:
        """
        ID of the created folder

        Different behavior based on configuration:
          - ID of the created folder (When action = 'create_folder')
          - ID of the folder (When action = 'read_folder')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("folder_id")

    @property
    def folder_ids(self) -> List[str]:
        """
        List of folder IDs

        Available: When action = 'get_folders'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("folder_ids")

    @property
    def folder_name(self) -> str:
        """
        Name of the created folder

        Different behavior based on configuration:
          - Name of the created folder (When action = 'create_folder')
          - Name of the folder (When action = 'read_folder')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("folder_name")

    @property
    def folder_names(self) -> List[str]:
        """
        List of folder names

        Available: When action = 'get_folders'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("folder_names")

    @property
    def goal_details(self) -> str:
        """
        Goal details in JSON format

        Different behavior based on configuration:
          - Goal details in JSON format (When action = 'create_goal', When action = 'get_goal', When action = 'update_goal')
          - Goals details in JSON format (When action = 'get_goals')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("goal_details")

    @property
    def goal_id(self) -> str:
        """
        ID of the created goal

        Different behavior based on configuration:
          - ID of the created goal (When action = 'create_goal')
          - ID of the deleted goal (When action = 'delete_goal')
          - ID of the goal (When action = 'get_goal')
          - ID of the updated goal (When action = 'update_goal')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("goal_id")

    @property
    def goal_ids(self) -> List[str]:
        """
        List of goal IDs

        Available: When action = 'get_goals'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("goal_ids")

    @property
    def goal_name(self) -> str:
        """
        Name of the created goal

        Different behavior based on configuration:
          - Name of the created goal (When action = 'create_goal')
          - Name of the goal (When action = 'get_goal')
          - Name of the updated goal (When action = 'update_goal')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("goal_name")

    @property
    def goal_names(self) -> List[str]:
        """
        List of goal names

        Available: When action = 'get_goals'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("goal_names")

    @property
    def key_result_details(self) -> str:
        """
        Key result details in JSON format

        Available: When action = 'create_goal_key_result', When action = 'update_goal_key_result'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("key_result_details")

    @property
    def key_result_id(self) -> str:
        """
        ID of the created key result

        Different behavior based on configuration:
          - ID of the created key result (When action = 'create_goal_key_result')
          - ID of the deleted key result (When action = 'delete_goal_key_result')
          - ID of the updated key result (When action = 'update_goal_key_result')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("key_result_id")

    @property
    def key_result_name(self) -> str:
        """
        Name of the created key result

        Different behavior based on configuration:
          - Name of the created key result (When action = 'create_goal_key_result')
          - Name of the updated key result (When action = 'update_goal_key_result')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("key_result_name")

    @property
    def list_details(self) -> str:
        """
        List details in JSON format

        Different behavior based on configuration:
          - List details in JSON format (When action = 'create_list', When action = 'read_list')
          - Lists details in JSON format (When action = 'get_lists')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("list_details")

    @property
    def list_id(self) -> str:
        """
        ID of the created list

        Different behavior based on configuration:
          - ID of the created list (When action = 'create_list')
          - ID of the list (When action = 'read_list', When action = 'add_task_to_list', When action = 'remove_task_from_list')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("list_id")

    @property
    def list_ids(self) -> List[str]:
        """
        List of list IDs

        Available: When action = 'get_lists'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("list_ids")

    @property
    def list_name(self) -> str:
        """
        Name of the created list

        Different behavior based on configuration:
          - Name of the created list (When action = 'create_list')
          - Name of the list (When action = 'read_list')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("list_name")

    @property
    def list_names(self) -> List[str]:
        """
        List of list names

        Available: When action = 'get_lists'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("list_names")

    @property
    def message(self) -> str:
        """
        Success message

        Available: When action = 'delete_task', When action = 'delete_checklist', When action = 'delete_checklist_item', When action = 'delete_goal', When action = 'delete_goal_key_result', When action = 'delete_time_entry', When action = 'start_time_entry', When action = 'stop_time_entry', When action = 'create_space_tag', When action = 'delete_space_tag', When action = 'update_space_tag', When action = 'add_task_tag', When action = 'remove_task_tag', When action = 'create_task_dependency', When action = 'delete_task_dependency', When action = 'add_task_to_list', When action = 'remove_task_from_list'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("message")

    @property
    def new_tag_name(self) -> str:
        """
        New name of the tag

        Available: When action = 'update_space_tag'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("new_tag_name")

    @property
    def old_tag_name(self) -> str:
        """
        Previous name of the tag

        Available: When action = 'update_space_tag'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("old_tag_name")

    @property
    def priority(self) -> str:
        """
        Priority of the task

        Available: When action = 'read_task'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("priority")

    @property
    def raw_data(self) -> str:
        """
        Raw API response data in JSON format

        Available: When action = 'get_tasks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("raw_data")

    @property
    def response_data(self) -> str:
        """
        Response data from the API

        Available: When action = 'delete_time_entry'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response_data")

    @property
    def space_details(self) -> str:
        """
        Space details in JSON format

        Available: When action = 'create_space', When action = 'read_space'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("space_details")

    @property
    def space_id(self) -> str:
        """
        ID of the created space

        Different behavior based on configuration:
          - ID of the created space (When action = 'create_space')
          - ID of the space (When action = 'read_space', When action = 'create_space_tag', When action = 'delete_space_tag', When action = 'get_space_tags', When action = 'update_space_tag')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("space_id")

    @property
    def space_name(self) -> str:
        """
        Name of the created space

        Different behavior based on configuration:
          - Name of the created space (When action = 'create_space')
          - Name of the space (When action = 'read_space')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("space_name")

    @property
    def start_date(self) -> str:
        """
        Start date of the task

        Available: When action = 'read_task'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("start_date")

    @property
    def status(self) -> str:
        """
        Status of the created task

        Different behavior based on configuration:
          - Status of the created task (When action = 'create_task')
          - Status of the updated task (When action = 'update_task')
          - Status of the task (When action = 'read_task')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("status")

    @property
    def success(self) -> bool:
        """
        Whether the task was successfully deleted

        Different behavior based on configuration:
          - Whether the task was successfully deleted (When action = 'delete_task')
          - Whether the checklist was successfully deleted (When action = 'delete_checklist')
          - Whether the checklist item was successfully deleted (When action = 'delete_checklist_item')
          - Whether the goal was successfully deleted (When action = 'delete_goal')
          - Whether the key result was successfully deleted (When action = 'delete_goal_key_result')
          - Whether the time entry was successfully deleted (When action = 'delete_time_entry')
          - Whether the tag was successfully created (When action = 'create_space_tag')
          - Whether the tag was successfully deleted (When action = 'delete_space_tag')
          - Whether the tag was successfully updated (When action = 'update_space_tag')
          - Whether the tag was successfully added (When action = 'add_task_tag')
          - Whether the tag was successfully removed (When action = 'remove_task_tag')
          - Whether the dependency was successfully created (When action = 'create_task_dependency')
          - Whether the dependency was successfully deleted (When action = 'delete_task_dependency')
          - Whether the task was successfully added to the list (When action = 'add_task_to_list')
          - Whether the task was successfully removed from the list (When action = 'remove_task_from_list')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("success")

    @property
    def tag_details(self) -> str:
        """
        Tags details in JSON format

        Available: When action = 'get_space_tags'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tag_details")

    @property
    def tag_name(self) -> str:
        """
        Name of the created tag

        Different behavior based on configuration:
          - Name of the created tag (When action = 'create_space_tag')
          - Name of the deleted tag (When action = 'delete_space_tag')
          - Name of the added tag (When action = 'add_task_tag')
          - Name of the removed tag (When action = 'remove_task_tag')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tag_name")

    @property
    def tag_names(self) -> List[str]:
        """
        List of tag names

        Available: When action = 'get_space_tags'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tag_names")

    @property
    def tags(self) -> List[str]:
        """
        List of tags for the task

        Available: When action = 'read_task'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tags")

    @property
    def task_assignees(self) -> str:
        """
        Task assignees in JSON format

        Available: When action = 'get_tasks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_assignees")

    @property
    def task_created_dates(self) -> List[str]:
        """
        List of task creation dates

        Available: When action = 'get_tasks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_created_dates")

    @property
    def task_descriptions(self) -> List[str]:
        """
        List of task descriptions

        Available: When action = 'get_tasks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_descriptions")

    @property
    def task_details(self) -> str:
        """
        Task details in JSON format

        Different behavior based on configuration:
          - Task details in JSON format (When action = 'create_task', When action = 'update_task', When action = 'read_task')
          - Tasks details in JSON format (When action = 'get_tasks')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_details")

    @property
    def task_due_dates(self) -> List[str]:
        """
        List of task due dates

        Available: When action = 'get_tasks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_due_dates")

    @property
    def task_id(self) -> str:
        """
        ID of the created task

        Different behavior based on configuration:
          - ID of the created task (When action = 'create_task')
          - ID of the updated task (When action = 'update_task')
          - ID of the task (When action = 'read_task', When action = 'add_task_tag', When action = 'remove_task_tag', When action = 'add_task_to_list', When action = 'remove_task_from_list')
          - ID of the deleted task (When action = 'delete_task')
          - ID of the dependent task (When action = 'create_task_dependency', When action = 'delete_task_dependency')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_id")

    @property
    def task_ids(self) -> List[str]:
        """
        List of task IDs

        Available: When action = 'get_tasks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_ids")

    @property
    def task_name(self) -> str:
        """
        Name of the created task

        Different behavior based on configuration:
          - Name of the created task (When action = 'create_task')
          - Name of the updated task (When action = 'update_task')
          - Name of the task (When action = 'read_task')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_name")

    @property
    def task_names(self) -> List[str]:
        """
        List of task names

        Available: When action = 'get_tasks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_names")

    @property
    def task_priorities(self) -> str:
        """
        Task priorities in JSON format

        Available: When action = 'get_tasks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_priorities")

    @property
    def task_start_dates(self) -> List[str]:
        """
        List of task start dates

        Available: When action = 'get_tasks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_start_dates")

    @property
    def task_statuses(self) -> List[str]:
        """
        List of task statuses

        Available: When action = 'get_tasks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_statuses")

    @property
    def task_tags(self) -> str:
        """
        Task tags in JSON format

        Available: When action = 'get_tasks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_tags")

    @property
    def task_updated_dates(self) -> List[str]:
        """
        List of task update dates

        Available: When action = 'get_tasks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_updated_dates")

    @property
    def task_url(self) -> str:
        """
        URL of the created task

        Different behavior based on configuration:
          - URL of the created task (When action = 'create_task')
          - URL of the updated task (When action = 'update_task')
          - URL of the task (When action = 'read_task')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_url")

    @property
    def task_urls(self) -> List[str]:
        """
        List of task URLs

        Available: When action = 'get_tasks'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("task_urls")

    @property
    def time_entry_details(self) -> str:
        """
        Time entry details in JSON format

        Different behavior based on configuration:
          - Time entry details in JSON format (When action = 'create_time_entry', When action = 'get_time_entry', When action = 'start_time_entry', When action = 'stop_time_entry', When action = 'update_time_entry')
          - Time entries details in JSON format (When action = 'get_time_entries')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("time_entry_details")

    @property
    def time_entry_id(self) -> str:
        """
        ID of the created time entry

        Different behavior based on configuration:
          - ID of the created time entry (When action = 'create_time_entry')
          - ID of the deleted time entry (When action = 'delete_time_entry')
          - ID of the time entry (When action = 'get_time_entry')
          - ID of the started time entry (When action = 'start_time_entry')
          - ID of the stopped time entry (When action = 'stop_time_entry')
          - ID of the updated time entry (When action = 'update_time_entry')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("time_entry_id")

    @property
    def time_entry_ids(self) -> List[str]:
        """
        List of time entry IDs

        Available: When action = 'get_time_entries'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("time_entry_ids")

    @property
    def updated_at(self) -> str:
        """
        Update timestamp of the task

        Different behavior based on configuration:
          - Update timestamp of the task (When action = 'update_task')
          - Last update timestamp of the task (When action = 'read_task')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated_at")

    @property
    def user(self) -> str:
        """
        User who created the comment

        Available: When action = 'create_comment'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("user")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationClickupNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("zapier")
class ZapierNode(Node):
    """


    ## Inputs
    ### Common Inputs
        payload: Text/JSON payload to deliver
        webhook_url: the Zapier URL to deliver the payload to

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "payload",
            "helper_text": "Text/JSON payload to deliver",
            "value": "",
            "type": "string",
        },
        {
            "field": "webhook_url",
            "helper_text": "the Zapier URL to deliver the payload to",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        payload: str = "",
        webhook_url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="zapier",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if payload is not None:
            self.inputs["payload"] = payload
        if webhook_url is not None:
            self.inputs["webhook_url"] = webhook_url

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "ZapierNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("make")
class MakeNode(Node):
    """


    ## Inputs
    ### Common Inputs
        payload: Text/JSON payload to deliver
        webhook_url: the Make URL to deliver the payload to

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "payload",
            "helper_text": "Text/JSON payload to deliver",
            "value": "",
            "type": "string",
        },
        {
            "field": "webhook_url",
            "helper_text": "the Make URL to deliver the payload to",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        payload: str = "",
        webhook_url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="make",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if payload is not None:
            self.inputs["payload"] = payload
        if webhook_url is not None:
            self.inputs["webhook_url"] = webhook_url

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "MakeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("text_manipulation")
class TextManipulationNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="text_manipulation",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "TextManipulationNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("file_operations")
class FileOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="file_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "FileOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_operations")
class AiOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="ai_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "AiOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("file_to_text")
class FileToTextNode(Node):
    """
    Convert data from type File to type Text

    ## Inputs
    ### Common Inputs
        chunk_text: Whether to chunk the text into smaller pieces.
        file: The file to convert to text.
        file_parser: The type of file parser to use.
        loader_type: The type of file to load.
    ### When chunk_text = True
        chunk_overlap: The overlap of each chunk of text.
        chunk_size: The size of each chunk of text.

    ## Outputs
    ### When chunk_text = True
        processed_text: The text as a list of chunks.
    ### When chunk_text = False
        processed_text: The text as a string.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_text",
            "helper_text": "Whether to chunk the text into smaller pieces.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "file",
            "helper_text": "The file to convert to text.",
            "value": None,
            "type": "file",
        },
        {
            "field": "file_parser",
            "helper_text": "The type of file parser to use.",
            "value": "default",
            "type": "enum<string>",
        },
        {
            "field": "loader_type",
            "helper_text": "The type of file to load.",
            "value": "File",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "chunk_size",
                    "type": "int32",
                    "value": 1024,
                    "helper_text": "The size of each chunk of text.",
                },
                {
                    "field": "chunk_overlap",
                    "type": "int32",
                    "value": 400,
                    "helper_text": "The overlap of each chunk of text.",
                },
            ],
            "outputs": [
                {
                    "field": "processed_text",
                    "type": "vec<string>",
                    "helper_text": "The text as a list of chunks.",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "processed_text",
                    "type": "string",
                    "helper_text": "The text as a string.",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["chunk_text"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_text: bool = False,
        chunk_overlap: int = 400,
        chunk_size: int = 1024,
        file: Optional[str] = None,
        file_parser: str = "default",
        loader_type: str = "File",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["chunk_text"] = chunk_text

        super().__init__(
            node_type="file_to_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file is not None:
            self.inputs["file"] = file
        if chunk_text is not None:
            self.inputs["chunk_text"] = chunk_text
        if file_parser is not None:
            self.inputs["file_parser"] = file_parser
        if loader_type is not None:
            self.inputs["loader_type"] = loader_type
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def processed_text(self) -> List[str]:
        """
        The text as a list of chunks.

        Different behavior based on configuration:
          - The text as a list of chunks. (When chunk_text = True)
          - The text as a string. (When chunk_text = False)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_text")

    @classmethod
    def from_dict(cls, data: dict) -> "FileToTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("code_execution")
class CodeExecutionNode(Node):
    """


    ## Inputs
    ### Common Inputs
        code: The code input
        language: The language input

    ## Outputs
    ### Common Outputs
        outputs: The outputs output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "code",
            "helper_text": "The code input",
            "value": "",
            "type": "string",
        },
        {
            "field": "language",
            "helper_text": "The language input",
            "value": 0,
            "type": "enum<int32>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "outputs", "helper_text": "The outputs output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        code: str = "",
        language: int = 0,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="code_execution",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if code is not None:
            self.inputs["code"] = code
        if language is not None:
            self.inputs["language"] = language

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def outputs(self) -> str:
        """
        The outputs output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("outputs")

    @classmethod
    def from_dict(cls, data: dict) -> "CodeExecutionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("chunking")
class ChunkingNode(Node):
    """
    Split text into chunks. Supports different chunking strategies like markdown-aware, sentence-based, or dynamic sizing.

    ## Inputs
    ### Common Inputs
        chunk_overlap: The overlap of each chunk of text.
        chunk_size: The size of each chunk of text.
        splitter_method: Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.
        text: The text to chunk
    ### dynamic
        segmentation_method: The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.

    ## Outputs
    ### Common Outputs
        chunks: The chunks output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_overlap",
            "helper_text": "The overlap of each chunk of text.",
            "value": 0,
            "type": "int32",
        },
        {
            "field": "chunk_size",
            "helper_text": "The size of each chunk of text.",
            "value": 512,
            "type": "int32",
        },
        {
            "field": "splitter_method",
            "helper_text": "Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.",
            "value": "markdown",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to chunk",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "chunks", "helper_text": "The chunks output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "dynamic": {
            "inputs": [
                {
                    "field": "segmentation_method",
                    "type": "enum<string>",
                    "value": "words",
                    "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["splitter_method"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        splitter_method: str = "markdown",
        chunk_overlap: int = 0,
        chunk_size: int = 512,
        segmentation_method: str = "words",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["splitter_method"] = splitter_method

        super().__init__(
            node_type="chunking",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap
        if splitter_method is not None:
            self.inputs["splitter_method"] = splitter_method
        if segmentation_method is not None:
            self.inputs["segmentation_method"] = segmentation_method

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def chunks(self) -> List[str]:
        """
        The chunks output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("chunks")

    @classmethod
    def from_dict(cls, data: dict) -> "ChunkingNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("notifications")
class NotificationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="notifications",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "NotificationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("custom_smtp_email_sender")
class CustomSmtpEmailSenderNode(Node):
    """
    Send emails via SMTP

    ## Inputs
    ### Common Inputs
        connection_type: Security type: SSL, TLS, or STARTTLS
        email_body: Email content
        email_subject: Subject line of the email
        recipient_email: Recipient email address(es), comma-separated
        send_as_html: Send email in HTML format
        sender_email: Sender email address
        sender_name: Display name for sender (optional)
        sender_password: SMTP server password
        smtp_server: SMTP server hostname or IP
        smtp_server_port: SMTP server port (25, 465, 587)

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "connection_type",
            "helper_text": "Security type: SSL, TLS, or STARTTLS",
            "value": "SSL",
            "type": "enum<string>",
        },
        {
            "field": "email_body",
            "helper_text": "Email content",
            "value": "",
            "type": "string",
        },
        {
            "field": "email_subject",
            "helper_text": "Subject line of the email",
            "value": "",
            "type": "string",
        },
        {
            "field": "recipient_email",
            "helper_text": "Recipient email address(es), comma-separated",
            "value": "",
            "type": "string",
        },
        {
            "field": "send_as_html",
            "helper_text": "Send email in HTML format",
            "value": "",
            "type": "bool",
        },
        {
            "field": "sender_email",
            "helper_text": "Sender email address",
            "value": "",
            "type": "string",
        },
        {
            "field": "sender_name",
            "helper_text": "Display name for sender (optional)",
            "value": "",
            "type": "string",
        },
        {
            "field": "sender_password",
            "helper_text": "SMTP server password",
            "value": "",
            "type": "string",
        },
        {
            "field": "smtp_server",
            "helper_text": "SMTP server hostname or IP",
            "value": "",
            "type": "string",
        },
        {
            "field": "smtp_server_port",
            "helper_text": "SMTP server port (25, 465, 587)",
            "value": 465,
            "type": "int32",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        connection_type: str = "SSL",
        email_body: str = "",
        email_subject: str = "",
        recipient_email: str = "",
        send_as_html: bool = False,
        sender_email: str = "",
        sender_name: str = "",
        sender_password: str = "",
        smtp_server: str = "",
        smtp_server_port: int = 465,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="custom_smtp_email_sender",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if recipient_email is not None:
            self.inputs["recipient_email"] = recipient_email
        if email_subject is not None:
            self.inputs["email_subject"] = email_subject
        if email_body is not None:
            self.inputs["email_body"] = email_body
        if send_as_html is not None:
            self.inputs["send_as_html"] = send_as_html
        if smtp_server is not None:
            self.inputs["smtp_server"] = smtp_server
        if smtp_server_port is not None:
            self.inputs["smtp_server_port"] = smtp_server_port
        if sender_email is not None:
            self.inputs["sender_email"] = sender_email
        if sender_password is not None:
            self.inputs["sender_password"] = sender_password
        if sender_name is not None:
            self.inputs["sender_name"] = sender_name
        if connection_type is not None:
            self.inputs["connection_type"] = connection_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "CustomSmtpEmailSenderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("email_notification")
class EmailNotificationNode(Node):
    """
    Send email notifications from no-reply@vectorshiftmail.com

    ## Inputs
    ### Common Inputs
        email_body: Email content
        email_subject: Subject line of the email
        recipient_email: Recipient email address(es), comma-separated
        send_as_html: Send email in HTML format

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "email_body",
            "helper_text": "Email content",
            "value": "",
            "type": "string",
        },
        {
            "field": "email_subject",
            "helper_text": "Subject line of the email",
            "value": "",
            "type": "string",
        },
        {
            "field": "recipient_email",
            "helper_text": "Recipient email address(es), comma-separated",
            "value": "",
            "type": "string",
        },
        {
            "field": "send_as_html",
            "helper_text": "Send email in HTML format",
            "value": "",
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        email_body: str = "",
        email_subject: str = "",
        recipient_email: str = "",
        send_as_html: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="email_notification",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if recipient_email is not None:
            self.inputs["recipient_email"] = recipient_email
        if email_subject is not None:
            self.inputs["email_subject"] = email_subject
        if email_body is not None:
            self.inputs["email_body"] = email_body
        if send_as_html is not None:
            self.inputs["send_as_html"] = send_as_html

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "EmailNotificationNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("sms_notification")
class SmsNotificationNode(Node):
    """
    Send text message notifications.

    ## Inputs
    ### Common Inputs
        message: SMS message content
        phone_number: US phone number in country code (+1)

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "message",
            "helper_text": "SMS message content",
            "value": "",
            "type": "string",
        },
        {
            "field": "phone_number",
            "helper_text": "US phone number in country code (+1)",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        message: str = "",
        phone_number: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="sms_notification",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if phone_number is not None:
            self.inputs["phone_number"] = phone_number
        if message is not None:
            self.inputs["message"] = message

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "SmsNotificationNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_filter_list")
class AiFilterListNode(Node):
    """
    Filter items in a list given a specific AI condition. Example, Filter (Red, White, Boat) by whether it is a color: (Red, White)

    ## Inputs
    ### Common Inputs
        ai_condition: Write in natural language the condition to filter each item in the list
        filter_by: The items to filter the list by
        list_to_filter: The list to filter
        model: The specific model for filtering
        output_blank_value: If true, output a blank value for values that do not meet the filter condition. If false, nothing will be outputted
        provider: The model provider

    ## Outputs
    ### Common Outputs
        output: The filtered list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "ai_condition",
            "helper_text": "Write in natural language the condition to filter each item in the list",
            "value": "",
            "type": "string",
        },
        {
            "field": "filter_by",
            "helper_text": "The items to filter the list by",
            "value": "",
            "type": "vec<string>",
        },
        {
            "field": "list_to_filter",
            "helper_text": "The list to filter",
            "value": "",
            "type": "vec<string>",
        },
        {
            "field": "model",
            "helper_text": "The specific model for filtering",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "output_blank_value",
            "helper_text": "If true, output a blank value for values that do not meet the filter condition. If false, nothing will be outputted",
            "value": False,
            "type": "bool",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The filtered list"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        ai_condition: str = "",
        filter_by: List[str] = [],
        list_to_filter: List[str] = [],
        model: str = "gpt-4o",
        output_blank_value: bool = False,
        provider: str = "openai",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="ai_filter_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if list_to_filter is not None:
            self.inputs["list_to_filter"] = list_to_filter
        if filter_by is not None:
            self.inputs["filter_by"] = filter_by
        if ai_condition is not None:
            self.inputs["ai_condition"] = ai_condition
        if output_blank_value is not None:
            self.inputs["output_blank_value"] = output_blank_value
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[str]:
        """
        The filtered list


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "AiFilterListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("filter_list")
class FilterListNode(Node):
    """
    Filter a list given a specific condition. Example, Filter (Red, White, Blue) by (100, 95, 80)>90 is (Red, White)

    ## Inputs
    ### Common Inputs
        condition_type: The type of condition to apply
        condition_value: The value to compare the list items against
        output_blank_value: If true, output a blank value for values that do not meet the filter condition. If false, nothing will be outputted
        type: The type of the list
    ### <T>
        filter_by: The items to filter the list by
        list_to_filter: The list to filter

    ## Outputs
    ### <T>
        output: The filtered list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "condition_type",
            "helper_text": "The type of condition to apply",
            "value": "IsEmpty",
            "type": "enum<string>",
        },
        {
            "field": "condition_value",
            "helper_text": "The value to compare the list items against",
            "value": "",
            "type": "string",
        },
        {
            "field": "output_blank_value",
            "helper_text": "If true, output a blank value for values that do not meet the filter condition. If false, nothing will be outputted",
            "value": False,
            "type": "bool",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list_to_filter",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The list to filter",
                },
                {
                    "field": "filter_by",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The items to filter the list by",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The filtered list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        condition_type: str = "IsEmpty",
        condition_value: str = "",
        filter_by: List[Any] = [],
        list_to_filter: List[Any] = [],
        output_blank_value: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="filter_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if condition_type is not None:
            self.inputs["condition_type"] = condition_type
        if condition_value is not None:
            self.inputs["condition_value"] = condition_value
        if output_blank_value is not None:
            self.inputs["output_blank_value"] = output_blank_value
        if list_to_filter is not None:
            self.inputs["list_to_filter"] = list_to_filter
        if filter_by is not None:
            self.inputs["filter_by"] = filter_by

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[Any]:
        """
        The filtered list

        Available: <T>


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "FilterListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("sales_data_enrichment")
class SalesDataEnrichmentNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="sales_data_enrichment",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "SalesDataEnrichmentNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("email_validator")
class EmailValidatorNode(Node):
    """
    Validate an email address

    ## Inputs
    ### Common Inputs
        email_to_validate: The email you want to validate
        model: The validation model to use
    ### custom-validator
        api_key: The API key to use
        provider: The validation provider to use

    ## Outputs
    ### Common Outputs
        status: Whether the email is valid
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "email_to_validate",
            "helper_text": "The email you want to validate",
            "value": "",
            "type": "string",
        },
        {
            "field": "model",
            "helper_text": "The validation model to use",
            "value": "regex",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "status", "helper_text": "Whether the email is valid"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "custom-validator": {
            "inputs": [
                {
                    "field": "provider",
                    "type": "enum<string>",
                    "value": "hunter",
                    "helper_text": "The validation provider to use",
                },
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "The API key to use",
                },
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["model"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        model: str = "regex",
        api_key: str = "",
        email_to_validate: str = "",
        provider: str = "hunter",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["model"] = model

        super().__init__(
            node_type="email_validator",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if email_to_validate is not None:
            self.inputs["email_to_validate"] = email_to_validate
        if model is not None:
            self.inputs["model"] = model
        if provider is not None:
            self.inputs["provider"] = provider
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def status(self) -> bool:
        """
        Whether the email is valid


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("status")

    @classmethod
    def from_dict(cls, data: dict) -> "EmailValidatorNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("combine_text")
class CombineTextNode(Node):
    """
    Combine text inputs into a singular output.

    ## Inputs
    ### Common Inputs
        text: The text to combine

    ## Outputs
    ### Common Outputs
        processed_text: The combined text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "text",
            "helper_text": "The text to combine",
            "value": ["", ""],
            "type": "vec<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "processed_text", "helper_text": "The combined text"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        text: List[str] = ["", ""],
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="combine_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def processed_text(self) -> str:
        """
        The combined text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_text")

    @classmethod
    def from_dict(cls, data: dict) -> "CombineTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("find_and_replace")
class FindAndReplaceNode(Node):
    """
    Find and replace words in a given text.

    ## Inputs
    ### Common Inputs
        replacements: The replacements input
        text_to_manipulate: The text to find and replace words in

    ## Outputs
    ### Common Outputs
        processed_text: The final text with found words replaced
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "replacements",
            "helper_text": "The replacements input",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "text_to_manipulate",
            "helper_text": "The text to find and replace words in",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "processed_text",
            "helper_text": "The final text with found words replaced",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        replacements: List[Any] = [],
        text_to_manipulate: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="find_and_replace",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text_to_manipulate is not None:
            self.inputs["text_to_manipulate"] = text_to_manipulate
        if replacements is not None:
            self.inputs["replacements"] = replacements

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def processed_text(self) -> str:
        """
        The final text with found words replaced


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_text")

    @classmethod
    def from_dict(cls, data: dict) -> "FindAndReplaceNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_fill_pdf")
class AiFillPdfNode(Node):
    """
    Fill out a PDF with form fields using AI. The AI will understand and fill each field using provided context. To convert your PDF to have fillable input fields, use: https://www.sejda.com/pdf-forms

    ## Inputs
    ### Common Inputs
        context: Context used by LLM to fill PDF fields
        file: The PDF with form fields to be filled
        model: The specific model for filling the PDF
        provider: The model provider
        select_pages: Whether to select specific pages to fill
    ### When select_pages = True
        selected_pages: PDF page range

    ## Outputs
    ### Common Outputs
        filled_pdf: Filled PDF
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "context",
            "helper_text": "Context used by LLM to fill PDF fields",
            "value": "",
            "type": "string",
        },
        {
            "field": "file",
            "helper_text": "The PDF with form fields to be filled",
            "value": None,
            "type": "file",
        },
        {
            "field": "model",
            "helper_text": "The specific model for filling the PDF",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "select_pages",
            "helper_text": "Whether to select specific pages to fill",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "filled_pdf", "helper_text": "Filled PDF"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "selected_pages",
                    "type": "string",
                    "value": "",
                    "helper_text": "PDF page range",
                }
            ],
            "outputs": [],
        },
        "false": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["select_pages"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        select_pages: bool = False,
        context: str = "",
        file: Optional[str] = None,
        model: str = "gpt-4o",
        provider: str = "openai",
        selected_pages: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["select_pages"] = select_pages

        super().__init__(
            node_type="ai_fill_pdf",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file is not None:
            self.inputs["file"] = file
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if select_pages is not None:
            self.inputs["select_pages"] = select_pages
        if context is not None:
            self.inputs["context"] = context
        if selected_pages is not None:
            self.inputs["selected_pages"] = selected_pages

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def filled_pdf(self) -> str:
        """
        Filled PDF


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("filled_pdf")

    @classmethod
    def from_dict(cls, data: dict) -> "AiFillPdfNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("extract_to_table")
class ExtractToTableNode(Node):
    """
    Extract data to a CSV using AI

    ## Inputs
    ### Common Inputs
        add_columns_manually: Add data points for some columns manually instead of having them extracted by the AI model.
        additional_context: Provide any additional context that may help the AI model extract the data.
        extract_multiple_rows: Choose the mode of extraction. If checked, it will extract multiple rows of data. If unchecked, it will extract a single row.
        file: Your file should contain headers in the first row.
        manual_columns: Pass in data to column names manually.
        model: The specific model for extracting the table
        provider: The model provider
        text_for_extraction: Text to extract table from

    ## Outputs
    ### Common Outputs
        table: The table extracted from the text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "add_columns_manually",
            "helper_text": "Add data points for some columns manually instead of having them extracted by the AI model.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "additional_context",
            "helper_text": "Provide any additional context that may help the AI model extract the data.",
            "value": "",
            "type": "string",
        },
        {
            "field": "extract_multiple_rows",
            "helper_text": "Choose the mode of extraction. If checked, it will extract multiple rows of data. If unchecked, it will extract a single row.",
            "value": True,
            "type": "bool",
        },
        {
            "field": "file",
            "helper_text": "Your file should contain headers in the first row.",
            "value": "",
            "type": "file",
        },
        {
            "field": "manual_columns",
            "helper_text": "Pass in data to column names manually.",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "model",
            "helper_text": "The specific model for extracting the table",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text_for_extraction",
            "helper_text": "Text to extract table from",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "table", "helper_text": "The table extracted from the text"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        add_columns_manually: bool = False,
        additional_context: str = "",
        extract_multiple_rows: bool = True,
        file: str = "",
        manual_columns: List[Any] = [],
        model: str = "gpt-4o",
        provider: str = "openai",
        text_for_extraction: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="extract_to_table",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text_for_extraction is not None:
            self.inputs["text_for_extraction"] = text_for_extraction
        if extract_multiple_rows is not None:
            self.inputs["extract_multiple_rows"] = extract_multiple_rows
        if add_columns_manually is not None:
            self.inputs["add_columns_manually"] = add_columns_manually
        if manual_columns is not None:
            self.inputs["manual_columns"] = manual_columns
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if file is not None:
            self.inputs["file"] = file

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def table(self) -> str:
        """
        The table extracted from the text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("table")

    @classmethod
    def from_dict(cls, data: dict) -> "ExtractToTableNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("sort_csv")
class SortCsvNode(Node):
    """
    Sort a CSV based on a column

    ## Inputs
    ### Common Inputs
        file: The CSV file to sort.
        has_headers: Whether the CSV has headers.
        is_file_variable: Whether the file is a variable.
        reverse_sort: Whether to reverse the sort.
    ### When is_file_variable = True
        column_index: The index of the column to sort by.
    ### When is_file_variable = False and has_headers = False
        column_index: The index of the column to sort by.
    ### When is_file_variable = False and has_headers = True
        column_to_sort_by: The column to sort by.

    ## Outputs
    ### Common Outputs
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file",
            "helper_text": "The CSV file to sort.",
            "value": None,
            "type": "file",
        },
        {
            "field": "has_headers",
            "helper_text": "Whether the CSV has headers.",
            "value": True,
            "type": "bool",
        },
        {
            "field": "is_file_variable",
            "helper_text": "Whether the file is a variable.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "reverse_sort",
            "helper_text": "Whether to reverse the sort.",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The output output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**(*)": {
            "inputs": [
                {
                    "field": "column_index",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The index of the column to sort by.",
                }
            ],
            "outputs": [],
        },
        "false**true": {
            "inputs": [
                {
                    "field": "column_to_sort_by",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "The column to sort by.",
                }
            ],
            "outputs": [],
        },
        "false**false": {
            "inputs": [
                {
                    "field": "column_index",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The index of the column to sort by.",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["is_file_variable", "has_headers"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        is_file_variable: bool = False,
        has_headers: bool = True,
        column_index: int = 0,
        column_to_sort_by: str = "",
        file: Optional[str] = None,
        reverse_sort: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["is_file_variable"] = is_file_variable
        params["has_headers"] = has_headers

        super().__init__(
            node_type="sort_csv",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if is_file_variable is not None:
            self.inputs["is_file_variable"] = is_file_variable
        if file is not None:
            self.inputs["file"] = file
        if has_headers is not None:
            self.inputs["has_headers"] = has_headers
        if reverse_sort is not None:
            self.inputs["reverse_sort"] = reverse_sort
        if column_index is not None:
            self.inputs["column_index"] = column_index
        if column_to_sort_by is not None:
            self.inputs["column_to_sort_by"] = column_to_sort_by

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The output output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "SortCsvNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("trigger_outlook")
class TriggerOutlookNode(Node):
    """
    Outlook Trigger

    ## Inputs
    ### Common Inputs
        event: The event input
        integration: The integration input
        item_id: Select the Trigger
        trigger_enabled: Enable/Disable Automation

    ## Outputs
    ### new_email
        attachments: The attachments output
        contents_of_email: The contents_of_email output
        email_id: The email_id output
        received_time: The received_time output
        recipient_email: The recipient_email output
        sender_email: The sender_email output
        subject: The subject output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "event",
            "helper_text": "The event input",
            "value": "",
            "type": "enum<string>",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Outlook>",
        },
        {
            "field": "item_id",
            "helper_text": "Select the Trigger",
            "value": "",
            "type": "string",
        },
        {
            "field": "trigger_enabled",
            "helper_text": "Enable/Disable Automation",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new_email": {
            "inputs": [],
            "outputs": [
                {"field": "email_id", "type": "string"},
                {"field": "subject", "type": "string"},
                {"field": "sender_email", "type": "string"},
                {"field": "recipient_email", "type": "string"},
                {"field": "received_time", "type": "string"},
                {"field": "contents_of_email", "type": "string"},
                {"field": "attachments", "type": "vec<file>"},
            ],
            "name": "new_email",
            "task_name": "tasks.outlook.new_email",
            "description": "Triggers when new email appears in the specified mailbox",
            "label": "New Email",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["event"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        event: str = "",
        item_id: str = "",
        trigger_enabled: bool = True,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["event"] = event

        super().__init__(
            node_type="trigger_outlook",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if event is not None:
            self.inputs["event"] = event
        if trigger_enabled is not None:
            self.inputs["trigger_enabled"] = trigger_enabled
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attachments(self) -> List[str]:
        """
        The attachments output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attachments")

    @property
    def contents_of_email(self) -> str:
        """
        The contents_of_email output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("contents_of_email")

    @property
    def email_id(self) -> str:
        """
        The email_id output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_id")

    @property
    def received_time(self) -> str:
        """
        The received_time output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("received_time")

    @property
    def recipient_email(self) -> str:
        """
        The recipient_email output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("recipient_email")

    @property
    def sender_email(self) -> str:
        """
        The sender_email output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("sender_email")

    @property
    def subject(self) -> str:
        """
        The subject output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("subject")

    @classmethod
    def from_dict(cls, data: dict) -> "TriggerOutlookNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("trigger_gmail")
class TriggerGmailNode(Node):
    """
    Gmail Trigger

    ## Inputs
    ### Common Inputs
        event: The event input
        integration: The integration input
        item_id: Select the Trigger
        trigger_enabled: Enable/Disable Automation

    ## Outputs
    ### new_email
        attachments: The attachments output
        contents_of_email: The contents_of_email output
        email_id: The email_id output
        received_time: The received_time output
        recipient_email: The recipient_email output
        sender_email: The sender_email output
        subject: The subject output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "event",
            "helper_text": "The event input",
            "value": "",
            "type": "enum<string>",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Gmail>",
        },
        {
            "field": "item_id",
            "helper_text": "Select the Trigger",
            "value": "",
            "type": "string",
        },
        {
            "field": "trigger_enabled",
            "helper_text": "Enable/Disable Automation",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new_email": {
            "inputs": [],
            "outputs": [
                {"field": "email_id", "type": "string"},
                {"field": "subject", "type": "string"},
                {"field": "sender_email", "type": "string"},
                {"field": "recipient_email", "type": "string"},
                {"field": "received_time", "type": "string"},
                {"field": "contents_of_email", "type": "string"},
                {"field": "attachments", "type": "vec<file>"},
            ],
            "name": "new_email",
            "task_name": "tasks.gmail.new_email",
            "description": "Triggers when new email appears in the specified mailbox",
            "label": "New Email",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["event"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        event: str = "",
        item_id: str = "",
        trigger_enabled: bool = True,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["event"] = event

        super().__init__(
            node_type="trigger_gmail",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if event is not None:
            self.inputs["event"] = event
        if trigger_enabled is not None:
            self.inputs["trigger_enabled"] = trigger_enabled
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attachments(self) -> List[str]:
        """
        The attachments output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attachments")

    @property
    def contents_of_email(self) -> str:
        """
        The contents_of_email output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("contents_of_email")

    @property
    def email_id(self) -> str:
        """
        The email_id output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_id")

    @property
    def received_time(self) -> str:
        """
        The received_time output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("received_time")

    @property
    def recipient_email(self) -> str:
        """
        The recipient_email output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("recipient_email")

    @property
    def sender_email(self) -> str:
        """
        The sender_email output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("sender_email")

    @property
    def subject(self) -> str:
        """
        The subject output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("subject")

    @classmethod
    def from_dict(cls, data: dict) -> "TriggerGmailNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("trigger_cron")
class TriggerCronNode(Node):
    """
    Cron Trigger

    ## Inputs
    ### Common Inputs
        event: The event input
        integration: The integration input
        item_id: Custom cron expression
        timezone: Timezone for the cron trigger
        trigger_enabled: Enable/Disable Automation
    ### monthly
        day_of_month: Day of the month to trigger
        time_of_day: Time of day to trigger (HH:MM)
    ### weekly
        day_of_week: Day of the week to trigger
        time_of_day: Time of day to trigger (HH:MM)
    ### daily
        time_of_day: Time of day to trigger (HH:MM)
        trigger_on_weekends: Trigger on weekends

    ## Outputs
    ### Common Outputs
        timestamp: The timestamp output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "event",
            "helper_text": "The event input",
            "value": "",
            "type": "enum<string>",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": {"object_type": 20, "object_id": "6809a715ad4615eeb652a551"},
            "type": "integration<Cron>",
        },
        {
            "field": "item_id",
            "helper_text": "Custom cron expression",
            "value": "0 0 * * *",
            "type": "string",
        },
        {
            "field": "timezone",
            "helper_text": "Timezone for the cron trigger",
            "value": "UTC",
            "type": "enum<string>",
        },
        {
            "field": "trigger_enabled",
            "helper_text": "Enable/Disable Automation",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "timestamp", "helper_text": "The timestamp output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "daily": {
            "inputs": [
                {
                    "field": "time_of_day",
                    "type": "string",
                    "value": "00:00",
                    "label": "Time of day",
                    "placeholder": "HH:MM",
                    "helper_text": "Time of day to trigger (HH:MM)",
                },
                {
                    "field": "trigger_on_weekends",
                    "type": "bool",
                    "value": False,
                    "label": "Trigger on weekends",
                    "helper_text": "Trigger on weekends",
                },
            ],
            "outputs": [],
            "name": "daily",
            "task_name": "tasks.cron.daily",
            "description": "Triggers once a day at a specified time",
            "label": "Daily",
        },
        "weekly": {
            "inputs": [
                {
                    "field": "day_of_week",
                    "type": "enum<string>",
                    "value": "Monday",
                    "label": "Day of the week",
                    "placeholder": "Select a day",
                    "helper_text": "Day of the week to trigger",
                },
                {
                    "field": "time_of_day",
                    "type": "string",
                    "value": "00:00",
                    "label": "Time of day",
                    "placeholder": "HH:MM",
                    "helper_text": "Time of day to trigger (HH:MM)",
                },
            ],
            "outputs": [],
            "name": "weekly",
            "task_name": "tasks.cron.weekly",
            "description": "Triggers once a week on a specified day and time",
            "label": "Weekly",
        },
        "monthly": {
            "inputs": [
                {
                    "field": "day_of_month",
                    "type": "int32",
                    "value": 1,
                    "label": "Day of the month",
                    "placeholder": "Select a day",
                    "helper_text": "Day of the month to trigger",
                },
                {
                    "field": "time_of_day",
                    "type": "string",
                    "value": "00:00",
                    "label": "Time of day",
                    "placeholder": "HH:MM",
                    "helper_text": "Time of day to trigger (HH:MM)",
                },
            ],
            "outputs": [],
            "name": "monthly",
            "task_name": "tasks.cron.monthly",
            "description": "Triggers once a month on a specified day and time",
            "label": "Monthly",
        },
        "custom": {
            "inputs": [],
            "outputs": [],
            "name": "custom",
            "task_name": "tasks.cron.custom",
            "description": "Triggers based on a custom cron expression",
            "label": "Custom Cron Expression",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["event"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        event: str = "",
        day_of_month: int = 1,
        day_of_week: str = "Monday",
        item_id: str = "0 0 * * *",
        time_of_day: str = "00:00",
        timezone: str = "UTC",
        trigger_enabled: bool = True,
        trigger_on_weekends: bool = False,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["event"] = event

        super().__init__(
            node_type="trigger_cron",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if event is not None:
            self.inputs["event"] = event
        if trigger_enabled is not None:
            self.inputs["trigger_enabled"] = trigger_enabled
        if timezone is not None:
            self.inputs["timezone"] = timezone
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if time_of_day is not None:
            self.inputs["time_of_day"] = time_of_day
        if trigger_on_weekends is not None:
            self.inputs["trigger_on_weekends"] = trigger_on_weekends
        if day_of_week is not None:
            self.inputs["day_of_week"] = day_of_week
        if day_of_month is not None:
            self.inputs["day_of_month"] = day_of_month
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def timestamp(self) -> str:
        """
        The timestamp output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("timestamp")

    @classmethod
    def from_dict(cls, data: dict) -> "TriggerCronNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("trigger_slack")
class TriggerSlackNode(Node):
    """
    Slack Trigger

    ## Inputs
    ### Common Inputs
        channel: The name of the Slack channel
        event: The event input
        integration: The integration input
        item_id: The item_id input
        team: The name of the Slack team
        trigger_enabled: Enable/Disable Automation

    ## Outputs
    ### new_message
        attachments: Files attached to the message
        channel_id: Unique identifier of the channel where the message was sent
        channel_name: Name of the channel where the message was sent
        message: The content of the message
        message_id: Unique identifier for the message
        permalink: Direct link to access this message
        timestamp: When the message was sent
        user_id: Unique identifier of the message sender
        user_name: Display name of the message sender
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "channel",
            "helper_text": "The name of the Slack channel",
            "value": "",
            "type": "string",
        },
        {
            "field": "event",
            "helper_text": "The event input",
            "value": "",
            "type": "enum<string>",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Slack>",
        },
        {
            "field": "item_id",
            "helper_text": "The item_id input",
            "value": "",
            "type": "string",
        },
        {
            "field": "team",
            "helper_text": "The name of the Slack team",
            "value": "",
            "type": "string",
        },
        {
            "field": "trigger_enabled",
            "helper_text": "Enable/Disable Automation",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new_message": {
            "inputs": [],
            "outputs": [
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "The content of the message",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "Unique identifier for the message",
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "helper_text": "When the message was sent",
                },
                {
                    "field": "user_name",
                    "type": "string",
                    "helper_text": "Display name of the message sender",
                },
                {
                    "field": "user_id",
                    "type": "string",
                    "helper_text": "Unique identifier of the message sender",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "helper_text": "Files attached to the message",
                },
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "Unique identifier of the channel where the message was sent",
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "helper_text": "Name of the channel where the message was sent",
                },
                {
                    "field": "permalink",
                    "type": "string",
                    "helper_text": "Direct link to access this message",
                },
            ],
            "name": "new_message",
            "task_name": "tasks.slack.new_message",
            "description": "Triggers when new message appears in the specified channel",
            "label": "New Message",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["event"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        event: str = "",
        channel: str = "",
        item_id: str = "",
        team: str = "",
        trigger_enabled: bool = True,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["event"] = event

        super().__init__(
            node_type="trigger_slack",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if event is not None:
            self.inputs["event"] = event
        if trigger_enabled is not None:
            self.inputs["trigger_enabled"] = trigger_enabled
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if team is not None:
            self.inputs["team"] = team
        if channel is not None:
            self.inputs["channel"] = channel
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attachments(self) -> List[str]:
        """
        Files attached to the message

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attachments")

    @property
    def channel_id(self) -> str:
        """
        Unique identifier of the channel where the message was sent

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("channel_id")

    @property
    def channel_name(self) -> str:
        """
        Name of the channel where the message was sent

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("channel_name")

    @property
    def message(self) -> str:
        """
        The content of the message

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("message")

    @property
    def message_id(self) -> str:
        """
        Unique identifier for the message

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("message_id")

    @property
    def permalink(self) -> str:
        """
        Direct link to access this message

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("permalink")

    @property
    def timestamp(self) -> str:
        """
        When the message was sent

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("timestamp")

    @property
    def user_id(self) -> str:
        """
        Unique identifier of the message sender

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("user_id")

    @property
    def user_name(self) -> str:
        """
        Display name of the message sender

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("user_name")

    @classmethod
    def from_dict(cls, data: dict) -> "TriggerSlackNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base_actions")
class KnowledgeBaseActionsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="knowledge_base_actions",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseActionsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base_sync")
class KnowledgeBaseSyncNode(Node):
    """
    Automatically trigger a sync to the integrations in the selected knowledge base

    ## Inputs
    ### Common Inputs
        knowledge_base: The knowledge base to sync

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "knowledge_base",
            "helper_text": "The knowledge base to sync",
            "value": {},
            "type": "knowledge_base",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        knowledge_base: Any = {},
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="knowledge_base_sync",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if knowledge_base is not None:
            self.inputs["knowledge_base"] = knowledge_base

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseSyncNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base_create")
class KnowledgeBaseCreateNode(Node):
    """
    Dynamically create a Knowledge Base with configured options

    ## Inputs
    ### Common Inputs
        analyze_documents: To analyze document contents and enrich them when parsing
        apify_key: Apify API Key for scraping URLs (optional)
        chunk_overlap: The overlap of the chunks to store in the knowledge base
        chunk_size: The size of the chunks to store in the knowledge base
        collection_name: The name of the collection to store the knowledge base in
        embedding_model: LLM model to use for embedding documents in the KB
        embedding_provider: The embedding provider to use
        file_processing_implementation: The file processing implementation to use
        is_hybrid: Whether to create a hybrid knowledge base
        name: The name of the knowledge base
        precision: The precision to use for the knowledge base
        segmentation_method: The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.
        sharded: Whether to shard the knowledge base
        splitter_method: Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.
        vector_db_provider: The vector database provider to use

    ## Outputs
    ### Common Outputs
        knowledge_base: The created knowledge base
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "analyze_documents",
            "helper_text": "To analyze document contents and enrich them when parsing",
            "value": False,
            "type": "bool",
        },
        {
            "field": "apify_key",
            "helper_text": "Apify API Key for scraping URLs (optional)",
            "value": "",
            "type": "string",
        },
        {
            "field": "chunk_overlap",
            "helper_text": "The overlap of the chunks to store in the knowledge base",
            "value": 0,
            "type": "int32",
        },
        {
            "field": "chunk_size",
            "helper_text": "The size of the chunks to store in the knowledge base",
            "value": 400,
            "type": "int32",
        },
        {
            "field": "collection_name",
            "helper_text": "The name of the collection to store the knowledge base in",
            "value": "text-embedding-3-small",
            "type": "string",
        },
        {
            "field": "embedding_model",
            "helper_text": "LLM model to use for embedding documents in the KB",
            "value": "text-embedding-3-small",
            "type": "string",
        },
        {
            "field": "embedding_provider",
            "helper_text": "The embedding provider to use",
            "value": "openai",
            "type": "string",
        },
        {
            "field": "file_processing_implementation",
            "helper_text": "The file processing implementation to use",
            "value": "default",
            "type": "string",
        },
        {
            "field": "is_hybrid",
            "helper_text": "Whether to create a hybrid knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "name",
            "helper_text": "The name of the knowledge base",
            "value": "",
            "type": "string",
        },
        {
            "field": "precision",
            "helper_text": "The precision to use for the knowledge base",
            "value": "Float16",
            "type": "string",
        },
        {
            "field": "segmentation_method",
            "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
            "value": "words",
            "type": "enum<string>",
        },
        {
            "field": "sharded",
            "helper_text": "Whether to shard the knowledge base",
            "value": True,
            "type": "bool",
        },
        {
            "field": "splitter_method",
            "helper_text": "Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.",
            "value": "markdown",
            "type": "enum<string>",
        },
        {
            "field": "vector_db_provider",
            "helper_text": "The vector database provider to use",
            "value": "qdrant",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "knowledge_base", "helper_text": "The created knowledge base"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "advanced": {
            "inputs": [
                {
                    "field": "segmentation_method",
                    "type": "enum<string>",
                    "value": "words",
                    "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["splitter_method"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        splitter_method: str = "markdown",
        analyze_documents: bool = False,
        apify_key: str = "",
        chunk_overlap: int = 0,
        chunk_size: int = 400,
        collection_name: str = "text-embedding-3-small",
        embedding_model: str = "text-embedding-3-small",
        embedding_provider: str = "openai",
        file_processing_implementation: str = "default",
        is_hybrid: bool = False,
        name: str = "",
        precision: str = "Float16",
        segmentation_method: str = "words",
        sharded: bool = True,
        vector_db_provider: str = "qdrant",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["splitter_method"] = splitter_method

        super().__init__(
            node_type="knowledge_base_create",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if name is not None:
            self.inputs["name"] = name
        if file_processing_implementation is not None:
            self.inputs["file_processing_implementation"] = (
                file_processing_implementation
            )
        if vector_db_provider is not None:
            self.inputs["vector_db_provider"] = vector_db_provider
        if collection_name is not None:
            self.inputs["collection_name"] = collection_name
        if embedding_model is not None:
            self.inputs["embedding_model"] = embedding_model
        if embedding_provider is not None:
            self.inputs["embedding_provider"] = embedding_provider
        if precision is not None:
            self.inputs["precision"] = precision
        if sharded is not None:
            self.inputs["sharded"] = sharded
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap
        if splitter_method is not None:
            self.inputs["splitter_method"] = splitter_method
        if segmentation_method is not None:
            self.inputs["segmentation_method"] = segmentation_method
        if analyze_documents is not None:
            self.inputs["analyze_documents"] = analyze_documents
        if is_hybrid is not None:
            self.inputs["is_hybrid"] = is_hybrid
        if apify_key is not None:
            self.inputs["apify_key"] = apify_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def knowledge_base(self) -> Any:
        """
        The created knowledge base


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("knowledge_base")

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseCreateNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("share_object")
class ShareObjectNode(Node):
    """
    Share a VectorShift object with another user

    ## Inputs
    ### Common Inputs
        object_type: The object_type input
        org_name: Enter the name of the organization of the user (leave blank if not part of org)
        user_identifier: Enter the username or email of the user you want to share with
    ### knowledge_base
        object: The object input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "object_type",
            "helper_text": "The object_type input",
            "value": "knowledge_base",
            "type": "enum<string>",
        },
        {
            "field": "org_name",
            "helper_text": "Enter the name of the organization of the user (leave blank if not part of org)",
            "value": "",
            "type": "string",
        },
        {
            "field": "user_identifier",
            "helper_text": "Enter the username or email of the user you want to share with",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "knowledge_base": {
            "inputs": [{"field": "object", "type": "knowledge_base"}],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["object_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        object_type: str = "knowledge_base",
        object: Optional[Any] = None,
        org_name: str = "",
        user_identifier: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["object_type"] = object_type

        super().__init__(
            node_type="share_object",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if object_type is not None:
            self.inputs["object_type"] = object_type
        if user_identifier is not None:
            self.inputs["user_identifier"] = user_identifier
        if org_name is not None:
            self.inputs["org_name"] = org_name
        if object is not None:
            self.inputs["object"] = object

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "ShareObjectNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("rename_file")
class RenameFileNode(Node):
    """
    Rename an existing file, assigning a new name along with the file extension

    ## Inputs
    ### Common Inputs
        file: The file to rename.
        new_name: The new name of the file, including its extension (e.g., file.txt, file.pdf, file.csv)

    ## Outputs
    ### Common Outputs
        renamed_file: The renamed file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file",
            "helper_text": "The file to rename.",
            "value": None,
            "type": "file",
        },
        {
            "field": "new_name",
            "helper_text": "The new name of the file, including its extension (e.g., file.txt, file.pdf, file.csv)",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "renamed_file", "helper_text": "The renamed file"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        file: Optional[str] = None,
        new_name: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="rename_file",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file is not None:
            self.inputs["file"] = file
        if new_name is not None:
            self.inputs["new_name"] = new_name

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def renamed_file(self) -> str:
        """
        The renamed file


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("renamed_file")

    @classmethod
    def from_dict(cls, data: dict) -> "RenameFileNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("start_flag")
class StartFlagNode(Node):
    """
    Start Flag

    ## Inputs
        None

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = []

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="start_flag",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "StartFlagNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("talk")
class TalkNode(Node):
    """
    Send a given message at a stage in a conversation.

    ## Inputs
    ### Common Inputs
        is_iframe: The is_iframe input
        variant: The variant input
    ### When variant = 'card'
        button: The button input
        content: The text to send to the user.
        description: The card’s description.
        image_url: The image to be sent at this step in the conversation.
        title: The card’s title.
    ### When variant = 'carousel'
        cards: The cards input
    ### When variant = 'message' and is_iframe = False
        content: The text to send to the user.
    ### When variant = 'message' and is_iframe = True
        content: The text to send to the user.
    ### When variant = 'image'
        image_url: The image to be sent at this step in the conversation.

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "is_iframe",
            "helper_text": "The is_iframe input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "variant",
            "helper_text": "The variant input",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "message**false": {
            "title": "Message",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/message",
            "helper_text": "Send a given message at a stage in a conversation.",
            "short_description": "Send a given message at a stage in a conversation.",
            "inputs": [
                {
                    "field": "content",
                    "type": "string",
                    "helper_text": "The text to send to the user.",
                    "value": "",
                },
                {"field": "variant", "type": "string", "value": "message"},
            ],
            "outputs": [],
        },
        "message**true": {
            "title": "Message",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/message",
            "helper_text": "Send a given message at a stage in a conversation.",
            "short_description": "Send a given iframe at a stage in a conversation.",
            "inputs": [
                {
                    "field": "content",
                    "type": "string",
                    "helper_text": "The text to send to the user.",
                    "value": "<iframe src='ENTER_URL_HERE' width='320px' height='400px'></iframe>",
                },
                {"field": "variant", "type": "string", "value": "message"},
            ],
            "outputs": [],
            "banner_text": "Please add your url in 'ENTER_URL_HERE'. Iframe width should be 320px",
        },
        "image**(*)": {
            "title": "Image",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/image",
            "helper_text": "Send an image in chat at this step in the conversation.",
            "short_description": "Send an image in chat at this step in the conversation.",
            "inputs": [
                {"field": "variant", "type": "string", "value": "image"},
                {
                    "field": "image_url",
                    "type": "image",
                    "helper_text": "The image to be sent at this step in the conversation.",
                },
            ],
            "outputs": [],
        },
        "card**(*)": {
            "title": "Card",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/card",
            "helper_text": "Send a card (a component with image, title, description, and button) in chat at this step in the conversation.",
            "short_description": "Send a card (a component with image, title, description, and button) in chat at this step in the conversation.",
            "inputs": [
                {"field": "variant", "type": "string", "value": "card"},
                {"field": "content", "type": "string", "value": "This is content"},
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "helper_text": "The card’s title.",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "helper_text": "The card’s description.",
                },
                {
                    "field": "button",
                    "type": "Dict[str, Any]",
                    "value": {
                        "id": "asfkwewkfmdke",
                        "name": "Submit",
                        "url": "https://vectorshift.ai/",
                        "actionType": "Link",
                    },
                    "table": {
                        "name": {"helper_text": "The name of the button."},
                        "url": {
                            "helper_text": "The URL to navigate to when the button is clicked."
                        },
                        "actionType": {
                            "helper_text": "Select the action to occur when the button is clicked."
                        },
                    },
                },
                {
                    "field": "image_url",
                    "type": "image",
                    "helper_text": "The card’s image.",
                },
            ],
            "outputs": [],
        },
        "carousel**(*)": {
            "title": "Carousel",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/carousel",
            "helper_text": "Send a carousel (a gallery of multiple cards) in chat at this step in the conversation.",
            "short_description": "Send a carousel (a gallery of multiple cards) in chat at this step in the conversation.",
            "inputs": [
                {"field": "variant", "type": "string", "value": "carousel"},
                {
                    "field": "cards",
                    "type": "vec<Dict[str, Any] }>",
                    "value": [
                        {
                            "id": "afgj3rf4fmo3i4jrf43rgfm",
                            "title": "Card 1",
                            "description": "This is a description",
                            "image_url": {},
                            "button": {
                                "id": "fref43jrfn",
                                "name": "Submit",
                                "url": "https://vectorshift.ai/",
                                "actionType": "Link",
                            },
                        }
                    ],
                    "table": {
                        "title": {"helper_text": "The card’s title."},
                        "description": {"helper_text": "The card’s description."},
                        "image_url": {"helper_text": "The card’s image URL."},
                        "button": {
                            "name": {"helper_text": "The name of the button."},
                            "url": {
                                "helper_text": "The URL to navigate to when the button is clicked."
                            },
                            "actionType": {
                                "helper_text": "Select the action to occur when the button is clicked."
                            },
                        },
                    },
                },
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["variant", "is_iframe"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        variant: str = "",
        is_iframe: bool = False,
        button: Any = {
            "id": "asfkwewkfmdke",
            "name": "Submit",
            "url": "https://vectorshift.ai/",
            "actionType": "Link",
        },
        cards: List[Any] = [
            {
                "id": "afgj3rf4fmo3i4jrf43rgfm",
                "title": "Card 1",
                "description": "This is a description",
                "image_url": {},
                "button": {
                    "id": "fref43jrfn",
                    "name": "Submit",
                    "url": "https://vectorshift.ai/",
                    "actionType": "Link",
                },
            }
        ],
        content: str = "",
        description: str = "",
        image_url: Optional[Any] = None,
        title: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["variant"] = variant
        params["is_iframe"] = is_iframe

        super().__init__(
            node_type="talk",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if variant is not None:
            self.inputs["variant"] = variant
        if is_iframe is not None:
            self.inputs["is_iframe"] = is_iframe
        if content is not None:
            self.inputs["content"] = content
        if image_url is not None:
            self.inputs["image_url"] = image_url
        if title is not None:
            self.inputs["title"] = title
        if description is not None:
            self.inputs["description"] = description
        if button is not None:
            self.inputs["button"] = button
        if cards is not None:
            self.inputs["cards"] = cards

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "TalkNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("listen")
class ListenNode(Node):
    """
    Listen for user input at a stage in the conversation.

    ## Inputs
    ### Common Inputs
        variant: The variant input
    ### button
        allow_user_message: The allow_user_message input
        buttons: The buttons input
        processed_outputs: The processed_outputs input

    ## Outputs
    ### button
        [processed_outputs]: The [processed_outputs] output
    ### capture
        response: The user message.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "variant",
            "helper_text": "The variant input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "button": {
            "title": "Button",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/listen/button",
            "helper_text": "Present users with clickable buttons during a conversation at this step and wait for the user to select one.",
            "short_description": "Present users with clickable buttons during a conversation at this step and wait for the user to select one.",
            "inputs": [
                {
                    "field": "buttons",
                    "type": "vec<Dict[str, Any]>",
                    "value": [{"name": "Button 1", "id": "8awi58eyqirm8ik9aq3"}],
                },
                {
                    "field": "processed_outputs",
                    "type": "map<string, string>",
                    "value": {"button_1": "path"},
                },
                {"field": "variant", "type": "string", "value": "button"},
                {"field": "allow_user_message", "type": "bool", "value": False},
            ],
            "outputs": [{"field": "[processed_outputs]", "type": ""}],
        },
        "capture": {
            "title": "Capture",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/listen/capture",
            "helper_text": "The conversation will pause at this step in the conversation and wait for the user to respond in chat. The user response will be stored in the capture response variable.",
            "short_description": "The conversation will pause at this step in the conversation and wait for the user to respond in chat. The user response will be stored in the capture response variable.",
            "inputs": [{"field": "variant", "type": "string", "value": "capture"}],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "value": "",
                    "helper_text": "The user message.",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["variant"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        variant: str = "",
        allow_user_message: bool = False,
        buttons: List[Any] = [{"name": "Button 1", "id": "8awi58eyqirm8ik9aq3"}],
        processed_outputs: Dict[str, str] = {"button_1": "path"},
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["variant"] = variant

        super().__init__(
            node_type="listen",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if variant is not None:
            self.inputs["variant"] = variant
        if buttons is not None:
            self.inputs["buttons"] = buttons
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs
        if allow_user_message is not None:
            self.inputs["allow_user_message"] = allow_user_message

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def response(self) -> str:
        """
        The user message.

        Available: capture


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @classmethod
    def from_dict(cls, data: dict) -> "ListenNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("add_node")
class AddNodeNode(Node):
    """
    Add Node

    ## Inputs
        None

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = []

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="add_node",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "AddNodeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("convert_type")
class ConvertTypeNode(Node):
    """
    Convert value from source type to target type.

    ## Inputs
    ### Common Inputs
        source_type: The type of the value to convert.
        target_type: The type to convert the value to.
        value: The value to convert

    ## Outputs
    ### int32
        converted_value: The converted value in Integer type
    ### float
        converted_value: The converted value in Decimal type
    ### bool
        converted_value: The converted value in Boolean type
    ### timestamp
        converted_value: The converted value in Timestamp type
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "source_type",
            "helper_text": "The type of the value to convert.",
            "value": "string",
            "type": "enum<string>",
        },
        {
            "field": "target_type",
            "helper_text": "The type to convert the value to.",
            "value": "int32",
            "type": "enum<string>",
        },
        {
            "field": "value",
            "helper_text": "The value to convert",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "int32": {
            "inputs": [
                {
                    "field": "target_type",
                    "type": "enum<string>",
                    "value": "int32",
                    "helper_text": "The type to convert the value to.",
                }
            ],
            "outputs": [
                {
                    "field": "converted_value",
                    "type": "int32",
                    "helper_text": "The converted value in Integer type",
                }
            ],
        },
        "float": {
            "inputs": [
                {
                    "field": "target_type",
                    "type": "enum<string>",
                    "value": "float",
                    "helper_text": "The type to convert the value to.",
                }
            ],
            "outputs": [
                {
                    "field": "converted_value",
                    "type": "float",
                    "helper_text": "The converted value in Decimal type",
                }
            ],
        },
        "bool": {
            "inputs": [
                {
                    "field": "target_type",
                    "type": "enum<string>",
                    "value": "bool",
                    "helper_text": "The type to convert the value to.",
                }
            ],
            "outputs": [
                {
                    "field": "converted_value",
                    "type": "bool",
                    "helper_text": "The converted value in Boolean type",
                }
            ],
        },
        "timestamp": {
            "inputs": [
                {
                    "field": "target_type",
                    "type": "enum<string>",
                    "value": "timestamp",
                    "helper_text": "The type to convert the value to.",
                }
            ],
            "outputs": [
                {
                    "field": "converted_value",
                    "type": "timestamp",
                    "helper_text": "The converted value in Timestamp type",
                }
            ],
            "banner_text": "Timestamp format: YYYY-MM-DDTHH:MM:SS",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["target_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        target_type: str = "int32",
        source_type: str = "string",
        value: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["target_type"] = target_type

        super().__init__(
            node_type="convert_type",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if value is not None:
            self.inputs["value"] = value
        if source_type is not None:
            self.inputs["source_type"] = source_type
        if target_type is not None:
            self.inputs["target_type"] = target_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def converted_value(self) -> int:
        """
        The converted value in Integer type

        Different behavior based on configuration:
          - The converted value in Integer type (int32)
          - The converted value in Decimal type (float)
          - The converted value in Boolean type (bool)
          - The converted value in Timestamp type (timestamp)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("converted_value")

    @classmethod
    def from_dict(cls, data: dict) -> "ConvertTypeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("set_variable")
class SetVariableNode(Node):
    """
    Set a variable to a new value

    ## Inputs
    ### Common Inputs
        scope: The scope of the variable
        variable_id: The ID of the variable to set
        variable_set_id: The ID of the variable set
    ### When variable_set_id = '[variable_sets._id.<A>]' and scope = '<Scope>' and variable_id = '<VariableId>'
        value: The new value to set the variable to

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "scope",
            "helper_text": "The scope of the variable",
            "value": "",
            "type": "string",
        },
        {
            "field": "variable_id",
            "helper_text": "The ID of the variable to set",
            "value": "",
            "type": "string",
        },
        {
            "field": "variable_set_id",
            "helper_text": "The ID of the variable set",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "[variable_sets._id.<A>]**<Scope>**<VariableId>": {
            "inputs": [
                {
                    "field": "value",
                    "type": "{<A>.variables.<Scope>.<VariableId>.data_type}",
                    "helper_text": "The new value to set the variable to",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["variable_set_id", "scope", "variable_id"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        variable_set_id: str = "",
        scope: str = "",
        variable_id: str = "",
        value: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["variable_set_id"] = variable_set_id
        params["scope"] = scope
        params["variable_id"] = variable_id

        super().__init__(
            node_type="set_variable",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if variable_set_id is not None:
            self.inputs["variable_set_id"] = variable_set_id
        if variable_id is not None:
            self.inputs["variable_id"] = variable_id
        if scope is not None:
            self.inputs["scope"] = scope
        if value is not None:
            self.inputs["value"] = value
        if value is not None:
            self.inputs["value"] = value

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "SetVariableNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("list_deduplicator")
class ListDeduplicatorNode(Node):
    """
    Remove duplicate items from a list. Outputs a list of unique items.

    ## Inputs
    ### Common Inputs
        type: The type of the list
    ### <T>
        list: The list to deduplicate

    ## Outputs
    ### <T>
        unique_items: The list of unique items
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": [],
                    "helper_text": "The list to deduplicate",
                }
            ],
            "outputs": [
                {
                    "field": "unique_items",
                    "type": "vec<<T>>",
                    "helper_text": "The list of unique items",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        list: List[Any] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="list_deduplicator",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def unique_items(self) -> List[Any]:
        """
        The list of unique items

        Available: <T>


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("unique_items")

    @classmethod
    def from_dict(cls, data: dict) -> "ListDeduplicatorNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("browser_extension")
class BrowserExtensionNode(Node):
    """
    Run a VectorShift workflow using the current page captured by the VectorShift chrome extension as input.

    ## Inputs
    ### Common Inputs
        page_content: The content of the page
        page_html: The HTML of the page
        page_urls: The URLs of the pages
        screenshot: The screenshot of the page
        show_chrome_extension: Deploy to chrome extension
        url: The URL of the page

    ## Outputs
    ### Common Outputs
        page_content: The content of the current page
        page_html: The HTML of the current page
        page_urls: The URLs on the current page
        screenshot: The screenshot of the current page
        url: The URL of the current page
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "page_content",
            "helper_text": "The content of the page",
            "value": "",
            "type": "string",
        },
        {
            "field": "page_html",
            "helper_text": "The HTML of the page",
            "value": "",
            "type": "string",
        },
        {
            "field": "page_urls",
            "helper_text": "The URLs of the pages",
            "value": [],
            "type": "vec<string>",
        },
        {
            "field": "screenshot",
            "helper_text": "The screenshot of the page",
            "value": {},
            "type": "image",
        },
        {
            "field": "show_chrome_extension",
            "helper_text": "Deploy to chrome extension",
            "value": True,
            "type": "bool",
        },
        {
            "field": "url",
            "helper_text": "The URL of the page",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "page_content", "helper_text": "The content of the current page"},
        {"field": "page_html", "helper_text": "The HTML of the current page"},
        {"field": "page_urls", "helper_text": "The URLs on the current page"},
        {"field": "screenshot", "helper_text": "The screenshot of the current page"},
        {"field": "url", "helper_text": "The URL of the current page"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        page_content: str = "",
        page_html: str = "",
        page_urls: List[str] = [],
        screenshot: Any = {},
        show_chrome_extension: bool = True,
        url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="browser_extension",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if url is not None:
            self.inputs["url"] = url
        if page_urls is not None:
            self.inputs["page_urls"] = page_urls
        if page_content is not None:
            self.inputs["page_content"] = page_content
        if page_html is not None:
            self.inputs["page_html"] = page_html
        if screenshot is not None:
            self.inputs["screenshot"] = screenshot
        if show_chrome_extension is not None:
            self.inputs["show_chrome_extension"] = show_chrome_extension

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def page_content(self) -> str:
        """
        The content of the current page


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("page_content")

    @property
    def page_html(self) -> str:
        """
        The HTML of the current page


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("page_html")

    @property
    def page_urls(self) -> List[str]:
        """
        The URLs on the current page


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("page_urls")

    @property
    def screenshot(self) -> Any:
        """
        The screenshot of the current page


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("screenshot")

    @property
    def url(self) -> str:
        """
        The URL of the current page


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("url")

    @classmethod
    def from_dict(cls, data: dict) -> "BrowserExtensionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


__all__ = [
    "AppendFilesNode",
    "StickyNoteNode",
    "CustomGroupNode",
    "TransformationNode",
    "ChatFileReaderNode",
    "PipelineNode",
    "AgentNode",
    "ChatMemoryNode",
    "LlmNode",
    "InputNode",
    "OutputNode",
    "CategorizerNode",
    "ExtractDataNode",
    "DataCollectorNode",
    "ScorerNode",
    "SpeechToTextNode",
    "FileSaveNode",
    "ImageGenNode",
    "FileNode",
    "GetListItemNode",
    "LlmOpenAiVisionNode",
    "LlmGoogleVisionNode",
    "SplitTextNode",
    "SummarizerNode",
    "TextNode",
    "TextToFileNode",
    "TimeNode",
    "TranslatorNode",
    "TtsElevenLabsNode",
    "TtsOpenAiNode",
    "AiAudioOperationsNode",
    "AiTextToSpeechNode",
    "AiSpeechToTextNode",
    "AiImageOperationsNode",
    "AiImageToTextNode",
    "AiTextToImageNode",
    "LlmAnthropicVisionNode",
    "SemanticSearchNode",
    "KnowledgeBaseNode",
    "KnowledgeBaseLoaderNode",
    "MapNode",
    "MergeNode",
    "ConditionNode",
    "NlToSqlNode",
    "ReadJsonValuesNode",
    "WriteJsonValueNode",
    "ApiNode",
    "UrlLoaderNode",
    "WikipediaNode",
    "YoutubeNode",
    "ArxivNode",
    "SerpApiNode",
    "YouDotComNode",
    "ExaAiNode",
    "GoogleSearchNode",
    "GoogleAlertRssReaderNode",
    "RssFeedReaderNode",
    "CsvQueryNode",
    "CsvReaderNode",
    "CsvWriterNode",
    "CreateListNode",
    "CombineListNode",
    "ListTrimmerNode",
    "DuplicateListNode",
    "FlattenListNode",
    "JoinListItemNode",
    "CsvToExcelNode",
    "TextFormatterNode",
    "JsonOperationsNode",
    "ListOperationsNode",
    "IntegrationGmailNode",
    "IntegrationCopperNode",
    "IntegrationDiscordNode",
    "IntegrationLinearNode",
    "IntegrationOutlookNode",
    "IntegrationSalesforceNode",
    "IntegrationSlackNode",
    "IntegrationJiraNode",
    "IntegrationSugarCrmNode",
    "IntegrationGithubNode",
    "IntegrationZendeskNode",
    "IntegrationStripeNode",
    "IntegrationTeamsNode",
    "IntegrationXNode",
    "IntegrationGohighlevelNode",
    "IntegrationPeopledatalabsNode",
    "IntegrationHubspotNode",
    "IntegrationSnowflakeNode",
    "IntegrationElasticsearchNode",
    "IntegrationMongodbNode",
    "IntegrationPineconeNode",
    "IntegrationPostgresNode",
    "IntegrationMysqlNode",
    "IntegrationWordpressNode",
    "IntegrationLinkedinNode",
    "IntegrationGoogleCalendarNode",
    "IntegrationMicrosoftCalendarNode",
    "IntegrationMailgunNode",
    "IntegrationGoogleDocsNode",
    "IntegrationMicrosoftNode",
    "IntegrationTypeformNode",
    "IntegrationDropboxNode",
    "IntegrationBoxNode",
    "IntegrationGoogleDriveNode",
    "IntegrationGoogleSheetsNode",
    "IntegrationAirtableNode",
    "IntegrationNotionNode",
    "IntegrationDatabricksNode",
    "IntegrationWeaviateNode",
    "IntegrationBlandAiNode",
    "IntegrationAlgoliaNode",
    "IntegrationApolloNode",
    "IntegrationClickupNode",
    "ZapierNode",
    "MakeNode",
    "TextManipulationNode",
    "FileOperationsNode",
    "AiOperationsNode",
    "FileToTextNode",
    "CodeExecutionNode",
    "ChunkingNode",
    "NotificationsNode",
    "CustomSmtpEmailSenderNode",
    "EmailNotificationNode",
    "SmsNotificationNode",
    "AiFilterListNode",
    "FilterListNode",
    "SalesDataEnrichmentNode",
    "EmailValidatorNode",
    "CombineTextNode",
    "FindAndReplaceNode",
    "AiFillPdfNode",
    "ExtractToTableNode",
    "SortCsvNode",
    "TriggerOutlookNode",
    "TriggerGmailNode",
    "TriggerCronNode",
    "TriggerSlackNode",
    "KnowledgeBaseActionsNode",
    "KnowledgeBaseSyncNode",
    "KnowledgeBaseCreateNode",
    "ShareObjectNode",
    "RenameFileNode",
    "StartFlagNode",
    "TalkNode",
    "ListenNode",
    "AddNodeNode",
    "ConvertTypeNode",
    "SetVariableNode",
    "ListDeduplicatorNode",
    "BrowserExtensionNode",
]
