"""
Generated node classes from TOML configuration.
This file is auto-generated. Do not edit manually.
"""

from typing import Any, Dict, List, Optional, Union, Protocol, runtime_checkable
from .node import Node, NodeOutputs


@Node.register_node_type("append_files")
class AppendFilesNode(Node):
    """
    Append files together in successive fashion

    ## Inputs
    ### Common Inputs
        file_type: The type of file to append.
        selected_files: The number of files to be appended. Files will be appended in successive fashion (e.g., file-1 first, then file-2, etc.).

    ## Outputs
    ### Common Outputs
        file: A file with all the files appended together.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file_type",
            "helper_text": "The type of file to append.",
            "value": "PDF",
            "type": "enum<string>",
        },
        {
            "field": "selected_files",
            "helper_text": "The number of files to be appended. Files will be appended in successive fashion (e.g., file-1 first, then file-2, etc.).",
            "value": [""],
            "type": "vec<file>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file", "helper_text": "A file with all the files appended together."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        file_type: str = "PDF",
        selected_files: List[str] = [""],
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="append_files",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_type is not None:
            self.inputs["file_type"] = file_type
        if selected_files is not None:
            self.inputs["selected_files"] = selected_files

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def file(self) -> str:
        """
        A file with all the files appended together.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file")

    @classmethod
    def from_dict(cls, data: dict) -> "AppendFilesNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("sticky_note")
class StickyNoteNode(Node):
    """


    ## Inputs
    ### Common Inputs
        text: The text input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "text",
            "helper_text": "The text input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="sticky_note",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "StickyNoteNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("custom_group")
class CustomGroupNode(Node):
    """


    ## Inputs
        None

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = []

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="custom_group",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "CustomGroupNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("transformation")
class TransformationNode(Node):
    """


    ## Inputs
    ### Common Inputs
        transformation_id: The transformation_id input
    ### [transformations._id.<A>]
        [<A>.inputs]: The [<A>.inputs] input

    ## Outputs
    ### [transformations._id.<A>]
        [<A>.outputs]: The [<A>.outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "transformation_id",
            "helper_text": "The transformation_id input",
            "value": "",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "[transformations._id.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["transformation_id"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        transformation_id: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["transformation_id"] = transformation_id

        super().__init__(
            node_type="transformation",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if transformation_id is not None:
            self.inputs["transformation_id"] = transformation_id

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "TransformationNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("chat_file_reader")
class ChatFileReaderNode(Node):
    """
    Allows for document upload within chatbots (often connected to the LLM node).

    ## Inputs
    ### Common Inputs
        chunk_overlap: The number of tokens of overlap between chunks (1 token = 4 characters)
        chunk_size: The number of tokens per chunk (1 token = 4 characters)
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
        max_docs_per_query: Sets the maximum number of chunks to retrieve for each query
        retrieval_unit: Return the most relevant Chunks (text content) or Documents (will return the document metadata)

    ## Outputs
    ### Common Outputs
        documents: The uploaded file (in the chat interface) is processed into text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_overlap",
            "helper_text": "The number of tokens of overlap between chunks (1 token = 4 characters)",
            "value": 200,
            "type": "int32",
        },
        {
            "field": "chunk_size",
            "helper_text": "The number of tokens per chunk (1 token = 4 characters)",
            "value": 1000,
            "type": "int32",
        },
        {
            "field": "file_parser",
            "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
            "value": "default",
            "type": "enum<string>",
        },
        {
            "field": "max_docs_per_query",
            "helper_text": "Sets the maximum number of chunks to retrieve for each query",
            "value": 10,
            "type": "int32",
        },
        {
            "field": "retrieval_unit",
            "helper_text": "Return the most relevant Chunks (text content) or Documents (will return the document metadata)",
            "value": "chunks",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "documents",
            "helper_text": "The uploaded file (in the chat interface) is processed into text",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_overlap: int = 200,
        chunk_size: int = 1000,
        file_parser: str = "default",
        max_docs_per_query: int = 10,
        retrieval_unit: str = "chunks",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="chat_file_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_parser is not None:
            self.inputs["file_parser"] = file_parser
        if max_docs_per_query is not None:
            self.inputs["max_docs_per_query"] = max_docs_per_query
        if retrieval_unit is not None:
            self.inputs["retrieval_unit"] = retrieval_unit
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def documents(self) -> List[str]:
        """
        The uploaded file (in the chat interface) is processed into text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("documents")

    @classmethod
    def from_dict(cls, data: dict) -> "ChatFileReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("pipeline")
class PipelineNode(Node):
    """
    Pipeline

    ## Inputs
    ### Common Inputs
        pipeline_id: The pipeline_id input
    ### [pipelines._id.<A>]
        [<A>.inputs]: The [<A>.inputs] input

    ## Outputs
    ### [pipelines._id.<A>]
        [<A>.outputs]: The [<A>.outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "pipeline_id",
            "helper_text": "The pipeline_id input",
            "value": "",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "[pipelines._id.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["pipeline_id"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        pipeline_id: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["pipeline_id"] = pipeline_id

        super().__init__(
            node_type="pipeline",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if pipeline_id is not None:
            self.inputs["pipeline_id"] = pipeline_id

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "PipelineNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("agent")
class AgentNode(Node):
    """
    Agent

    ## Inputs
    ### Common Inputs
        agent_id: The agent_id input
    ### [agents._id.<A>]
        [<A>.inputs]: The [<A>.inputs] input

    ## Outputs
    ### [agents._id.<A>]
        [<A>.outputs]: The [<A>.outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "agent_id",
            "helper_text": "The agent_id input",
            "value": "",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "[agents._id.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["agent_id"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        agent_id: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["agent_id"] = agent_id

        super().__init__(
            node_type="agent",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if agent_id is not None:
            self.inputs["agent_id"] = agent_id

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "AgentNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("chat_memory")
class ChatMemoryNode(Node):
    """
    Give connected nodes access to conversation history.

    ## Inputs
    ### Common Inputs
        memory_type: The type of memory to use
        memory_window: The number of tokens to store in memory

    ## Outputs
    ### Common Outputs
        memory: The conversation history in the format of the selected type
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "memory_type",
            "helper_text": "The type of memory to use",
            "value": "Token Buffer",
            "type": "string",
        },
        {
            "field": "memory_window",
            "helper_text": "The number of tokens to store in memory",
            "value": 2048,
            "type": "int32",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "memory",
            "helper_text": "The conversation history in the format of the selected type",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "Vector Database": {
            "inputs": [
                {"field": "memory_window", "type": "int32", "value": 20},
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Vector Database",
                    "helper_text": "Stores all previous messages in a Vector Database. Will return most similar messages based on the user message",
                },
            ],
            "outputs": [],
        },
        "Message Buffer": {
            "inputs": [
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Message Buffer",
                    "helper_text": "Returns a set number of previous consecutive messages",
                },
                {"field": "memory_window", "type": "int32", "value": 10},
            ],
            "outputs": [],
        },
        "Token Buffer": {
            "inputs": [
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Token Buffer",
                    "helper_text": "Returns a set number of previous consecutive messages until adding an additional message would cause the total history size to be larger than the Max Tokens",
                },
                {"field": "memory_window", "type": "int32", "value": 2048},
            ],
            "outputs": [],
        },
        "Full - Formatted": {
            "inputs": [
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Full - Formatted",
                    "helper_text": "Returns all previous chat history",
                }
            ],
            "outputs": [],
        },
        "Full - Raw": {
            "inputs": [
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Full - Raw",
                    "helper_text": 'Returns a Python list with elements in the following format: {"type": type, "message": message}',
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["memory_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        memory_type: str = "Token Buffer",
        memory_window: int = 2048,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["memory_type"] = memory_type

        super().__init__(
            node_type="chat_memory",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if memory_type is not None:
            self.inputs["memory_type"] = memory_type
        if memory_window is not None:
            self.inputs["memory_window"] = memory_window

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def memory(self) -> str:
        """
        The conversation history in the format of the selected type


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("memory")

    @classmethod
    def from_dict(cls, data: dict) -> "ChatMemoryNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("llm")
class LlmNode(Node):
    """
    LLM

    ## Inputs
    ### Common Inputs
        enable_moderation: Whether to enable moderation
        enable_pii_address: Whether to enable PII address
        enable_pii_cc: Whether to enable PII cc
        enable_pii_email: Whether to enable PII email
        enable_pii_name: Whether to enable PII name
        enable_pii_phone: Whether to enable PII phone
        enable_pii_ssn: Whether to enable PII ssn
        max_tokens: The maximum amount of input + output tokens the model will take in and generate per run (1 token = 4 characters). Note: different models have different token limits and the workflow will error if the max token is reached.
        model: Select the LLM model to be used
        prompt: The data that is sent to the LLM. Add data from other nodes with double curly braces e.g., {{input_0.text}}
        provider: Select the LLM provider to be used
        retry_on_failure: Enable retrying when the node execution fails
        safe_context_token_window: If enabled, the context window will be reduced to fit the model's maximum context window.
        show_confidence: Whether to show the confidence score of the response
        show_sources: Whether to show the sources used to generate the response
        stream: Whether to stream the response
        system: The system prompt to be used
        temperature: The “creativity” of the response - increase the temperature for more creative responses.
        thinking_token_limit: The maximum number of tokens the model can use for thinking
        top_p: The “randomness” of the output - higher Top P values increase the randomness
    ### When use_personal_api_key = True
        api_key: Your personal API key
    ### When provider = 'custom'
        api_key: Your personal API key
        base_url: The base URL of the custom LLM provider
        finetuned_model: Use your finetuned model for response generation. Make sure to select the matching base model from the dropdown.
        use_personal_api_key: Whether to use a personal API key
    ### When show_sources = True
        citation_metadata: The metadata of the sources used to generate the response
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'azure' and use_personal_api_key = True
        deployment_id: The deployment ID for the Azure OpenAI model. This is required when using Azure OpenAI services.
        endpoint: The Azure OpenAI endpoint URL (e.g., https://your-resource-name.openai.azure.com)
    ### When provider = 'openai' and use_personal_api_key = True
        finetuned_model: Use your finetuned model for response generation. Make sure to select the matching base model from the dropdown.
    ### When provider = 'openai'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'anthropic'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'google'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'cohere'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'together'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'bedrock'
        json_response: Whether to return the response as a JSON object
    ### When provider = 'azure'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When json_response = True
        json_schema: The schema of the JSON response
    ### When retry_on_failure = True
        max_retries: The maximum number of retries
        retry_interval_ms: The interval between retries in milliseconds
    ### When provider = 'perplexity'
        use_personal_api_key: Whether to use a personal API key

    ## Outputs
    ### Common Outputs
        credits_used: The number of credits used
        input_tokens: The number of input tokens
        output_tokens: The number of output tokens
        tokens_used: The number of tokens used
    ### When stream = True
        response: The response as a stream of text
    ### When stream = False
        response: The response as a single string
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "enable_moderation",
            "helper_text": "Whether to enable moderation",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_address",
            "helper_text": "Whether to enable PII address",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_cc",
            "helper_text": "Whether to enable PII cc",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_email",
            "helper_text": "Whether to enable PII email",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_name",
            "helper_text": "Whether to enable PII name",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_phone",
            "helper_text": "Whether to enable PII phone",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_ssn",
            "helper_text": "Whether to enable PII ssn",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The maximum amount of input + output tokens the model will take in and generate per run (1 token = 4 characters). Note: different models have different token limits and the workflow will error if the max token is reached.",
            "value": 128000,
            "type": "int64",
        },
        {
            "field": "model",
            "helper_text": "Select the LLM model to be used",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The data that is sent to the LLM. Add data from other nodes with double curly braces e.g., {{input_0.text}}",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "Select the LLM provider to be used",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "retry_on_failure",
            "helper_text": "Enable retrying when the node execution fails",
            "value": False,
            "type": "bool",
        },
        {
            "field": "safe_context_token_window",
            "helper_text": "If enabled, the context window will be reduced to fit the model's maximum context window.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "show_confidence",
            "helper_text": "Whether to show the confidence score of the response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "show_sources",
            "helper_text": "Whether to show the sources used to generate the response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "stream",
            "helper_text": "Whether to stream the response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "system",
            "helper_text": "The system prompt to be used",
            "value": "",
            "type": "string",
        },
        {
            "field": "temperature",
            "helper_text": "The “creativity” of the response - increase the temperature for more creative responses.",
            "value": 0.5,
            "type": "float",
        },
        {
            "field": "thinking_token_limit",
            "helper_text": "The maximum number of tokens the model can use for thinking",
            "value": 0,
            "type": "int64",
        },
        {
            "field": "top_p",
            "helper_text": "The “randomness” of the output - higher Top P values increase the randomness",
            "value": 0.5,
            "type": "float",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "credits_used", "helper_text": "The number of credits used"},
        {"field": "input_tokens", "helper_text": "The number of input tokens"},
        {"field": "output_tokens", "helper_text": "The number of output tokens"},
        {"field": "tokens_used", "helper_text": "The number of tokens used"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**true**(*)**(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "response",
                    "type": "stream<string>",
                    "helper_text": "The response as a stream of text",
                }
            ],
        },
        "(*)**false**(*)**(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "helper_text": "The response as a single string",
                }
            ],
        },
        "(*)**(*)**true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Your personal API key",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_schema",
                    "type": "string",
                    "value": "",
                    "helper_text": "The schema of the JSON response",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**(*)**true**(*)": {
            "inputs": [
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "value": "",
                    "helper_text": "The metadata of the sources used to generate the response",
                },
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**(*)**(*)**true": {
            "inputs": [
                {
                    "field": "max_retries",
                    "type": "int32",
                    "value": 1,
                    "helper_text": "The maximum number of retries",
                },
                {
                    "field": "retry_interval_ms",
                    "type": "int32",
                    "value": 1000,
                    "helper_text": "The interval between retries in milliseconds",
                },
            ],
            "outputs": [],
        },
        "custom**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "base_url",
                    "type": "string",
                    "value": "",
                    "helper_text": "The base URL of the custom LLM provider",
                },
                {
                    "field": "model",
                    "type": "string",
                    "value": "",
                    "helper_text": "The model to be used",
                },
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Your API key",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Whether to use a personal API key",
                },
                {
                    "field": "finetuned_model",
                    "type": "string",
                    "value": "",
                    "helper_text": "Use your finetuned model for response generation. Make sure to select the matching base model from the dropdown.",
                },
            ],
            "outputs": [],
            "title": "Custom",
        },
        "openai**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
            ],
            "outputs": [],
            "title": "OpenAI",
        },
        "openai**(*)**true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "finetuned_model",
                    "type": "string",
                    "value": "",
                    "helper_text": "Use your finetuned model for response generation. Make sure to select the matching base model from the dropdown.",
                }
            ],
            "outputs": [],
        },
        "anthropic**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
            ],
            "outputs": [],
            "title": "Anthropic",
        },
        "perplexity**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                }
            ],
            "outputs": [],
            "title": "Perplexity",
        },
        "google**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
            ],
            "outputs": [],
            "title": "Google",
        },
        "cohere**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
            ],
            "outputs": [],
            "title": "Cohere",
        },
        "together**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
            ],
            "outputs": [],
            "title": "Open Source",
        },
        "bedrock**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                }
            ],
            "outputs": [],
            "title": "Bedrock",
        },
        "azure**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                },
            ],
            "outputs": [],
            "title": "Azure",
        },
        "azure**(*)**true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "endpoint",
                    "type": "string",
                    "value": "",
                    "helper_text": "The Azure OpenAI endpoint URL (e.g., https://your-resource-name.openai.azure.com)",
                },
                {
                    "field": "deployment_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The deployment ID for the Azure OpenAI model. This is required when using Azure OpenAI services.",
                },
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = [
        "provider",
        "stream",
        "use_personal_api_key",
        "json_response",
        "show_sources",
        "retry_on_failure",
    ]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        provider: str = "openai",
        stream: bool = False,
        use_personal_api_key: bool = False,
        json_response: bool = False,
        show_sources: bool = False,
        retry_on_failure: bool = False,
        api_key: str = "",
        base_url: str = "",
        citation_metadata: List[str] = [],
        deployment_id: str = "",
        enable_moderation: bool = False,
        enable_pii_address: bool = False,
        enable_pii_cc: bool = False,
        enable_pii_email: bool = False,
        enable_pii_name: bool = False,
        enable_pii_phone: bool = False,
        enable_pii_ssn: bool = False,
        endpoint: str = "",
        finetuned_model: str = "",
        json_schema: str = "",
        max_retries: int = 1,
        max_tokens: int = 128000,
        model: str = "gpt-4o",
        prompt: str = "",
        retry_interval_ms: int = 1000,
        safe_context_token_window: bool = False,
        show_confidence: bool = False,
        system: str = "",
        temperature: Any = 0.5,
        thinking_token_limit: int = 0,
        top_p: Any = 0.5,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["provider"] = provider
        params["stream"] = stream
        params["use_personal_api_key"] = use_personal_api_key
        params["json_response"] = json_response
        params["show_sources"] = show_sources
        params["retry_on_failure"] = retry_on_failure

        super().__init__(
            node_type="llm",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if system is not None:
            self.inputs["system"] = system
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if stream is not None:
            self.inputs["stream"] = stream
        if show_sources is not None:
            self.inputs["show_sources"] = show_sources
        if show_confidence is not None:
            self.inputs["show_confidence"] = show_confidence
        if enable_moderation is not None:
            self.inputs["enable_moderation"] = enable_moderation
        if enable_pii_name is not None:
            self.inputs["enable_pii_name"] = enable_pii_name
        if enable_pii_email is not None:
            self.inputs["enable_pii_email"] = enable_pii_email
        if enable_pii_phone is not None:
            self.inputs["enable_pii_phone"] = enable_pii_phone
        if enable_pii_ssn is not None:
            self.inputs["enable_pii_ssn"] = enable_pii_ssn
        if enable_pii_address is not None:
            self.inputs["enable_pii_address"] = enable_pii_address
        if enable_pii_cc is not None:
            self.inputs["enable_pii_cc"] = enable_pii_cc
        if thinking_token_limit is not None:
            self.inputs["thinking_token_limit"] = thinking_token_limit
        if safe_context_token_window is not None:
            self.inputs["safe_context_token_window"] = safe_context_token_window
        if retry_on_failure is not None:
            self.inputs["retry_on_failure"] = retry_on_failure
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if json_schema is not None:
            self.inputs["json_schema"] = json_schema
        if citation_metadata is not None:
            self.inputs["citation_metadata"] = citation_metadata
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if max_retries is not None:
            self.inputs["max_retries"] = max_retries
        if retry_interval_ms is not None:
            self.inputs["retry_interval_ms"] = retry_interval_ms
        if base_url is not None:
            self.inputs["base_url"] = base_url
        if finetuned_model is not None:
            self.inputs["finetuned_model"] = finetuned_model
        if endpoint is not None:
            self.inputs["endpoint"] = endpoint
        if deployment_id is not None:
            self.inputs["deployment_id"] = deployment_id

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def credits_used(self) -> Any:
        """
        The number of credits used


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("credits_used")

    @property
    def input_tokens(self) -> int:
        """
        The number of input tokens


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("input_tokens")

    @property
    def output_tokens(self) -> int:
        """
        The number of output tokens


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output_tokens")

    @property
    def response(self) -> Any:
        """
        The response as a stream of text

        Different behavior based on configuration:
          - The response as a stream of text (When stream = True)
          - The response as a single string (When stream = False)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @property
    def tokens_used(self) -> int:
        """
        The number of tokens used


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tokens_used")

    @classmethod
    def from_dict(cls, data: dict) -> "LlmNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("input")
class InputNode(Node):
    """
    Pass data of different types into your workflow.

    ## Inputs
    ### Common Inputs
        description: The description of the input
        input_type: Raw Text
        use_default_value: Set default value to be used if no value is provided
    ### When input_type = 'string' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'file' and use_default_value = True
        default_value: The default value to be used if no value is provided
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
    ### When input_type = 'audio' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'image' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'knowledge_base' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'pipeline' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'vec<file>' and use_default_value = True
        default_value: The default value to be used if no value is provided
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
    ### When input_type = 'int32' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'bool' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'timestamp' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'vec<string>' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'file' and use_default_value = False
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
    ### When input_type = 'vec<file>' and use_default_value = False
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.

    ## Outputs
    ### When input_type = 'audio' and use_default_value = False
        audio: The audio that was passed in
    ### When input_type = 'audio' and use_default_value = True
        audio: The audio that was passed in
    ### When input_type = 'file' and use_default_value = False
        file: The file that was passed in
        processed_text: The processed text of the file.
    ### When input_type = 'file' and use_default_value = True
        file: The file that was passed in
        processed_text: The processed text of the file.
    ### When input_type = 'vec<file>' and use_default_value = False
        files: The files that were passed in
        processed_texts: The processed text of the files
    ### When input_type = 'vec<file>' and use_default_value = True
        files: The files that were passed in
        processed_texts: The processed text of the files
    ### When input_type = 'image' and use_default_value = False
        image: The image that was passed in
    ### When input_type = 'image' and use_default_value = True
        image: The image that was passed in
    ### When input_type = 'knowledge_base' and use_default_value = False
        knowledge_base: The Knowledge Base that was passed in
    ### When input_type = 'knowledge_base' and use_default_value = True
        knowledge_base: The Knowledge Base that was passed in
    ### When input_type = 'pipeline' and use_default_value = False
        pipeline: The pipeline output
    ### When input_type = 'pipeline' and use_default_value = True
        pipeline: The pipeline output
    ### When input_type = 'string' and use_default_value = False
        text: The text that was passed in
    ### When input_type = 'string' and use_default_value = True
        text: The text that was passed in
    ### When input_type = 'int32' and use_default_value = False
        value: The integer that was passed in
    ### When input_type = 'int32' and use_default_value = True
        value: The integer that was passed in
    ### When input_type = 'bool' and use_default_value = False
        value: The boolean that was passed in
    ### When input_type = 'bool' and use_default_value = True
        value: The boolean that was passed in
    ### When input_type = 'timestamp' and use_default_value = False
        value: The timestamp that was passed in
    ### When input_type = 'timestamp' and use_default_value = True
        value: The timestamp that was passed in
    ### When input_type = 'vec<string>' and use_default_value = False
        value: The list of strings that was passed in
    ### When input_type = 'vec<string>' and use_default_value = True
        value: The list of strings that was passed in
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "description",
            "helper_text": "The description of the input",
            "value": "",
            "type": "string",
        },
        {
            "field": "input_type",
            "helper_text": "Raw Text",
            "value": "string",
            "type": "enum<string>",
        },
        {
            "field": "use_default_value",
            "helper_text": "Set default value to be used if no value is provided",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "string**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "string",
                    "helper_text": "Raw Text",
                }
            ],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The text that was passed in",
                }
            ],
        },
        "string**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "string",
                    "helper_text": "Raw Text",
                },
                {
                    "field": "default_value",
                    "type": "string",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The text that was passed in",
                }
            ],
        },
        "file**false": {
            "inputs": [
                {
                    "field": "file_parser",
                    "type": "enum<string>",
                    "value": "default",
                    "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
                },
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "file",
                    "helper_text": "File of any type: PDF, Word, MP3, JPEG, etc.",
                },
            ],
            "outputs": [
                {
                    "field": "processed_text",
                    "type": "string",
                    "helper_text": "The processed text of the file.",
                },
                {
                    "field": "file",
                    "type": "file",
                    "helper_text": "The file that was passed in",
                },
            ],
        },
        "file**true": {
            "inputs": [
                {
                    "field": "file_parser",
                    "type": "enum<string>",
                    "value": "default",
                    "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
                },
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "file",
                    "helper_text": "File of any type: PDF, Word, MP3, JPEG, etc.",
                },
                {
                    "field": "default_value",
                    "type": "file",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "processed_text",
                    "type": "string",
                    "helper_text": "The processed text of the file.",
                },
                {
                    "field": "file",
                    "type": "file",
                    "helper_text": "The file that was passed in",
                },
            ],
        },
        "audio**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "audio",
                    "helper_text": "Allows you to record audio through the VectorShift platform. To convert the audio to text, connect the input node to a Speech to Text node",
                }
            ],
            "outputs": [
                {
                    "field": "audio",
                    "type": "audio",
                    "helper_text": "The audio that was passed in",
                }
            ],
        },
        "audio**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "audio",
                    "helper_text": "Allows you to record audio through the VectorShift platform. To convert the audio to text, connect the input node to a Speech to Text node",
                },
                {
                    "field": "default_value",
                    "type": "audio",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "audio",
                    "type": "audio",
                    "helper_text": "The audio that was passed in",
                }
            ],
        },
        "image**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "image",
                    "helper_text": "Image of any type: JPEG, PNG, etc.",
                }
            ],
            "outputs": [
                {
                    "field": "image",
                    "type": "image",
                    "helper_text": "The image that was passed in",
                }
            ],
        },
        "image**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "image",
                    "helper_text": "Image of any type: JPEG, PNG, etc.",
                },
                {
                    "field": "default_value",
                    "type": "image",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "image",
                    "type": "image",
                    "helper_text": "The image that was passed in",
                }
            ],
        },
        "knowledge_base**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "knowledge_base",
                    "helper_text": "Allows you to pass a Knowledge Base as an input",
                }
            ],
            "outputs": [
                {
                    "field": "knowledge_base",
                    "type": "knowledge_base",
                    "helper_text": "The Knowledge Base that was passed in",
                }
            ],
        },
        "knowledge_base**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "knowledge_base",
                    "helper_text": "Allows you to pass a Knowledge Base as an input",
                },
                {
                    "field": "default_value",
                    "type": "knowledge_base",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "knowledge_base",
                    "type": "knowledge_base",
                    "helper_text": "The Knowledge Base that was passed in",
                }
            ],
        },
        "pipeline**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "pipeline",
                    "helper_text": "Allows you to pass a Pipeline as an input",
                }
            ],
            "outputs": [{"field": "pipeline", "type": "pipeline"}],
        },
        "pipeline**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "pipeline",
                    "helper_text": "Allows you to pass a Pipeline as an input",
                },
                {
                    "field": "default_value",
                    "type": "pipeline",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [{"field": "pipeline", "type": "pipeline"}],
        },
        "vec<file>**false": {
            "inputs": [
                {
                    "field": "file_parser",
                    "type": "enum<string>",
                    "value": "default",
                    "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
                },
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "vec<file>",
                    "helper_text": "Allows you to pass a list of files as an input",
                },
            ],
            "outputs": [
                {
                    "field": "processed_texts",
                    "type": "vec<string>",
                    "helper_text": "The processed text of the files",
                },
                {
                    "field": "files",
                    "type": "vec<file>",
                    "helper_text": "The files that were passed in",
                },
            ],
        },
        "vec<file>**true": {
            "inputs": [
                {
                    "field": "file_parser",
                    "type": "enum<string>",
                    "value": "default",
                    "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
                },
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "vec<file>",
                    "helper_text": "Allows you to pass a list of files as an input",
                },
                {
                    "field": "default_value",
                    "type": "vec<file>",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "processed_texts",
                    "type": "vec<string>",
                    "helper_text": "The processed text of the files",
                },
                {
                    "field": "files",
                    "type": "vec<file>",
                    "helper_text": "The files that were passed in",
                },
            ],
        },
        "int32**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "int32",
                    "helper_text": "Allows you to pass an integer as an input",
                }
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "int32",
                    "helper_text": "The integer that was passed in",
                }
            ],
        },
        "int32**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "int32",
                    "helper_text": "Allows you to pass an integer as an input",
                },
                {
                    "field": "default_value",
                    "type": "int32",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "int32",
                    "helper_text": "The integer that was passed in",
                }
            ],
        },
        "bool**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "bool",
                    "helper_text": "Allows you to pass a boolean as an input",
                }
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "bool",
                    "helper_text": "The boolean that was passed in",
                }
            ],
        },
        "bool**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "bool",
                    "helper_text": "Allows you to pass a boolean as an input",
                },
                {
                    "field": "default_value",
                    "type": "bool",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "bool",
                    "helper_text": "The boolean that was passed in",
                }
            ],
        },
        "timestamp**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "timestamp",
                    "helper_text": "Allows you to pass a timestamp as an input",
                }
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "timestamp",
                    "helper_text": "The timestamp that was passed in",
                }
            ],
        },
        "timestamp**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "timestamp",
                    "helper_text": "Allows you to pass a timestamp as an input",
                },
                {
                    "field": "default_value",
                    "type": "timestamp",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "timestamp",
                    "helper_text": "The timestamp that was passed in",
                }
            ],
        },
        "vec<string>**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "vec<string>",
                    "helper_text": "Allows you to pass a list of strings as an input",
                }
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "vec<string>",
                    "helper_text": "The list of strings that was passed in",
                }
            ],
        },
        "vec<string>**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "vec<string>",
                    "helper_text": "Allows you to pass a list of strings as an input",
                },
                {
                    "field": "default_value",
                    "type": "vec<string>",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "vec<string>",
                    "helper_text": "The list of strings that was passed in",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["input_type", "use_default_value"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        input_type: str = "string",
        use_default_value: bool = False,
        default_value: Optional[str] = None,
        description: str = "",
        file_parser: str = "default",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["input_type"] = input_type
        params["use_default_value"] = use_default_value

        super().__init__(
            node_type="input",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if input_type is not None:
            self.inputs["input_type"] = input_type
        if description is not None:
            self.inputs["description"] = description
        if use_default_value is not None:
            self.inputs["use_default_value"] = use_default_value
        if default_value is not None:
            self.inputs["default_value"] = default_value
        if file_parser is not None:
            self.inputs["file_parser"] = file_parser

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def audio(self) -> Any:
        """
        The audio that was passed in

        Available: When input_type = 'audio' and use_default_value = False, When input_type = 'audio' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("audio")

    @property
    def file(self) -> str:
        """
        The file that was passed in

        Available: When input_type = 'file' and use_default_value = False, When input_type = 'file' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file")

    @property
    def files(self) -> List[str]:
        """
        The files that were passed in

        Available: When input_type = 'vec<file>' and use_default_value = False, When input_type = 'vec<file>' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("files")

    @property
    def image(self) -> Any:
        """
        The image that was passed in

        Available: When input_type = 'image' and use_default_value = False, When input_type = 'image' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("image")

    @property
    def knowledge_base(self) -> Any:
        """
        The Knowledge Base that was passed in

        Available: When input_type = 'knowledge_base' and use_default_value = False, When input_type = 'knowledge_base' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("knowledge_base")

    @property
    def pipeline(self) -> Any:
        """
        The pipeline output

        Available: When input_type = 'pipeline' and use_default_value = False, When input_type = 'pipeline' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("pipeline")

    @property
    def processed_text(self) -> str:
        """
        The processed text of the file.

        Available: When input_type = 'file' and use_default_value = False, When input_type = 'file' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_text")

    @property
    def processed_texts(self) -> List[str]:
        """
        The processed text of the files

        Available: When input_type = 'vec<file>' and use_default_value = False, When input_type = 'vec<file>' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_texts")

    @property
    def text(self) -> str:
        """
        The text that was passed in

        Available: When input_type = 'string' and use_default_value = False, When input_type = 'string' and use_default_value = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @property
    def value(self) -> int:
        """
        The integer that was passed in

        Different behavior based on configuration:
          - The integer that was passed in (When input_type = 'int32' and use_default_value = False, When input_type = 'int32' and use_default_value = True)
          - The boolean that was passed in (When input_type = 'bool' and use_default_value = False, When input_type = 'bool' and use_default_value = True)
          - The timestamp that was passed in (When input_type = 'timestamp' and use_default_value = False, When input_type = 'timestamp' and use_default_value = True)
          - The list of strings that was passed in (When input_type = 'vec<string>' and use_default_value = False, When input_type = 'vec<string>' and use_default_value = True)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("value")

    @classmethod
    def from_dict(cls, data: dict) -> "InputNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("output")
class OutputNode(Node):
    """
    Output data of different types from your workflow.

    ## Inputs
    ### Common Inputs
        description: The description of the output
        output_type: The output_type input
    ### string
        value: The value input
    ### file
        value: The value input
    ### audio
        value: The value input
    ### json
        value: The value input
    ### image
        value: The value input
    ### stream<string>
        value: The value input
    ### vec<file>
        value: The value input
    ### int32
        value: The value input
    ### float
        value: The value input
    ### bool
        value: The value input
    ### timestamp
        value: The value input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "description",
            "helper_text": "The description of the output",
            "value": "",
            "type": "string",
        },
        {
            "field": "output_type",
            "helper_text": "The output_type input",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "string": {
            "inputs": [
                {"field": "value", "type": "string", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "string",
                    "helper_text": "Output raw text",
                },
            ],
            "outputs": [],
        },
        "file": {
            "inputs": [
                {"field": "value", "type": "file", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "file",
                    "helper_text": "Output file of any type: PDF, Word, Excel, CSV, MP3, JPEG, etc.",
                },
            ],
            "outputs": [],
        },
        "audio": {
            "inputs": [
                {"field": "value", "type": "audio", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "audio",
                    "helper_text": "Output raw audio. Output can be generated with the text to speech node",
                },
            ],
            "outputs": [],
        },
        "json": {
            "inputs": [
                {"field": "value", "type": "string", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "json",
                    "helper_text": "Output JSON (e.g., LLMs can output JSON - input the schema by selecting “JSON Output” in the gear of the LLM)",
                },
            ],
            "outputs": [],
        },
        "image": {
            "inputs": [
                {"field": "value", "type": "image", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "image",
                    "helper_text": "Output Image(s) (images are of file type PNG)",
                },
            ],
            "outputs": [],
        },
        "stream<string>": {
            "inputs": [
                {"field": "value", "type": "stream<string>", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "stream<string>",
                    "helper_text": "Output as a stream of raw text",
                },
            ],
            "outputs": [],
            "banner_text": 'Ensure to check "Stream Response" in gear of the LLM',
        },
        "vec<file>": {
            "inputs": [
                {"field": "value", "type": "vec<file>", "value": []},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "vec<file>",
                    "helper_text": "Output a list of files",
                },
            ],
            "outputs": [],
        },
        "int32": {
            "inputs": [
                {"field": "value", "type": "int32", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "int32",
                    "helper_text": "Output an integer",
                },
            ],
            "outputs": [],
        },
        "float": {
            "inputs": [
                {"field": "value", "type": "float", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "float",
                    "helper_text": "Output a float",
                },
            ],
            "outputs": [],
        },
        "bool": {
            "inputs": [
                {"field": "value", "type": "bool", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "bool",
                    "helper_text": "Output a boolean",
                },
            ],
            "outputs": [],
        },
        "timestamp": {
            "inputs": [
                {"field": "value", "type": "timestamp", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "timestamp",
                    "helper_text": "Output a timestamp",
                },
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["output_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        output_type: str = "string",
        description: str = "",
        value: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["output_type"] = output_type

        super().__init__(
            node_type="output",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if output_type is not None:
            self.inputs["output_type"] = output_type
        if description is not None:
            self.inputs["description"] = description
        if value is not None:
            self.inputs["value"] = value

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "OutputNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("categorizer")
class CategorizerNode(Node):
    """
    Categorize text using AI into custom-defined buckets

    ## Inputs
    ### Common Inputs
        additional_context: Provide any additional context or instructions
        fields: The fields to be categorized
        justification: Include the AI’s justification for its score
        max_tokens: The maximum number of tokens to generate
        model: The specific model for categorization
        provider: The model provider
        temperature: The temperature of the model
        text: The text that will be categorized
        top_p: The top-p value

    ## Outputs
    ### Common Outputs
        category: The category of the input text
        credits_used: The number of credits used
        input_tokens: The number of input tokens
        output_tokens: The number of output tokens
        tokens_used: The number of tokens used
    ### When justification = True
        justification: The AI justification
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "additional_context",
            "helper_text": "Provide any additional context or instructions",
            "value": "",
            "type": "string",
        },
        {
            "field": "fields",
            "helper_text": "The fields to be categorized",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "justification",
            "helper_text": "Include the AI’s justification for its score",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The maximum number of tokens to generate",
            "value": 2048,
            "type": "int64",
        },
        {
            "field": "model",
            "helper_text": "The specific model for categorization",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature of the model",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "text",
            "helper_text": "The text that will be categorized",
            "value": "",
            "type": "string",
        },
        {
            "field": "top_p",
            "helper_text": "The top-p value",
            "value": 1.0,
            "type": "float",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "category", "helper_text": "The category of the input text"},
        {"field": "credits_used", "helper_text": "The number of credits used"},
        {"field": "input_tokens", "helper_text": "The number of input tokens"},
        {"field": "output_tokens", "helper_text": "The number of output tokens"},
        {"field": "tokens_used", "helper_text": "The number of tokens used"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [],
            "outputs": [
                {
                    "field": "justification",
                    "type": "string",
                    "helper_text": "The AI justification",
                }
            ],
        },
        "false": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["justification"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        justification: bool = False,
        additional_context: str = "",
        fields: List[Any] = [],
        max_tokens: int = 2048,
        model: str = "gpt-4o",
        provider: str = "openai",
        temperature: Any = 0.7,
        text: str = "",
        top_p: Any = 1.0,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["justification"] = justification

        super().__init__(
            node_type="categorizer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if justification is not None:
            self.inputs["justification"] = justification
        if fields is not None:
            self.inputs["fields"] = fields
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if text is not None:
            self.inputs["text"] = text
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if top_p is not None:
            self.inputs["top_p"] = top_p

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def category(self) -> str:
        """
        The category of the input text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("category")

    @property
    def credits_used(self) -> Any:
        """
        The number of credits used


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("credits_used")

    @property
    def input_tokens(self) -> int:
        """
        The number of input tokens


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("input_tokens")

    @property
    def justification(self) -> str:
        """
        The AI justification

        Available: When justification = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("justification")

    @property
    def output_tokens(self) -> int:
        """
        The number of output tokens


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output_tokens")

    @property
    def tokens_used(self) -> int:
        """
        The number of tokens used


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tokens_used")

    @classmethod
    def from_dict(cls, data: dict) -> "CategorizerNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("extract_data")
class ExtractDataNode(Node):
    """
    Extract key pieces of information or a list of information from a input text.

    ## Inputs
    ### Common Inputs
        additional_context: Provide any additional context or instructions
        fields: The fields input
        model: The specific model for data extraction
        processed_outputs: The processed_outputs input
        provider: The model provider
        text: The text that data will be extracted from

    ## Outputs
    ### Common Outputs
        [processed_outputs]: The [processed_outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "additional_context",
            "helper_text": "Provide any additional context or instructions",
            "value": "",
            "type": "string",
        },
        {
            "field": "fields",
            "helper_text": "The fields input",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "model",
            "helper_text": "The specific model for data extraction",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "processed_outputs",
            "helper_text": "The processed_outputs input",
            "value": {},
            "type": "map<string, string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text that data will be extracted from",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "[processed_outputs]",
            "helper_text": "The [processed_outputs] output",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        additional_context: str = "",
        fields: List[Any] = [],
        model: str = "gpt-4o",
        processed_outputs: Dict[str, str] = {},
        provider: str = "openai",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="extract_data",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if fields is not None:
            self.inputs["fields"] = fields
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if text is not None:
            self.inputs["text"] = text
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "ExtractDataNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("data_collector")
class DataCollectorNode(Node):
    """
    Allows a chatbot to collect information by asking the user to provide specific pieces of information (e.g., name, email, etc.).

    ## Inputs
    ### Common Inputs
        auto_generate: If checked, the node will output questions in successive order until all fields are successfully collected. If unchecked, the node will output the data that is collected (often passed to an LLM with a prompt to ask successive questions to the user, along with specific instructions after all fields are collected) - e.g., {'Field1': 'Collected_Data', 'Field2': 'Collected_Data'}
        data_collector_node_id: The ID of the data collector node
        fields: The fields to be collected
        prompt: Specific instructions of how the LLM should collect the information
        query: The query to be analysed for data collection (passed to the LLM)
    ### When auto_generate = True
        llm: The model provider
        model: The specific model for question generation

    ## Outputs
    ### When auto_generate = False
        collected_data: The data that is collected
    ### When auto_generate = True
        question: The question to be asked to the user
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "auto_generate",
            "helper_text": "If checked, the node will output questions in successive order until all fields are successfully collected. If unchecked, the node will output the data that is collected (often passed to an LLM with a prompt to ask successive questions to the user, along with specific instructions after all fields are collected) - e.g., {'Field1': 'Collected_Data', 'Field2': 'Collected_Data'}",
            "value": True,
            "type": "bool",
        },
        {
            "field": "data_collector_node_id",
            "helper_text": "The ID of the data collector node",
            "value": "",
            "type": "string",
        },
        {
            "field": "fields",
            "helper_text": "The fields to be collected",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "prompt",
            "helper_text": "Specific instructions of how the LLM should collect the information",
            "value": "",
            "type": "string",
        },
        {
            "field": "query",
            "helper_text": "The query to be analysed for data collection (passed to the LLM)",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "llm",
                    "type": "enum<string>",
                    "value": "openai",
                    "helper_text": "The model provider",
                },
                {
                    "field": "model",
                    "type": "enum<string>",
                    "value": "gpt-4-1106-preview",
                    "helper_text": "The specific model for question generation",
                },
            ],
            "outputs": [
                {
                    "field": "question",
                    "type": "string",
                    "helper_text": "The question to be asked to the user",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "collected_data",
                    "type": "string",
                    "helper_text": "The data that is collected",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["auto_generate"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        auto_generate: bool = True,
        data_collector_node_id: str = "",
        fields: List[Any] = [],
        llm: str = "openai",
        model: str = "gpt-4-1106-preview",
        prompt: str = "",
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["auto_generate"] = auto_generate

        super().__init__(
            node_type="data_collector",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if auto_generate is not None:
            self.inputs["auto_generate"] = auto_generate
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if fields is not None:
            self.inputs["fields"] = fields
        if data_collector_node_id is not None:
            self.inputs["data_collector_node_id"] = data_collector_node_id
        if query is not None:
            self.inputs["query"] = query
        if llm is not None:
            self.inputs["llm"] = llm
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def collected_data(self) -> str:
        """
        The data that is collected

        Available: When auto_generate = False


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("collected_data")

    @property
    def question(self) -> str:
        """
        The question to be asked to the user

        Available: When auto_generate = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("question")

    @classmethod
    def from_dict(cls, data: dict) -> "DataCollectorNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("scorer")
class ScorerNode(Node):
    """
    Score text using AI based on a set of criteria.

    ## Inputs
    ### Common Inputs
        additional_context: Provide any additional context or instructions
        criteria: The criteria that the text will be scored
        justification: Include the AI’s justification for its score
        model: The specific model for scoring
        provider: The model provider
        text: The text that will be scored

    ## Outputs
    ### Common Outputs
        score: The score of the text based on the criteria
    ### When justification = True
        justification: The AI justification
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "additional_context",
            "helper_text": "Provide any additional context or instructions",
            "value": "",
            "type": "string",
        },
        {
            "field": "criteria",
            "helper_text": "The criteria that the text will be scored",
            "value": "",
            "type": "string",
        },
        {
            "field": "justification",
            "helper_text": "Include the AI’s justification for its score",
            "value": False,
            "type": "bool",
        },
        {
            "field": "model",
            "helper_text": "The specific model for scoring",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text that will be scored",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "score", "helper_text": "The score of the text based on the criteria"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [],
            "outputs": [
                {
                    "field": "justification",
                    "type": "string",
                    "helper_text": "The AI justification",
                }
            ],
        },
        "false": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["justification"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        justification: bool = False,
        additional_context: str = "",
        criteria: str = "",
        model: str = "gpt-4o",
        provider: str = "openai",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["justification"] = justification

        super().__init__(
            node_type="scorer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if justification is not None:
            self.inputs["justification"] = justification
        if text is not None:
            self.inputs["text"] = text
        if criteria is not None:
            self.inputs["criteria"] = criteria
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def justification(self) -> str:
        """
        The AI justification

        Available: When justification = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("justification")

    @property
    def score(self) -> Any:
        """
        The score of the text based on the criteria


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("score")

    @classmethod
    def from_dict(cls, data: dict) -> "ScorerNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("speech_to_text")
class SpeechToTextNode(Node):
    """


    ## Inputs
    ### Common Inputs
        audio: The audio input
        model: The model input
    ### Deepgram
        submodel: The submodel input
        tier: The tier input

    ## Outputs
    ### Common Outputs
        text: The text output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "audio",
            "helper_text": "The audio input",
            "value": "",
            "type": "audio",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "OpenAI Whisper",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "text", "helper_text": "The text output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "OpenAI Whisper": {"inputs": [], "outputs": []},
        "Deepgram": {
            "inputs": [
                {"field": "submodel", "type": "enum<string>", "value": "nova-2"},
                {"field": "tier", "type": "enum<string>", "value": "general"},
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["model"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        model: str = "OpenAI Whisper",
        audio: Any = None,
        submodel: str = "nova-2",
        tier: str = "general",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["model"] = model

        super().__init__(
            node_type="speech_to_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if model is not None:
            self.inputs["model"] = model
        if audio is not None:
            self.inputs["audio"] = audio
        if submodel is not None:
            self.inputs["submodel"] = submodel
        if tier is not None:
            self.inputs["tier"] = tier

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def text(self) -> str:
        """
        The text output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @classmethod
    def from_dict(cls, data: dict) -> "SpeechToTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("file_save")
class FileSaveNode(Node):
    """
    Save a file on the VectorShift platform (under the 'Files' tab).

    ## Inputs
    ### Common Inputs
        files: The files to be saved
        name: The name of the file

    ## Outputs
    ### Common Outputs
        file_name: The name of the file saved
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "files",
            "helper_text": "The files to be saved",
            "value": [""],
            "type": "vec<file>",
        },
        {
            "field": "name",
            "helper_text": "The name of the file",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file_name", "helper_text": "The name of the file saved"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        files: List[str] = [""],
        name: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="file_save",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if name is not None:
            self.inputs["name"] = name
        if files is not None:
            self.inputs["files"] = files

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def file_name(self) -> List[str]:
        """
        The name of the file saved


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_name")

    @classmethod
    def from_dict(cls, data: dict) -> "FileSaveNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("image_gen")
class ImageGenNode(Node):
    """


    ## Inputs
    ### Common Inputs
        aspect_ratio: The aspect_ratio input
        image_count: The image_count input
        model: The model input
        prompt: The prompt input
        provider: The provider input
        size: The size input

    ## Outputs
    ### Common Outputs
        images: The images output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "aspect_ratio",
            "helper_text": "The aspect_ratio input",
            "value": "1:1",
            "type": "enum<string>",
        },
        {
            "field": "image_count",
            "helper_text": "The image_count input",
            "value": "1",
            "type": "string",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "gpt-4-1106-preview",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The prompt input",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "The provider input",
            "value": "llmOpenAI",
            "type": "enum<string>",
        },
        {
            "field": "size",
            "helper_text": "The size input",
            "value": "512x512",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "images", "helper_text": "The images output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        aspect_ratio: str = "1:1",
        image_count: str = "1",
        model: str = "gpt-4-1106-preview",
        prompt: str = "",
        provider: str = "llmOpenAI",
        size: str = "512x512",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="image_gen",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if size is not None:
            self.inputs["size"] = size
        if aspect_ratio is not None:
            self.inputs["aspect_ratio"] = aspect_ratio
        if image_count is not None:
            self.inputs["image_count"] = image_count

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def images(self) -> List[Any]:
        """
        The images output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("images")

    @classmethod
    def from_dict(cls, data: dict) -> "ImageGenNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("file")
class FileNode(Node):
    """
    Load a static file into the workflow as a raw File or process it into Text.

    ## Inputs
    ### Common Inputs
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
        selected_option: Select an existing file from the VectorShift platform
    ### upload
        file: The file that was passed in
    ### name
        file_name: The name of the file from the VectorShift platform (for files on the File tab)

    ## Outputs
    ### Common Outputs
        file: The file that was passed in
        processed_text: The processed text of the file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file_parser",
            "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
            "value": "default",
            "type": "enum<string>",
        },
        {
            "field": "selected_option",
            "helper_text": "Select an existing file from the VectorShift platform",
            "value": "upload",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file", "helper_text": "The file that was passed in"},
        {"field": "processed_text", "helper_text": "The processed text of the file"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "upload": {
            "inputs": [
                {
                    "field": "file",
                    "type": "file",
                    "helper_text": "The file that was passed in",
                }
            ],
            "outputs": [],
        },
        "name": {
            "inputs": [
                {
                    "field": "file_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "The name of the file from the VectorShift platform (for files on the File tab)",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["selected_option"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        selected_option: str = "upload",
        file: Optional[str] = None,
        file_name: str = "",
        file_parser: str = "default",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["selected_option"] = selected_option

        super().__init__(
            node_type="file",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_parser is not None:
            self.inputs["file_parser"] = file_parser
        if selected_option is not None:
            self.inputs["selected_option"] = selected_option
        if file is not None:
            self.inputs["file"] = file
        if file_name is not None:
            self.inputs["file_name"] = file_name

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def file(self) -> str:
        """
        The file that was passed in


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file")

    @property
    def processed_text(self) -> str:
        """
        The processed text of the file


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_text")

    @classmethod
    def from_dict(cls, data: dict) -> "FileNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("get_list_item")
class GetListItemNode(Node):
    """
    Get a value from a list given an index. The first item in the list is index 0.

    ## Inputs
    ### Common Inputs
        index: The index of the item to retrieve
        type: The type of the list
    ### <T>
        list: The list to retrieve the item from

    ## Outputs
    ### <T>
        output: The item retrieved from the list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "index",
            "helper_text": "The index of the item to retrieve",
            "value": 0,
            "type": "int32",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The list to retrieve the item from",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "<T>",
                    "helper_text": "The item retrieved from the list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        index: int = 0,
        list: List[Any] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="get_list_item",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if index is not None:
            self.inputs["index"] = index
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "GetListItemNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("llm_open_ai_vision")
class LlmOpenAiVisionNode(Node):
    """


    ## Inputs
    ### Common Inputs
        image: The image input
        json_response: The json_response input
        max_tokens: The max_tokens input
        model: The model input
        prompt: The prompt input
        provider: The provider input
        stream: The stream input
        system: The system input
        temperature: The temperature input
        top_p: The top_p input
        use_personal_api_key: The use_personal_api_key input
    ### When use_personal_api_key = True
        api_key: The api_key input
    ### When json_response = True
        json_schema: The json_schema input

    ## Outputs
    ### Common Outputs
        response: The response output
        tokens_used: The tokens_used output
    ### When stream = True
        response_deltas: The response_deltas output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "image",
            "helper_text": "The image input",
            "value": None,
            "type": "image",
        },
        {
            "field": "json_response",
            "helper_text": "The json_response input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The max_tokens input",
            "value": 128000,
            "type": "int32",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "gpt-4-vision-preview",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The prompt input",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "The provider input",
            "value": "openAiImageToText",
            "type": "enum<string>",
        },
        {
            "field": "stream",
            "helper_text": "The stream input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "system",
            "helper_text": "The system input",
            "value": "",
            "type": "string",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature input",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "top_p",
            "helper_text": "The top_p input",
            "value": 0.9,
            "type": "float",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "The use_personal_api_key input",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "response", "helper_text": "The response output"},
        {"field": "tokens_used", "helper_text": "The tokens_used output"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**true**(*)**(*)": {
            "inputs": [],
            "outputs": [{"field": "response_deltas", "type": "Stream<string>"}],
        },
        "(*)**false**(*)**(*)": {"inputs": [], "outputs": []},
        "(*)**(*)**true**(*)": {
            "inputs": [{"field": "api_key", "type": "string", "value": ""}],
            "outputs": [],
        },
        "(*)**(*)**false**(*)": {"inputs": [], "outputs": []},
        "(*)**(*)**(*)**true": {
            "inputs": [{"field": "json_schema", "type": "string", "value": ""}],
            "outputs": [],
        },
        "(*)**(*)**(*)**false": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["provider", "stream", "use_personal_api_key", "json_response"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        provider: str = "openAiImageToText",
        stream: bool = False,
        use_personal_api_key: bool = False,
        json_response: bool = False,
        api_key: str = "",
        image: Optional[Any] = None,
        json_schema: str = "",
        max_tokens: int = 128000,
        model: str = "gpt-4-vision-preview",
        prompt: str = "",
        system: str = "",
        temperature: Any = 0.7,
        top_p: Any = 0.9,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["provider"] = provider
        params["stream"] = stream
        params["use_personal_api_key"] = use_personal_api_key
        params["json_response"] = json_response

        super().__init__(
            node_type="llm_open_ai_vision",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if system is not None:
            self.inputs["system"] = system
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if stream is not None:
            self.inputs["stream"] = stream
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if image is not None:
            self.inputs["image"] = image
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if json_schema is not None:
            self.inputs["json_schema"] = json_schema

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def response(self) -> str:
        """
        The response output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @property
    def tokens_used(self) -> int:
        """
        The tokens_used output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tokens_used")

    @classmethod
    def from_dict(cls, data: dict) -> "LlmOpenAiVisionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("llm_google_vision")
class LlmGoogleVisionNode(Node):
    """


    ## Inputs
    ### Common Inputs
        api_key: The api_key input
        image: The image input
        json_response: The json_response input
        max_tokens: The max_tokens input
        model: The model input
        prompt: The prompt input
        provider: The provider input
        stream: The stream input
        temperature: The temperature input
        top_p: The top_p input

    ## Outputs
    ### Common Outputs
        response: The response output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "api_key",
            "helper_text": "The api_key input",
            "value": "",
            "type": "string",
        },
        {
            "field": "image",
            "helper_text": "The image input",
            "value": None,
            "type": "image",
        },
        {
            "field": "json_response",
            "helper_text": "The json_response input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The max_tokens input",
            "value": 32760,
            "type": "int32",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "gemini-pro-vision",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The prompt input",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "The provider input",
            "value": "googleImageToText",
            "type": "enum<string>",
        },
        {
            "field": "stream",
            "helper_text": "The stream input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature input",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "top_p",
            "helper_text": "The top_p input",
            "value": 0.9,
            "type": "float",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "response", "helper_text": "The response output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        api_key: str = "",
        image: Optional[Any] = None,
        json_response: bool = False,
        max_tokens: int = 32760,
        model: str = "gemini-pro-vision",
        prompt: str = "",
        provider: str = "googleImageToText",
        stream: bool = False,
        temperature: Any = 0.7,
        top_p: Any = 0.9,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="llm_google_vision",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if stream is not None:
            self.inputs["stream"] = stream
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if image is not None:
            self.inputs["image"] = image

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def response(self) -> str:
        """
        The response output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @classmethod
    def from_dict(cls, data: dict) -> "LlmGoogleVisionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("split_text")
class SplitTextNode(Node):
    """
    Takes input text and separate it into a List of texts based on the delimiter.

    ## Inputs
    ### Common Inputs
        delimiter: The delimiter to split the text on
        text: The text to split
    ### character(s)
        character: The character(s) to split the text on

    ## Outputs
    ### Common Outputs
        processed_text: The text split into a list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "delimiter",
            "helper_text": "The delimiter to split the text on",
            "value": "space",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to split",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "processed_text", "helper_text": "The text split into a list"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "character(s)": {
            "inputs": [
                {
                    "field": "character",
                    "type": "string",
                    "value": "",
                    "helper_text": "The character(s) to split the text on",
                }
            ],
            "outputs": [],
        },
        "space": {"inputs": [], "outputs": []},
        "newline": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["delimiter"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        delimiter: str = "space",
        character: str = "",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["delimiter"] = delimiter

        super().__init__(
            node_type="split_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if delimiter is not None:
            self.inputs["delimiter"] = delimiter
        if text is not None:
            self.inputs["text"] = text
        if character is not None:
            self.inputs["character"] = character

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def processed_text(self) -> List[str]:
        """
        The text split into a list


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_text")

    @classmethod
    def from_dict(cls, data: dict) -> "SplitTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("summarizer")
class SummarizerNode(Node):
    """
    Summarize text with AI

    ## Inputs
    ### Common Inputs
        model: The specific model for summarization
        provider: The model provider
        text: The text to be summarized

    ## Outputs
    ### Common Outputs
        summary: The summary of the text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "model",
            "helper_text": "The specific model for summarization",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to be summarized",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "summary", "helper_text": "The summary of the text"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        model: str = "gpt-4o",
        provider: str = "openai",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="summarizer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def summary(self) -> str:
        """
        The summary of the text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("summary")

    @classmethod
    def from_dict(cls, data: dict) -> "SummarizerNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("text")
class TextNode(Node):
    """
    Accepts Text from upstream nodes and allows you to write additional text / concatenate different texts to pass to downstream nodes.

    ## Inputs
    ### Common Inputs
        text: The text to be processed

    ## Outputs
    ### Common Outputs
        text: The text from the node
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "text",
            "helper_text": "The text to be processed",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "text", "helper_text": "The text from the node"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def text(self) -> str:
        """
        The text from the node


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @classmethod
    def from_dict(cls, data: dict) -> "TextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("text_to_file")
class TextToFileNode(Node):
    """
    Convert data from type Text to type File

    ## Inputs
    ### Common Inputs
        file_type: The type of file to convert the text to.
        text: The text for conversion.

    ## Outputs
    ### Common Outputs
        file: The text as converted to a file.
        file_type: The type of file that was converted the text to.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file_type",
            "helper_text": "The type of file to convert the text to.",
            "value": "PDF",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text for conversion.",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file", "helper_text": "The text as converted to a file."},
        {
            "field": "file_type",
            "helper_text": "The type of file that was converted the text to.",
        },
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        file_type: str = "PDF",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="text_to_file",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_type is not None:
            self.inputs["file_type"] = file_type
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def file(self) -> str:
        """
        The text as converted to a file.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file")

    @property
    def file_type(self) -> str:
        """
        The type of file that was converted the text to.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file_type")

    @classmethod
    def from_dict(cls, data: dict) -> "TextToFileNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("time")
class TimeNode(Node):
    """
    Outputs the current time (often connected to LLM node)

    ## Inputs
    ### Common Inputs
        delta_time_unit: The unit of the delta
        delta_value: The value of the delta
        is_positive: If the time should be positive
        is_positive_delta: If the time should be positive
        output_format: The format of the output time
        time_node_zone: The timezone of the time node

    ## Outputs
    ### Common Outputs
        processed_time: The time from the node
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "delta_time_unit",
            "helper_text": "The unit of the delta",
            "value": "Seconds",
            "type": "enum<string>",
        },
        {
            "field": "delta_value",
            "helper_text": "The value of the delta",
            "value": 0,
            "type": "int32",
        },
        {
            "field": "is_positive",
            "helper_text": "If the time should be positive",
            "value": "+",
            "type": "enum<string>",
        },
        {
            "field": "is_positive_delta",
            "helper_text": "If the time should be positive",
            "value": True,
            "type": "bool",
        },
        {
            "field": "output_format",
            "helper_text": "The format of the output time",
            "value": "DD/MM/YYYY",
            "type": "enum<string>",
        },
        {
            "field": "time_node_zone",
            "helper_text": "The timezone of the time node",
            "value": "America/New_York",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "processed_time", "helper_text": "The time from the node"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        delta_time_unit: str = "Seconds",
        delta_value: int = 0,
        is_positive: str = "+",
        is_positive_delta: bool = True,
        output_format: str = "DD/MM/YYYY",
        time_node_zone: str = "America/New_York",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="time",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if is_positive is not None:
            self.inputs["is_positive"] = is_positive
        if is_positive_delta is not None:
            self.inputs["is_positive_delta"] = is_positive_delta
        if delta_value is not None:
            self.inputs["delta_value"] = delta_value
        if delta_time_unit is not None:
            self.inputs["delta_time_unit"] = delta_time_unit
        if output_format is not None:
            self.inputs["output_format"] = output_format
        if time_node_zone is not None:
            self.inputs["time_node_zone"] = time_node_zone

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def processed_time(self) -> str:
        """
        The time from the node


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_time")

    @classmethod
    def from_dict(cls, data: dict) -> "TimeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("translator")
class TranslatorNode(Node):
    """
    Translate text from one language to another

    ## Inputs
    ### Common Inputs
        model: The specific model for translation
        provider: The model provider
        source_language: The language of the input text
        target_language: The language to translate to
        text: The text to be translated

    ## Outputs
    ### Common Outputs
        translation: The translation of the text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "model",
            "helper_text": "The specific model for translation",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "source_language",
            "helper_text": "The language of the input text",
            "value": "Detect Language",
            "type": "enum<string>",
        },
        {
            "field": "target_language",
            "helper_text": "The language to translate to",
            "value": "English",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to be translated",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "translation", "helper_text": "The translation of the text"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        model: str = "gpt-4o",
        provider: str = "openai",
        source_language: str = "Detect Language",
        target_language: str = "English",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="translator",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if source_language is not None:
            self.inputs["source_language"] = source_language
        if target_language is not None:
            self.inputs["target_language"] = target_language

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def translation(self) -> str:
        """
        The translation of the text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("translation")

    @classmethod
    def from_dict(cls, data: dict) -> "TranslatorNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("tts_eleven_labs")
class TtsElevenLabsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        api_key: The api_key input
        model: The model input
        text: The text input
        voice: The voice input

    ## Outputs
    ### Common Outputs
        audio: The audio output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "api_key",
            "helper_text": "The api_key input",
            "value": "",
            "type": "string",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "eleven_multilingual_v2",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text input",
            "value": "",
            "type": "string",
        },
        {
            "field": "voice",
            "helper_text": "The voice input",
            "value": "shimmer",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "audio", "helper_text": "The audio output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        api_key: str = "",
        model: str = "eleven_multilingual_v2",
        text: str = "",
        voice: str = "shimmer",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="tts_eleven_labs",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if model is not None:
            self.inputs["model"] = model
        if voice is not None:
            self.inputs["voice"] = voice
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def audio(self) -> Any:
        """
        The audio output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("audio")

    @classmethod
    def from_dict(cls, data: dict) -> "TtsElevenLabsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("tts_open_ai")
class TtsOpenAiNode(Node):
    """


    ## Inputs
    ### Common Inputs
        model: The model input
        text: The text input
        use_personal_api_key: The use_personal_api_key input
        voice: The voice input
    ### When use_personal_api_key = True
        api_key: The api_key input

    ## Outputs
    ### Common Outputs
        audio: The audio output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "tts-1",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text input",
            "value": "",
            "type": "string",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "The use_personal_api_key input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "voice",
            "helper_text": "The voice input",
            "value": "alloy",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "audio", "helper_text": "The audio output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false": {"inputs": [], "outputs": []},
        "true": {
            "inputs": [{"field": "api_key", "type": "string", "value": ""}],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        api_key: str = "",
        model: str = "tts-1",
        text: str = "",
        voice: str = "alloy",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key

        super().__init__(
            node_type="tts_open_ai",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if model is not None:
            self.inputs["model"] = model
        if voice is not None:
            self.inputs["voice"] = voice
        if text is not None:
            self.inputs["text"] = text
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def audio(self) -> Any:
        """
        The audio output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("audio")

    @classmethod
    def from_dict(cls, data: dict) -> "TtsOpenAiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_audio_operations")
class AiAudioOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="ai_audio_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "AiAudioOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_text_to_speech")
class AiTextToSpeechNode(Node):
    """
    Generate Audio from text using AI

    ## Inputs
    ### Common Inputs
        model: Select the text-to-speech model
        provider: Select the model provider.
        text: The text for conversion.
        use_personal_api_key: Use your personal API key
        voice: Select the voice
    ### When use_personal_api_key = True
        api_key: Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run

    ## Outputs
    ### Common Outputs
        audio: The Text as converted to Audio.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "model",
            "helper_text": "Select the text-to-speech model",
            "value": "tts-1",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "Select the model provider.",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text for conversion.",
            "value": "",
            "type": "string",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "Use your personal API key",
            "value": False,
            "type": "bool",
        },
        {
            "field": "voice",
            "helper_text": "Select the voice",
            "value": "alloy",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "audio", "helper_text": "The Text as converted to Audio."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)": {"inputs": [], "outputs": []},
        "true**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run",
                }
            ],
            "outputs": [],
        },
        "(*)**openai": {"inputs": [], "outputs": [], "title": "OpenAI Text to Speech"},
        "(*)**eleven_labs": {
            "inputs": [],
            "outputs": [],
            "title": "Eleven Labs Text to Speech",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "provider"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        provider: str = "openai",
        api_key: str = "",
        model: str = "tts-1",
        text: str = "",
        voice: str = "alloy",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["provider"] = provider

        super().__init__(
            node_type="ai_text_to_speech",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if voice is not None:
            self.inputs["voice"] = voice
        if text is not None:
            self.inputs["text"] = text
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def audio(self) -> Any:
        """
        The Text as converted to Audio.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("audio")

    @classmethod
    def from_dict(cls, data: dict) -> "AiTextToSpeechNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_speech_to_text")
class AiSpeechToTextNode(Node):
    """
    Generate Text from Audio using AI

    ## Inputs
    ### Common Inputs
        audio: The audio for conversion
        model: Select the speech-to-text model
        provider: Select the model provider.
        use_personal_api_key: Use your personal API key
    ### When use_personal_api_key = True
        api_key: The api_key input
    ### When provider = 'deepgram'
        tier: Select the tier

    ## Outputs
    ### Common Outputs
        text: The Text from the Audio.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "audio",
            "helper_text": "The audio for conversion",
            "value": "",
            "type": "audio",
        },
        {
            "field": "model",
            "helper_text": "Select the speech-to-text model",
            "value": "whisper-1",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "Select the model provider.",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "Use your personal API key",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "text", "helper_text": "The Text from the Audio."}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**openai": {"inputs": [], "outputs": [], "title": "OpenAI Speech to Text"},
        "(*)**deepgram": {
            "inputs": [
                {
                    "field": "tier",
                    "type": "enum<string>",
                    "value": "general",
                    "helper_text": "Select the tier",
                }
            ],
            "outputs": [],
            "title": "Deepgram Speech to Text",
        },
        "false**(*)": {"inputs": [], "outputs": []},
        "true**(*)": {
            "inputs": [{"field": "api_key", "type": "string", "value": ""}],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "provider"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        provider: str = "openai",
        api_key: str = "",
        audio: Any = None,
        model: str = "whisper-1",
        tier: str = "general",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["provider"] = provider

        super().__init__(
            node_type="ai_speech_to_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if audio is not None:
            self.inputs["audio"] = audio
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if tier is not None:
            self.inputs["tier"] = tier
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def text(self) -> str:
        """
        The Text from the Audio.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @classmethod
    def from_dict(cls, data: dict) -> "AiSpeechToTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_image_operations")
class AiImageOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="ai_image_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "AiImageOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_image_to_text")
class AiImageToTextNode(Node):
    """
    Generate Text from Image using AI

    ## Inputs
    ### Common Inputs
        image: The image for conversion
        json_response: Return the response as a JSON object
        max_tokens: The maximum number of tokens to generate
        model: Select the image-to-text model
        prompt: The data that is sent to the LLM. Add data from other nodes with double curly braces, e.g., {{input1}}
        provider: Select the model provider.
        stream: Stream the response
        system: Tell the AI model how you would like it to respond. Be as specific as possible. For example, you can instruct the model on what tone to respond in or how to respond given the information you provide
        temperature: The temperature of the model
        top_p: The top-p value
        use_personal_api_key: Use your personal API key
    ### When use_personal_api_key = True
        api_key: Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run
    ### When json_response = True
        json_schema: The JSON schema to use for the response

    ## Outputs
    ### Common Outputs
        tokens_used: The number of tokens used
    ### When stream = False
        text: The Text from the Image.
    ### When stream = True
        text: Stream of text generated from the Image.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "image",
            "helper_text": "The image for conversion",
            "value": None,
            "type": "image",
        },
        {
            "field": "json_response",
            "helper_text": "Return the response as a JSON object",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The maximum number of tokens to generate",
            "value": 128000,
            "type": "int64",
        },
        {
            "field": "model",
            "helper_text": "Select the image-to-text model",
            "value": "chatgpt-4o-latest",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The data that is sent to the LLM. Add data from other nodes with double curly braces, e.g., {{input1}}",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "Select the model provider.",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "stream",
            "helper_text": "Stream the response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "system",
            "helper_text": "Tell the AI model how you would like it to respond. Be as specific as possible. For example, you can instruct the model on what tone to respond in or how to respond given the information you provide",
            "value": "",
            "type": "string",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature of the model",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "top_p",
            "helper_text": "The top-p value",
            "value": 0.9,
            "type": "float",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "Use your personal API key",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "tokens_used", "helper_text": "The number of tokens used"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)**(*)**(*)": {"inputs": [], "outputs": []},
        "true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run",
                }
            ],
            "outputs": [],
        },
        "(*)**false**(*)**(*)": {"inputs": [], "outputs": []},
        "(*)**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_schema",
                    "type": "string",
                    "value": "",
                    "helper_text": "The JSON schema to use for the response",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**false**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The Text from the Image.",
                }
            ],
        },
        "(*)**(*)**true**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "text",
                    "type": "stream<string>",
                    "helper_text": "Stream of text generated from the Image.",
                }
            ],
        },
        "(*)**(*)**(*)**openai": {
            "inputs": [],
            "outputs": [],
            "title": "OpenAI Image to Text",
        },
        "(*)**(*)**(*)**anthropic": {
            "inputs": [],
            "outputs": [],
            "title": "Anthropic Image to Text",
        },
        "(*)**(*)**(*)**google": {
            "inputs": [],
            "outputs": [],
            "title": "Google Image to Text",
        },
        "(*)**(*)**(*)**xai": {
            "inputs": [],
            "outputs": [],
            "title": "XAI Image to Text",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "json_response", "stream", "provider"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        json_response: bool = False,
        stream: bool = False,
        provider: str = "openai",
        api_key: str = "",
        image: Optional[Any] = None,
        json_schema: str = "",
        max_tokens: int = 128000,
        model: str = "chatgpt-4o-latest",
        prompt: str = "",
        system: str = "",
        temperature: Any = 0.7,
        top_p: Any = 0.9,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["json_response"] = json_response
        params["stream"] = stream
        params["provider"] = provider

        super().__init__(
            node_type="ai_image_to_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if system is not None:
            self.inputs["system"] = system
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if image is not None:
            self.inputs["image"] = image
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if stream is not None:
            self.inputs["stream"] = stream
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if json_schema is not None:
            self.inputs["json_schema"] = json_schema

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def text(self) -> str:
        """
        The Text from the Image.

        Different behavior based on configuration:
          - The Text from the Image. (When stream = False)
          - Stream of text generated from the Image. (When stream = True)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @property
    def tokens_used(self) -> int:
        """
        The number of tokens used


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("tokens_used")

    @classmethod
    def from_dict(cls, data: dict) -> "AiImageToTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_text_to_image")
class AiTextToImageNode(Node):
    """
    Generate Image from Text using AI

    ## Inputs
    ### Common Inputs
        aspect_ratio: Select the aspect ratio.
        model: Select the text-to-image model
        prompt: Tell the AI model how you would like it to respond. Be as specific as possible. For example, you can instruct the model to use bright colors.
        provider: Select the model provider.
        size: Select the size.
        use_personal_api_key: Use your personal API key
    ### When use_personal_api_key = True
        api_key: Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run

    ## Outputs
    ### Common Outputs
        image: The Image(s) generated from the Text.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "aspect_ratio",
            "helper_text": "Select the aspect ratio.",
            "value": "1:1",
            "type": "enum<string>",
        },
        {
            "field": "model",
            "helper_text": "Select the text-to-image model",
            "value": "dall-e-2",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "Tell the AI model how you would like it to respond. Be as specific as possible. For example, you can instruct the model to use bright colors.",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "Select the model provider.",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "size",
            "helper_text": "Select the size.",
            "value": "512x512",
            "type": "enum<string>",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "Use your personal API key",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "image", "helper_text": "The Image(s) generated from the Text."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)": {"inputs": [], "outputs": []},
        "true**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run",
                }
            ],
            "outputs": [],
        },
        "(*)**openai": {"inputs": [], "outputs": [], "title": "OpenAI Text to Image"},
        "(*)**stabilityai": {
            "inputs": [],
            "outputs": [],
            "title": "Stability AI Text to Image",
        },
        "(*)**flux": {"inputs": [], "outputs": [], "title": "Flux Text to Image"},
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "provider"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        provider: str = "openai",
        api_key: str = "",
        aspect_ratio: str = "1:1",
        model: str = "dall-e-2",
        prompt: str = "",
        size: str = "512x512",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["provider"] = provider

        super().__init__(
            node_type="ai_text_to_image",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if size is not None:
            self.inputs["size"] = size
        if aspect_ratio is not None:
            self.inputs["aspect_ratio"] = aspect_ratio
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def image(self) -> Any:
        """
        The Image(s) generated from the Text.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("image")

    @classmethod
    def from_dict(cls, data: dict) -> "AiTextToImageNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("llm_anthropic_vision")
class LlmAnthropicVisionNode(Node):
    """


    ## Inputs
    ### Common Inputs
        image: The image input
        json_response: The json_response input
        max_tokens: The max_tokens input
        model: The model input
        prompt: The prompt input
        system: The system input
        temperature: The temperature input
        top_p: The top_p input
        use_personal_api_key: The use_personal_api_key input
    ### When use_personal_api_key = True
        api_key: The api_key input
    ### When json_response = True
        json_schema: The json_schema input

    ## Outputs
    ### Common Outputs
        response: The response output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "image",
            "helper_text": "The image input",
            "value": None,
            "type": "image",
        },
        {
            "field": "json_response",
            "helper_text": "The json_response input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The max_tokens input",
            "value": 200000,
            "type": "int32",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "claude-3-haiku-20240307",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The prompt input",
            "value": "",
            "type": "string",
        },
        {
            "field": "system",
            "helper_text": "The system input",
            "value": "",
            "type": "string",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature input",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "top_p",
            "helper_text": "The top_p input",
            "value": 0.9,
            "type": "float",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "The use_personal_api_key input",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "response", "helper_text": "The response output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)": {"inputs": [], "outputs": []},
        "true**(*)": {
            "inputs": [{"field": "api_key", "type": "string", "value": ""}],
            "outputs": [],
        },
        "(*)**false": {"inputs": [], "outputs": []},
        "(*)**true": {
            "inputs": [{"field": "json_schema", "type": "string", "value": ""}],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "json_response"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        json_response: bool = False,
        api_key: str = "",
        image: Optional[Any] = None,
        json_schema: str = "",
        max_tokens: int = 200000,
        model: str = "claude-3-haiku-20240307",
        prompt: str = "",
        system: str = "",
        temperature: Any = 0.7,
        top_p: Any = 0.9,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["json_response"] = json_response

        super().__init__(
            node_type="llm_anthropic_vision",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if system is not None:
            self.inputs["system"] = system
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if image is not None:
            self.inputs["image"] = image
        if model is not None:
            self.inputs["model"] = model
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if json_schema is not None:
            self.inputs["json_schema"] = json_schema

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def response(self) -> str:
        """
        The response output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @classmethod
    def from_dict(cls, data: dict) -> "LlmAnthropicVisionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("semantic_search")
class SemanticSearchNode(Node):
    """
    Generate a temporary vector database at run-time and retrieve the most relevant pieces from the documents based on the query.

    ## Inputs
    ### Common Inputs
        alpha: The alpha value for the retrieval
        analyze_documents: To analyze document contents and enrich them when parsing
        answer_multiple_questions: Extract separate questions from the query and retrieve content separately for each question to improve search performance
        do_advanced_qa: Use additional LLM calls to analyze each document to improve answer correctness
        do_nl_metadata_query: Do a natural language metadata query
        documents: The text for semantic search. Note: you may add multiple upstream nodes to this field.
        enable_context: Additional context passed to advanced search and query analysis
        enable_document_db_filter: Filter the documents returned from the knowledge base
        enable_filter: Filter the content returned from the knowledge base
        expand_query: Expand query to improve semantic search
        expand_query_terms: Expand query terms to improve semantic search
        format_context_for_llm: Format the context for the LLM
        is_hybrid: Whether to create a hybrid knowledge base
        max_docs_per_query: The maximum number of relevant chunks to be returned
        model: The model to use for the embedding
        query: The query will be used to search documents for relevant pieces semantically.
        rerank_documents: Refine the initial ranking of returned chunks based on relevancy
        retrieval_unit: The unit of retrieval
        score_cutoff: The score cutoff
        segmentation_method: The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.
        show_intermediate_steps: Show intermediate steps
        splitter_method: Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.
        transform_query: Transform the query for better semantic search
    ### When do_advanced_qa = True
        advanced_search_mode: The mode to use for the advanced search
        qa_model_name: The model to use for the QA
    ### When enable_context = True
        context: Additional context to pass to the query analysis and qa steps
    ### When enable_document_db_filter = True
        document_db_filter: Filter the documents returned from the knowledge base
    ### When enable_filter = True
        filter: Filter the content returned from the knowledge base
    ### When rerank_documents = True
        rerank_model: Refine the initial ranking of returned chunks based on relevancy

    ## Outputs
    ### When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = False
        chunks: Semantically similar chunks retrieved from the knowledge base
    ### When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True
        chunks: Semantically similar chunks retrieved from the knowledge base
        formatted_text: Knowledge base outputs formatted for input to a LLM
    ### When do_advanced_qa = True
        citation_metadata: Citation metadata for semantic search outputs, used for showing sources in LLM responses
        response: The response from the semantic search
    ### When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = False
        documents: Semantically similar documents retrieved from the knowledge base
    ### When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True
        documents: Semantically similar documents retrieved from the knowledge base
        formatted_text: Knowledge base outputs formatted for input to a LLM
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "alpha",
            "helper_text": "The alpha value for the retrieval",
            "value": 0.5,
            "type": "float",
        },
        {
            "field": "analyze_documents",
            "helper_text": "To analyze document contents and enrich them when parsing",
            "value": False,
            "type": "bool",
        },
        {
            "field": "answer_multiple_questions",
            "helper_text": "Extract separate questions from the query and retrieve content separately for each question to improve search performance",
            "value": False,
            "type": "bool",
        },
        {
            "field": "do_advanced_qa",
            "helper_text": "Use additional LLM calls to analyze each document to improve answer correctness",
            "value": False,
            "type": "bool",
        },
        {
            "field": "do_nl_metadata_query",
            "helper_text": "Do a natural language metadata query",
            "value": False,
            "type": "bool",
        },
        {
            "field": "documents",
            "helper_text": "The text for semantic search. Note: you may add multiple upstream nodes to this field.",
            "value": [],
            "type": "string",
        },
        {
            "field": "enable_context",
            "helper_text": "Additional context passed to advanced search and query analysis",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_document_db_filter",
            "helper_text": "Filter the documents returned from the knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_filter",
            "helper_text": "Filter the content returned from the knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "expand_query",
            "helper_text": "Expand query to improve semantic search",
            "value": False,
            "type": "bool",
        },
        {
            "field": "expand_query_terms",
            "helper_text": "Expand query terms to improve semantic search",
            "value": False,
            "type": "bool",
        },
        {
            "field": "format_context_for_llm",
            "helper_text": "Format the context for the LLM",
            "value": False,
            "type": "bool",
        },
        {
            "field": "is_hybrid",
            "helper_text": "Whether to create a hybrid knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_docs_per_query",
            "helper_text": "The maximum number of relevant chunks to be returned",
            "value": 5,
            "type": "int32",
        },
        {
            "field": "model",
            "helper_text": "The model to use for the embedding",
            "value": "openai/text-embedding-3-small",
            "type": "enum<string>",
        },
        {
            "field": "query",
            "helper_text": "The query will be used to search documents for relevant pieces semantically.",
            "value": "",
            "type": "string",
        },
        {
            "field": "rerank_documents",
            "helper_text": "Refine the initial ranking of returned chunks based on relevancy",
            "value": False,
            "type": "bool",
        },
        {
            "field": "retrieval_unit",
            "helper_text": "The unit of retrieval",
            "value": "chunks",
            "type": "enum<string>",
        },
        {
            "field": "score_cutoff",
            "helper_text": "The score cutoff",
            "value": 0,
            "type": "float",
        },
        {
            "field": "segmentation_method",
            "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
            "value": "words",
            "type": "enum<string>",
        },
        {
            "field": "show_intermediate_steps",
            "helper_text": "Show intermediate steps",
            "value": False,
            "type": "bool",
        },
        {
            "field": "splitter_method",
            "helper_text": "Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.",
            "value": "markdown",
            "type": "enum<string>",
        },
        {
            "field": "transform_query",
            "helper_text": "Transform the query for better semantic search",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**(*)**(*)**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "qa_model_name",
                    "type": "enum<string>",
                    "value": "gpt-4o-mini",
                    "helper_text": "The model to use for the QA",
                },
                {
                    "field": "advanced_search_mode",
                    "type": "enum<string>",
                    "value": "accurate",
                    "helper_text": "The mode to use for the advanced search",
                },
            ],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "helper_text": "The response from the semantic search",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for semantic search outputs, used for showing sources in LLM responses",
                },
            ],
        },
        "(*)**true**(*)**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter the content returned from the knowledge base",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**true**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "rerank_model",
                    "type": "enum<string>",
                    "value": "cohere/rerank-english-v3.0",
                    "helper_text": "Refine the initial ranking of returned chunks based on relevancy",
                }
            ],
            "outputs": [],
        },
        "false**(*)**(*)**documents**(*)**false**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "documents",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar documents retrieved from the knowledge base",
                }
            ],
        },
        "false**(*)**(*)**chunks**(*)**false**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "chunks",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar chunks retrieved from the knowledge base",
                }
            ],
        },
        "false**(*)**(*)**documents**(*)**true**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "documents",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar documents retrieved from the knowledge base",
                },
                {
                    "field": "formatted_text",
                    "type": "string",
                    "helper_text": "Knowledge base outputs formatted for input to a LLM",
                },
            ],
        },
        "false**(*)**(*)**chunks**(*)**true**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "chunks",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar chunks retrieved from the knowledge base",
                },
                {
                    "field": "formatted_text",
                    "type": "string",
                    "helper_text": "Knowledge base outputs formatted for input to a LLM",
                },
            ],
        },
        "(*)**(*)**(*)**(*)**true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "context",
                    "type": "string",
                    "value": "",
                    "helper_text": "Additional context to pass to the query analysis and qa steps",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**(*)**(*)**(*)**true**(*)": {
            "inputs": [
                {
                    "field": "document_db_filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter the documents returned from the knowledge base",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**(*)**(*)**(*)**(*)**(dynamic)": {
            "inputs": [
                {
                    "field": "segmentation_method",
                    "type": "enum<string>",
                    "value": "words",
                    "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = [
        "do_advanced_qa",
        "enable_filter",
        "rerank_documents",
        "retrieval_unit",
        "enable_context",
        "format_context_for_llm",
        "enable_document_db_filter",
        "splitter_method",
    ]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        do_advanced_qa: bool = False,
        enable_filter: bool = False,
        rerank_documents: bool = False,
        retrieval_unit: str = "chunks",
        enable_context: bool = False,
        format_context_for_llm: bool = False,
        enable_document_db_filter: bool = False,
        splitter_method: str = "markdown",
        advanced_search_mode: str = "accurate",
        alpha: Any = 0.5,
        analyze_documents: bool = False,
        answer_multiple_questions: bool = False,
        context: str = "",
        do_nl_metadata_query: bool = False,
        document_db_filter: str = "",
        documents: str = "[]",
        expand_query: bool = False,
        expand_query_terms: bool = False,
        filter: str = "",
        is_hybrid: bool = False,
        max_docs_per_query: int = 5,
        model: str = "openai/text-embedding-3-small",
        qa_model_name: str = "gpt-4o-mini",
        query: str = "",
        rerank_model: str = "cohere/rerank-english-v3.0",
        score_cutoff: Any = 0,
        segmentation_method: str = "words",
        show_intermediate_steps: bool = False,
        transform_query: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["do_advanced_qa"] = do_advanced_qa
        params["enable_filter"] = enable_filter
        params["rerank_documents"] = rerank_documents
        params["retrieval_unit"] = retrieval_unit
        params["enable_context"] = enable_context
        params["format_context_for_llm"] = format_context_for_llm
        params["enable_document_db_filter"] = enable_document_db_filter
        params["splitter_method"] = splitter_method

        super().__init__(
            node_type="semantic_search",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if model is not None:
            self.inputs["model"] = model
        if query is not None:
            self.inputs["query"] = query
        if max_docs_per_query is not None:
            self.inputs["max_docs_per_query"] = max_docs_per_query
        if rerank_documents is not None:
            self.inputs["rerank_documents"] = rerank_documents
        if documents is not None:
            self.inputs["documents"] = documents
        if enable_filter is not None:
            self.inputs["enable_filter"] = enable_filter
        if do_nl_metadata_query is not None:
            self.inputs["do_nl_metadata_query"] = do_nl_metadata_query
        if retrieval_unit is not None:
            self.inputs["retrieval_unit"] = retrieval_unit
        if alpha is not None:
            self.inputs["alpha"] = alpha
        if transform_query is not None:
            self.inputs["transform_query"] = transform_query
        if answer_multiple_questions is not None:
            self.inputs["answer_multiple_questions"] = answer_multiple_questions
        if expand_query is not None:
            self.inputs["expand_query"] = expand_query
        if expand_query_terms is not None:
            self.inputs["expand_query_terms"] = expand_query_terms
        if do_advanced_qa is not None:
            self.inputs["do_advanced_qa"] = do_advanced_qa
        if show_intermediate_steps is not None:
            self.inputs["show_intermediate_steps"] = show_intermediate_steps
        if score_cutoff is not None:
            self.inputs["score_cutoff"] = score_cutoff
        if enable_context is not None:
            self.inputs["enable_context"] = enable_context
        if format_context_for_llm is not None:
            self.inputs["format_context_for_llm"] = format_context_for_llm
        if enable_document_db_filter is not None:
            self.inputs["enable_document_db_filter"] = enable_document_db_filter
        if analyze_documents is not None:
            self.inputs["analyze_documents"] = analyze_documents
        if is_hybrid is not None:
            self.inputs["is_hybrid"] = is_hybrid
        if splitter_method is not None:
            self.inputs["splitter_method"] = splitter_method
        if segmentation_method is not None:
            self.inputs["segmentation_method"] = segmentation_method
        if qa_model_name is not None:
            self.inputs["qa_model_name"] = qa_model_name
        if advanced_search_mode is not None:
            self.inputs["advanced_search_mode"] = advanced_search_mode
        if filter is not None:
            self.inputs["filter"] = filter
        if rerank_model is not None:
            self.inputs["rerank_model"] = rerank_model
        if context is not None:
            self.inputs["context"] = context
        if document_db_filter is not None:
            self.inputs["document_db_filter"] = document_db_filter

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def chunks(self) -> List[str]:
        """
        Semantically similar chunks retrieved from the knowledge base

        Available: When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = False, When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("chunks")

    @property
    def citation_metadata(self) -> List[str]:
        """
        Citation metadata for semantic search outputs, used for showing sources in LLM responses

        Available: When do_advanced_qa = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("citation_metadata")

    @property
    def documents(self) -> List[str]:
        """
        Semantically similar documents retrieved from the knowledge base

        Available: When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = False, When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("documents")

    @property
    def formatted_text(self) -> str:
        """
        Knowledge base outputs formatted for input to a LLM

        Available: When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True, When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("formatted_text")

    @property
    def response(self) -> str:
        """
        The response from the semantic search

        Available: When do_advanced_qa = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @classmethod
    def from_dict(cls, data: dict) -> "SemanticSearchNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base")
class KnowledgeBaseNode(Node):
    """
    Semantically query a knowledge base that can contain files, scraped URLs, and data from synced integrations (e.g., Google Drive).

    ## Inputs
    ### Common Inputs
        alpha: The alpha value for the retrieval
        answer_multiple_questions: Extract separate questions from the query and retrieve content separately for each question to improve search performance
        do_advanced_qa: Use additional LLM calls to analyze each document to improve answer correctness
        do_nl_metadata_query: Do a natural language metadata query
        enable_context: Enable context
        enable_document_db_filter: Enable the document DB filter
        enable_filter: Filter the content returned from the knowledge base
        expand_query: Expand query to improve semantic search
        expand_query_terms: Expand query terms to improve semantic search
        format_context_for_llm: Format the context for the LLM
        knowledge_base: Select an existing knowledge base
        max_docs_per_query: The number of relevant chunks to be returned
        query: The query will be used to search documents for relevant pieces semantically.
        rerank_documents: Rerank the documents returned from the knowledge base
        retrieval_unit: The unit of retrieval
        score_cutoff: The score cutoff
        show_intermediate_steps: Show intermediate steps
        transform_query: Transform the query for better semantic search
    ### When do_advanced_qa = True
        advanced_search_mode: The mode to use for the advanced search
        qa_model_name: The model to use for the QA
    ### When enable_context = True
        context: Additional context to pass to the query analysis and qa steps
    ### When enable_document_db_filter = True
        document_db_filter: Filter the documents returned from the knowledge base
    ### When enable_filter = True
        filter: Filter the content returned from the knowledge base
    ### When rerank_documents = True
        rerank_model: Refine the initial ranking of returned chunks based on relevancy

    ## Outputs
    ### When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = False
        chunks: Semantically similar chunks retrieved from the knowledge base.
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
    ### When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True
        chunks: Semantically similar chunks retrieved from the knowledge base.
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        formatted_text: Knowledge base outputs formatted for input to a LLM
    ### When do_advanced_qa = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        response: The response from the knowledge base
    ### When enable_filter = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
    ### When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = False
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        documents: The documents returned from the knowledge base
    ### When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        documents: Semantically similar documents retrieved from the knowledge base.
        formatted_text: Knowledge base outputs formatted for input to a LLM
    ### When enable_context = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
    ### When enable_document_db_filter = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "alpha",
            "helper_text": "The alpha value for the retrieval",
            "value": 0.5,
            "type": "float",
        },
        {
            "field": "answer_multiple_questions",
            "helper_text": "Extract separate questions from the query and retrieve content separately for each question to improve search performance",
            "value": False,
            "type": "bool",
        },
        {
            "field": "do_advanced_qa",
            "helper_text": "Use additional LLM calls to analyze each document to improve answer correctness",
            "value": False,
            "type": "bool",
        },
        {
            "field": "do_nl_metadata_query",
            "helper_text": "Do a natural language metadata query",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_context",
            "helper_text": "Enable context",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_document_db_filter",
            "helper_text": "Enable the document DB filter",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_filter",
            "helper_text": "Filter the content returned from the knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "expand_query",
            "helper_text": "Expand query to improve semantic search",
            "value": False,
            "type": "bool",
        },
        {
            "field": "expand_query_terms",
            "helper_text": "Expand query terms to improve semantic search",
            "value": False,
            "type": "bool",
        },
        {
            "field": "format_context_for_llm",
            "helper_text": "Format the context for the LLM",
            "value": False,
            "type": "bool",
        },
        {
            "field": "knowledge_base",
            "helper_text": "Select an existing knowledge base",
            "value": {},
            "type": "knowledge_base",
        },
        {
            "field": "max_docs_per_query",
            "helper_text": "The number of relevant chunks to be returned",
            "value": 10,
            "type": "int32",
        },
        {
            "field": "query",
            "helper_text": "The query will be used to search documents for relevant pieces semantically.",
            "value": "",
            "type": "string",
        },
        {
            "field": "rerank_documents",
            "helper_text": "Rerank the documents returned from the knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "retrieval_unit",
            "helper_text": "The unit of retrieval",
            "value": "chunks",
            "type": "enum<string>",
        },
        {
            "field": "score_cutoff",
            "helper_text": "The score cutoff",
            "value": 0,
            "type": "float",
        },
        {
            "field": "show_intermediate_steps",
            "helper_text": "Show intermediate steps",
            "value": False,
            "type": "bool",
        },
        {
            "field": "transform_query",
            "helper_text": "Transform the query for better semantic search",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**(*)**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "qa_model_name",
                    "type": "enum<string>",
                    "value": "gpt-4o-mini",
                    "helper_text": "The model to use for the QA",
                },
                {
                    "field": "advanced_search_mode",
                    "type": "enum<string>",
                    "value": "accurate",
                    "helper_text": "The mode to use for the advanced search",
                },
            ],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "helper_text": "The response from the knowledge base",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
            ],
        },
        "(*)**true**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter the content returned from the knowledge base",
                }
            ],
            "outputs": [
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                }
            ],
        },
        "(*)**(*)**true**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "rerank_model",
                    "type": "enum<string>",
                    "value": "cohere/rerank-english-v3.0",
                    "helper_text": "Refine the initial ranking of returned chunks based on relevancy",
                }
            ],
            "outputs": [],
        },
        "false**(*)**(*)**documents**(*)**false**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "documents",
                    "type": "vec<string>",
                    "helper_text": "The documents returned from the knowledge base",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
            ],
        },
        "false**(*)**(*)**chunks**(*)**false**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "chunks",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar chunks retrieved from the knowledge base.",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
            ],
        },
        "false**(*)**(*)**documents**(*)**true**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "documents",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar documents retrieved from the knowledge base.",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
                {
                    "field": "formatted_text",
                    "type": "string",
                    "helper_text": "Knowledge base outputs formatted for input to a LLM",
                },
            ],
        },
        "false**(*)**(*)**chunks**(*)**true**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "chunks",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar chunks retrieved from the knowledge base.",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
                {
                    "field": "formatted_text",
                    "type": "string",
                    "helper_text": "Knowledge base outputs formatted for input to a LLM",
                },
            ],
        },
        "(*)**(*)**(*)**(*)**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "context",
                    "type": "string",
                    "value": "",
                    "helper_text": "Additional context to pass to the query analysis and qa steps",
                }
            ],
            "outputs": [
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                }
            ],
        },
        "(*)**(*)**(*)**(*)**(*)**(*)**true": {
            "inputs": [
                {
                    "field": "document_db_filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter the documents returned from the knowledge base",
                }
            ],
            "outputs": [
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = [
        "do_advanced_qa",
        "enable_filter",
        "rerank_documents",
        "retrieval_unit",
        "enable_context",
        "format_context_for_llm",
        "enable_document_db_filter",
    ]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        do_advanced_qa: bool = False,
        enable_filter: bool = False,
        rerank_documents: bool = False,
        retrieval_unit: str = "chunks",
        enable_context: bool = False,
        format_context_for_llm: bool = False,
        enable_document_db_filter: bool = False,
        advanced_search_mode: str = "accurate",
        alpha: Any = 0.5,
        answer_multiple_questions: bool = False,
        context: str = "",
        do_nl_metadata_query: bool = False,
        document_db_filter: str = "",
        expand_query: bool = False,
        expand_query_terms: bool = False,
        filter: str = "",
        knowledge_base: Any = {},
        max_docs_per_query: int = 10,
        qa_model_name: str = "gpt-4o-mini",
        query: str = "",
        rerank_model: str = "cohere/rerank-english-v3.0",
        score_cutoff: Any = 0,
        show_intermediate_steps: bool = False,
        transform_query: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["do_advanced_qa"] = do_advanced_qa
        params["enable_filter"] = enable_filter
        params["rerank_documents"] = rerank_documents
        params["retrieval_unit"] = retrieval_unit
        params["enable_context"] = enable_context
        params["format_context_for_llm"] = format_context_for_llm
        params["enable_document_db_filter"] = enable_document_db_filter

        super().__init__(
            node_type="knowledge_base",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if knowledge_base is not None:
            self.inputs["knowledge_base"] = knowledge_base
        if query is not None:
            self.inputs["query"] = query
        if max_docs_per_query is not None:
            self.inputs["max_docs_per_query"] = max_docs_per_query
        if enable_filter is not None:
            self.inputs["enable_filter"] = enable_filter
        if rerank_documents is not None:
            self.inputs["rerank_documents"] = rerank_documents
        if do_nl_metadata_query is not None:
            self.inputs["do_nl_metadata_query"] = do_nl_metadata_query
        if retrieval_unit is not None:
            self.inputs["retrieval_unit"] = retrieval_unit
        if alpha is not None:
            self.inputs["alpha"] = alpha
        if transform_query is not None:
            self.inputs["transform_query"] = transform_query
        if answer_multiple_questions is not None:
            self.inputs["answer_multiple_questions"] = answer_multiple_questions
        if expand_query is not None:
            self.inputs["expand_query"] = expand_query
        if expand_query_terms is not None:
            self.inputs["expand_query_terms"] = expand_query_terms
        if do_advanced_qa is not None:
            self.inputs["do_advanced_qa"] = do_advanced_qa
        if show_intermediate_steps is not None:
            self.inputs["show_intermediate_steps"] = show_intermediate_steps
        if score_cutoff is not None:
            self.inputs["score_cutoff"] = score_cutoff
        if enable_context is not None:
            self.inputs["enable_context"] = enable_context
        if format_context_for_llm is not None:
            self.inputs["format_context_for_llm"] = format_context_for_llm
        if enable_document_db_filter is not None:
            self.inputs["enable_document_db_filter"] = enable_document_db_filter
        if qa_model_name is not None:
            self.inputs["qa_model_name"] = qa_model_name
        if advanced_search_mode is not None:
            self.inputs["advanced_search_mode"] = advanced_search_mode
        if filter is not None:
            self.inputs["filter"] = filter
        if rerank_model is not None:
            self.inputs["rerank_model"] = rerank_model
        if context is not None:
            self.inputs["context"] = context
        if document_db_filter is not None:
            self.inputs["document_db_filter"] = document_db_filter

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def chunks(self) -> List[str]:
        """
        Semantically similar chunks retrieved from the knowledge base.

        Available: When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = False, When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("chunks")

    @property
    def citation_metadata(self) -> List[str]:
        """
        Citation metadata for knowledge base outputs, used for showing sources in LLM responses

        Available: When do_advanced_qa = True, When enable_filter = True, When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = False, When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = False, When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True, When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True, When enable_context = True, When enable_document_db_filter = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("citation_metadata")

    @property
    def documents(self) -> List[str]:
        """
        The documents returned from the knowledge base

        Different behavior based on configuration:
          - The documents returned from the knowledge base (When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = False)
          - Semantically similar documents retrieved from the knowledge base. (When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("documents")

    @property
    def formatted_text(self) -> str:
        """
        Knowledge base outputs formatted for input to a LLM

        Available: When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True, When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("formatted_text")

    @property
    def response(self) -> str:
        """
        The response from the knowledge base

        Available: When do_advanced_qa = True


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base_loader")
class KnowledgeBaseLoaderNode(Node):
    """
    Load data into an existing knowledge base.

    ## Inputs
    ### Common Inputs
        document_type: Scrape sub-pages of the provided link
        knowledge_base: The knowledge base to load data into
        rescrape_frequency: The frequency to rescrape the URL
    ### File
        documents: The file to be added to the selected knowledge base. Note: to convert text to file, use the Text to File node
    ### Recursive URL
        load_sitemap: Load URLs to crawl from a sitemap. If the URL is a sitemap, it will be used directly. If the URL is not a sitemap, the sitemap will be fetched automatically.
        max_depth: The maximum depth of the URL to crawl
        max_recursive_urls: The maximum number of recursive URLs to scrape
        same_domain_only: Whether to only crawl links from the same domain
        url: The raw URL link (e.g., https://vectorshift.ai/)
    ### URL
        max_recursive_urls: The maximum number of recursive URLs to scrape
        url: The raw URL link (e.g., https://vectorshift.ai/)

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "document_type",
            "helper_text": "Scrape sub-pages of the provided link",
            "value": "File",
            "type": "enum<string>",
        },
        {
            "field": "knowledge_base",
            "helper_text": "The knowledge base to load data into",
            "value": {},
            "type": "knowledge_base",
        },
        {
            "field": "rescrape_frequency",
            "helper_text": "The frequency to rescrape the URL",
            "value": "Never",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "URL": {
            "inputs": [
                {
                    "field": "max_recursive_urls",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The maximum number of recursive URLs to scrape",
                },
                {
                    "field": "url",
                    "type": "string",
                    "value": "",
                    "helper_text": "The raw URL link (e.g., https://vectorshift.ai/)",
                },
            ],
            "outputs": [],
        },
        "File": {
            "inputs": [
                {
                    "field": "documents",
                    "type": "vec<file>",
                    "value": [""],
                    "helper_text": "The file to be added to the selected knowledge base. Note: to convert text to file, use the Text to File node",
                }
            ],
            "outputs": [],
        },
        "Recursive URL": {
            "inputs": [
                {
                    "field": "max_recursive_urls",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The maximum number of recursive URLs to scrape",
                    "label": "Max urls to crawl (max 800)",
                },
                {
                    "field": "url",
                    "type": "string",
                    "value": "",
                    "helper_text": "The raw URL link (e.g., https://vectorshift.ai/)",
                },
                {
                    "field": "max_depth",
                    "type": "int32",
                    "value": 5,
                    "helper_text": "The maximum depth of the URL to crawl",
                    "label": "Max depth to crawl",
                },
                {
                    "field": "same_domain_only",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to only crawl links from the same domain",
                    "label": "Same domain only",
                },
                {
                    "field": "load_sitemap",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Load URLs to crawl from a sitemap. If the URL is a sitemap, it will be used directly. If the URL is not a sitemap, the sitemap will be fetched automatically.",
                    "label": "Load sitemap",
                },
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["document_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        document_type: str = "File",
        documents: List[str] = [""],
        knowledge_base: Any = {},
        load_sitemap: bool = False,
        max_depth: int = 5,
        max_recursive_urls: int = 10,
        rescrape_frequency: str = "Never",
        same_domain_only: bool = False,
        url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["document_type"] = document_type

        super().__init__(
            node_type="knowledge_base_loader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if knowledge_base is not None:
            self.inputs["knowledge_base"] = knowledge_base
        if document_type is not None:
            self.inputs["document_type"] = document_type
        if rescrape_frequency is not None:
            self.inputs["rescrape_frequency"] = rescrape_frequency
        if max_recursive_urls is not None:
            self.inputs["max_recursive_urls"] = max_recursive_urls
        if url is not None:
            self.inputs["url"] = url
        if documents is not None:
            self.inputs["documents"] = documents
        if max_depth is not None:
            self.inputs["max_depth"] = max_depth
        if same_domain_only is not None:
            self.inputs["same_domain_only"] = same_domain_only
        if load_sitemap is not None:
            self.inputs["load_sitemap"] = load_sitemap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseLoaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("map")
class MapNode(Node):
    """


    ## Inputs
    ### Common Inputs
        function: The function input
        inputs: The inputs input

    ## Outputs
    ### Common Outputs
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "function",
            "helper_text": "The function input",
            "value": "",
            "type": "string",
        },
        {
            "field": "inputs",
            "helper_text": "The inputs input",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The output output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        function: str = "",
        inputs: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="map",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if inputs is not None:
            self.inputs["inputs"] = inputs
        if function is not None:
            self.inputs["function"] = function

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The output output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "MapNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("merge")
class MergeNode(Node):
    """
    Recombine paths created by a condition node. Note: if you are not using a condition node, you shouldn’t use a merge node

    ## Inputs
    ### Common Inputs
        function: The function to apply to the input fields
        type: The expected type of the input and output fields
    ### When function = 'first' and type = '<T>'
        fields: The fields input
    ### When function = 'join' and type = '<T>'
        fields: The fields input

    ## Outputs
    ### When function = 'first' and type = '<T>'
        output: The Text from the path based on the condition node
    ### When function = 'join' and type = '<T>'
        output: The Text from the path based on the condition node
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "function",
            "helper_text": "The function to apply to the input fields",
            "value": "first",
            "type": "enum<string>",
        },
        {
            "field": "type",
            "helper_text": "The expected type of the input and output fields",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "first**<T>": {
            "inputs": [
                {"field": "fields", "type": "vec<<T>>", "value": [""]},
                {
                    "field": "function",
                    "type": "enum<string>",
                    "value": "first",
                    "helper_text": "The function to apply to the input fields",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "<T>",
                    "helper_text": "The Text from the path based on the condition node",
                }
            ],
        },
        "join**<T>": {
            "inputs": [
                {"field": "fields", "type": "vec<<T>>", "value": [""]},
                {
                    "field": "function",
                    "type": "enum<string>",
                    "value": "join",
                    "helper_text": "The function to apply to the output fields",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The Text from the path based on the condition node",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["function", "type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        function: str = "first",
        type: str = "string",
        fields: List[Any] = [""],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["function"] = function
        params["type"] = type

        super().__init__(
            node_type="merge",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if function is not None:
            self.inputs["function"] = function
        if fields is not None:
            self.inputs["fields"] = fields

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "MergeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("condition")
class ConditionNode(Node):
    """
    Specify a series of conditions and execute different paths based on the value of the conditions.

    ## Inputs
    ### Common Inputs
        conditions: The conditions input
        outputs: The outputs input

    ## Outputs
    ### Common Outputs
        [outputs]: The [outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "conditions",
            "helper_text": "The conditions input",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "outputs",
            "helper_text": "The outputs input",
            "value": {},
            "type": "map<string, string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "[outputs]", "helper_text": "The [outputs] output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        conditions: List[Any] = [],
        outputs: Dict[str, str] = {},
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="condition",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if conditions is not None:
            self.inputs["conditions"] = conditions
        if outputs is not None:
            self.inputs["outputs"] = outputs

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "ConditionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("nl_to_sql")
class NlToSqlNode(Node):
    """
    Convert natural language queries to SQL queries.

    ## Inputs
    ### Common Inputs
        db_dialect: The database dialect to use
        model: The model to use for the conversion
        schema: The schema of the database
        text: The natural language query to convert to SQL

    ## Outputs
    ### Common Outputs
        sql_query: The SQL query generated from the natural language query
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "db_dialect",
            "helper_text": "The database dialect to use",
            "value": "PostgreSQL",
            "type": "enum<string>",
        },
        {
            "field": "model",
            "helper_text": "The model to use for the conversion",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "schema",
            "helper_text": "The schema of the database",
            "value": "",
            "type": "string",
        },
        {
            "field": "text",
            "helper_text": "The natural language query to convert to SQL",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "sql_query",
            "helper_text": "The SQL query generated from the natural language query",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        db_dialect: str = "PostgreSQL",
        model: str = "gpt-4o",
        schema: str = "",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="nl_to_sql",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if db_dialect is not None:
            self.inputs["db_dialect"] = db_dialect
        if schema is not None:
            self.inputs["schema"] = schema
        if text is not None:
            self.inputs["text"] = text
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def sql_query(self) -> str:
        """
        The SQL query generated from the natural language query


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("sql_query")

    @classmethod
    def from_dict(cls, data: dict) -> "NlToSqlNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("read_json_values")
class ReadJsonValuesNode(Node):
    """
    Read values from a JSON object based on a provided key(s).

    ## Inputs
    ### Common Inputs
        json_string: The JSON you want to read from
        keys: Define the name(s) of the JSON keys from the JSON that you want to read
        processed_outputs: The processed_outputs input

    ## Outputs
    ### Common Outputs
        [processed_outputs]: The [processed_outputs] output
        json_values: The JSON Value
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "json_string",
            "helper_text": "The JSON you want to read from",
            "value": "",
            "type": "string",
        },
        {
            "field": "keys",
            "helper_text": "Define the name(s) of the JSON keys from the JSON that you want to read",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "processed_outputs",
            "helper_text": "The processed_outputs input",
            "value": {},
            "type": "map<string, string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "[processed_outputs]",
            "helper_text": "The [processed_outputs] output",
        },
        {"field": "json_values", "helper_text": "The JSON Value"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        json_string: str = "",
        keys: List[Any] = [],
        processed_outputs: Dict[str, str] = {},
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="read_json_values",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if json_string is not None:
            self.inputs["json_string"] = json_string
        if keys is not None:
            self.inputs["keys"] = keys
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def json_values(self) -> str:
        """
        The JSON Value


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("json_values")

    @classmethod
    def from_dict(cls, data: dict) -> "ReadJsonValuesNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("write_json_value")
class WriteJsonValueNode(Node):
    """
    Update a specific value in a JSON.

    ## Inputs
    ### Common Inputs
        fields: The fields input
        selected: Whether to update the JSON value or create a new JSON
    ### old
        json_string: The JSON to update

    ## Outputs
    ### Common Outputs
        updated_json: The updated JSON
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "fields",
            "helper_text": "The fields input",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "selected",
            "helper_text": "Whether to update the JSON value or create a new JSON",
            "value": "new",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "updated_json", "helper_text": "The updated JSON"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "old": {
            "inputs": [
                {
                    "field": "json_string",
                    "type": "string",
                    "value": "",
                    "helper_text": "The JSON to update",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["selected"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        selected: str = "new",
        fields: List[Any] = [],
        json_string: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["selected"] = selected

        super().__init__(
            node_type="write_json_value",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if selected is not None:
            self.inputs["selected"] = selected
        if fields is not None:
            self.inputs["fields"] = fields
        if json_string is not None:
            self.inputs["json_string"] = json_string

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def updated_json(self) -> str:
        """
        The updated JSON


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated_json")

    @classmethod
    def from_dict(cls, data: dict) -> "WriteJsonValueNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("api")
class ApiNode(Node):
    """
    Make an API request to a given URL.

    ## Inputs
    ### Common Inputs
        files: Files to include in the API request
        headers: Headers to include in the API request
        is_raw_json: Whether to return the raw JSON response from the API
        method: Choose the API Method desired (GET, POST, PUT, DELETE, PATCH)
        query_params: Query parameters to include in the API request
        url: Target URL for the API Request
    ### When is_raw_json = False
        body_params: The body parameters to include in the API request
    ### When is_raw_json = True
        raw_json: The raw JSON request to the API

    ## Outputs
    ### Common Outputs
        output: The response from the API
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "files",
            "helper_text": "Files to include in the API request",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "headers",
            "helper_text": "Headers to include in the API request",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "is_raw_json",
            "helper_text": "Whether to return the raw JSON response from the API",
            "value": False,
            "type": "bool",
        },
        {
            "field": "method",
            "helper_text": "Choose the API Method desired (GET, POST, PUT, DELETE, PATCH)",
            "value": "GET",
            "type": "enum<string>",
        },
        {
            "field": "query_params",
            "helper_text": "Query parameters to include in the API request",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "url",
            "helper_text": "Target URL for the API Request",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The response from the API"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "raw_json",
                    "type": "string",
                    "value": "",
                    "helper_text": "The raw JSON request to the API",
                    "label": "Raw JSON",
                    "order": 7,
                }
            ],
            "outputs": [],
        },
        "false": {
            "inputs": [
                {
                    "field": "body_params",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                    "helper_text": "The body parameters to include in the API request",
                    "label": "Body Parameters",
                    "component": {"type": "table"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["is_raw_json"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        is_raw_json: bool = False,
        body_params: List[Any] = [],
        files: List[Any] = [],
        headers: List[Any] = [],
        method: str = "GET",
        query_params: List[Any] = [],
        raw_json: str = "",
        url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["is_raw_json"] = is_raw_json

        super().__init__(
            node_type="api",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if method is not None:
            self.inputs["method"] = method
        if url is not None:
            self.inputs["url"] = url
        if headers is not None:
            self.inputs["headers"] = headers
        if query_params is not None:
            self.inputs["query_params"] = query_params
        if files is not None:
            self.inputs["files"] = files
        if is_raw_json is not None:
            self.inputs["is_raw_json"] = is_raw_json
        if raw_json is not None:
            self.inputs["raw_json"] = raw_json
        if body_params is not None:
            self.inputs["body_params"] = body_params

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The response from the API


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "ApiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("url_loader")
class UrlLoaderNode(Node):
    """
    Scrape content from a URL.

    ## Inputs
    ### Common Inputs
        provider: The provider to use for the URL loader
        url: The URL to load
    ### When provider = 'modal' and use_actions = True
        actions: The browser actions to perform on the URL
    ### When provider = 'modal'
        ai_enhance_content: Whether to enhance the content
        load_sitemap: Load URLs to crawl from a sitemap. If the URL is a sitemap, it will be used directly. If the URL is not a sitemap, the sitemap will be fetched automatically.
        recursive: Whether to recursively load the URL
        use_actions: Perform browser actions to interact with the input website
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'apify'
        api_key: The API key to use
        recursive: Whether to recursively load the URL
    ### When provider = 'jina' and use_personal_api_key = True
        api_key: The API key to use
    ### When provider = 'modal' and use_personal_api_key = True
        apify_key: The API key to use
    ### When provider = 'modal' and recursive = True
        url_limit: The maximum number of URLs to load
    ### When provider = 'apify' and recursive = True
        url_limit: The maximum number of URLs to load
    ### When provider = 'jina'
        use_personal_api_key: Whether to use a personal API key

    ## Outputs
    ### Common Outputs
        content: The content of the URL
        links: The sub-links present on the webpage of the provided URL
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "provider",
            "helper_text": "The provider to use for the URL loader",
            "value": "modal",
            "type": "enum<string>",
        },
        {
            "field": "url",
            "helper_text": "The URL to load",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "content", "helper_text": "The content of the URL"},
        {
            "field": "links",
            "helper_text": "The sub-links present on the webpage of the provided URL",
        },
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "jina**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "label": "Use personal API key",
                    "component": {"type": "bool"},
                }
            ],
            "outputs": [],
            "inputs_sort_order": ["provider", "url", "use_personal_api_key", "api_key"],
        },
        "apify**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "recursive",
                    "type": "bool",
                    "value": False,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "helper_text": "Whether to recursively load the URL",
                    "label": "Recursive",
                    "component": {"type": "bool"},
                },
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "The API key to use",
                    "label": "API key",
                    "component": {"type": "password"},
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "inputs_sort_order": [
                "provider",
                "url",
                "recursive",
                "url_limit",
                "api_key",
            ],
        },
        "modal**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "recursive",
                    "type": "bool",
                    "value": False,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "helper_text": "Whether to recursively load the URL",
                    "label": "Recursive",
                    "component": {"type": "bool"},
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "label": "Use personal API key",
                    "component": {"type": "bool"},
                },
                {
                    "field": "ai_enhance_content",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to enhance the content",
                    "label": "AI enhance content",
                    "component": {"type": "bool"},
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "use_actions",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Perform browser actions to interact with the input website",
                    "label": "Use browser actions",
                    "component": {"type": "bool"},
                    "banner_text": "This feature is only supported for the default provider and with recursive disabled",
                    "agent_field_type": "dynamic",
                    "is_hidden_in_agent": True,
                    "disable_conversion": True,
                },
                {
                    "field": "load_sitemap",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Load URLs to crawl from a sitemap. If the URL is a sitemap, it will be used directly. If the URL is not a sitemap, the sitemap will be fetched automatically.",
                    "label": "Load sitemap",
                    "component": {"type": "bool"},
                    "agent_field_type": "dynamic",
                },
            ],
            "outputs": [],
            "inputs_sort_order": [
                "provider",
                "url",
                "use_actions",
                "actions",
                "recursive",
                "url_limit",
                "use_personal_api_key",
                "apify_key",
                "ai_enhance_content",
            ],
        },
        "modal**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "apify_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "The API key to use",
                    "label": "API key",
                    "component": {"type": "password"},
                    "agent_field_type": "static",
                    "disable_conversion": True,
                }
            ],
            "outputs": [],
        },
        "modal**(*)**true**(*)": {
            "inputs": [
                {
                    "field": "actions",
                    "type": "vec<any>",
                    "value": [],
                    "helper_text": "The browser actions to perform on the URL",
                    "label": "Actions",
                    "agent_field_type": "dynamic",
                    "is_hidden_in_agent": True,
                    "disable_conversion": True,
                }
            ],
            "outputs": [],
        },
        "modal**(*)**(*)**true": {
            "inputs": [
                {
                    "field": "url_limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The maximum number of URLs to load",
                    "label": "URL limit",
                    "component": {"type": "int32"},
                }
            ],
            "outputs": [],
        },
        "jina**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "The API key to use",
                    "label": "API key",
                    "component": {"type": "password"},
                    "agent_field_type": "static",
                    "disable_conversion": True,
                }
            ],
            "outputs": [],
        },
        "apify**(*)**(*)**true": {
            "inputs": [
                {
                    "field": "url_limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The maximum number of URLs to load",
                    "label": "URL limit",
                    "component": {"type": "int32"},
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["provider", "use_personal_api_key", "use_actions", "recursive"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        provider: str = "modal",
        use_personal_api_key: bool = False,
        use_actions: bool = False,
        recursive: bool = False,
        actions: List[Any] = [],
        ai_enhance_content: bool = False,
        api_key: str = "",
        apify_key: str = "",
        load_sitemap: bool = False,
        url: str = "",
        url_limit: int = 10,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["provider"] = provider
        params["use_personal_api_key"] = use_personal_api_key
        params["use_actions"] = use_actions
        params["recursive"] = recursive

        super().__init__(
            node_type="url_loader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if url is not None:
            self.inputs["url"] = url
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if recursive is not None:
            self.inputs["recursive"] = recursive
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if ai_enhance_content is not None:
            self.inputs["ai_enhance_content"] = ai_enhance_content
        if use_actions is not None:
            self.inputs["use_actions"] = use_actions
        if load_sitemap is not None:
            self.inputs["load_sitemap"] = load_sitemap
        if apify_key is not None:
            self.inputs["apify_key"] = apify_key
        if actions is not None:
            self.inputs["actions"] = actions
        if url_limit is not None:
            self.inputs["url_limit"] = url_limit

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def content(self) -> str:
        """
        The content of the URL


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("content")

    @property
    def links(self) -> List[str]:
        """
        The sub-links present on the webpage of the provided URL


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("links")

    @classmethod
    def from_dict(cls, data: dict) -> "UrlLoaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("wikipedia")
class WikipediaNode(Node):
    """
    Query Wikipedia to return relevant articles

    ## Inputs
    ### Common Inputs
        chunk_text: Whether to chunk the text
        query: The Wikipedia query
    ### When chunk_text = True
        chunk_overlap: The overlap of the chunks
        chunk_size: The size of the chunks to create

    ## Outputs
    ### When chunk_text = True
        output: List of raw text from the Wikipedia article
    ### When chunk_text = False
        output: The raw text from the Wikipedia article
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_text",
            "helper_text": "Whether to chunk the text",
            "value": False,
            "type": "bool",
        },
        {
            "field": "query",
            "helper_text": "The Wikipedia query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "chunk_size",
                    "type": "int32",
                    "value": 512,
                    "helper_text": "The size of the chunks to create",
                },
                {
                    "field": "chunk_overlap",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The overlap of the chunks",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<string>",
                    "helper_text": "List of raw text from the Wikipedia article",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "The raw text from the Wikipedia article",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["chunk_text"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_text: bool = False,
        chunk_overlap: int = 0,
        chunk_size: int = 512,
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["chunk_text"] = chunk_text

        super().__init__(
            node_type="wikipedia",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if chunk_text is not None:
            self.inputs["chunk_text"] = chunk_text
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[str]:
        """
        List of raw text from the Wikipedia article

        Different behavior based on configuration:
          - List of raw text from the Wikipedia article (When chunk_text = True)
          - The raw text from the Wikipedia article (When chunk_text = False)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "WikipediaNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("youtube")
class YoutubeNode(Node):
    """
    Get the transcript of a youtube video.

    ## Inputs
    ### Common Inputs
        chunk_text: Whether to chunk the text
        url: The YouTube URL to get the transcript of
    ### When chunk_text = True
        chunk_overlap: The overlap of the chunks
        chunk_size: The size of the chunks to create

    ## Outputs
    ### When chunk_text = True
        output: List of raw text from the YouTube transcript
    ### When chunk_text = False
        output: The raw text from the YouTube transcript
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_text",
            "helper_text": "Whether to chunk the text",
            "value": False,
            "type": "bool",
        },
        {
            "field": "url",
            "helper_text": "The YouTube URL to get the transcript of",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "chunk_size",
                    "type": "int32",
                    "value": 512,
                    "helper_text": "The size of the chunks to create",
                },
                {
                    "field": "chunk_overlap",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The overlap of the chunks",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<string>",
                    "helper_text": "List of raw text from the YouTube transcript",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "The raw text from the YouTube transcript",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["chunk_text"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_text: bool = False,
        chunk_overlap: int = 0,
        chunk_size: int = 512,
        url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["chunk_text"] = chunk_text

        super().__init__(
            node_type="youtube",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if url is not None:
            self.inputs["url"] = url
        if chunk_text is not None:
            self.inputs["chunk_text"] = chunk_text
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[str]:
        """
        List of raw text from the YouTube transcript

        Different behavior based on configuration:
          - List of raw text from the YouTube transcript (When chunk_text = True)
          - The raw text from the YouTube transcript (When chunk_text = False)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "YoutubeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("arxiv")
class ArxivNode(Node):
    """
    Query ARXIV to return relevant articles

    ## Inputs
    ### Common Inputs
        chunk_text: Whether to chunk the text
        query: The ARXIV query
    ### When chunk_text = True
        chunk_overlap: The overlap of the chunks
        chunk_size: The size of the chunks to create

    ## Outputs
    ### When chunk_text = True
        output: List of raw text from the ARXIV article
    ### When chunk_text = False
        output: The raw text from the ARXIV article
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_text",
            "helper_text": "Whether to chunk the text",
            "value": False,
            "type": "bool",
        },
        {
            "field": "query",
            "helper_text": "The ARXIV query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "chunk_size",
                    "type": "int32",
                    "value": 512,
                    "helper_text": "The size of the chunks to create",
                },
                {
                    "field": "chunk_overlap",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The overlap of the chunks",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<string>",
                    "helper_text": "List of raw text from the ARXIV article",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "The raw text from the ARXIV article",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["chunk_text"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_text: bool = False,
        chunk_overlap: int = 0,
        chunk_size: int = 512,
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["chunk_text"] = chunk_text

        super().__init__(
            node_type="arxiv",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if chunk_text is not None:
            self.inputs["chunk_text"] = chunk_text
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[str]:
        """
        List of raw text from the ARXIV article

        Different behavior based on configuration:
          - List of raw text from the ARXIV article (When chunk_text = True)
          - The raw text from the ARXIV article (When chunk_text = False)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "ArxivNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("serp_api")
class SerpApiNode(Node):
    """
    Query the SERPAPI Google search API

    ## Inputs
    ### Common Inputs
        api_key: SERP API key
        query: The web search query

    ## Outputs
    ### Common Outputs
        output: Results of the SERP query
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "api_key",
            "helper_text": "SERP API key",
            "value": "",
            "type": "string",
        },
        {
            "field": "query",
            "helper_text": "The web search query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "Results of the SERP query"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        api_key: str = "",
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="serp_api",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[str]:
        """
        Results of the SERP query


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "SerpApiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("you_dot_com")
class YouDotComNode(Node):
    """
    Query the You.com search API

    ## Inputs
    ### Common Inputs
        api_key: You.com API key
        loader_type: Select the loader type: General or News
        query: The search query

    ## Outputs
    ### Common Outputs
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "api_key",
            "helper_text": "You.com API key",
            "value": "",
            "type": "string",
        },
        {
            "field": "loader_type",
            "helper_text": "Select the loader type: General or News",
            "value": "YOU_DOT_COM",
            "type": "enum<string>",
        },
        {
            "field": "query",
            "helper_text": "The search query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The output output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "YOU_DOT_COM": {"inputs": [], "outputs": [], "title": "You.com Web Search"},
        "YOU_DOT_COM_NEWS": {
            "inputs": [],
            "outputs": [],
            "title": "You.com Search News",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["loader_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        loader_type: str = "YOU_DOT_COM",
        api_key: str = "",
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["loader_type"] = loader_type

        super().__init__(
            node_type="you_dot_com",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if loader_type is not None:
            self.inputs["loader_type"] = loader_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The output output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "YouDotComNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("exa_ai")
class ExaAiNode(Node):
    """
    Query the Exa search API

    ## Inputs
    ### Common Inputs
        loader_type: Select the loader type: General, Companies, or Research Papers
        query: The search query

    ## Outputs
    ### Common Outputs
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "loader_type",
            "helper_text": "Select the loader type: General, Companies, or Research Papers",
            "value": "EXA_AI_SEARCH",
            "type": "enum<string>",
        },
        {
            "field": "query",
            "helper_text": "The search query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The output output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "EXA_AI_SEARCH": {"inputs": [], "outputs": [], "title": "Exa AI Web Search"},
        "EXA_AI_SEARCH_COMPANIES": {
            "inputs": [],
            "outputs": [],
            "title": "Exa AI Companies",
        },
        "EXA_AI_SEARCH_RESEARCH_PAPERS": {
            "inputs": [],
            "outputs": [],
            "title": "Exa AI Research Papers",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["loader_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        loader_type: str = "EXA_AI_SEARCH",
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["loader_type"] = loader_type

        super().__init__(
            node_type="exa_ai",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if loader_type is not None:
            self.inputs["loader_type"] = loader_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[str]:
        """
        The output output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "ExaAiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("google_search")
class GoogleSearchNode(Node):
    """
    Query the Google Search search API

    ## Inputs
    ### Common Inputs
        location: The location of the search
        num_results: The number of results to return
        query: The Google search query
        search_type: Select the search type: Web, Image, Hotels, Events, or News

    ## Outputs
    ### Common Outputs
        snippets: The snippets of the Google search results
        urls: The URLs of the Google search results
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "location",
            "helper_text": "The location of the search",
            "value": "us",
            "type": "enum<string>",
        },
        {
            "field": "num_results",
            "helper_text": "The number of results to return",
            "value": 10,
            "type": "int32",
        },
        {
            "field": "query",
            "helper_text": "The Google search query",
            "value": "",
            "type": "string",
        },
        {
            "field": "search_type",
            "helper_text": "Select the search type: Web, Image, Hotels, Events, or News",
            "value": "web",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "snippets",
            "helper_text": "The snippets of the Google search results",
        },
        {"field": "urls", "helper_text": "The URLs of the Google search results"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        location: str = "us",
        num_results: int = 10,
        query: str = "",
        search_type: str = "web",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="google_search",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if num_results is not None:
            self.inputs["num_results"] = num_results
        if search_type is not None:
            self.inputs["search_type"] = search_type
        if location is not None:
            self.inputs["location"] = location

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def snippets(self) -> List[str]:
        """
        The snippets of the Google search results


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("snippets")

    @property
    def urls(self) -> List[str]:
        """
        The URLs of the Google search results


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("urls")

    @classmethod
    def from_dict(cls, data: dict) -> "GoogleSearchNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("google_alert_rss_reader")
class GoogleAlertRssReaderNode(Node):
    """
    Read the contents from a Google Alert RSS feed

    ## Inputs
    ### Common Inputs
        feed_link: The link of the Google Alert RSS feed you want to read
        timeframe: The publish dates of the items in the feed to read

    ## Outputs
    ### Common Outputs
        dates: The publish dates of the Google Alert RSS feed items
        links: The links of the Google Alert RSS feed items
        snippets: The snippets of the Google Alert RSS feed items
        titles: The titles of the Google Alert RSS feed items
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "feed_link",
            "helper_text": "The link of the Google Alert RSS feed you want to read",
            "value": "",
            "type": "string",
        },
        {
            "field": "timeframe",
            "helper_text": "The publish dates of the items in the feed to read",
            "value": "all",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "dates",
            "helper_text": "The publish dates of the Google Alert RSS feed items",
        },
        {
            "field": "links",
            "helper_text": "The links of the Google Alert RSS feed items",
        },
        {
            "field": "snippets",
            "helper_text": "The snippets of the Google Alert RSS feed items",
        },
        {
            "field": "titles",
            "helper_text": "The titles of the Google Alert RSS feed items",
        },
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        feed_link: str = "",
        timeframe: str = "all",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="google_alert_rss_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if feed_link is not None:
            self.inputs["feed_link"] = feed_link
        if timeframe is not None:
            self.inputs["timeframe"] = timeframe

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def dates(self) -> List[str]:
        """
        The publish dates of the Google Alert RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("dates")

    @property
    def links(self) -> List[str]:
        """
        The links of the Google Alert RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("links")

    @property
    def snippets(self) -> List[str]:
        """
        The snippets of the Google Alert RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("snippets")

    @property
    def titles(self) -> List[str]:
        """
        The titles of the Google Alert RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("titles")

    @classmethod
    def from_dict(cls, data: dict) -> "GoogleAlertRssReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("rss_feed_reader")
class RssFeedReaderNode(Node):
    """
    Read the contents from an RSS feed

    ## Inputs
    ### Common Inputs
        entries: The number of entries you want to fetch
        timeframe: The publish dates of the items in the feed to read
        url: The link of the RSS feed you want to read

    ## Outputs
    ### Common Outputs
        authors: The authors of the RSS feed items
        contents: The contents of the RSS feed items
        links: The links of the RSS feed items
        published_dates: The publish dates of the RSS feed items
        summaries: The summaries of the RSS feed items
        titles: The titles of the RSS feed items
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "entries",
            "helper_text": "The number of entries you want to fetch",
            "value": 10,
            "type": "int32",
        },
        {
            "field": "timeframe",
            "helper_text": "The publish dates of the items in the feed to read",
            "value": "all",
            "type": "enum<string>",
        },
        {
            "field": "url",
            "helper_text": "The link of the RSS feed you want to read",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "authors", "helper_text": "The authors of the RSS feed items"},
        {"field": "contents", "helper_text": "The contents of the RSS feed items"},
        {"field": "links", "helper_text": "The links of the RSS feed items"},
        {
            "field": "published_dates",
            "helper_text": "The publish dates of the RSS feed items",
        },
        {"field": "summaries", "helper_text": "The summaries of the RSS feed items"},
        {"field": "titles", "helper_text": "The titles of the RSS feed items"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        entries: int = 10,
        timeframe: str = "all",
        url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="rss_feed_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if url is not None:
            self.inputs["url"] = url
        if timeframe is not None:
            self.inputs["timeframe"] = timeframe
        if entries is not None:
            self.inputs["entries"] = entries

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def authors(self) -> List[str]:
        """
        The authors of the RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("authors")

    @property
    def contents(self) -> List[str]:
        """
        The contents of the RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("contents")

    @property
    def links(self) -> List[str]:
        """
        The links of the RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("links")

    @property
    def published_dates(self) -> List[str]:
        """
        The publish dates of the RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("published_dates")

    @property
    def summaries(self) -> List[str]:
        """
        The summaries of the RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("summaries")

    @property
    def titles(self) -> List[str]:
        """
        The titles of the RSS feed items


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("titles")

    @classmethod
    def from_dict(cls, data: dict) -> "RssFeedReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("csv_query")
class CsvQueryNode(Node):
    """
    Utilizes an LLM agent to query CSV(s). Delimeter for the CSV must be commas.

    ## Inputs
    ### Common Inputs
        csv: The CSV to be queried (file must be a CSV). Note: Ensure connecting node is of type File not text
        query: The question you want to be answered by the CSV
        stream: Whether to stream the results of the query

    ## Outputs
    ### Common Outputs
        output: The answer to the Query based on the CSV
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "csv",
            "helper_text": "The CSV to be queried (file must be a CSV). Note: Ensure connecting node is of type File not text",
            "value": None,
            "type": "file",
        },
        {
            "field": "query",
            "helper_text": "The question you want to be answered by the CSV",
            "value": "",
            "type": "string",
        },
        {
            "field": "stream",
            "helper_text": "Whether to stream the results of the query",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "The answer to the Query based on the CSV"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        csv: Optional[str] = None,
        query: str = "",
        stream: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="csv_query",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if csv is not None:
            self.inputs["csv"] = csv
        if query is not None:
            self.inputs["query"] = query
        if stream is not None:
            self.inputs["stream"] = stream

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The answer to the Query based on the CSV


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "CsvQueryNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("csv_reader")
class CsvReaderNode(Node):
    """
    Read the contents from a CSV file and output a list of the data for each column.

    ## Inputs
    ### Common Inputs
        columns: Define the name(s) of the columns that you want to read
        file_type: The type of file to read.
        processed_outputs: The processed_outputs input
        selected_file: The file to read.
    ### EXCEL
        sheet: The sheet input
        sheets: The sheets input

    ## Outputs
    ### Common Outputs
        [processed_outputs]: The [processed_outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "columns",
            "helper_text": "Define the name(s) of the columns that you want to read",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "file_type",
            "helper_text": "The type of file to read.",
            "value": "CSV",
            "type": "enum<string>",
        },
        {
            "field": "processed_outputs",
            "helper_text": "The processed_outputs input",
            "value": {},
            "type": "map<string, string>",
        },
        {
            "field": "selected_file",
            "helper_text": "The file to read.",
            "value": None,
            "type": "file",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "[processed_outputs]",
            "helper_text": "The [processed_outputs] output",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "CSV": {"inputs": [], "outputs": []},
        "EXCEL": {
            "inputs": [
                {"field": "sheet", "type": "enum<string>"},
                {"field": "sheets", "type": "vec<string>", "value": []},
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["file_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        file_type: str = "CSV",
        columns: List[Any] = [],
        processed_outputs: Dict[str, str] = {},
        selected_file: Optional[str] = None,
        sheet: Optional[str] = None,
        sheets: List[str] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["file_type"] = file_type

        super().__init__(
            node_type="csv_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_type is not None:
            self.inputs["file_type"] = file_type
        if selected_file is not None:
            self.inputs["selected_file"] = selected_file
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs
        if columns is not None:
            self.inputs["columns"] = columns
        if sheet is not None:
            self.inputs["sheet"] = sheet
        if sheets is not None:
            self.inputs["sheets"] = sheets

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "CsvReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("csv_writer")
class CsvWriterNode(Node):
    """
    Create a CSV from data

    ## Inputs
    ### Common Inputs
        load_option: Whether to load the CSV from a file or a string.
        selected_option: Whether to create a new CSV or update an existing one.
    ### When selected_option = 'new'
        columns: The columns to write to the CSV.
    ### When selected_option = 'old' and load_option = 'file'
        columns: The columns to write to the CSV.
        selected_file: The file to update.
    ### When selected_option = 'old' and load_option = 'text'
        csv_string: The CSV string to write.

    ## Outputs
    ### Common Outputs
        file: The CSV file created or updated.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "load_option",
            "helper_text": "Whether to load the CSV from a file or a string.",
            "value": "file",
            "type": "enum<string>",
        },
        {
            "field": "selected_option",
            "helper_text": "Whether to create a new CSV or update an existing one.",
            "value": "new",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file", "helper_text": "The CSV file created or updated."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new**(*)": {
            "inputs": [
                {
                    "field": "columns",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                    "helper_text": "The columns to write to the CSV.",
                    "table": {
                        "name": {"helper_text": "The name of the column"},
                        "value": {"helper_text": "The value of the column"},
                    },
                }
            ],
            "outputs": [],
        },
        "old**file": {
            "inputs": [
                {
                    "field": "selected_file",
                    "type": "file",
                    "helper_text": "The file to update.",
                },
                {
                    "field": "columns",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                    "helper_text": "The columns to write to the CSV.",
                    "table": {
                        "name": {"helper_text": "The name of the column"},
                        "value": {"helper_text": "The value of the column"},
                    },
                },
            ],
            "outputs": [],
        },
        "old**text": {
            "inputs": [
                {
                    "field": "csv_string",
                    "type": "string",
                    "value": "",
                    "helper_text": "The CSV string to write.",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["selected_option", "load_option"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        selected_option: str = "new",
        load_option: str = "file",
        columns: List[Any] = [],
        csv_string: str = "",
        selected_file: Optional[str] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["selected_option"] = selected_option
        params["load_option"] = load_option

        super().__init__(
            node_type="csv_writer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if selected_option is not None:
            self.inputs["selected_option"] = selected_option
        if load_option is not None:
            self.inputs["load_option"] = load_option
        if columns is not None:
            self.inputs["columns"] = columns
        if selected_file is not None:
            self.inputs["selected_file"] = selected_file
        if csv_string is not None:
            self.inputs["csv_string"] = csv_string

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def file(self) -> str:
        """
        The CSV file created or updated.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file")

    @classmethod
    def from_dict(cls, data: dict) -> "CsvWriterNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("create_list")
class CreateListNode(Node):
    """
    Create a list from input texts. Final list is ordered in the order of the inputs.

    ## Inputs
    ### Common Inputs
        type: The type of the list
    ### <T>
        list: Value to be added to the list

    ## Outputs
    ### <T>
        output: The created list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": ["", ""],
                    "helper_text": "Value to be added to the list",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The created list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        list: List[Any] = ["", ""],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="create_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[Any]:
        """
        The created list

        Available: <T>


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "CreateListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("combine_list")
class CombineListNode(Node):
    """
    Combine multiple lists into one list. Final list is ordered in the order of the input lists.

    ## Inputs
    ### Common Inputs
        type: The type of the list
    ### <T>
        list: List to be combined

    ## Outputs
    ### <T>
        output: The combined list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<vec<<T>>>",
                    "value": ["", ""],
                    "helper_text": "List to be combined",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The combined list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        list: List[List[Any]] = ["", ""],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="combine_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[Any]:
        """
        The combined list

        Available: <T>


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "CombineListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("list_trimmer")
class ListTrimmerNode(Node):
    """
    Trim a list to just the sections you want. Enter enter the number of items or specify the section of the list that you want to keep.

    ## Inputs
    ### Common Inputs
        specify_section: Check this to specify a section of the list to keep. Leave unchecked to keep a specified number of items from the start.
        type: The type of the list
    ### When specify_section = True and type = '<T>'
        end_index: The ending index of the section to keep (exclusive).
        list: The list to trim
        start_index: The starting index of the section to keep (inclusive). The first item of the list is index 0.
    ### When specify_section = False and type = '<T>'
        item_to_keep: Check this to specify a section of the list to keep. Leave unchecked to keep a specified number of items.
        list: The list to trim

    ## Outputs
    ### When specify_section = False and type = '<T>'
        output: The trimmed list
    ### When specify_section = True and type = '<T>'
        output: The trimmed list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "specify_section",
            "helper_text": "Check this to specify a section of the list to keep. Leave unchecked to keep a specified number of items from the start.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**<T>": {
            "inputs": [
                {
                    "field": "item_to_keep",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Check this to specify a section of the list to keep. Leave unchecked to keep a specified number of items.",
                },
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The list to trim",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The trimmed list",
                }
            ],
        },
        "true**<T>": {
            "inputs": [
                {
                    "field": "start_index",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The starting index of the section to keep (inclusive). The first item of the list is index 0.",
                },
                {
                    "field": "end_index",
                    "type": "int32",
                    "value": 1,
                    "helper_text": "The ending index of the section to keep (exclusive).",
                },
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The list to trim",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The trimmed list",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["specify_section", "type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        specify_section: bool = False,
        type: str = "string",
        end_index: int = 1,
        item_to_keep: int = 0,
        list: List[Any] = [],
        start_index: int = 0,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["specify_section"] = specify_section
        params["type"] = type

        super().__init__(
            node_type="list_trimmer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if specify_section is not None:
            self.inputs["specify_section"] = specify_section
        if item_to_keep is not None:
            self.inputs["item_to_keep"] = item_to_keep
        if list is not None:
            self.inputs["list"] = list
        if start_index is not None:
            self.inputs["start_index"] = start_index
        if end_index is not None:
            self.inputs["end_index"] = end_index

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[Any]:
        """
        The trimmed list

        Available: When specify_section = False and type = '<T>', When specify_section = True and type = '<T>'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "ListTrimmerNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("duplicate_list")
class DuplicateListNode(Node):
    """
    Create a new list by duplicating a single item with the size of the new list either matching the size of another list, or a specified size.

    ## Inputs
    ### Common Inputs
        specify_list_size: Check this box if you want to manually specify the list size. In this case 'Match List Size' will not be used.
        type: The type of the list
    ### When specify_list_size = True and type = '<T>'
        input_field: Item to duplicate
        list_size: The size of the new list
    ### When specify_list_size = False and type = '<T>'
        input_field: Item to duplicate
        list_size_to_match: The size of the list you want to match

    ## Outputs
    ### When specify_list_size = True and type = '<T>'
        output: The duplicated list
    ### When specify_list_size = False and type = '<T>'
        output: The duplicated list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "specify_list_size",
            "helper_text": "Check this box if you want to manually specify the list size. In this case 'Match List Size' will not be used.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**<T>": {
            "inputs": [
                {
                    "field": "list_size",
                    "type": "int32",
                    "value": 1,
                    "helper_text": "The size of the new list",
                },
                {
                    "field": "input_field",
                    "type": "<T>",
                    "value": "",
                    "helper_text": "Item to duplicate",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The duplicated list",
                }
            ],
        },
        "false**<T>": {
            "inputs": [
                {
                    "field": "list_size_to_match",
                    "type": "vec<string>",
                    "value": "",
                    "helper_text": "The size of the list you want to match",
                },
                {
                    "field": "input_field",
                    "type": "<T>",
                    "value": "",
                    "helper_text": "Item to duplicate",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The duplicated list",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["specify_list_size", "type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        specify_list_size: bool = False,
        type: str = "string",
        list_size: int = 1,
        list_size_to_match: List[str] = [],
        input_field: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["specify_list_size"] = specify_list_size
        params["type"] = type

        super().__init__(
            node_type="duplicate_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if specify_list_size is not None:
            self.inputs["specify_list_size"] = specify_list_size
        if list_size is not None:
            self.inputs["list_size"] = list_size
        if input_field is not None:
            self.inputs["input_field"] = input_field
        if list_size_to_match is not None:
            self.inputs["list_size_to_match"] = list_size_to_match
        if input_field is not None:
            self.inputs["input_field"] = input_field

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[Any]:
        """
        The duplicated list

        Available: When specify_list_size = True and type = '<T>', When specify_list_size = False and type = '<T>'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "DuplicateListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("flatten_list")
class FlattenListNode(Node):
    """
    Flatten list of lists into a single list. For example, [[a, b], [c, d]] becomes [a,b,c,d].

    ## Inputs
    ### Common Inputs
        type: The type of the list
    ### <T>
        list_of_lists: List of lists to be flattened

    ## Outputs
    ### <T>
        flattened_list: The flattened list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list_of_lists",
                    "type": "vec<vec<<T>>>",
                    "value": "",
                    "helper_text": "List of lists to be flattened",
                }
            ],
            "outputs": [
                {
                    "field": "flattened_list",
                    "type": "vec<<T>>",
                    "helper_text": "The flattened list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        list_of_lists: List[List[Any]] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="flatten_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if list_of_lists is not None:
            self.inputs["list_of_lists"] = list_of_lists

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def flattened_list(self) -> List[Any]:
        """
        The flattened list

        Available: <T>


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("flattened_list")

    @classmethod
    def from_dict(cls, data: dict) -> "FlattenListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("join_list_item")
class JoinListItemNode(Node):
    """
    Join a list of items into a single string. If join_by_newline is true, the items are joined by a newline character.

    ## Inputs
    ### Common Inputs
        join_by_newline: Separate each line in the final output with a new line
        type: The type of the list
    ### When join_by_newline = False
        join_characters: Use a specified character to join list items into a single string
    ### When type = '<T>'
        list: List of items to be joined

    ## Outputs
    ### Common Outputs
        joined_text: The joined string
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "join_by_newline",
            "helper_text": "Separate each line in the final output with a new line",
            "value": False,
            "type": "bool",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "joined_text", "helper_text": "The joined string"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)": {
            "inputs": [
                {
                    "field": "join_characters",
                    "type": "string",
                    "value": "",
                    "helper_text": "Use a specified character to join list items into a single string",
                }
            ],
            "outputs": [],
        },
        "(*)**<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "List of items to be joined",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["join_by_newline", "type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        join_by_newline: bool = False,
        type: str = "string",
        join_characters: str = "",
        list: List[Any] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["join_by_newline"] = join_by_newline
        params["type"] = type

        super().__init__(
            node_type="join_list_item",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if join_by_newline is not None:
            self.inputs["join_by_newline"] = join_by_newline
        if join_characters is not None:
            self.inputs["join_characters"] = join_characters
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def joined_text(self) -> str:
        """
        The joined string


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("joined_text")

    @classmethod
    def from_dict(cls, data: dict) -> "JoinListItemNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("csv_to_excel")
class CsvToExcelNode(Node):
    """
    Convert a CSV file into XLSX

    ## Inputs
    ### Common Inputs
        csv_file: The CSV file to convert.
        horizontal_alignment: The horizontal alignment of the text
        max_column_width: The maximum width of the columns
        vertical_alignment: The vertical alignment of the text
        wrap_text: Enable text wrapping

    ## Outputs
    ### Common Outputs
        xlsx_file: The Excel file created.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "csv_file",
            "helper_text": "The CSV file to convert.",
            "value": None,
            "type": "file",
        },
        {
            "field": "horizontal_alignment",
            "helper_text": "The horizontal alignment of the text",
            "value": "left",
            "type": "enum<string>",
        },
        {
            "field": "max_column_width",
            "helper_text": "The maximum width of the columns",
            "value": 100,
            "type": "int32",
        },
        {
            "field": "vertical_alignment",
            "helper_text": "The vertical alignment of the text",
            "value": "top",
            "type": "enum<string>",
        },
        {
            "field": "wrap_text",
            "helper_text": "Enable text wrapping",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "xlsx_file", "helper_text": "The Excel file created."}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        csv_file: Optional[str] = None,
        horizontal_alignment: str = "left",
        max_column_width: int = 100,
        vertical_alignment: str = "top",
        wrap_text: bool = True,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="csv_to_excel",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if csv_file is not None:
            self.inputs["csv_file"] = csv_file
        if wrap_text is not None:
            self.inputs["wrap_text"] = wrap_text
        if max_column_width is not None:
            self.inputs["max_column_width"] = max_column_width
        if horizontal_alignment is not None:
            self.inputs["horizontal_alignment"] = horizontal_alignment
        if vertical_alignment is not None:
            self.inputs["vertical_alignment"] = vertical_alignment

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def xlsx_file(self) -> str:
        """
        The Excel file created.


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("xlsx_file")

    @classmethod
    def from_dict(cls, data: dict) -> "CsvToExcelNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("text_formatter")
class TextFormatterNode(Node):
    """
    Format text based off a specified formatter

    ## Inputs
    ### Common Inputs
        formatter: The formatter to apply to the text
        text: The text to format
    ### Truncate
        max_num_token: The maximum number of tokens to truncate the text to

    ## Outputs
    ### Common Outputs
        output: The formatted text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "formatter",
            "helper_text": "The formatter to apply to the text",
            "value": "To Uppercase",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to format",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The formatted text"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "Truncate": {
            "inputs": [
                {
                    "field": "max_num_token",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The maximum number of tokens to truncate the text to",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["formatter"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        formatter: str = "To Uppercase",
        max_num_token: int = 0,
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["formatter"] = formatter

        super().__init__(
            node_type="text_formatter",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text
        if formatter is not None:
            self.inputs["formatter"] = formatter
        if max_num_token is not None:
            self.inputs["max_num_token"] = max_num_token

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The formatted text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "TextFormatterNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("json_operations")
class JsonOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="json_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "JsonOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("list_operations")
class ListOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="list_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "ListOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_gmail")
class IntegrationGmailNode(Node):
    """
    Gmail

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'create_draft'
        attachments: Attachments to be appended.
        body: The body of the email
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients’ emails
        subject: The subject of the email
    ### When action = 'send_email'
        attachments: Attachments to be appended.
        body: The body of the email
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients’ emails
        subject: The subject of the email
    ### When action = 'draft_reply'
        attachments: Attachments to be appended.
        body: The body of the email
        email_id: The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients’ emails
    ### When action = 'send_reply'
        attachments: Attachments to be appended.
        body: The body of the email
        email_id: The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients’ emails
    ### When action = 'list_messages'
        bcc: Emails BCC'd to this address
        body: The body of the email
        category: Filter by tab (e.g. Primary, Social)
        cc: Emails CC'd to this address
        custom_params: Extra filters as raw query
        filename: Find attachments by name or type
        from: Emails sent by this address
        has: Filter by feature (e.g. attachment, drive)
        has_attachment: Only emails with attachments
        has_images: Emails containing images
        has_links: Emails containing links
        has_starred: Only starred emails
        has_unread: Only unread emails
        has_user_labels: Emails with custom labels
        in: Search within a folder (e.g. sent, spam)
        include_spam_trash: Include spam and trash emails
        is: Filter by status (e.g. read, unread, starred)
        label: Search emails with this label
        label_ids: Emails with all listed label IDs
        larger: Emails larger than this size (e.g. 5M)
        list: Emails from this mailing list
        msg_id: Search by message ID (ignores other filters)
        newer_than: Emails newer than a time (e.g. 7d, 2m)
        num_messages: Specify the last n number of emails
        older_than: Emails older than a time (e.g. 7d, 2m)
        page_token: Use to fetch next page of results
        projection: Select which fields to return
        query: Raw query string to use directly. If provided, overrides all other query parameters.
        smaller: Emails smaller than this size (e.g. 5M)
        subject: The subject of the email
        to: Emails sent to this address
        use_date: Toggle to use dates
    ### When action = 'list_messages' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'list_messages' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'list_messages' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'list_messages'
        attachments: The attachments of the retrieved emails
        email_bodies: The content of the retrieved emails
        email_dates: The sent dates of the retrieved emails
        email_display_names: The display names of the senders
        email_ids: The IDs of the retrieved emails
        email_subjects: The subjects of the retrieved emails
        recipient_addresses: The email addresses of the recipients
        sender_addresses: The email addresses of the senders
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Gmail>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_nodes",
        },
        "create_draft**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients’ emails",
                    "order": 4,
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Introduction to John",
                    "helper_text": "The subject of the email",
                    "order": 5,
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                    "order": 6,
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "order": 3,
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                    "order": 7,
                },
            ],
            "outputs": [],
            "name": "create_draft",
            "task_name": "tasks.gmail.create_email_draft",
            "description": "Create (but do not send) a new email",
            "label": "Create Email Draft",
            "inputs_sort_order": [
                "integration",
                "action",
                "format",
                "recipients",
                "subject",
                "body",
                "attachments",
            ],
        },
        "send_email**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients’ emails",
                    "order": 4,
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Introduction to John",
                    "helper_text": "The subject of the email",
                    "order": 5,
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                    "order": 6,
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "order": 3,
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                    "order": 7,
                },
            ],
            "outputs": [],
            "name": "send_email",
            "task_name": "tasks.gmail.send_email",
            "description": "Create and send a new email",
            "label": "Send Email",
            "inputs_sort_order": [
                "integration",
                "action",
                "format",
                "recipients",
                "subject",
                "body",
                "attachments",
            ],
        },
        "draft_reply**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients’ emails",
                    "order": 4,
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                    "order": 5,
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "order": 3,
                },
                {
                    "field": "email_id",
                    "type": "string",
                    "value": "",
                    "label": "Email Id",
                    "placeholder": "john@company.com",
                    "helper_text": "The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)",
                    "order": 6,
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                    "order": 7,
                },
            ],
            "outputs": [],
            "name": "draft_reply",
            "task_name": "tasks.gmail.draft_reply",
            "description": "Create (but do not send) a draft of a reply to an existing email",
            "label": "Draft Reply",
            "inputs_sort_order": [
                "integration",
                "action",
                "format",
                "recipients",
                "body",
                "email_id",
                "attachments",
            ],
        },
        "send_reply**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients’ emails",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "email_id",
                    "type": "string",
                    "value": "",
                    "label": "Email Id",
                    "placeholder": "john@company.com",
                    "helper_text": "The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [],
            "name": "send_reply",
            "task_name": "tasks.gmail.send_reply",
            "description": "Create and send a new reply to an existing email",
            "label": "Send Reply",
            "inputs_sort_order": [
                "integration",
                "action",
                "format",
                "recipients",
                "body",
                "email_id",
                "attachments",
            ],
        },
        "list_messages**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "order": 3,
                },
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Emails",
                    "helper_text": "Specify the last n number of emails",
                    "order": 5,
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Raw Query",
                    "helper_text": "Raw query string to use directly. If provided, overrides all other query parameters.",
                },
                {
                    "field": "from",
                    "type": "string",
                    "value": "",
                    "label": "From",
                    "helper_text": "Emails sent by this address",
                },
                {
                    "field": "to",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "helper_text": "Emails sent to this address",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "helper_text": "Search keywords in the subject",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "helper_text": "Search text in the email body",
                },
                {
                    "field": "has_attachment",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only emails with attachments",
                    "label": "Has Attachment",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Emails With Attachments", "value": "True"},
                            {"label": "Emails Without Attachments", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_images",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Emails containing images",
                    "label": "Has Images",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Emails With Images", "value": "True"},
                            {"label": "Emails Without Images", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_links",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Emails containing links",
                    "label": "Has Links",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Emails With Links", "value": "True"},
                            {"label": "Emails Without Links", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_starred",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only starred emails",
                    "label": "Has Starred",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Starred Emails", "value": "True"},
                            {"label": "Exclude Starred Emails", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_unread",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only unread emails",
                    "label": "Has Unread",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Unread Emails", "value": "True"},
                            {"label": "Exclude Unread Emails", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "label",
                    "type": "string",
                    "value": "",
                    "label": "Label",
                    "helper_text": "Search emails with this label",
                },
                {
                    "field": "in",
                    "type": "string",
                    "value": "",
                    "label": "Inside Folder",
                    "helper_text": "Search within a folder (e.g. sent, spam)",
                },
                {
                    "field": "is",
                    "type": "string",
                    "value": "",
                    "label": "Is",
                    "helper_text": "Filter by status (e.g. read, unread, starred)",
                },
                {
                    "field": "has",
                    "type": "string",
                    "value": "",
                    "label": "Has",
                    "helper_text": "Filter by feature (e.g. attachment, drive)",
                },
                {
                    "field": "filename",
                    "type": "string",
                    "value": "",
                    "label": "Filename",
                    "helper_text": "Find attachments by name or type",
                },
                {
                    "field": "newer_than",
                    "type": "string",
                    "value": "",
                    "label": "Newer Than",
                    "helper_text": "Emails newer than a time (e.g. 7d, 2m)",
                },
                {
                    "field": "older_than",
                    "type": "string",
                    "value": "",
                    "label": "Older Than",
                    "helper_text": "Emails older than a time (e.g. 7d, 2m)",
                },
                {
                    "field": "cc",
                    "type": "string",
                    "value": "",
                    "label": "CC",
                    "helper_text": "Emails CC'd to this address",
                },
                {
                    "field": "bcc",
                    "type": "string",
                    "value": "",
                    "label": "BCC",
                    "helper_text": "Emails BCC'd to this address",
                },
                {
                    "field": "list",
                    "type": "string",
                    "value": "",
                    "label": "List",
                    "helper_text": "Emails from this mailing list",
                },
                {
                    "field": "category",
                    "type": "string",
                    "value": "",
                    "label": "Category",
                    "helper_text": "Filter by tab (e.g. Primary, Social)",
                },
                {
                    "field": "larger",
                    "type": "string",
                    "value": "",
                    "label": "Larger",
                    "helper_text": "Emails larger than this size (e.g. 5M)",
                },
                {
                    "field": "smaller",
                    "type": "string",
                    "value": "",
                    "label": "Smaller",
                    "helper_text": "Emails smaller than this size (e.g. 5M)",
                },
                {
                    "field": "custom_params",
                    "type": "string",
                    "value": "",
                    "label": "Custom Parameters",
                    "helper_text": "Extra filters as raw query",
                },
                {
                    "field": "projection",
                    "type": "string",
                    "value": "",
                    "label": "Projection",
                    "helper_text": "Select which fields to return",
                },
                {
                    "field": "page_token",
                    "type": "string",
                    "value": "",
                    "label": "Page Token",
                    "helper_text": "Use to fetch next page of results",
                },
                {
                    "field": "label_ids",
                    "type": "string",
                    "value": "",
                    "label": "Label IDs",
                    "helper_text": "Emails with all listed label IDs",
                },
                {
                    "field": "has_user_labels",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Emails with custom labels",
                    "label": "Has User Labels",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Emails With User Labels", "value": "True"},
                            {"label": "Emails Without User Labels", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "include_spam_trash",
                    "type": "enum<string>",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Include spam and trash emails",
                    "label": "Include Spam Trash",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Spam and Trash Emails", "value": "True"},
                            {
                                "label": "Exclude Spam and Trash Emails",
                                "value": "False",
                            },
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "msg_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "helper_text": "Search by message ID (ignores other filters)",
                },
            ],
            "outputs": [
                {
                    "field": "email_ids",
                    "type": "vec<string>",
                    "helper_text": "The IDs of the retrieved emails",
                },
                {
                    "field": "email_subjects",
                    "type": "vec<string>",
                    "helper_text": "The subjects of the retrieved emails",
                },
                {
                    "field": "email_dates",
                    "type": "vec<string>",
                    "helper_text": "The sent dates of the retrieved emails",
                },
                {
                    "field": "email_bodies",
                    "type": "vec<string>",
                    "helper_text": "The content of the retrieved emails",
                },
                {
                    "field": "sender_addresses",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the senders",
                },
                {
                    "field": "email_display_names",
                    "type": "vec<string>",
                    "helper_text": "The display names of the senders",
                },
                {
                    "field": "recipient_addresses",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the recipients",
                },
                {
                    "field": "attachments",
                    "type": "vec<vec<file>>",
                    "helper_text": "The attachments of the retrieved emails",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "list_messages",
            "task_name": "tasks.gmail.list_messages",
            "description": "Get emails from Gmail",
            "label": "Get Emails",
            "inputs_sort_order": [
                "integration",
                "action",
                "num_messages",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "query",
                "from",
                "to",
                "subject",
                "body",
                "has_attachment",
            ],
        },
        "list_messages**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "order": 4,
                }
            ],
            "outputs": [],
        },
        "list_messages**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "label": "Date Range",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "list_messages**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "label": "Exact date",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        attachments: List[str] = [],
        bcc: str = "",
        body: str = "",
        category: str = "",
        cc: str = "",
        custom_params: str = "",
        email_id: str = "",
        exact_date: Any = {"start": "", "end": ""},
        filename: str = "",
        format: str = "text",
        from_: str = "",
        has: str = "",
        has_attachment: str = "Ignore",
        has_images: str = "Ignore",
        has_links: str = "Ignore",
        has_starred: str = "Ignore",
        has_unread: str = "Ignore",
        has_user_labels: str = "Ignore",
        in_: str = "",
        include_spam_trash: str = "Ignore",
        is_: str = "",
        label: str = "",
        label_ids: str = "",
        larger: str = "",
        list: str = "",
        msg_id: str = "",
        newer_than: str = "",
        num_messages: int = 10,
        older_than: str = "",
        page_token: str = "",
        projection: str = "",
        query: str = "",
        recipients: str = "",
        smaller: str = "",
        subject: str = "",
        to: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_gmail",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if recipients is not None:
            self.inputs["recipients"] = recipients
        if subject is not None:
            self.inputs["subject"] = subject
        if body is not None:
            self.inputs["body"] = body
        if format is not None:
            self.inputs["format"] = format
        if attachments is not None:
            self.inputs["attachments"] = attachments
        if email_id is not None:
            self.inputs["email_id"] = email_id
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if query is not None:
            self.inputs["query"] = query
        if from_ is not None:
            self.inputs["from"] = from_
        if to is not None:
            self.inputs["to"] = to
        if has_attachment is not None:
            self.inputs["has_attachment"] = has_attachment
        if has_images is not None:
            self.inputs["has_images"] = has_images
        if has_links is not None:
            self.inputs["has_links"] = has_links
        if has_starred is not None:
            self.inputs["has_starred"] = has_starred
        if has_unread is not None:
            self.inputs["has_unread"] = has_unread
        if label is not None:
            self.inputs["label"] = label
        if in_ is not None:
            self.inputs["in"] = in_
        if is_ is not None:
            self.inputs["is"] = is_
        if has is not None:
            self.inputs["has"] = has
        if filename is not None:
            self.inputs["filename"] = filename
        if newer_than is not None:
            self.inputs["newer_than"] = newer_than
        if older_than is not None:
            self.inputs["older_than"] = older_than
        if cc is not None:
            self.inputs["cc"] = cc
        if bcc is not None:
            self.inputs["bcc"] = bcc
        if list is not None:
            self.inputs["list"] = list
        if category is not None:
            self.inputs["category"] = category
        if larger is not None:
            self.inputs["larger"] = larger
        if smaller is not None:
            self.inputs["smaller"] = smaller
        if custom_params is not None:
            self.inputs["custom_params"] = custom_params
        if projection is not None:
            self.inputs["projection"] = projection
        if page_token is not None:
            self.inputs["page_token"] = page_token
        if label_ids is not None:
            self.inputs["label_ids"] = label_ids
        if has_user_labels is not None:
            self.inputs["has_user_labels"] = has_user_labels
        if include_spam_trash is not None:
            self.inputs["include_spam_trash"] = include_spam_trash
        if msg_id is not None:
            self.inputs["msg_id"] = msg_id
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if from_ is not None:
            self.inputs["from"] = from_
        if in_ is not None:
            self.inputs["in"] = in_
        if integration is not None:
            self.inputs["integration"] = integration
        if is_ is not None:
            self.inputs["is"] = is_

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attachments(self) -> List[List[str]]:
        """
        The attachments of the retrieved emails

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attachments")

    @property
    def email_bodies(self) -> List[str]:
        """
        The content of the retrieved emails

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_bodies")

    @property
    def email_dates(self) -> List[str]:
        """
        The sent dates of the retrieved emails

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_dates")

    @property
    def email_display_names(self) -> List[str]:
        """
        The display names of the senders

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_display_names")

    @property
    def email_ids(self) -> List[str]:
        """
        The IDs of the retrieved emails

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_ids")

    @property
    def email_subjects(self) -> List[str]:
        """
        The subjects of the retrieved emails

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_subjects")

    @property
    def recipient_addresses(self) -> List[str]:
        """
        The email addresses of the recipients

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("recipient_addresses")

    @property
    def sender_addresses(self) -> List[str]:
        """
        The email addresses of the senders

        Available: When action = 'list_messages'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("sender_addresses")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGmailNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_copper")
class IntegrationCopperNode(Node):
    """
    Copper

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_lead
        email: The email of the lead
        name: The name of the lead

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Copper>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_lead": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name",
                    "placeholder": "John Smith",
                    "helper_text": "The name of the lead",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@company.com",
                    "helper_text": "The email of the lead",
                },
            ],
            "outputs": [],
            "name": "create_lead",
            "task_name": "tasks.copper.create_lead",
            "description": "Create a new lead",
            "label": "Create Lead",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        email: str = "",
        name: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_copper",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if name is not None:
            self.inputs["name"] = name
        if email is not None:
            self.inputs["email"] = email
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationCopperNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_discord")
class IntegrationDiscordNode(Node):
    """
    Discord

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### send_message
        channel_name: The name of the Discord channel
        message: The message you want to send

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Discord>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "send_message": {
            "inputs": [
                {
                    "field": "channel_name",
                    "type": "string",
                    "value": "",
                    "label": "Channel Name",
                    "placeholder": "General",
                    "helper_text": "The name of the Discord channel",
                },
                {
                    "field": "message",
                    "type": "string",
                    "value": "",
                    "label": "Message",
                    "placeholder": "Hello World!",
                    "helper_text": "The message you want to send",
                },
            ],
            "outputs": [],
            "name": "send_message",
            "task_name": "tasks.discord.send_message",
            "description": "Send a message to a specific channel",
            "label": "Send Message",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        channel_name: str = "",
        message: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_discord",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if channel_name is not None:
            self.inputs["channel_name"] = channel_name
        if message is not None:
            self.inputs["message"] = message
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationDiscordNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_linear")
class IntegrationLinearNode(Node):
    """
    Linear

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_comment
        comment: The comment on the issue
        issue_name: The name of the issue for the comment
    ### create_issue
        description: The description of the ticket
        team_name: The team within Linear
        title: The title of the issue

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Linear>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_issue": {
            "inputs": [
                {
                    "field": "team_name",
                    "type": "string",
                    "label": "Team",
                    "helper_text": "The team within Linear",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "label": "Title",
                    "placeholder": "Bug on submit button",
                    "helper_text": "The title of the issue",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Clicking on submit button leads to wrong page",
                    "helper_text": "The description of the ticket",
                },
            ],
            "outputs": [],
            "name": "create_issue",
            "task_name": "tasks.linear.create_new_issue",
            "description": "Create a new issue",
            "label": "Create Issue",
            "variant": "common_integration_nodes",
        },
        "create_comment": {
            "inputs": [
                {
                    "field": "issue_name",
                    "type": "string",
                    "value": "",
                    "label": "Issue",
                    "placeholder": "Bug on submit button",
                    "helper_text": "The name of the issue for the comment",
                },
                {
                    "field": "comment",
                    "type": "string",
                    "value": "",
                    "label": "Comment",
                    "placeholder": "More users are facing this issue",
                    "helper_text": "The comment on the issue",
                },
            ],
            "outputs": [],
            "name": "create_comment",
            "task_name": "tasks.linear.create_new_comment",
            "description": "Create a new comment",
            "label": "Create Comment",
            "variant": "default_integration_nodes",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        comment: str = "",
        description: str = "",
        issue_name: str = "",
        team_name: Optional[str] = None,
        title: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_linear",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if team_name is not None:
            self.inputs["team_name"] = team_name
        if title is not None:
            self.inputs["title"] = title
        if description is not None:
            self.inputs["description"] = description
        if issue_name is not None:
            self.inputs["issue_name"] = issue_name
        if comment is not None:
            self.inputs["comment"] = comment
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationLinearNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_outlook")
class IntegrationOutlookNode(Node):
    """
    Outlook

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'send_email'
        attachments: Attachments to be appended.
        body: The body of the email
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
        subject: The subject of the email
    ### When action = 'send_reply'
        attachments: Attachments to be appended.
        body: The body of the email
        email_id: The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
    ### When action = 'create_draft'
        body: The body of the email
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
        subject: The subject of the email
    ### When action = 'draft_reply'
        body: The body of the email
        email_id: The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
    ### When action = 'read_email' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'read_email' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'read_email'
        item_id: Select an email to read
        num_messages: Specify the last n number of emails
        use_date: Toggle to use dates
    ### When action = 'read_email' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_email'
        attachments: The attachments for each email
        email_bodies: The content of the retrieved emails
        email_dates: The sent dates of the retrieved emails
        email_ids: The IDs of the retrieved emails
        email_labels: The display names of the senders
        email_subjects: The subjects of the retrieved emails
        recipient_addresses: The email addresses of the recipients
        sender_addresses: The email addresses of the senders
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Outlook>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_nodes",
        },
        "create_draft**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Introduction to John",
                    "helper_text": "The subject of the email",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "create_draft",
            "task_name": "tasks.outlook.create_email_draft",
            "description": "Create (but do not send) a new email",
            "label": "Create Email Draft",
            "inputs_sort_order": [
                "integration",
                "action",
                "recipients",
                "subject",
                "format",
                "body",
            ],
        },
        "send_email**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Introduction to John",
                    "helper_text": "The subject of the email",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [""],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [],
            "name": "send_email",
            "task_name": "tasks.outlook.send_email",
            "description": "Create and send a new email",
            "label": "Send Email",
            "inputs_sort_order": [
                "integration",
                "action",
                "recipients",
                "subject",
                "format",
                "body",
                "attachments",
            ],
        },
        "draft_reply**(*)**(*)": {
            "inputs": [
                {
                    "field": "email_id",
                    "type": "string",
                    "value": "",
                    "label": "Email Id",
                    "placeholder": "john@company.com",
                    "helper_text": "The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)",
                },
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "draft_reply",
            "task_name": "tasks.outlook.draft_reply",
            "description": "Create (but do not send) a draft of a reply to an existing email",
            "label": "Draft Reply",
            "inputs_sort_order": [
                "integration",
                "action",
                "email_id",
                "recipients",
                "format",
                "body",
            ],
        },
        "send_reply**(*)**(*)": {
            "inputs": [
                {
                    "field": "email_id",
                    "type": "string",
                    "value": "",
                    "label": "Email Id",
                    "placeholder": "john@company.com",
                    "helper_text": "The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)",
                },
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "enum<string>",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [""],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [],
            "name": "send_reply",
            "task_name": "tasks.outlook.send_reply",
            "description": "Create and send a new reply to an existing email",
            "label": "Send Reply",
            "inputs_sort_order": [
                "integration",
                "action",
                "email_id",
                "recipients",
                "format",
                "body",
                "attachments",
            ],
        },
        "read_email**(*)**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "label": "Mailbox",
                    "helper_text": "Select an email to read",
                    "show_date_range": True,
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "order": 1,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "hidden": True,
                    "order": 2,
                },
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Emails",
                    "helper_text": "Specify the last n number of emails",
                    "hidden": True,
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "email_ids",
                    "type": "vec<string>",
                    "helper_text": "The IDs of the retrieved emails",
                },
                {
                    "field": "email_subjects",
                    "type": "vec<string>",
                    "helper_text": "The subjects of the retrieved emails",
                },
                {
                    "field": "email_dates",
                    "type": "vec<string>",
                    "helper_text": "The sent dates of the retrieved emails",
                },
                {
                    "field": "email_bodies",
                    "type": "vec<string>",
                    "helper_text": "The content of the retrieved emails",
                },
                {
                    "field": "sender_addresses",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the senders",
                },
                {
                    "field": "email_labels",
                    "type": "vec<string>",
                    "helper_text": "The display names of the senders",
                },
                {
                    "field": "recipient_addresses",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the recipients",
                },
                {
                    "field": "attachments",
                    "type": "vec<vec<file>>",
                    "helper_text": "The attachments for each email",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "read_email",
            "task_name": "tasks.outlook.read_email",
            "description": "Read emails from Outlook",
            "label": "Read Emails",
            "inputs_sort_order": [
                "integration",
                "action",
                "item_id",
                "num_messages",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
            ],
        },
        "read_email**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "hidden": True,
                    "order": 3,
                }
            ],
            "outputs": [],
        },
        "read_email**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                    "order": 4,
                }
            ],
            "outputs": [],
        },
        "read_email**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                    "order": 4,
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        attachments: List[str] = [""],
        body: str = "",
        email_id: str = "",
        exact_date: Any = {"start": "", "end": ""},
        format: str = "text",
        item_id: Optional[str] = None,
        num_messages: int = 10,
        recipients: str = "",
        subject: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_outlook",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if recipients is not None:
            self.inputs["recipients"] = recipients
        if subject is not None:
            self.inputs["subject"] = subject
        if body is not None:
            self.inputs["body"] = body
        if format is not None:
            self.inputs["format"] = format
        if attachments is not None:
            self.inputs["attachments"] = attachments
        if email_id is not None:
            self.inputs["email_id"] = email_id
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attachments(self) -> List[List[str]]:
        """
        The attachments for each email

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attachments")

    @property
    def email_bodies(self) -> List[str]:
        """
        The content of the retrieved emails

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_bodies")

    @property
    def email_dates(self) -> List[str]:
        """
        The sent dates of the retrieved emails

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_dates")

    @property
    def email_ids(self) -> List[str]:
        """
        The IDs of the retrieved emails

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_ids")

    @property
    def email_labels(self) -> List[str]:
        """
        The display names of the senders

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_labels")

    @property
    def email_subjects(self) -> List[str]:
        """
        The subjects of the retrieved emails

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_subjects")

    @property
    def recipient_addresses(self) -> List[str]:
        """
        The email addresses of the recipients

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("recipient_addresses")

    @property
    def sender_addresses(self) -> List[str]:
        """
        The email addresses of the senders

        Available: When action = 'read_email'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("sender_addresses")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationOutlookNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_salesforce")
class IntegrationSalesforceNode(Node):
    """
    Salesforce

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'run_sql_query'
        sql_query: SQL Query in Salesforce Object Query Language

    ## Outputs
    ### When action = 'run_sql_query'
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Salesforce>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "run_sql_query**(*)**(*)": {
            "inputs": [
                {
                    "field": "sql_query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "SELECT Id, Name, AccountNumber FROM Account",
                    "helper_text": "SQL Query in Salesforce Object Query Language",
                }
            ],
            "outputs": [{"field": "output", "type": "string"}],
            "name": "run_sql_query",
            "task_name": "tasks.salesforce.run_sql_query",
            "description": "Run a SQL query to query data",
            "label": "Run SQL Query",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        sql_query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_salesforce",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if sql_query is not None:
            self.inputs["sql_query"] = sql_query
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The output output

        Available: When action = 'run_sql_query'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationSalesforceNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_slack")
class IntegrationSlackNode(Node):
    """
    Slack

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'send_message'
        attachments: Attachments to be appended.
        channel: The name of the Slack channel
        message: The message you want to send
        team: The name of the Slack team
    ### When action = 'read_message'
        channel: The name of the Slack channel
        num_messages: Specify the last n number of messages
        team: The name of the Slack team
        use_date: Toggle to use dates
    ### When action = 'read_message' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'read_message' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'read_message' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_message'
        attachment_names: The retrieved attachment names
        message: The retrieved messages
        sender_id: The retrieved sender ids
        thread_id: The retrieved thread ids
        thread_link: The retrieved thread links
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Slack>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_nodes",
        },
        "send_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Slack team",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "label": "Channel",
                    "placeholder": "General",
                    "helper_text": "The name of the Slack channel",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "message",
                    "type": "string",
                    "value": "",
                    "label": "Message",
                    "placeholder": "Hello World!",
                    "helper_text": "The message you want to send",
                    "order": 5,
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [],
            "name": "send_message",
            "task_name": "tasks.slack.create_message",
            "description": "Post a new message to a specific channel",
            "label": "Send Message",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "message",
                "attachments",
            ],
        },
        "read_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Slack team",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "label": "Channel",
                    "placeholder": "General",
                    "helper_text": "The name of the Slack channel",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "hidden": True,
                },
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Messages",
                    "helper_text": "Specify the last n number of messages",
                    "hidden": True,
                },
            ],
            "outputs": [
                {
                    "field": "message",
                    "type": "vec<string>",
                    "helper_text": "The retrieved messages",
                },
                {
                    "field": "thread_id",
                    "type": "vec<string>",
                    "helper_text": "The retrieved thread ids",
                },
                {
                    "field": "attachment_names",
                    "type": "vec<vec<string>>",
                    "helper_text": "The retrieved attachment names",
                },
                {
                    "field": "sender_id",
                    "type": "vec<string>",
                    "helper_text": "The retrieved sender ids",
                },
                {
                    "field": "thread_link",
                    "type": "vec<string>",
                    "helper_text": "The retrieved thread links",
                },
            ],
            "name": "read_message",
            "task_name": "tasks.slack.read_messages",
            "description": "Reads n messages from a channel",
            "label": "Read Message",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
            ],
        },
        "read_message**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "hidden": True,
                }
            ],
            "outputs": [],
        },
        "read_message**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "read_message**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        attachments: List[str] = [],
        channel: str = "",
        exact_date: Any = {"start": "", "end": ""},
        message: str = "",
        num_messages: int = 10,
        team: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_slack",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if team is not None:
            self.inputs["team"] = team
        if channel is not None:
            self.inputs["channel"] = channel
        if message is not None:
            self.inputs["message"] = message
        if attachments is not None:
            self.inputs["attachments"] = attachments
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attachment_names(self) -> List[List[str]]:
        """
        The retrieved attachment names

        Available: When action = 'read_message'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attachment_names")

    @property
    def message(self) -> List[str]:
        """
        The retrieved messages

        Available: When action = 'read_message'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("message")

    @property
    def sender_id(self) -> List[str]:
        """
        The retrieved sender ids

        Available: When action = 'read_message'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("sender_id")

    @property
    def thread_id(self) -> List[str]:
        """
        The retrieved thread ids

        Available: When action = 'read_message'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("thread_id")

    @property
    def thread_link(self) -> List[str]:
        """
        The retrieved thread links

        Available: When action = 'read_message'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("thread_link")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationSlackNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_jira")
class IntegrationJiraNode(Node):
    """
    Jira

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: The integration input
    ### When action = 'get_issues'
        affected_version: Filter by affected version
        assignee_name: Account Name of the user to assign the issue to
        comment: The comment text to add
        comment_exact: Match comment exactly
        component: Filter by issue component
        created: Issue creation (YYYY-MM-DD)
        description: Detailed description of the issue
        description_exact: Match description exactly
        due: Due (YYYY-MM-DD)
        fix_version: Filter by fix version
        issue_summary: Search by issue summary
        issue_type: Type of issue (e.g. Task, Bug, Story)
        labels: Filter by issue labels
        num_messages: Specify the number of issues to fetch
        project: The name of the project
        query: The query to filter issues
        reporter_name: Account Name of the user who reported the issue
        resolution: Filter by resolution status
        resolved: Resolution (YYYY-MM-DD)
        site: The name of the Jira site
        status: The status of the issue (e.g. Open, Closed, In Progress)
        summary_exact: Match summary exactly
        text: Search in all text fields
        text_exact: Match text exactly across fields
        updated: Last update (YYYY-MM-DD)
        use_date: Toggle to use dates
    ### When action = 'create_issue'
        assignee_name: Account Name of the user to assign the issue to
        description: Detailed description of the issue
        issue_type: Type of issue (e.g. Task, Bug, Story)
        project: The name of the project
        site: The name of the Jira site
        summary: A brief title or summary of the issue
    ### When action = 'add_issue_comment'
        comment: The comment text to add
        issue_key: The key of the issue to update (e.g. PROJ-123)
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'get_issues' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'get_issues' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'update_issue'
        issue_key: The key of the issue to update (e.g. PROJ-123)
        project: The name of the project
        site: The name of the Jira site
        update_assignee_name: Account Name of the user to assign the issue to
        update_description: The new description for the issue
        update_issue_type: Type of issue (e.g. Task, Bug, Story)
        update_summary: The new summary for the issue
    ### When action = 'read_issue'
        issue_key: The key of the issue to update (e.g. PROJ-123)
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'read_issue_comments'
        issue_key: The key of the issue to update (e.g. PROJ-123)
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'get_users'
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'get_issues' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'get_users'
        account_id: The account IDs of the users in the project
        active: The active status of the users in the project
        display_name: The display names of the users in the project
        email: The email addresses of the users in the project
        raw_data: The raw response data from Jira API
    ### When action = 'read_issue'
        assignee_email: The email address of the assignees
        assignee_id: The account ID of the assignees
        assignee_name: The display name of the assignees
        browser_url: The URL to view the issues in browser
        comments: The comments of the issues
        created_date: The date and time when the issues was created
        description: The description of the issues
        issue_attachments: The attachments of the issues
        issue_id: The unique identifier of the issues
        issue_key: The key of the issues (e.g. PROJ-123)
        issue_type: The type of the issues
        raw_data: The raw response data from Jira API
        reporter_email: The email address of the reporters
        reporter_id: The account ID of the reporters
        reporter_name: The display name of the reporters
        status: The current status of the issues
        summary: The summary/title of the issues
        updated_date: The date and time when the issues was last updated
    ### When action = 'get_issues'
        assignee_emails: The email address of the assignee
        assignee_ids: The account ID of the assignee
        assignee_names: The display name of the assignee
        browser_urls: The URL to view the issue in browser
        comments: The comments of the issue
        created_dates: The date and time when the issue was created
        descriptions: The description of the issue
        issue_attachments: The attachments of the issue
        issue_ids: The unique identifier of the issue
        issue_keys: The key of the issue (e.g. PROJ-123)
        issue_types: The type of the issue
        raw_data: The raw response data from Jira API
        reporter_emails: The email address of the reporter
        reporter_ids: The account ID of the reporter
        reporter_names: The display name of the reporter
        statuses: The current status of the issue
        summaries: The summary/title of the issue
        updated_dates: The date and time when the issue was last updated
    ### When action = 'read_issue_comments'
        author_email: Array of comment author email addresses
        author_id: Array of comment author account IDs
        author_name: Array of comment author display names
        body: Array of comment bodies
        comment_id: Array of comment IDs
        created_date: Array of comment creation dates
        raw_data: The raw response data from Jira API
        total: Total number of comments
        updated_date: Array of comment update dates
    ### When action = 'add_issue_comment'
        comment_id: ID of the newly created comment
        created_date: Creation date of the comment
        message: Success message
        raw_data: The raw response data from Jira API
        updated_date: Last update date of the comment
    ### When action = 'create_issue'
        issue_id: The ID of the created issue
        issue_key: The key of the created issue
        raw_data: The raw response data from Jira API
        site: The name of the Jira site
        url: The URL of the created issue
    ### When action = 'update_issue'
        issue_key: The key of the updated issue
        message: Success message confirming the update
        raw_data: The raw response data from Jira API
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Jira>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "summary",
                    "label": "Summary",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue summary",
                    "helper_text": "A brief title or summary of the issue",
                    "order": 7,
                },
                {
                    "field": "description",
                    "label": "Description",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter detailed description",
                    "helper_text": "Detailed description of the issue",
                    "order": 8,
                },
                {
                    "field": "issue_type",
                    "label": "Issue Type",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select issue type",
                    "helper_text": "Type of issue (e.g. Task, Bug, Story)",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_type&project={inputs.project}&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "assignee_name",
                    "label": "Assignee Name",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select assignee",
                    "helper_text": "Account Name of the user to assign the issue to",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee_name&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "The ID of the created issue",
                },
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the created issue",
                },
                {
                    "field": "url",
                    "type": "string",
                    "helper_text": "The URL of the created issue",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_issue",
            "task_name": "tasks.jira.create_issue",
            "description": "Create a issue",
            "label": "Create Issue",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_type",
                "assignee_name",
                "summary",
                "description",
            ],
        },
        "update_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to update (e.g. PROJ-123)",
                    "order": 5,
                },
                {
                    "field": "update_summary",
                    "label": "Summary",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter new summary",
                    "helper_text": "The new summary for the issue",
                },
                {
                    "field": "update_description",
                    "label": "Description",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter new description",
                    "helper_text": "The new description for the issue",
                },
                {
                    "field": "update_issue_type",
                    "label": "Issue Type",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select issue type",
                    "helper_text": "Type of issue (e.g. Task, Bug, Story)",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_type&project={inputs.project}&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "update_assignee_name",
                    "label": "Assignee Name",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select assignee",
                    "helper_text": "Account Name of the user to assign the issue to",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee_name&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the updated issue",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message confirming the update",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_issue",
            "task_name": "tasks.jira.update_issue",
            "description": "Update an existing Jira issue",
            "label": "Update Issue",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "update_issue_type",
                "update_assignee_name",
                "issue_key",
                "update_summary",
                "update_description",
            ],
        },
        "get_users**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "account_id",
                    "type": "vec<string>",
                    "helper_text": "The account IDs of the users in the project",
                },
                {
                    "field": "email",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the users in the project",
                },
                {
                    "field": "display_name",
                    "type": "vec<string>",
                    "helper_text": "The display names of the users in the project",
                },
                {
                    "field": "active",
                    "type": "vec<bool>",
                    "helper_text": "The active status of the users in the project",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_users",
            "task_name": "tasks.jira.get_users",
            "description": "Get users from a Jira project",
            "label": "Get Users",
            "inputs_sort_order": ["integration", "action", "site", "project"],
        },
        "read_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to retrieve (e.g. PROJ-123)",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "The unique identifier of the issues",
                },
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the issues (e.g. PROJ-123)",
                },
                {
                    "field": "summary",
                    "type": "string",
                    "helper_text": "The summary/title of the issues",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "The description of the issues",
                },
                {
                    "field": "comments",
                    "type": "vec<string>",
                    "helper_text": "The comments of the issues",
                },
                {
                    "field": "issue_attachments",
                    "type": "vec<file>",
                    "helper_text": "The attachments of the issues",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "helper_text": "The date and time when the issues was created",
                },
                {
                    "field": "updated_date",
                    "type": "string",
                    "helper_text": "The date and time when the issues was last updated",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "The current status of the issues",
                },
                {
                    "field": "browser_url",
                    "type": "string",
                    "helper_text": "The URL to view the issues in browser",
                },
                {
                    "field": "issue_type",
                    "type": "string",
                    "helper_text": "The type of the issues",
                },
                {
                    "field": "assignee_id",
                    "type": "string",
                    "helper_text": "The account ID of the assignees",
                },
                {
                    "field": "assignee_name",
                    "type": "string",
                    "helper_text": "The display name of the assignees",
                },
                {
                    "field": "assignee_email",
                    "type": "string",
                    "helper_text": "The email address of the assignees",
                },
                {
                    "field": "reporter_id",
                    "type": "string",
                    "helper_text": "The account ID of the reporters",
                },
                {
                    "field": "reporter_name",
                    "type": "string",
                    "helper_text": "The display name of the reporters",
                },
                {
                    "field": "reporter_email",
                    "type": "string",
                    "helper_text": "The email address of the reporters",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_issue",
            "task_name": "tasks.jira.read_issue",
            "description": "Retrieve details of an existing Jira issue",
            "label": "Read Issue",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
            ],
        },
        "read_issue_comments**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to get comments for (e.g. PROJ-123)",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "type": "vec<string>",
                    "helper_text": "Array of comment IDs",
                },
                {
                    "field": "body",
                    "type": "vec<string>",
                    "helper_text": "Array of comment bodies",
                },
                {
                    "field": "created_date",
                    "type": "vec<string>",
                    "helper_text": "Array of comment creation dates",
                },
                {
                    "field": "updated_date",
                    "type": "vec<string>",
                    "helper_text": "Array of comment update dates",
                },
                {
                    "field": "author_id",
                    "type": "vec<string>",
                    "helper_text": "Array of comment author account IDs",
                },
                {
                    "field": "author_email",
                    "type": "vec<string>",
                    "helper_text": "Array of comment author email addresses",
                },
                {
                    "field": "author_name",
                    "type": "vec<string>",
                    "helper_text": "Array of comment author display names",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of comments",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_issue_comments",
            "task_name": "tasks.jira.read_issue_comments",
            "description": "Get all comments for a Jira issue",
            "label": "Read Issue Comments",
        },
        "add_issue_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to add comment to (e.g. PROJ-123)",
                    "order": 6,
                },
                {
                    "field": "comment",
                    "label": "Comment",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter your comment",
                    "helper_text": "The comment text to add",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "label": "Comment Id",
                    "type": "string",
                    "helper_text": "ID of the newly created comment",
                },
                {
                    "field": "created_date",
                    "label": "Created Dates",
                    "type": "string",
                    "helper_text": "Creation date of the comment",
                },
                {
                    "field": "updated_date",
                    "type": "string",
                    "helper_text": "Last update date of the comment",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "add_issue_comment",
            "task_name": "tasks.jira.add_issue_comment",
            "description": "Add a comment to a Jira issue",
            "label": "Add Issue Comment",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
                "comment",
            ],
        },
        "get_issues**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "order": 7,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "issue_type",
                    "label": "Issue Type",
                    "type": "string",
                    "hidden": True,
                    "value": "",
                    "placeholder": "Select issue type",
                    "helper_text": "Type of issue (e.g. Task, Bug, Story)",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_type&project={inputs.project}&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "assignee_name",
                    "label": "Assignee Name",
                    "type": "string",
                    "hidden": True,
                    "value": "",
                    "placeholder": "Select assignee",
                    "helper_text": "Account Name of the user to assign the issue to",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee_name&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Issues",
                    "helper_text": "Specify the number of issues to fetch",
                    "order": 6,
                },
                {
                    "field": "status",
                    "type": "string",
                    "value": "",
                    "label": "Status",
                    "placeholder": "Open",
                    "helper_text": "The status of the issue (e.g. Open, Closed, In Progress)",
                },
                {
                    "field": "reporter_name",
                    "label": "Reporter Name",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select reporter",
                    "helper_text": "Account Name of the user who reported the issue",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "Query",
                    "helper_text": "The query to filter issues",
                },
                {
                    "field": "issue_summary",
                    "type": "string",
                    "value": "",
                    "label": "Summary",
                    "placeholder": "Summary",
                    "helper_text": "Search by issue summary",
                },
                {
                    "field": "summary_exact",
                    "type": "string",
                    "value": "",
                    "label": "Summary Exact",
                    "placeholder": "Summary Exact",
                    "helper_text": "Match summary exactly",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Description",
                    "helper_text": "Search in issue description",
                },
                {
                    "field": "description_exact",
                    "type": "string",
                    "value": "",
                    "label": "Description Exact",
                    "placeholder": "Description Exact",
                    "helper_text": "Match description exactly",
                },
                {
                    "field": "comment",
                    "type": "string",
                    "value": "",
                    "label": "Comment",
                    "placeholder": "Comment",
                    "helper_text": "Search in issue comments",
                },
                {
                    "field": "comment_exact",
                    "type": "string",
                    "value": "",
                    "label": "Comment Exact",
                    "placeholder": "Comment Exact",
                    "helper_text": "Match comment exactly",
                },
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Text",
                    "placeholder": "Text",
                    "helper_text": "Search in all text fields",
                },
                {
                    "field": "text_exact",
                    "type": "string",
                    "value": "",
                    "label": "Text Exact",
                    "placeholder": "Text Exact",
                    "helper_text": "Match text exactly across fields",
                },
                {
                    "field": "labels",
                    "type": "string",
                    "value": "",
                    "label": "Labels",
                    "placeholder": "Labels",
                    "helper_text": "Filter by issue labels",
                },
                {
                    "field": "fix_version",
                    "type": "string",
                    "value": "",
                    "label": "Fix Version",
                    "placeholder": "Fix Version",
                    "helper_text": "Filter by fix version",
                },
                {
                    "field": "affected_version",
                    "type": "string",
                    "value": "",
                    "label": "Affected Version",
                    "placeholder": "Affected Version",
                    "helper_text": "Filter by affected version",
                },
                {
                    "field": "component",
                    "type": "string",
                    "value": "",
                    "label": "Component",
                    "placeholder": "Component",
                    "helper_text": "Filter by issue component",
                },
                {
                    "field": "resolution",
                    "type": "string",
                    "value": "",
                    "label": "Resolution",
                    "placeholder": "Resolution",
                    "helper_text": "Filter by resolution status",
                },
                {
                    "field": "created",
                    "type": "string",
                    "value": "",
                    "label": "Created",
                    "placeholder": "YYYY-MM-DD",
                    "helper_text": "Issue creation (YYYY-MM-DD)",
                },
                {
                    "field": "updated",
                    "type": "string",
                    "value": "",
                    "label": "Updated",
                    "placeholder": "YYYY-MM-DD",
                    "helper_text": "Last update (YYYY-MM-DD)",
                },
                {
                    "field": "resolved",
                    "type": "string",
                    "value": "",
                    "label": "Resolved",
                    "placeholder": "YYYY-MM-DD",
                    "helper_text": "Resolution (YYYY-MM-DD)",
                },
                {
                    "field": "due",
                    "type": "string",
                    "value": "",
                    "label": "Due",
                    "placeholder": "YYYY-MM-DD",
                    "helper_text": "Due (YYYY-MM-DD)",
                },
            ],
            "outputs": [
                {
                    "field": "issue_ids",
                    "type": "vec<string>",
                    "helper_text": "The unique identifier of the issue",
                },
                {
                    "field": "issue_keys",
                    "type": "vec<string>",
                    "helper_text": "The key of the issue (e.g. PROJ-123)",
                },
                {
                    "field": "summaries",
                    "type": "vec<string>",
                    "helper_text": "The summary/title of the issue",
                },
                {
                    "field": "descriptions",
                    "type": "vec<string>",
                    "helper_text": "The description of the issue",
                },
                {
                    "field": "comments",
                    "type": "vec<vec<string>>",
                    "helper_text": "The comments of the issue",
                },
                {
                    "field": "issue_attachments",
                    "type": "vec<file>",
                    "helper_text": "The attachments of the issue",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "The date and time when the issue was created",
                },
                {
                    "field": "updated_dates",
                    "type": "vec<string>",
                    "helper_text": "The date and time when the issue was last updated",
                },
                {
                    "field": "statuses",
                    "type": "vec<string>",
                    "helper_text": "The current status of the issue",
                },
                {
                    "field": "browser_urls",
                    "type": "vec<string>",
                    "helper_text": "The URL to view the issue in browser",
                },
                {
                    "field": "issue_types",
                    "type": "vec<string>",
                    "helper_text": "The type of the issue",
                },
                {
                    "field": "assignee_ids",
                    "type": "vec<string>",
                    "helper_text": "The account ID of the assignee",
                },
                {
                    "field": "assignee_names",
                    "type": "vec<string>",
                    "helper_text": "The display name of the assignee",
                },
                {
                    "field": "assignee_emails",
                    "type": "vec<string>",
                    "helper_text": "The email address of the assignee",
                },
                {
                    "field": "reporter_ids",
                    "type": "vec<string>",
                    "helper_text": "The account ID of the reporter",
                },
                {
                    "field": "reporter_names",
                    "type": "vec<string>",
                    "helper_text": "The display name of the reporter",
                },
                {
                    "field": "reporter_emails",
                    "type": "vec<string>",
                    "helper_text": "The email address of the reporter",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_issues",
            "task_name": "tasks.jira.get_issues",
            "description": "Get all issues for a Jira project",
            "label": "Get Issues",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_type",
                "status",
                "assignee_name",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "reporter_name",
                "query",
                "issue_summary",
                "summary_exact",
                "description",
                "description_exact",
                "comment",
                "comment_exact",
                "text",
                "text_exact",
                "labels",
                "fix_version",
                "affected_version",
                "component",
                "resolution",
                "created",
                "updated",
                "resolved",
                "due",
            ],
        },
        "get_issues**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "order": 8,
                }
            ],
            "outputs": [],
        },
        "get_issues**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "label": "Date Range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "order": 9,
                }
            ],
            "outputs": [],
        },
        "get_issues**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "label": "Exact date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "order": 9,
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        affected_version: str = "",
        assignee_name: str = "",
        comment: str = "",
        comment_exact: str = "",
        component: str = "",
        created: str = "",
        description: str = "",
        description_exact: str = "",
        due: str = "",
        exact_date: Any = {"start": "", "end": ""},
        fix_version: str = "",
        issue_key: str = "",
        issue_summary: str = "",
        issue_type: str = "",
        labels: str = "",
        num_messages: int = 10,
        project: str = "",
        query: str = "",
        reporter_name: str = "",
        resolution: str = "",
        resolved: str = "",
        site: str = "",
        status: str = "",
        summary: str = "",
        summary_exact: str = "",
        text: str = "",
        text_exact: str = "",
        update_assignee_name: str = "",
        update_description: str = "",
        update_issue_type: str = "",
        update_summary: str = "",
        updated: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_jira",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if site is not None:
            self.inputs["site"] = site
        if project is not None:
            self.inputs["project"] = project
        if summary is not None:
            self.inputs["summary"] = summary
        if description is not None:
            self.inputs["description"] = description
        if issue_type is not None:
            self.inputs["issue_type"] = issue_type
        if assignee_name is not None:
            self.inputs["assignee_name"] = assignee_name
        if issue_key is not None:
            self.inputs["issue_key"] = issue_key
        if update_summary is not None:
            self.inputs["update_summary"] = update_summary
        if update_description is not None:
            self.inputs["update_description"] = update_description
        if update_issue_type is not None:
            self.inputs["update_issue_type"] = update_issue_type
        if update_assignee_name is not None:
            self.inputs["update_assignee_name"] = update_assignee_name
        if comment is not None:
            self.inputs["comment"] = comment
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if status is not None:
            self.inputs["status"] = status
        if reporter_name is not None:
            self.inputs["reporter_name"] = reporter_name
        if query is not None:
            self.inputs["query"] = query
        if issue_summary is not None:
            self.inputs["issue_summary"] = issue_summary
        if summary_exact is not None:
            self.inputs["summary_exact"] = summary_exact
        if description_exact is not None:
            self.inputs["description_exact"] = description_exact
        if comment_exact is not None:
            self.inputs["comment_exact"] = comment_exact
        if text is not None:
            self.inputs["text"] = text
        if text_exact is not None:
            self.inputs["text_exact"] = text_exact
        if labels is not None:
            self.inputs["labels"] = labels
        if fix_version is not None:
            self.inputs["fix_version"] = fix_version
        if affected_version is not None:
            self.inputs["affected_version"] = affected_version
        if component is not None:
            self.inputs["component"] = component
        if resolution is not None:
            self.inputs["resolution"] = resolution
        if created is not None:
            self.inputs["created"] = created
        if updated is not None:
            self.inputs["updated"] = updated
        if resolved is not None:
            self.inputs["resolved"] = resolved
        if due is not None:
            self.inputs["due"] = due
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def account_id(self) -> List[str]:
        """
        The account IDs of the users in the project

        Available: When action = 'get_users'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("account_id")

    @property
    def active(self) -> List[bool]:
        """
        The active status of the users in the project

        Available: When action = 'get_users'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("active")

    @property
    def assignee_email(self) -> str:
        """
        The email address of the assignees

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignee_email")

    @property
    def assignee_emails(self) -> List[str]:
        """
        The email address of the assignee

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignee_emails")

    @property
    def assignee_id(self) -> str:
        """
        The account ID of the assignees

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignee_id")

    @property
    def assignee_ids(self) -> List[str]:
        """
        The account ID of the assignee

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignee_ids")

    @property
    def assignee_name(self) -> str:
        """
        The display name of the assignees

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignee_name")

    @property
    def assignee_names(self) -> List[str]:
        """
        The display name of the assignee

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("assignee_names")

    @property
    def author_email(self) -> List[str]:
        """
        Array of comment author email addresses

        Available: When action = 'read_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("author_email")

    @property
    def author_id(self) -> List[str]:
        """
        Array of comment author account IDs

        Available: When action = 'read_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("author_id")

    @property
    def author_name(self) -> List[str]:
        """
        Array of comment author display names

        Available: When action = 'read_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("author_name")

    @property
    def body(self) -> List[str]:
        """
        Array of comment bodies

        Available: When action = 'read_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("body")

    @property
    def browser_url(self) -> str:
        """
        The URL to view the issues in browser

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("browser_url")

    @property
    def browser_urls(self) -> List[str]:
        """
        The URL to view the issue in browser

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("browser_urls")

    @property
    def comment_id(self) -> List[str]:
        """
        Array of comment IDs

        Different behavior based on configuration:
          - Array of comment IDs (When action = 'read_issue_comments')
          - ID of the newly created comment (When action = 'add_issue_comment')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comment_id")

    @property
    def comments(self) -> List[str]:
        """
        The comments of the issues

        Different behavior based on configuration:
          - The comments of the issues (When action = 'read_issue')
          - The comments of the issue (When action = 'get_issues')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("comments")

    @property
    def created_date(self) -> str:
        """
        The date and time when the issues was created

        Different behavior based on configuration:
          - The date and time when the issues was created (When action = 'read_issue')
          - Array of comment creation dates (When action = 'read_issue_comments')
          - Creation date of the comment (When action = 'add_issue_comment')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_date")

    @property
    def created_dates(self) -> List[str]:
        """
        The date and time when the issue was created

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_dates")

    @property
    def description(self) -> str:
        """
        The description of the issues

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("description")

    @property
    def descriptions(self) -> List[str]:
        """
        The description of the issue

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("descriptions")

    @property
    def display_name(self) -> List[str]:
        """
        The display names of the users in the project

        Available: When action = 'get_users'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("display_name")

    @property
    def email(self) -> List[str]:
        """
        The email addresses of the users in the project

        Available: When action = 'get_users'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email")

    @property
    def issue_attachments(self) -> List[str]:
        """
        The attachments of the issues

        Different behavior based on configuration:
          - The attachments of the issues (When action = 'read_issue')
          - The attachments of the issue (When action = 'get_issues')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_attachments")

    @property
    def issue_id(self) -> str:
        """
        The ID of the created issue

        Different behavior based on configuration:
          - The ID of the created issue (When action = 'create_issue')
          - The unique identifier of the issues (When action = 'read_issue')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_id")

    @property
    def issue_ids(self) -> List[str]:
        """
        The unique identifier of the issue

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_ids")

    @property
    def issue_key(self) -> str:
        """
        The key of the created issue

        Different behavior based on configuration:
          - The key of the created issue (When action = 'create_issue')
          - The key of the updated issue (When action = 'update_issue')
          - The key of the issues (e.g. PROJ-123) (When action = 'read_issue')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_key")

    @property
    def issue_keys(self) -> List[str]:
        """
        The key of the issue (e.g. PROJ-123)

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_keys")

    @property
    def issue_type(self) -> str:
        """
        The type of the issues

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_type")

    @property
    def issue_types(self) -> List[str]:
        """
        The type of the issue

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("issue_types")

    @property
    def message(self) -> str:
        """
        Success message confirming the update

        Different behavior based on configuration:
          - Success message confirming the update (When action = 'update_issue')
          - Success message (When action = 'add_issue_comment')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("message")

    @property
    def raw_data(self) -> str:
        """
        The raw response data from Jira API

        Available: When action = 'create_issue', When action = 'update_issue', When action = 'get_users', When action = 'read_issue', When action = 'read_issue_comments', When action = 'add_issue_comment', When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("raw_data")

    @property
    def reporter_email(self) -> str:
        """
        The email address of the reporters

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("reporter_email")

    @property
    def reporter_emails(self) -> List[str]:
        """
        The email address of the reporter

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("reporter_emails")

    @property
    def reporter_id(self) -> str:
        """
        The account ID of the reporters

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("reporter_id")

    @property
    def reporter_ids(self) -> List[str]:
        """
        The account ID of the reporter

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("reporter_ids")

    @property
    def reporter_name(self) -> str:
        """
        The display name of the reporters

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("reporter_name")

    @property
    def reporter_names(self) -> List[str]:
        """
        The display name of the reporter

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("reporter_names")

    @property
    def site(self) -> str:
        """
        The name of the Jira site

        Available: When action = 'create_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("site")

    @property
    def status(self) -> str:
        """
        The current status of the issues

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("status")

    @property
    def statuses(self) -> List[str]:
        """
        The current status of the issue

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("statuses")

    @property
    def summaries(self) -> List[str]:
        """
        The summary/title of the issue

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("summaries")

    @property
    def summary(self) -> str:
        """
        The summary/title of the issues

        Available: When action = 'read_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("summary")

    @property
    def total(self) -> int:
        """
        Total number of comments

        Available: When action = 'read_issue_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("total")

    @property
    def updated_date(self) -> str:
        """
        The date and time when the issues was last updated

        Different behavior based on configuration:
          - The date and time when the issues was last updated (When action = 'read_issue')
          - Array of comment update dates (When action = 'read_issue_comments')
          - Last update date of the comment (When action = 'add_issue_comment')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated_date")

    @property
    def updated_dates(self) -> List[str]:
        """
        The date and time when the issue was last updated

        Available: When action = 'get_issues'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated_dates")

    @property
    def url(self) -> str:
        """
        The URL of the created issue

        Available: When action = 'create_issue'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("url")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationJiraNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_sugar_crm")
class IntegrationSugarCrmNode(Node):
    """
    SugarCRM

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### get_records
        filter: To filter records within module
        module: Your existing module on SugarCRM

    ## Outputs
    ### get_records
        output: The retrieved output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<SugarCRM>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "get_records": {
            "inputs": [
                {
                    "field": "module",
                    "type": "string",
                    "value": "",
                    "label": "Module",
                    "placeholder": "customer_support",
                    "helper_text": "Your existing module on SugarCRM",
                },
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "label": "Filter",
                    "placeholder": "Name = 'John'",
                    "helper_text": "To filter records within module",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "any",
                    "helper_text": "The retrieved output",
                }
            ],
            "name": "get_records",
            "task_name": "tasks.sugar_crm.get_records",
            "description": "Fetch records",
            "label": "Get Records",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        filter: str = "",
        module: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_sugar_crm",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if module is not None:
            self.inputs["module"] = module
        if filter is not None:
            self.inputs["filter"] = filter
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> Any:
        """
        The retrieved output

        Available: get_records


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationSugarCrmNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_github")
class IntegrationGithubNode(Node):
    """
    Github

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_pr
        base: Base branch for the PR - branch to which changes should be applied
        body: A description of the PR
        head: Head branch of the PR - branch containing changes you want to integrate
        owner_name: Github username of the repo owner (user or organization)
        repo_name: Name of the repository to read from
        title: The title of the PR
    ### update_pr
        body: A description of the PR
        owner_name: Github username of the repo owner (user or organization)
        pull_number: The number of the PR
        repo_name: Name of the repository to read from
        title: The title of the PR
    ### read_file
        branch_name: Name of the branch to read the file from
        file_name: Full path name of the file to read
        repo_name: Name of the repository to read from

    ## Outputs
    ### read_file
        output: File contents
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Github>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "read_file": {
            "inputs": [
                {
                    "field": "repo_name",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "label": "Repository Name",
                    "helper_text": "Name of the repository to read from",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repo_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "branch_name",
                    "type": "string",
                    "value": "",
                    "label": "Branch Name",
                    "placeholder": "main",
                    "helper_text": "Name of the branch to read the file from",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "value": "",
                    "label": "File Name",
                    "placeholder": "server/chat-commands/info.ts",
                    "helper_text": "Full path name of the file to read",
                },
            ],
            "outputs": [
                {"field": "output", "type": "string", "helper_text": "File contents"}
            ],
            "name": "read_file",
            "task_name": "tasks.github.read_file",
            "description": "Download a file from Github",
            "label": "Read a File",
        },
        "create_pr": {
            "inputs": [
                {
                    "field": "repo_name",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "label": "Repository Name",
                    "helper_text": "Name of the repository to read from",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repo_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "owner_name",
                    "type": "string",
                    "value": "",
                    "label": "Owner Name",
                    "placeholder": "smogon",
                    "helper_text": "Github username of the repo owner (user or organization)",
                },
                {
                    "field": "base",
                    "type": "string",
                    "value": "",
                    "label": "Base",
                    "placeholder": "dev",
                    "helper_text": "Base branch for the PR - branch to which changes should be applied",
                },
                {
                    "field": "head",
                    "type": "string",
                    "value": "",
                    "label": "Head",
                    "placeholder": "bugs-151-fix-bug",
                    "helper_text": "Head branch of the PR - branch containing changes you want to integrate",
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "label": "Title",
                    "placeholder": "Fix Bug",
                    "helper_text": "The title of the PR",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Fixes existing bugs",
                    "helper_text": "A description of the PR",
                },
            ],
            "outputs": [],
            "name": "create_pr",
            "task_name": "tasks.github.create_pr",
            "description": "Create a new pull request",
            "label": "Create a Pull Request",
        },
        "update_pr": {
            "inputs": [
                {
                    "field": "repo_name",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "label": "Repository Name",
                    "helper_text": "Name of the repository to read from",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repo_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "owner_name",
                    "type": "string",
                    "value": "",
                    "label": "Owner Name",
                    "placeholder": "smogon",
                    "helper_text": "Github username of the repo owner (user or organization)",
                },
                {
                    "field": "pull_number",
                    "type": "string",
                    "value": "",
                    "label": "Pull Number",
                    "placeholder": "123",
                    "helper_text": "The number of the PR",
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "label": "Title",
                    "placeholder": "Add new feature",
                    "helper_text": "The title of the PR",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "This PR adds a new feature to the project",
                    "helper_text": "The body of the PR",
                },
            ],
            "outputs": [],
            "name": "update_pr",
            "task_name": "tasks.github.update_pr",
            "description": "Update a pull request",
            "label": "Update a Pull Request",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        base: str = "",
        body: str = "",
        branch_name: str = "",
        file_name: str = "",
        head: str = "",
        owner_name: str = "",
        pull_number: str = "",
        repo_name: Optional[str] = None,
        title: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_github",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if repo_name is not None:
            self.inputs["repo_name"] = repo_name
        if branch_name is not None:
            self.inputs["branch_name"] = branch_name
        if file_name is not None:
            self.inputs["file_name"] = file_name
        if owner_name is not None:
            self.inputs["owner_name"] = owner_name
        if base is not None:
            self.inputs["base"] = base
        if head is not None:
            self.inputs["head"] = head
        if title is not None:
            self.inputs["title"] = title
        if body is not None:
            self.inputs["body"] = body
        if pull_number is not None:
            self.inputs["pull_number"] = pull_number
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        File contents

        Available: read_file


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGithubNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_zendesk")
class IntegrationZendeskNode(Node):
    """
    Zendesk

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'get_tickets'
        assignee: Assignee of the ticket
        body: Search in the full ticket content
        brand: Filter by brand
        comment: Search in ticket comments
        comment_exact: Match comment exactly
        description: Search in the ticket description
        due: Tickets due on this date
        external_id: Search by external ID
        group: Filter by assigned group
        include: Include related data (e.g. users)
        num_messages: Specify the number of tickets to fetch
        organization: Organization of the ticket
        priority: Priority of the ticket
        requester: Requester of the ticket
        satisfaction: Customer satisfaction rating
        solved: Tickets solved on this date
        sort_by: Field to sort results by
        sort_order: Order of sorting (asc/desc)
        status: Status of the ticket
        subject: Search tickets by subject
        subject_exact: Match subject exactly
        ticket_form: Filter by ticket form
        ticket_type: Type of the ticket
        updated: Tickets updated on this date
        use_date: Toggle to use dates
    ### When action = 'get_tickets' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'get_tickets' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'create_comment'
        public: Whether the comment should be public
        ticket_body: Body content of the ticket
        ticket_id: The ID of Zendesk ticket to update
    ### When action = 'create_ticket'
        requester_email: Email of the requester
        requester_name: Name of the requester (Required if requester email is not already registered)
        ticket_body: Body content of the ticket
        ticket_priority: Priority of the ticket
        ticket_status: Status of the ticket
        ticket_subject: Subject content of the ticket
        ticket_type: Type of the ticket
    ### When action = 'update_ticket'
        ticket_id: The ID of Zendesk ticket to update
        ticket_priority: Priority of the ticket
        ticket_status: Status of the ticket
        ticket_type: Type of the ticket
        update_ticket_assignee_id: The ID of the assignee to update the ticket to
        update_ticket_body: Body content of the ticket
        update_ticket_subject: Subject content of the ticket
    ### When action = 'read_ticket'
        ticket_id: The ID of Zendesk ticket to update
    ### When action = 'read_ticket_comments'
        ticket_id: The ID of Zendesk ticket to update
    ### When action = 'get_tickets' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_ticket'
        created_at: Date and time the ticket was created
        ticket_assignee_id: ID of ticket assignee
        ticket_attachments: Attachments of the ticket
        ticket_body: Body of the ticket
        ticket_details: Ticket details in JSON format
        ticket_priority: Priority of the ticket
        ticket_requester_id: ID of ticket requester
        ticket_status: Status of the ticket
        ticket_subject: Subject of the ticket
        ticket_type: Type of the ticket
        ticket_url: URL of the ticket
        updated_at: Date and time the ticket was last updated
    ### When action = 'get_tickets'
        created_at: Date and time the tickets was created
        ticket_assignee_id: ID of tickets assignee
        ticket_attachments: Attachments of the tickets
        ticket_body: Body of the tickets
        ticket_details: Tickets details in JSON format
        ticket_id: ID of the tickets
        ticket_priority: Priority of the tickets
        ticket_requester_id: ID of tickets requester
        ticket_status: Status of the tickets
        ticket_subject: Subject of the tickets
        ticket_type: Type of the tickets
        ticket_url: URL of the tickets
        updated_at: Date and time the tickets was last updated
    ### When action = 'read_ticket_comments'
        ticket_attachments: Attachments of the ticket
        ticket_comments: Ticket comments in JSON format
        ticket_details: Ticket details in JSON format
    ### When action = 'create_ticket'
        ticket_details: Ticket details in JSON format
        ticket_id: Ticket ID of the created ticket
    ### When action = 'update_ticket'
        ticket_details: Ticket details in JSON format
    ### When action = 'create_comment'
        ticket_details: Ticket details in JSON format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Zendesk>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_subject",
                    "type": "string",
                    "value": "",
                    "helper_text": "Subject content of the ticket",
                    "label": "Subject",
                    "placeholder": "Incident report",
                },
                {
                    "field": "ticket_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Body content of the ticket",
                    "label": "Body",
                    "placeholder": "Clicking on submit button doens’t work",
                },
                {
                    "field": "requester_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the requester",
                    "label": "Requester Email",
                    "placeholder": "john@company.com",
                },
                {
                    "field": "requester_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the requester (Required if requester email is not already registered)",
                    "label": "Requester Name",
                    "placeholder": "John Smith",
                },
                {
                    "field": "ticket_priority",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Priority of the ticket",
                    "label": "Priority",
                    "placeholder": "High",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Low", "value": "Low"},
                            {"label": "Normal", "value": "Normal"},
                            {"label": "High", "value": "High"},
                            {"label": "Urgent", "value": "Urgent"},
                        ],
                    },
                },
                {
                    "field": "ticket_type",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Type of the ticket",
                    "label": "Type",
                    "placeholder": "Incident",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Question", "value": "Question"},
                            {"label": "Incident", "value": "Incident"},
                            {"label": "Problem", "value": "Problem"},
                            {"label": "Task", "value": "Task"},
                        ],
                    },
                },
                {
                    "field": "ticket_status",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Status of the ticket",
                    "label": "Status",
                    "placeholder": "Open",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "New", "value": "New"},
                            {"label": "Open", "value": "Open"},
                            {"label": "Pending", "value": "Pending"},
                            {"label": "Hold", "value": "Hold"},
                            {"label": "Solved", "value": "Solved"},
                            {"label": "Closed", "value": "Closed"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "helper_text": "Ticket ID of the created ticket",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_ticket",
            "task_name": "tasks.zendesk.create_ticket",
            "description": "Create a new ticket on Zendesk",
            "label": "Create Ticket",
            "inputs_sort_order": [
                "integration",
                "action",
                "ticket_priority",
                "ticket_type",
                "ticket_status",
                "ticket_subject",
                "ticket_body",
                "requester_email",
                "requester_name",
            ],
        },
        "update_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of Zendesk ticket to update",
                    "label": "Ticket ID",
                    "placeholder": "123",
                },
                {
                    "field": "update_ticket_subject",
                    "type": "string",
                    "value": "",
                    "helper_text": "Subject content of the ticket",
                    "label": "Subject",
                    "placeholder": "Incident report",
                },
                {
                    "field": "update_ticket_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Body content of the ticket",
                    "label": "Body",
                    "placeholder": "Clicking on submit button not working",
                },
                {
                    "field": "update_ticket_assignee_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the assignee to update the ticket to",
                    "label": "Assignee ID",
                    "placeholder": "1234",
                },
                {
                    "field": "ticket_priority",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Priority of the ticket",
                    "label": "Priority",
                    "placeholder": "High",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Low", "value": "Low"},
                            {"label": "Normal", "value": "Normal"},
                            {"label": "High", "value": "High"},
                            {"label": "Urgent", "value": "Urgent"},
                        ],
                    },
                },
                {
                    "field": "ticket_type",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Type of the ticket",
                    "label": "Type",
                    "placeholder": "Incident",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Question", "value": "Question"},
                            {"label": "Incident", "value": "Incident"},
                            {"label": "Problem", "value": "Problem"},
                            {"label": "Task", "value": "Task"},
                        ],
                    },
                },
                {
                    "field": "ticket_status",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Status of the ticket",
                    "label": "Status",
                    "placeholder": "Open",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "New", "value": "New"},
                            {"label": "Open", "value": "Open"},
                            {"label": "Pending", "value": "Pending"},
                            {"label": "Hold", "value": "Hold"},
                            {"label": "Solved", "value": "Solved"},
                            {"label": "Closed", "value": "Closed"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "update_ticket",
            "task_name": "tasks.zendesk.update_ticket",
            "description": "Update an existing ticket on Zendesk",
            "label": "Update Ticket",
            "inputs_sort_order": [
                "integration",
                "action",
                "ticket_priority",
                "ticket_type",
                "ticket_status",
                "ticket_id",
                "update_ticket_subject",
                "update_ticket_body",
                "update_ticket_assignee_id",
            ],
        },
        "create_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of Zendesk ticket to add comment to",
                    "label": "Ticket ID",
                    "placeholder": "123",
                },
                {
                    "field": "ticket_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Content of the comment",
                    "label": "Comment Body",
                    "placeholder": "Clicking on submit button not working",
                },
                {
                    "field": "public",
                    "type": "bool",
                    "value": "",
                    "helper_text": "Whether the comment should be public",
                    "label": "Public",
                },
            ],
            "outputs": [
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                }
            ],
            "name": "create_comment",
            "task_name": "tasks.zendesk.create_comment",
            "description": "Create a new comment on a Zendesk ticket",
            "label": "Create Comment",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "ticket_id",
                "ticket_body",
                "public",
            ],
        },
        "read_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of Zendesk ticket to read",
                    "label": "Ticket ID",
                    "placeholder": "123",
                }
            ],
            "outputs": [
                {
                    "field": "ticket_subject",
                    "type": "string",
                    "helper_text": "Subject of the ticket",
                },
                {
                    "field": "ticket_body",
                    "type": "vec<string>",
                    "helper_text": "Body of the ticket",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Date and time the ticket was created",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Date and time the ticket was last updated",
                },
                {
                    "field": "ticket_priority",
                    "type": "string",
                    "helper_text": "Priority of the ticket",
                },
                {
                    "field": "ticket_type",
                    "type": "string",
                    "helper_text": "Type of the ticket",
                },
                {
                    "field": "ticket_status",
                    "type": "string",
                    "helper_text": "Status of the ticket",
                },
                {
                    "field": "ticket_url",
                    "type": "string",
                    "helper_text": "URL of the ticket",
                },
                {
                    "field": "ticket_attachments",
                    "type": "vec<file>",
                    "helper_text": "Attachments of the ticket",
                },
                {
                    "field": "ticket_assignee_id",
                    "type": "string",
                    "helper_text": "ID of ticket assignee",
                },
                {
                    "field": "ticket_requester_id",
                    "type": "string",
                    "helper_text": "ID of ticket requester",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                },
            ],
            "name": "read_ticket",
            "task_name": "tasks.zendesk.read_ticket",
            "description": "Read an existing ticket on Zendesk",
            "label": "Read Ticket",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "ticket_id"],
        },
        "read_ticket_comments**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of Zendesk ticket to read comments from",
                    "label": "Ticket ID",
                    "placeholder": "123",
                }
            ],
            "outputs": [
                {
                    "field": "ticket_comments",
                    "type": "vec<string>",
                    "helper_text": "Ticket comments in JSON format",
                },
                {
                    "field": "ticket_attachments",
                    "type": "vec<file>",
                    "helper_text": "Attachments of the ticket",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                },
            ],
            "name": "read_ticket_comments",
            "task_name": "tasks.zendesk.read_ticket_comments",
            "description": "Read comments from an existing ticket on Zendesk",
            "label": "Read Ticket Comments",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "ticket_id"],
        },
        "get_tickets**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Tickets",
                    "helper_text": "Specify the number of tickets to fetch",
                },
                {
                    "field": "assignee",
                    "type": "string",
                    "value": "",
                    "label": "Assignee",
                    "helper_text": "Assignee of the ticket",
                    "placeholder": "John Smith",
                },
                {
                    "field": "requester",
                    "type": "string",
                    "value": "",
                    "label": "Requester",
                    "helper_text": "Requester of the ticket",
                    "placeholder": "John Smith",
                },
                {
                    "field": "organization",
                    "type": "string",
                    "value": "",
                    "label": "Organization",
                    "helper_text": "Organization of the ticket",
                    "placeholder": "Acme Corp",
                },
                {
                    "field": "priority",
                    "type": "enum<string>",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Priority of the ticket",
                    "label": "Priority",
                    "placeholder": "High",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Low", "value": "Low"},
                            {"label": "Normal", "value": "Normal"},
                            {"label": "High", "value": "High"},
                            {"label": "Urgent", "value": "Urgent"},
                        ],
                    },
                },
                {
                    "field": "ticket_type",
                    "type": "enum<string>",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Type of the ticket",
                    "label": "Type",
                    "placeholder": "Incident",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Question", "value": "Question"},
                            {"label": "Incident", "value": "Incident"},
                            {"label": "Problem", "value": "Problem"},
                            {"label": "Task", "value": "Task"},
                        ],
                    },
                },
                {
                    "field": "status",
                    "type": "enum<string>",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Status of the ticket",
                    "label": "Status",
                    "placeholder": "Open",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "New", "value": "New"},
                            {"label": "Open", "value": "Open"},
                            {"label": "Pending", "value": "Pending"},
                            {"label": "Hold", "value": "Hold"},
                            {"label": "Solved", "value": "Solved"},
                            {"label": "Closed", "value": "Closed"},
                        ],
                    },
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "helper_text": "Search tickets by subject",
                    "placeholder": "Incident report",
                },
                {
                    "field": "subject_exact",
                    "type": "string",
                    "value": "",
                    "label": "Subject Exact",
                    "helper_text": "Match subject exactly",
                    "placeholder": "Incident report",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "helper_text": "Search in the ticket description",
                    "placeholder": "Clicking on submit button doesn't work",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "helper_text": "Search in the full ticket content",
                    "placeholder": "Clicking on submit button doesn't work",
                },
                {
                    "field": "comment",
                    "type": "string",
                    "value": "",
                    "label": "Comment",
                    "helper_text": "Search in ticket comments",
                    "placeholder": "Clicking on submit button doesn't work",
                },
                {
                    "field": "comment_exact",
                    "type": "string",
                    "value": "",
                    "label": "Comment Exact",
                    "helper_text": "Match comment exactly",
                    "placeholder": "Clicking on submit button doesn't work",
                },
                {
                    "field": "updated",
                    "type": "string",
                    "value": "",
                    "label": "Updated Date",
                    "helper_text": "Tickets updated on this date",
                    "placeholder": "YYYY-MM-DD",
                },
                {
                    "field": "solved",
                    "type": "string",
                    "value": "",
                    "label": "Solved Date",
                    "helper_text": "Tickets solved on this date",
                    "placeholder": "YYYY-MM-DD",
                },
                {
                    "field": "due",
                    "type": "string",
                    "value": "",
                    "label": "Due Date",
                    "helper_text": "Tickets due on this date",
                    "placeholder": "YYYY-MM-DD",
                },
                {
                    "field": "brand",
                    "type": "string",
                    "value": "",
                    "label": "Brand",
                    "helper_text": "Filter by brand",
                    "placeholder": "Acme Corp",
                },
                {
                    "field": "satisfaction",
                    "type": "enum<string>",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Customer satisfaction rating",
                    "label": "Satisfaction",
                    "placeholder": "Good",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Good", "value": "good"},
                            {"label": "Bad", "value": "bad"},
                            {"label": "Offered", "value": "offered"},
                        ],
                    },
                },
                {
                    "field": "ticket_form",
                    "type": "string",
                    "value": "",
                    "label": "Ticket Form",
                    "helper_text": "Filter by ticket form",
                    "placeholder": "Support",
                },
                {
                    "field": "group",
                    "type": "string",
                    "value": "",
                    "label": "Group",
                    "helper_text": "Filter by assigned group",
                    "placeholder": "Support",
                },
                {
                    "field": "sort_by",
                    "type": "string",
                    "value": "",
                    "label": "Sort By",
                    "helper_text": "Field to sort results by",
                    "placeholder": "created_at",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "helper_text": "Order of sorting (asc/desc)",
                    "placeholder": "desc",
                },
                {
                    "field": "external_id",
                    "type": "string",
                    "value": "",
                    "label": "External ID",
                    "helper_text": "Search by external ID",
                    "placeholder": "123",
                },
                {
                    "field": "include",
                    "type": "string",
                    "value": "",
                    "label": "Include",
                    "helper_text": "Include related data (e.g. users)",
                    "placeholder": "users,groups,organizations",
                },
            ],
            "outputs": [
                {
                    "field": "ticket_id",
                    "type": "vec<string>",
                    "helper_text": "ID of the tickets",
                },
                {
                    "field": "ticket_subject",
                    "type": "vec<string>",
                    "helper_text": "Subject of the tickets",
                },
                {
                    "field": "ticket_body",
                    "type": "vec<string>",
                    "helper_text": "Body of the tickets",
                },
                {
                    "field": "created_at",
                    "type": "vec<string>",
                    "helper_text": "Date and time the tickets was created",
                },
                {
                    "field": "updated_at",
                    "type": "vec<string>",
                    "helper_text": "Date and time the tickets was last updated",
                },
                {
                    "field": "ticket_priority",
                    "type": "vec<string>",
                    "helper_text": "Priority of the tickets",
                },
                {
                    "field": "ticket_type",
                    "type": "vec<string>",
                    "helper_text": "Type of the tickets",
                },
                {
                    "field": "ticket_status",
                    "type": "vec<string>",
                    "helper_text": "Status of the tickets",
                },
                {
                    "field": "ticket_url",
                    "type": "vec<string>",
                    "helper_text": "URL of the tickets",
                },
                {
                    "field": "ticket_attachments",
                    "type": "vec<vec<file>>",
                    "helper_text": "Attachments of the tickets",
                },
                {
                    "field": "ticket_assignee_id",
                    "type": "vec<string>",
                    "helper_text": "ID of tickets assignee",
                },
                {
                    "field": "ticket_requester_id",
                    "type": "vec<string>",
                    "helper_text": "ID of tickets requester",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Tickets details in JSON format",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_tickets",
            "task_name": "tasks.zendesk.get_tickets",
            "description": "Get a list of tickets from Zendesk",
            "label": "Get Tickets",
            "inputs_sort_order": [
                "integration",
                "action",
                "use_date",
                "use_exact_date",
                "ticket_subject",
                "ticket_body",
                "requester_email",
                "requester_name",
                "ticket_priority",
                "ticket_type",
                "ticket_status",
                "assignee",
                "requester",
                "organization",
                "subject",
                "subject_exact",
                "description",
                "body",
                "comment",
                "comment_exact",
                "updated",
                "solved",
                "due",
                "brand",
                "satisfaction",
                "ticket_form",
                "group",
                "sort_by",
                "sort_order",
                "external_id",
                "include",
            ],
        },
        "get_tickets**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "label": "Date Range",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "label": "Exact date",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        assignee: str = "",
        body: str = "",
        brand: str = "",
        comment: str = "",
        comment_exact: str = "",
        description: str = "",
        due: str = "",
        exact_date: Any = {"start": "", "end": ""},
        external_id: str = "",
        group: str = "",
        include: str = "",
        num_messages: int = 10,
        organization: str = "",
        priority: str = "",
        public: bool = False,
        requester: str = "",
        requester_email: str = "",
        requester_name: str = "",
        satisfaction: str = "",
        solved: str = "",
        sort_by: str = "",
        sort_order: str = "",
        status: str = "",
        subject: str = "",
        subject_exact: str = "",
        ticket_body: str = "",
        ticket_form: str = "",
        ticket_id: str = "",
        ticket_priority: str = "",
        ticket_status: str = "",
        ticket_subject: str = "",
        ticket_type: str = "",
        update_ticket_assignee_id: str = "",
        update_ticket_body: str = "",
        update_ticket_subject: str = "",
        updated: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_zendesk",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if ticket_subject is not None:
            self.inputs["ticket_subject"] = ticket_subject
        if ticket_body is not None:
            self.inputs["ticket_body"] = ticket_body
        if requester_email is not None:
            self.inputs["requester_email"] = requester_email
        if requester_name is not None:
            self.inputs["requester_name"] = requester_name
        if ticket_priority is not None:
            self.inputs["ticket_priority"] = ticket_priority
        if ticket_type is not None:
            self.inputs["ticket_type"] = ticket_type
        if ticket_status is not None:
            self.inputs["ticket_status"] = ticket_status
        if ticket_id is not None:
            self.inputs["ticket_id"] = ticket_id
        if update_ticket_subject is not None:
            self.inputs["update_ticket_subject"] = update_ticket_subject
        if update_ticket_body is not None:
            self.inputs["update_ticket_body"] = update_ticket_body
        if update_ticket_assignee_id is not None:
            self.inputs["update_ticket_assignee_id"] = update_ticket_assignee_id
        if public is not None:
            self.inputs["public"] = public
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if assignee is not None:
            self.inputs["assignee"] = assignee
        if requester is not None:
            self.inputs["requester"] = requester
        if organization is not None:
            self.inputs["organization"] = organization
        if priority is not None:
            self.inputs["priority"] = priority
        if status is not None:
            self.inputs["status"] = status
        if subject is not None:
            self.inputs["subject"] = subject
        if subject_exact is not None:
            self.inputs["subject_exact"] = subject_exact
        if description is not None:
            self.inputs["description"] = description
        if body is not None:
            self.inputs["body"] = body
        if comment is not None:
            self.inputs["comment"] = comment
        if comment_exact is not None:
            self.inputs["comment_exact"] = comment_exact
        if updated is not None:
            self.inputs["updated"] = updated
        if solved is not None:
            self.inputs["solved"] = solved
        if due is not None:
            self.inputs["due"] = due
        if brand is not None:
            self.inputs["brand"] = brand
        if satisfaction is not None:
            self.inputs["satisfaction"] = satisfaction
        if ticket_form is not None:
            self.inputs["ticket_form"] = ticket_form
        if group is not None:
            self.inputs["group"] = group
        if sort_by is not None:
            self.inputs["sort_by"] = sort_by
        if sort_order is not None:
            self.inputs["sort_order"] = sort_order
        if external_id is not None:
            self.inputs["external_id"] = external_id
        if include is not None:
            self.inputs["include"] = include
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def created_at(self) -> str:
        """
        Date and time the ticket was created

        Different behavior based on configuration:
          - Date and time the ticket was created (When action = 'read_ticket')
          - Date and time the tickets was created (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("created_at")

    @property
    def ticket_assignee_id(self) -> str:
        """
        ID of ticket assignee

        Different behavior based on configuration:
          - ID of ticket assignee (When action = 'read_ticket')
          - ID of tickets assignee (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_assignee_id")

    @property
    def ticket_attachments(self) -> List[str]:
        """
        Attachments of the ticket

        Different behavior based on configuration:
          - Attachments of the ticket (When action = 'read_ticket', When action = 'read_ticket_comments')
          - Attachments of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_attachments")

    @property
    def ticket_body(self) -> List[str]:
        """
        Body of the ticket

        Different behavior based on configuration:
          - Body of the ticket (When action = 'read_ticket')
          - Body of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_body")

    @property
    def ticket_comments(self) -> List[str]:
        """
        Ticket comments in JSON format

        Available: When action = 'read_ticket_comments'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_comments")

    @property
    def ticket_details(self) -> str:
        """
        Ticket details in JSON format

        Different behavior based on configuration:
          - Ticket details in JSON format (When action = 'create_ticket', When action = 'update_ticket', When action = 'create_comment', When action = 'read_ticket', When action = 'read_ticket_comments')
          - Tickets details in JSON format (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_details")

    @property
    def ticket_id(self) -> str:
        """
        Ticket ID of the created ticket

        Different behavior based on configuration:
          - Ticket ID of the created ticket (When action = 'create_ticket')
          - ID of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_id")

    @property
    def ticket_priority(self) -> str:
        """
        Priority of the ticket

        Different behavior based on configuration:
          - Priority of the ticket (When action = 'read_ticket')
          - Priority of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_priority")

    @property
    def ticket_requester_id(self) -> str:
        """
        ID of ticket requester

        Different behavior based on configuration:
          - ID of ticket requester (When action = 'read_ticket')
          - ID of tickets requester (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_requester_id")

    @property
    def ticket_status(self) -> str:
        """
        Status of the ticket

        Different behavior based on configuration:
          - Status of the ticket (When action = 'read_ticket')
          - Status of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_status")

    @property
    def ticket_subject(self) -> str:
        """
        Subject of the ticket

        Different behavior based on configuration:
          - Subject of the ticket (When action = 'read_ticket')
          - Subject of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_subject")

    @property
    def ticket_type(self) -> str:
        """
        Type of the ticket

        Different behavior based on configuration:
          - Type of the ticket (When action = 'read_ticket')
          - Type of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_type")

    @property
    def ticket_url(self) -> str:
        """
        URL of the ticket

        Different behavior based on configuration:
          - URL of the ticket (When action = 'read_ticket')
          - URL of the tickets (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("ticket_url")

    @property
    def updated_at(self) -> str:
        """
        Date and time the ticket was last updated

        Different behavior based on configuration:
          - Date and time the ticket was last updated (When action = 'read_ticket')
          - Date and time the tickets was last updated (When action = 'get_tickets')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("updated_at")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationZendeskNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_teams")
class IntegrationTeamsNode(Node):
    """
    Teams

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### send_message
        channel_name: The name of the channel in the specified team
        message: The message you want to send
        team_name: The name of the team

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Teams>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "send_message": {
            "inputs": [
                {
                    "field": "team_name",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the team",
                    "agent_field_type": "static",
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "value": "",
                    "label": "Channel",
                    "placeholder": "General",
                    "helper_text": "The name of the channel in the specified team",
                    "agent_field_type": "static",
                },
                {
                    "field": "message",
                    "type": "string",
                    "value": "",
                    "label": "Message",
                    "placeholder": "Hello World!",
                    "helper_text": "The message you want to send",
                },
            ],
            "outputs": [],
            "name": "send_message",
            "task_name": "teams.create_message",
            "description": "Post a new message to a specific teams channel",
            "label": "Send Message",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        channel_name: str = "",
        message: str = "",
        team_name: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_teams",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if team_name is not None:
            self.inputs["team_name"] = team_name
        if channel_name is not None:
            self.inputs["channel_name"] = channel_name
        if message is not None:
            self.inputs["message"] = message
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationTeamsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_x")
class IntegrationXNode(Node):
    """
    X

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_post
        text: The text of the post
    ### create_thread
        text: The text of the post

    ## Outputs
    ### create_post
        post_url: URL of the created post
    ### create_thread
        post_url: URL of the created thread
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<X>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "create_post": {
            "inputs": [
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Text",
                    "placeholder": "Hello World!",
                    "helper_text": "The text of the post",
                }
            ],
            "outputs": [
                {
                    "field": "post_url",
                    "type": "string",
                    "helper_text": "URL of the created post",
                }
            ],
            "name": "create_post",
            "task_name": "tasks.x.create_post",
            "description": "Create a new post on X",
            "label": "Create Post",
        },
        "create_thread": {
            "inputs": [
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Text",
                    "placeholder": '["Post1", "Post2", "Post3"]',
                    "helper_text": "A list of text to be posted as a thread",
                }
            ],
            "outputs": [
                {
                    "field": "post_url",
                    "type": "string",
                    "helper_text": "URL of the created thread",
                }
            ],
            "name": "create_thread",
            "task_name": "tasks.x.create_thread",
            "description": "Create a new thread on X",
            "label": "Create Thread",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        text: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_x",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if text is not None:
            self.inputs["text"] = text
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def post_url(self) -> str:
        """
        URL of the created post

        Different behavior based on configuration:
          - URL of the created post (create_post)
          - URL of the created thread (create_thread)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("post_url")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationXNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_gohighlevel")
class IntegrationGohighlevelNode(Node):
    """
    GoHighLevel

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_opportunity
        contact_name: Name of the existing contact to link to the opportunity. One contact can only be linked to one opportunity.
        name: Name of the opportunity
        pipeline_name: Name of the existing pipeline to link to the opportunity
        status: Status of the opportunity (must be one of: 'open', 'won', 'lost', 'abandoned')
        value: Money value of the opportunity
    ### create_contact
        email: Email address of the contact
        first_name: First name of the contact
        last_name: Last name of the contact
        phone: Phone number of the contact

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<GoHighLevel>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "create_contact": {
            "inputs": [
                {
                    "field": "first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "John",
                    "helper_text": "First name of the contact",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Doe",
                    "helper_text": "Last name of the contact",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@doe.com",
                    "helper_text": "Email address of the contact",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "value": "",
                    "label": "Phone",
                    "placeholder": "+1 888-888-8888",
                    "helper_text": "Phone number of the contact",
                },
            ],
            "outputs": [],
            "name": "create_contact",
            "task_name": "tasks.gohighlevel.create_contact",
            "description": "Create a new contact on GoHighLevel",
            "label": "Create Contact",
        },
        "create_opportunity": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name",
                    "placeholder": "First op",
                    "helper_text": "Name of the opportunity",
                },
                {
                    "field": "status",
                    "type": "string",
                    "value": "",
                    "label": "Status",
                    "placeholder": "open",
                    "helper_text": "Status of the opportunity (must be one of: 'open', 'won', 'lost', 'abandoned')",
                },
                {
                    "field": "value",
                    "type": "string",
                    "value": "",
                    "label": "Value",
                    "placeholder": "500",
                    "helper_text": "Money value of the opportunity",
                },
                {
                    "field": "pipeline_name",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline Name",
                    "placeholder": "onboarding",
                    "helper_text": "Name of the existing pipeline to link to the opportunity",
                },
                {
                    "field": "contact_name",
                    "type": "string",
                    "value": "",
                    "label": "Contact Name",
                    "placeholder": "John",
                    "helper_text": "Name of the existing contact to link to the opportunity. One contact can only be linked to one opportunity.",
                },
            ],
            "outputs": [],
            "name": "create_opportunity",
            "task_name": "tasks.gohighlevel.create_opportunity",
            "description": "Create a new opportunity on GoHighLevel",
            "label": "Create Opportunity",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        contact_name: str = "",
        email: str = "",
        first_name: str = "",
        last_name: str = "",
        name: str = "",
        phone: str = "",
        pipeline_name: str = "",
        status: str = "",
        value: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_gohighlevel",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if first_name is not None:
            self.inputs["first_name"] = first_name
        if last_name is not None:
            self.inputs["last_name"] = last_name
        if email is not None:
            self.inputs["email"] = email
        if phone is not None:
            self.inputs["phone"] = phone
        if name is not None:
            self.inputs["name"] = name
        if status is not None:
            self.inputs["status"] = status
        if value is not None:
            self.inputs["value"] = value
        if pipeline_name is not None:
            self.inputs["pipeline_name"] = pipeline_name
        if contact_name is not None:
            self.inputs["contact_name"] = contact_name
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGohighlevelNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_peopledatalabs")
class IntegrationPeopledatalabsNode(Node):
    """
    PeopleDataLabs

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### enrich_person
        company: The name, website, or social URL of a company where the person has worked
        email: Email address of the person
        first_name: First name of the person
        last_name: Last name of the person
        location: The location where a person lives (can be address, city, country, etc.)
        profile_url: Social media profile URLs for the contact (LinkedIn, Twitter, Facebook, etc.)
    ### search_companies
        company_size_ranges: Comma-separated list of company size ranges. The value should be one of the ones mentioned here: https://docs.peopledatalabs.com/docs/company-sizes
        country: Name of the country
        founded_year_range: A range representing the founding year of the company
        industries: Comma-separated list of industries
        number_of_results: Number of results to return
        tags: Comma-separated tags associated with the company
    ### search_people
        country: Name of the country
        job_company_names: Comma-separated list of company names to search within
        job_titles: Comma-separated list of job titles
        number_of_results: Number of results to return
        skills: Comma-separated list of skills to search for
    ### search_people_query
        es_query: A valid Elasticsearch query. Available Fields: https://docs.peopledatalabs.com/docs/elasticsearch-mapping
        number_of_results: Number of results to return
        sql: A valid SQL query
    ### search_companies_query
        es_query: A valid Elasticsearch query. Available Fields: https://docs.peopledatalabs.com/docs/elasticsearch-mapping
        number_of_results: Number of results to return
        sql: A valid SQL query
    ### enrich_company
        name: The name of the company
        profile: Company social media profile URL
        website: Company website URL

    ## Outputs
    ### enrich_person
        output: Enriched person data including additional information found
    ### search_people
        output: List of matching people profiles
    ### search_people_query
        output: List of matching people profiles
    ### enrich_company
        output: Enriched company data including additional information found
    ### search_companies
        output: List of matching company profiles
    ### search_companies_query
        output: List of matching company profiles
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<PeopleDataLabs>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "enrich_person": {
            "inputs": [
                {
                    "field": "first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "John",
                    "helper_text": "First name of the person",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Doe",
                    "helper_text": "Last name of the person",
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "placeholder": "San Francisco, CA",
                    "helper_text": "The location where a person lives (can be address, city, country, etc.)",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@doe.com",
                    "helper_text": "Email address of the person",
                },
                {
                    "field": "company",
                    "type": "string",
                    "value": "",
                    "label": "Company",
                    "placeholder": "Acme Corp",
                    "helper_text": "The name, website, or social URL of a company where the person has worked",
                },
                {
                    "field": "profile_url",
                    "type": "string",
                    "value": "",
                    "label": "Profile URL",
                    "placeholder": "linkedin.com/in/johnsmith",
                    "helper_text": "Social media profile URLs for the contact (LinkedIn, Twitter, Facebook, etc.)",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Enriched person data including additional information found",
                }
            ],
            "name": "enrich_person",
            "task_name": "tasks.peopledatalabs.enrich_person",
            "description": "Enrich Person",
            "label": "Enrich Person",
        },
        "search_people": {
            "inputs": [
                {
                    "field": "country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "US",
                    "helper_text": "Name of the country",
                },
                {
                    "field": "job_titles",
                    "type": "string",
                    "value": "",
                    "label": "Job Titles",
                    "placeholder": "Software Engineer, Product Manager, CTO",
                    "helper_text": "Comma-separated list of job titles",
                },
                {
                    "field": "job_company_names",
                    "type": "string",
                    "value": "",
                    "label": "Job Company Names",
                    "placeholder": "Google, Microsoft, Apple",
                    "helper_text": "Comma-separated list of company names to search within",
                },
                {
                    "field": "skills",
                    "type": "string",
                    "value": "",
                    "label": "Skills",
                    "placeholder": "Python, Machine Learning, Leadership",
                    "helper_text": "Comma-separated list of skills to search for",
                },
                {
                    "field": "number_of_results",
                    "type": "string",
                    "value": "",
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Number of results to return",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matching people profiles",
                }
            ],
            "name": "search_people",
            "task_name": "tasks.peopledatalabs.search_people",
            "description": "Search People",
            "label": "Search People",
        },
        "search_people_query": {
            "inputs": [
                {
                    "field": "es_query",
                    "type": "string",
                    "value": "",
                    "label": "ES Query",
                    "placeholder": '{"query": {"match_all": {}}}',
                    "helper_text": "A valid Elasticsearch query. Available Fields: https://docs.peopledatalabs.com/docs/elasticsearch-mapping",
                },
                {
                    "field": "sql",
                    "type": "string",
                    "value": "",
                    "label": "SQL",
                    "placeholder": '{"query": {"match": {"job_title": "Software Engineer"}}}',
                    "helper_text": "A valid SQL query",
                },
                {
                    "field": "number_of_results",
                    "type": "string",
                    "value": "",
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Number of results to return",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matching people profiles",
                }
            ],
            "name": "search_people_query",
            "task_name": "tasks.peopledatalabs.search_people_query",
            "description": "Search People (query)",
            "label": "Search People (query)",
        },
        "enrich_company": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name",
                    "placeholder": "Acme Corp",
                    "helper_text": "The name of the company",
                },
                {
                    "field": "profile",
                    "type": "string",
                    "value": "",
                    "label": "Profile",
                    "placeholder": "linkedin.com/company/acme-corp",
                    "helper_text": "Company social media profile URL",
                },
                {
                    "field": "website",
                    "type": "string",
                    "value": "",
                    "label": "Website",
                    "placeholder": "www.acmecorp.com",
                    "helper_text": "Company website URL",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Enriched company data including additional information found",
                }
            ],
            "name": "enrich_company",
            "task_name": "tasks.peopledatalabs.enrich_company",
            "description": "Enrich Company",
            "label": "Enrich Company",
        },
        "search_companies": {
            "inputs": [
                {
                    "field": "tags",
                    "type": "string",
                    "value": "",
                    "label": "Tags",
                    "placeholder": "B2B, SaaS, Fintech",
                    "helper_text": "Comma-separated tags associated with the company",
                },
                {
                    "field": "industries",
                    "type": "string",
                    "value": "",
                    "label": "Industries",
                    "placeholder": "Technology, Healthcare, Finance",
                    "helper_text": "Comma-separated list of industries",
                },
                {
                    "field": "company_size_ranges",
                    "type": "string",
                    "value": "",
                    "label": "Company Size Ranges",
                    "placeholder": "1-10, 11-50, 51-200, 201-500, 501-1000, 1000+",
                    "helper_text": "Comma-separated list of company size ranges. The value should be one of the ones mentioned here: https://docs.peopledatalabs.com/docs/company-sizes",
                },
                {
                    "field": "founded_year_range",
                    "type": "string",
                    "value": "",
                    "label": "Founded Year Range",
                    "placeholder": "2015-2020",
                    "helper_text": "A range representing the founding year of the company",
                },
                {
                    "field": "country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "US",
                    "helper_text": "Name of the country",
                },
                {
                    "field": "number_of_results",
                    "type": "string",
                    "value": "",
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Number of results to return",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matching company profiles",
                }
            ],
            "name": "search_companies",
            "task_name": "tasks.peopledatalabs.search_companies",
            "description": "Search Companies",
            "label": "Search Companies",
        },
        "search_companies_query": {
            "inputs": [
                {
                    "field": "es_query",
                    "type": "string",
                    "value": "",
                    "label": "Elastic Search Query",
                    "placeholder": '{"query": {"match_all": {}}}',
                    "helper_text": "A valid Elasticsearch query. Available fields: https://docs.peopledatalabs.com/docs/elasticsearch-mapping-company",
                },
                {
                    "field": "sql",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "SELECT * FROM companies WHERE industry = 'Technology'",
                    "helper_text": "A valid SQL Query. Available fields: https://docs.peopledatalabs.com/docs/company-schema",
                },
                {
                    "field": "number_of_results",
                    "type": "int32",
                    "value": 10,
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Number of results to display",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matching company profiles",
                }
            ],
            "name": "search_companies_query",
            "task_name": "tasks.peopledatalabs.search_companies_query",
            "description": "Search Companies (query)",
            "label": "Search Companies (query)",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        company: str = "",
        company_size_ranges: str = "",
        country: str = "",
        email: str = "",
        es_query: str = "",
        first_name: str = "",
        founded_year_range: str = "",
        industries: str = "",
        job_company_names: str = "",
        job_titles: str = "",
        last_name: str = "",
        location: str = "",
        name: str = "",
        number_of_results: str = "",
        profile: str = "",
        profile_url: str = "",
        skills: str = "",
        sql: str = "",
        tags: str = "",
        website: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_peopledatalabs",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if first_name is not None:
            self.inputs["first_name"] = first_name
        if last_name is not None:
            self.inputs["last_name"] = last_name
        if location is not None:
            self.inputs["location"] = location
        if email is not None:
            self.inputs["email"] = email
        if company is not None:
            self.inputs["company"] = company
        if profile_url is not None:
            self.inputs["profile_url"] = profile_url
        if country is not None:
            self.inputs["country"] = country
        if job_titles is not None:
            self.inputs["job_titles"] = job_titles
        if job_company_names is not None:
            self.inputs["job_company_names"] = job_company_names
        if skills is not None:
            self.inputs["skills"] = skills
        if number_of_results is not None:
            self.inputs["number_of_results"] = number_of_results
        if es_query is not None:
            self.inputs["es_query"] = es_query
        if sql is not None:
            self.inputs["sql"] = sql
        if name is not None:
            self.inputs["name"] = name
        if profile is not None:
            self.inputs["profile"] = profile
        if website is not None:
            self.inputs["website"] = website
        if tags is not None:
            self.inputs["tags"] = tags
        if industries is not None:
            self.inputs["industries"] = industries
        if company_size_ranges is not None:
            self.inputs["company_size_ranges"] = company_size_ranges
        if founded_year_range is not None:
            self.inputs["founded_year_range"] = founded_year_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Enriched person data including additional information found

        Different behavior based on configuration:
          - Enriched person data including additional information found (enrich_person)
          - List of matching people profiles (search_people, search_people_query)
          - Enriched company data including additional information found (enrich_company)
          - List of matching company profiles (search_companies, search_companies_query)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationPeopledatalabsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_hubspot")
class IntegrationHubspotNode(Node):
    """
    Hubspot

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_deal
        amount: Deal amount
        associated_object_id: The ID of the associated object
        associated_object_type: The type of the associated object
        closedate: Expected close date
        dealname: Name of the deal
        dealstage: Stage of the deal
        item_type: The item_type input
        pipeline: Deal pipeline
    ### create_company
        associated_object_id: The ID of the associated object
        associated_object_type: The type of the associated object
        city: Company city location
        domain: The domain of the company
        industry: Company industry
        item_type: The item_type input
        name: The name of the company
        phone: Company phone number'
        state: Company state location
    ### create_contact
        associated_object_id: The ID of the associated object
        associated_object_type: The type of the associated object
        company: Contact company name
        email: Contact email address
        firstname: Contact first name
        item_type: The item_type input
        lastname: Contact last name
        phone: Company phone number'
        website: Contact website
    ### create_ticket
        associated_object_id: The ID of the associated object
        associated_object_type: The type of the associated object
        hs_pipeline: Ticket pipeline
        hs_pipeline_stage: Stage in the pipeline
        hs_ticket_priority: Ticket priority level
        item_type: The item_type input
        subject: Ticket subject
    ### create_note
        associated_object_id: The ID of the associated object
        associated_object_type: The type of the associated object
        body: Content of the note
        item_type: The item_type input
    ### create_call
        associated_object_id: The ID of the associated object
        associated_object_type: The type of the associated object
        body: Content of the note
        duration: Call duration in seconds
        from_number: Caller phone number
        item_type: The item_type input
        title: Title of the call
        to_number: Recipient phone number
    ### create_task
        associated_object_id: The ID of the associated object
        associated_object_type: The type of the associated object
        body: Content of the note
        item_type: The item_type input
        priority: Task priority level
        status: Current status of the task
        subject: Ticket subject
    ### create_meeting
        associated_object_id: The ID of the associated object
        associated_object_type: The type of the associated object
        body: Content of the note
        end_time: Meeting end time
        item_type: The item_type input
        meeting_notes: Notes from the meeting
        start_time: Meeting start time
        title: Title of the call
    ### create_email
        associated_object_id: The ID of the associated object
        associated_object_type: The type of the associated object
        direction: Direction of the email (INCOMING/OUTGOING)
        item_type: The item_type input
        recipient_email: Email address of the recipient
        sender_email: Email address of the sender
        subject: Ticket subject
        text: Email body content
    ### fetch_contacts
        item_type: The item_type input
        query: Valid Hubspot Search Query - See API docs for format
    ### fetch_companies
        item_type: The item_type input
        query: Valid Hubspot Search Query - See API docs for format
    ### fetch_deals
        item_type: The item_type input
        query: Valid Hubspot Search Query - See API docs for format
    ### fetch_tickets
        item_type: The item_type input
        query: Valid Hubspot Search Query - See API docs for format
    ### fetch_notes
        item_type: The item_type input
        query: Valid Hubspot Search Query - See API docs for format
    ### fetch_calls
        item_type: The item_type input
        query: Valid Hubspot Search Query - See API docs for format
    ### fetch_tasks
        item_type: The item_type input
        query: Valid Hubspot Search Query - See API docs for format
    ### fetch_meetings
        item_type: The item_type input
        query: Valid Hubspot Search Query - See API docs for format
    ### fetch_emails
        item_type: The item_type input
        query: Valid Hubspot Search Query - See API docs for format

    ## Outputs
    ### fetch_contacts
        output: List of matched contacts
    ### fetch_companies
        output: List of matched companies
    ### fetch_deals
        output: List of matched deals
    ### fetch_tickets
        output: List of matched tickets
    ### fetch_notes
        output: List of matched notes
    ### fetch_calls
        output: List of matched calls
    ### fetch_tasks
        output: List of matched tasks
    ### fetch_meetings
        output: List of matched meetings
    ### fetch_emails
        output: List of matched emails
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Hubspot>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "fetch_contacts": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query (JSON)",
                    "placeholder": "",
                    "helper_text": "Valid Hubspot Search Query - See API docs for format",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "contact",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matched contacts",
                }
            ],
            "name": "fetch_contacts",
            "task_name": "tasks.hubspot.fetch_items",
            "description": "Fetch contacts from Hubspot CRM",
            "label": "Fetch Contacts",
        },
        "fetch_companies": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query (JSON)",
                    "placeholder": "",
                    "helper_text": "Valid Hubspot Search Query - See API docs for format",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "company",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matched companies",
                }
            ],
            "name": "fetch_companies",
            "task_name": "tasks.hubspot.fetch_items",
            "description": "Fetch companies from Hubspot CRM",
            "label": "Fetch Companies",
        },
        "fetch_deals": {
            "inputs": [
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "deal",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "",
                    "helper_text": "Valid Hubspot Search Query - See API docs for format",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matched deals",
                }
            ],
            "name": "fetch_deals",
            "task_name": "tasks.hubspot.fetch_items",
            "description": "Fetch deals from Hubspot CRM",
            "label": "Fetch Deals",
        },
        "fetch_tickets": {
            "inputs": [
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "ticket",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "",
                    "helper_text": "Valid Hubspot Search Query - See API docs for format",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matched tickets",
                }
            ],
            "name": "fetch_tickets",
            "task_name": "tasks.hubspot.fetch_items",
            "description": "Fetch tickets from Hubspot CRM",
            "label": "Fetch Tickets",
        },
        "fetch_notes": {
            "inputs": [
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "note",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "",
                    "helper_text": "Valid Hubspot Search Query - See API docs for format",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matched notes",
                }
            ],
            "name": "fetch_notes",
            "task_name": "tasks.hubspot.fetch_items",
            "description": "Fetch notes from Hubspot CRM",
            "label": "Fetch Notes",
        },
        "fetch_calls": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "",
                    "helper_text": "Valid Hubspot Search Query - See API docs for format",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "call",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matched calls",
                }
            ],
            "name": "fetch_calls",
            "task_name": "tasks.hubspot.fetch_items",
            "description": "Fetch calls from Hubspot CRM",
            "label": "Fetch Calls",
        },
        "fetch_tasks": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "",
                    "helper_text": "Valid Hubspot Search Query - See API docs for format",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "task",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matched tasks",
                }
            ],
            "name": "fetch_tasks",
            "task_name": "tasks.hubspot.fetch_items",
            "description": "Fetch tasks from Hubspot CRM",
            "label": "Fetch Tasks",
        },
        "fetch_meetings": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "",
                    "helper_text": "Valid Hubspot Search Query - See API docs for format",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "meeting",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matched meetings",
                }
            ],
            "name": "fetch_meetings",
            "task_name": "tasks.hubspot.fetch_items",
            "description": "Fetch meetings from Hubspot CRM",
            "label": "Fetch Meetings",
        },
        "fetch_emails": {
            "inputs": [
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "email",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "",
                    "helper_text": "Valid Hubspot Search Query - See API docs for format",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matched emails",
                }
            ],
            "name": "fetch_emails",
            "task_name": "tasks.hubspot.fetch_items",
            "description": "Fetch emails from Hubspot CRM",
            "label": "Fetch Emails",
        },
        "create_company": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name",
                    "placeholder": "Acme Corp",
                    "helper_text": "The name of the company",
                },
                {
                    "field": "domain",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "placeholder": "acme.com",
                    "helper_text": "The domain of the company",
                },
                {
                    "field": "city",
                    "type": "string",
                    "value": "",
                    "label": "City",
                    "placeholder": "Boston",
                    "helper_text": "Company city location",
                },
                {
                    "field": "industry",
                    "type": "string",
                    "value": "",
                    "label": "Industry",
                    "placeholder": "Technology",
                    "helper_text": "Company industry",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "value": "",
                    "label": "Phone",
                    "placeholder": "123-456-7890",
                    "helper_text": "Company phone number'",
                },
                {
                    "field": "state",
                    "type": "string",
                    "value": "",
                    "label": "State",
                    "placeholder": "MA",
                    "helper_text": "Company state location",
                },
                {
                    "field": "associated_object_id",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object ID",
                    "placeholder": "12345",
                    "helper_text": "The ID of the associated object",
                },
                {
                    "field": "associated_object_type",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object Type",
                    "placeholder": "contact",
                    "helper_text": "The type of the associated object",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "company",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "create_company",
            "task_name": "tasks.hubspot.create_item",
            "description": "Create a new company on Hubspot CRM",
            "label": "Create Company",
        },
        "create_contact": {
            "inputs": [
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@doe.com",
                    "helper_text": "Contact email address",
                },
                {
                    "field": "firstname",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "John",
                    "helper_text": "Contact first name",
                },
                {
                    "field": "lastname",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Doe",
                    "helper_text": "Contact last name",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "value": "",
                    "label": "Phone",
                    "placeholder": "+1-234-567-8900",
                    "helper_text": "Contact phone number",
                },
                {
                    "field": "company",
                    "type": "string",
                    "value": "",
                    "label": "Company",
                    "placeholder": "Acme Corp",
                    "helper_text": "Contact company name",
                },
                {
                    "field": "website",
                    "type": "string",
                    "value": "",
                    "label": "Website",
                    "placeholder": "www.example.com",
                    "helper_text": "Contact website",
                },
                {
                    "field": "associated_object_id",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object ID",
                    "placeholder": "12345",
                    "helper_text": "The ID of the associated object",
                },
                {
                    "field": "associated_object_type",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object Type",
                    "placeholder": "contact",
                    "helper_text": "The type of the associated object",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "contact",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "create_contact",
            "task_name": "tasks.hubspot.create_item",
            "description": "Create a new contact on Hubspot CRM",
            "label": "Create Contact",
        },
        "create_deal": {
            "inputs": [
                {
                    "field": "amount",
                    "type": "string",
                    "value": "",
                    "label": "Amount",
                    "placeholder": "10000",
                    "helper_text": "Deal amount",
                },
                {
                    "field": "closedate",
                    "type": "string",
                    "value": "",
                    "label": "Close Date",
                    "placeholder": "2025-01-01",
                    "helper_text": "Expected close date",
                },
                {
                    "field": "dealname",
                    "type": "string",
                    "value": "",
                    "label": "Deal Name",
                    "placeholder": "Enterprise Solution 2024",
                    "helper_text": "Name of the deal",
                },
                {
                    "field": "pipeline",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline",
                    "placeholder": "default",
                    "helper_text": "Deal pipeline",
                },
                {
                    "field": "dealstage",
                    "type": "string",
                    "value": "",
                    "label": "Deal Stage",
                    "placeholder": "Prospect",
                    "helper_text": "Stage of the deal",
                },
                {
                    "field": "associated_object_id",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object ID",
                    "placeholder": "12345",
                    "helper_text": "The ID of the associated object",
                },
                {
                    "field": "associated_object_type",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object Type",
                    "placeholder": "contact",
                    "helper_text": "The type of the associated object",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "deal",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "create_deal",
            "task_name": "tasks.hubspot.create_item",
            "description": "Create a new deal on Hubspot CRM",
            "label": "Create Deal",
        },
        "create_ticket": {
            "inputs": [
                {
                    "field": "hs_pipeline",
                    "type": "string",
                    "value": "",
                    "label": "HS Pipeline",
                    "placeholder": "support",
                    "helper_text": "Ticket pipeline",
                },
                {
                    "field": "hs_pipeline_stage",
                    "type": "string",
                    "value": "",
                    "label": "HS Pipeline Stage",
                    "placeholder": "new",
                    "helper_text": "Stage in the pipeline",
                },
                {
                    "field": "hs_ticket_priority",
                    "type": "string",
                    "value": "",
                    "label": "HS Ticket Priority",
                    "placeholder": "HIGH",
                    "helper_text": "Ticket priority level",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Technical Support Request",
                    "helper_text": "Ticket subject",
                },
                {
                    "field": "associated_object_id",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object ID",
                    "placeholder": "12345",
                    "helper_text": "ID of associated object",
                },
                {
                    "field": "associated_object_type",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object Type",
                    "placeholder": "CONTACT",
                    "helper_text": "Type of associated object",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "ticket",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "create_ticket",
            "task_name": "tasks.hubspot.create_item",
            "description": "Create a new ticket on Hubspot CRM",
            "label": "Create Ticket",
        },
        "create_note": {
            "inputs": [
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Discussion notes from client meeting",
                    "helper_text": "Content of the note",
                },
                {
                    "field": "associated_object_id",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object ID",
                    "placeholder": "12345",
                    "helper_text": "ID of associated object",
                },
                {
                    "field": "associated_object_type",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object Type",
                    "placeholder": "DEAL",
                    "helper_text": "Type of associated object",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "note",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "create_note",
            "task_name": "tasks.hubspot.create_item",
            "description": "Create a new note on Hubspot CRM",
            "label": "Create Note",
        },
        "create_call": {
            "inputs": [
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Discussed Q4 objectives",
                    "helper_text": "Call notes or summary",
                },
                {
                    "field": "duration",
                    "type": "string",
                    "value": "",
                    "label": "Call Duration",
                    "placeholder": "1800",
                    "helper_text": "Call duration in seconds",
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "label": "Title",
                    "placeholder": "Q4 Planning Call",
                    "helper_text": "Title of the call",
                },
                {
                    "field": "from_number",
                    "type": "string",
                    "value": "",
                    "label": "From Number",
                    "placeholder": "+1-234-567-8900",
                    "helper_text": "Caller phone number",
                },
                {
                    "field": "to_number",
                    "type": "string",
                    "value": "",
                    "label": "To Number",
                    "placeholder": "+1-234-567-8901",
                    "helper_text": "Recipient phone number",
                },
                {
                    "field": "associated_object_id",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object ID",
                    "placeholder": "12345",
                    "helper_text": "ID of associated object",
                },
                {
                    "field": "associated_object_type",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object Type",
                    "placeholder": "CONTACT",
                    "helper_text": "Type of associated object",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "call",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "create_call",
            "task_name": "tasks.hubspot.create_item",
            "description": "Create a new call on Hubspot CRM",
            "label": "Create Call",
        },
        "create_task": {
            "inputs": [
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Follow up on proposal",
                    "helper_text": "Task description",
                },
                {
                    "field": "status",
                    "type": "string",
                    "value": "",
                    "label": "Status",
                    "placeholder": "NOT_STARTED",
                    "helper_text": "Current status of the task",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Send follow-up email",
                    "helper_text": "Subject of the task",
                },
                {
                    "field": "priority",
                    "type": "string",
                    "value": "",
                    "label": "Priority",
                    "placeholder": "HIGH",
                    "helper_text": "Task priority level",
                },
                {
                    "field": "associated_object_id",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object ID",
                    "placeholder": "12345",
                    "helper_text": "ID of associated object",
                },
                {
                    "field": "associated_object_type",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object Type",
                    "placeholder": "DEAL",
                    "helper_text": "Type of associated object",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "task",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "create_task",
            "task_name": "tasks.hubspot.create_item",
            "description": "Create a new task on Hubspot CRM",
            "label": "Create Task",
        },
        "create_meeting": {
            "inputs": [
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Monthly review meeting",
                    "helper_text": "Meeting description",
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "label": "Title",
                    "placeholder": "Monthly Review - January 2024",
                    "helper_text": "Title of the meeting",
                },
                {
                    "field": "start_time",
                    "type": "string",
                    "value": "",
                    "label": "Start Time",
                    "placeholder": "2024-01-15T10:00:00Z",
                    "helper_text": "Meeting start time",
                },
                {
                    "field": "end_time",
                    "type": "string",
                    "value": "",
                    "label": "End Time",
                    "placeholder": "2024-01-15T11:00:00Z",
                    "helper_text": "Meeting end time",
                },
                {
                    "field": "meeting_notes",
                    "type": "string",
                    "value": "",
                    "label": "Meeting Notes",
                    "placeholder": "Discussion points and action items",
                    "helper_text": "Notes from the meeting",
                },
                {
                    "field": "associated_object_id",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object ID",
                    "placeholder": "12345",
                    "helper_text": "ID of associated object",
                },
                {
                    "field": "associated_object_type",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object Type",
                    "placeholder": "COMPANY",
                    "helper_text": "Type of associated object",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "meeting",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "create_meeting",
            "task_name": "tasks.hubspot.create_item",
            "description": "Create a new meeting on Hubspot CRM",
            "label": "Create Meeting",
        },
        "create_email": {
            "inputs": [
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Text",
                    "placeholder": "valued customer...",
                    "helper_text": "Email body content",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Follow-up from our meeting",
                    "helper_text": "Email subject line",
                },
                {
                    "field": "recipient_email",
                    "type": "string",
                    "value": "",
                    "label": "Recipient Email",
                    "placeholder": "contact@company.com",
                    "helper_text": "Email address of the recipient",
                },
                {
                    "field": "sender_email",
                    "type": "string",
                    "value": "",
                    "label": "Sender Email",
                    "placeholder": "sales@ourcompany.com",
                    "helper_text": "Email address of the sender",
                },
                {
                    "field": "direction",
                    "type": "string",
                    "value": "",
                    "label": "Direction",
                    "placeholder": "OUTGOING",
                    "helper_text": "Direction of the email (INCOMING/OUTGOING)",
                },
                {
                    "field": "associated_object_id",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object ID",
                    "placeholder": "12345",
                    "helper_text": "ID of associated object",
                },
                {
                    "field": "associated_object_type",
                    "type": "string",
                    "value": "",
                    "label": "Associated Object Type",
                    "placeholder": "CONTACT",
                    "helper_text": "Type of associated object",
                },
                {
                    "field": "item_type",
                    "type": "string",
                    "value": "email",
                    "label": "",
                    "placeholder": "",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "create_email",
            "task_name": "tasks.hubspot.create_item",
            "description": "Create a new email on Hubspot CRM",
            "label": "Create Email",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        amount: str = "",
        associated_object_id: str = "",
        associated_object_type: str = "",
        body: str = "",
        city: str = "",
        closedate: str = "",
        company: str = "",
        dealname: str = "",
        dealstage: str = "",
        direction: str = "",
        domain: str = "",
        duration: str = "",
        email: str = "",
        end_time: str = "",
        firstname: str = "",
        from_number: str = "",
        hs_pipeline: str = "",
        hs_pipeline_stage: str = "",
        hs_ticket_priority: str = "",
        industry: str = "",
        item_type: str = "contact",
        lastname: str = "",
        meeting_notes: str = "",
        name: str = "",
        phone: str = "",
        pipeline: str = "",
        priority: str = "",
        query: str = "",
        recipient_email: str = "",
        sender_email: str = "",
        start_time: str = "",
        state: str = "",
        status: str = "",
        subject: str = "",
        text: str = "",
        title: str = "",
        to_number: str = "",
        website: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_hubspot",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if item_type is not None:
            self.inputs["item_type"] = item_type
        if name is not None:
            self.inputs["name"] = name
        if domain is not None:
            self.inputs["domain"] = domain
        if city is not None:
            self.inputs["city"] = city
        if industry is not None:
            self.inputs["industry"] = industry
        if phone is not None:
            self.inputs["phone"] = phone
        if state is not None:
            self.inputs["state"] = state
        if associated_object_id is not None:
            self.inputs["associated_object_id"] = associated_object_id
        if associated_object_type is not None:
            self.inputs["associated_object_type"] = associated_object_type
        if email is not None:
            self.inputs["email"] = email
        if firstname is not None:
            self.inputs["firstname"] = firstname
        if lastname is not None:
            self.inputs["lastname"] = lastname
        if company is not None:
            self.inputs["company"] = company
        if website is not None:
            self.inputs["website"] = website
        if amount is not None:
            self.inputs["amount"] = amount
        if closedate is not None:
            self.inputs["closedate"] = closedate
        if dealname is not None:
            self.inputs["dealname"] = dealname
        if pipeline is not None:
            self.inputs["pipeline"] = pipeline
        if dealstage is not None:
            self.inputs["dealstage"] = dealstage
        if hs_pipeline is not None:
            self.inputs["hs_pipeline"] = hs_pipeline
        if hs_pipeline_stage is not None:
            self.inputs["hs_pipeline_stage"] = hs_pipeline_stage
        if hs_ticket_priority is not None:
            self.inputs["hs_ticket_priority"] = hs_ticket_priority
        if subject is not None:
            self.inputs["subject"] = subject
        if body is not None:
            self.inputs["body"] = body
        if duration is not None:
            self.inputs["duration"] = duration
        if title is not None:
            self.inputs["title"] = title
        if from_number is not None:
            self.inputs["from_number"] = from_number
        if to_number is not None:
            self.inputs["to_number"] = to_number
        if status is not None:
            self.inputs["status"] = status
        if priority is not None:
            self.inputs["priority"] = priority
        if start_time is not None:
            self.inputs["start_time"] = start_time
        if end_time is not None:
            self.inputs["end_time"] = end_time
        if meeting_notes is not None:
            self.inputs["meeting_notes"] = meeting_notes
        if text is not None:
            self.inputs["text"] = text
        if recipient_email is not None:
            self.inputs["recipient_email"] = recipient_email
        if sender_email is not None:
            self.inputs["sender_email"] = sender_email
        if direction is not None:
            self.inputs["direction"] = direction
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        List of matched contacts

        Different behavior based on configuration:
          - List of matched contacts (fetch_contacts)
          - List of matched companies (fetch_companies)
          - List of matched deals (fetch_deals)
          - List of matched tickets (fetch_tickets)
          - List of matched notes (fetch_notes)
          - List of matched calls (fetch_calls)
          - List of matched tasks (fetch_tasks)
          - List of matched meetings (fetch_meetings)
          - List of matched emails (fetch_emails)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationHubspotNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_snowflake")
class IntegrationSnowflakeNode(Node):
    """
    Snowflake

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### nl
        database: Select the Database on which to perform the query
        query: SQL Query to execute
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        schema: Select the schema to be used in the query
        sql_generation_model: The sql_generation_model input
        warehouse: Select the SQL Warehouse which will perform the operation
    ### raw_sql
        database: Select the Database on which to perform the query
        query: SQL Query to execute
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        schema: Select the schema to be used in the query
        sql_generation_model: The sql_generation_model input
        warehouse: Select the SQL Warehouse which will perform the operation
    ### nl_agent
        database: Select the Database on which to perform the query
        query: SQL Query to execute
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        schema: Select the schema to be used in the query
        sql_generation_model: The sql_generation_model input
        warehouse: Select the SQL Warehouse which will perform the operation

    ## Outputs
    ### Common Outputs
        output: Output of the query as Markdown table
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Snowflake>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "Output of the query as Markdown table"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "nl": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "warehouse",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Warehouse",
                    "helper_text": "Select the SQL Warehouse which will perform the operation",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=warehouse&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "database",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Database",
                    "helper_text": "Select the Database on which to perform the query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "schema",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Schema",
                    "helper_text": "Select the schema to be used in the query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=schema&database={inputs.database}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl",
            "task_name": "tasks.tables.integrations.snowflake.query",
            "description": "Generate and execute a SQL query",
            "label": "Natural Language Query",
        },
        "raw_sql": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "warehouse",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Warehouse",
                    "helper_text": "Select the SQL Warehouse which will perform the operation",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=warehouse&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "database",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Database",
                    "helper_text": "Select the Database on which to perform the query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "schema",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Schema",
                    "helper_text": "Select the schema to be used in the query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=schema&database={inputs.database}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "raw_sql",
            "task_name": "tasks.tables.integrations.snowflake.query",
            "description": "Execute a SQL query",
            "label": "Raw SQL Query",
        },
        "nl_agent": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "warehouse",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Warehouse",
                    "helper_text": "Select the SQL Warehouse which will perform the operation",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=warehouse&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "database",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Database",
                    "helper_text": "Select the Database on which to perform the query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "schema",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Schema",
                    "helper_text": "Select the schema to be used in the query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=schema&database={inputs.database}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl_agent",
            "task_name": "tasks.tables.integrations.snowflake.query",
            "description": "Let an LLM agent query the database",
            "label": "Natural Language Agent",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        database: str = "",
        query: str = "",
        query_agent_model: str = "gpt-4-turbo-preview",
        query_type: str = "Raw SQL",
        schema: str = "",
        sql_generation_model: str = "gpt-4-turbo-preview",
        warehouse: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_snowflake",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if query_type is not None:
            self.inputs["query_type"] = query_type
        if warehouse is not None:
            self.inputs["warehouse"] = warehouse
        if database is not None:
            self.inputs["database"] = database
        if schema is not None:
            self.inputs["schema"] = schema
        if sql_generation_model is not None:
            self.inputs["sql_generation_model"] = sql_generation_model
        if query_agent_model is not None:
            self.inputs["query_agent_model"] = query_agent_model
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> Any:
        """
        Output of the query as Markdown table


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationSnowflakeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_elasticsearch")
class IntegrationElasticsearchNode(Node):
    """
    Elasticsearch

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### search_index
        index: Elasticsearch index name
        query: Query to search over index in JSON format

    ## Outputs
    ### search_index
        output: Search results from the Elasticsearch index
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Elasticsearch>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "search_index": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "JSON Query",
                    "placeholder": '{"query_string": {"query": "mountain*", "fields": ["title", "description"]}}',
                    "helper_text": "Query to search over index in JSON format",
                },
                {
                    "field": "index",
                    "type": "string",
                    "value": "",
                    "label": "Index",
                    "placeholder": "my-index",
                    "helper_text": "Elasticsearch index name",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Search results from the Elasticsearch index",
                }
            ],
            "name": "search_index",
            "task_name": "tasks.elasticsearch.search_index",
            "description": "Query your Elasticsearch index",
            "label": "Search Elasticsearch index",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        index: str = "",
        query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_elasticsearch",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if index is not None:
            self.inputs["index"] = index
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Search results from the Elasticsearch index

        Available: search_index


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationElasticsearchNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_mongodb")
class IntegrationMongodbNode(Node):
    """
    MongoDB

    ## Inputs
    ### Common Inputs
        action: The action input
        integration: Connect to your account
    ### find
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records
    ### find_one
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records
    ### aggregate
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records
    ### mongodb_nl
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records
    ### mongodb_nl_aggregation
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records

    ## Outputs
    ### Common Outputs
        output: Results of the Query. Example: {“name”: “John”, “age”: 29, “height”: 185}
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "The action input",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<MongoDB>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "output",
            "helper_text": "Results of the Query. Example: {“name”: “John”, “age”: 29, “height”: 185}",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "find": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "find",
            "task_name": "tasks.document_dbs.mongo.query",
            "description": "Query MongoDB data",
            "label": "MongoDB Find",
        },
        "find_one": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "find_one",
            "task_name": "tasks.document_dbs.mongo.query",
            "description": "Query MongoDB data",
            "label": "MongoDB Find One",
        },
        "aggregate": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "aggregate",
            "task_name": "tasks.document_dbs.mongo.query",
            "description": "Run an Aggegation on MongoDB data",
            "label": "MongoDB Aggegate",
        },
        "mongodb_nl": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "mongodb_nl",
            "task_name": "tasks.document_dbs.mongo.query",
            "description": "Query MongoDB data with Natural Language",
            "label": "NL Query",
        },
        "mongodb_nl_aggregation": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "mongodb_nl_aggregation",
            "task_name": "tasks.document_dbs.mongo.query",
            "description": "Aggregate MongoDB data with Natural Language",
            "label": "NL Aggregation",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        collection: str = "",
        query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_mongodb",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if collection is not None:
            self.inputs["collection"] = collection
        if query is not None:
            self.inputs["query"] = query
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Results of the Query. Example: {“name”: “John”, “age”: 29, “height”: 185}


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMongodbNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_pinecone")
class IntegrationPineconeNode(Node):
    """
    Pinecone

    ## Inputs
    ### Common Inputs
        action: The action input
        integration: Connect to your account
    ### query_pinecone
        embedding_model: Select the embedding model to use to embed the query
        index: The Pinecone index to query
        namespace: Select the namespace to query (queries across all namespaces if left empty)
        query: Natural Language query

    ## Outputs
    ### query_pinecone
        output: Query output in Langchain-style documents
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "The action input",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Pinecone>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "query_pinecone": {
            "inputs": [
                {
                    "field": "embedding_model",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Embedding Model",
                    "helper_text": "Select the embedding model to use to embed the query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {
                                "label": "OpenAI Text Embedding 3 Small",
                                "value": "openai/text-embedding-3-small",
                            },
                            {
                                "label": "OpenAI Text Embedding 3 Large",
                                "value": "openai/text-embedding-3-large",
                            },
                            {
                                "label": "OpenAI Text Embedding Ada 002",
                                "value": "openai/text-embedding-ada-002",
                            },
                            {
                                "label": "Cohere Embed English v3.0",
                                "value": "cohere/embed-english-v3.0",
                            },
                            {
                                "label": "Cohere Embed Multilingual v3.0",
                                "value": "cohere/embed-multilingual-v3.0",
                            },
                            {
                                "label": "Cohere Embed English Light v3.0",
                                "value": "cohere/embed-english-light-v3.0",
                            },
                            {
                                "label": "Cohere Embed Multilingual Light v3.0",
                                "value": "cohere/embed-multilingual-light-v3.0",
                            },
                        ],
                    },
                },
                {
                    "field": "index",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Index",
                    "helper_text": "The Pinecone index to query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=index&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "namespace",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Namespace",
                    "helper_text": "Select the namespace to query (queries across all namespaces if left empty)",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=namespace&index={inputs.index}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "“Birthday parties in March”",
                    "helper_text": "Natural Language query",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "any",
                    "helper_text": "Query output in Langchain-style documents",
                }
            ],
            "name": "query_pinecone",
            "task_name": "tasks.vectordbs.integrations.pinecone.query",
            "description": "Query Pinecone data",
            "label": "Query Pinecone",
            "variant": "common_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        embedding_model: str = "",
        index: str = "",
        namespace: str = "",
        query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_pinecone",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if embedding_model is not None:
            self.inputs["embedding_model"] = embedding_model
        if index is not None:
            self.inputs["index"] = index
        if namespace is not None:
            self.inputs["namespace"] = namespace
        if query is not None:
            self.inputs["query"] = query
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> Any:
        """
        Query output in Langchain-style documents

        Available: query_pinecone


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationPineconeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_postgres")
class IntegrationPostgresNode(Node):
    """
    Postgres

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### nl
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input
    ### raw_sql
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input
    ### nl_agent
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input

    ## Outputs
    ### Common Outputs
        output: Query results in Markdown format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Postgres>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "Query results in Markdown format"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "nl": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "Natural language query to be converted to SQL",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl",
            "task_name": "tasks.tables.integrations.postgres.query",
            "description": "Generate and execute a SQL query",
            "label": "Natural Language Query",
        },
        "raw_sql": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "raw_sql",
            "task_name": "tasks.tables.integrations.postgres.query",
            "description": "Execute a SQL query",
            "label": "Raw SQL Query",
        },
        "nl_agent": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "Natural language query for the LLM agent to process",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl_agent",
            "task_name": "tasks.tables.integrations.postgres.query",
            "description": "Let an LLM agent query the database",
            "label": "Natural Language Agent",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        query: str = "",
        query_agent_model: str = "gpt-4-turbo-preview",
        query_type: str = "Raw SQL",
        sql_generation_model: str = "gpt-4-turbo-preview",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_postgres",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if query_type is not None:
            self.inputs["query_type"] = query_type
        if sql_generation_model is not None:
            self.inputs["sql_generation_model"] = sql_generation_model
        if query_agent_model is not None:
            self.inputs["query_agent_model"] = query_agent_model
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Query results in Markdown format


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationPostgresNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_mysql")
class IntegrationMysqlNode(Node):
    """
    MySQL

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### nl
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input
    ### raw_sql
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input
    ### nl_agent
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input

    ## Outputs
    ### Common Outputs
        output: Query results in Markdown table format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<MySQL>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "Query results in Markdown table format"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "nl": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "Natural language query to be converted to SQL",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl",
            "task_name": "tasks.tables.integrations.mysql.query",
            "description": "Generate and execute a SQL query",
            "label": "Natural Language Query",
        },
        "raw_sql": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "raw_sql",
            "task_name": "tasks.tables.integrations.mysql.query",
            "description": "Execute a SQL query",
            "label": "Raw SQL Query",
        },
        "nl_agent": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "Natural language query for the LLM agent to process",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl_agent",
            "task_name": "tasks.tables.integrations.mysql.query",
            "description": "Let an LLM agent query the database",
            "label": "Natural Language Agent",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        query: str = "",
        query_agent_model: str = "gpt-4-turbo-preview",
        query_type: str = "Raw SQL",
        sql_generation_model: str = "gpt-4-turbo-preview",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_mysql",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if query_type is not None:
            self.inputs["query_type"] = query_type
        if sql_generation_model is not None:
            self.inputs["sql_generation_model"] = sql_generation_model
        if query_agent_model is not None:
            self.inputs["query_agent_model"] = query_agent_model
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Query results in Markdown table format


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMysqlNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_wordpress")
class IntegrationWordpressNode(Node):
    """
    Wordpress

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_post
        post_content: The content of the post
        post_title: The title of the post
        wordpress_url: Wordpress domain URL

    ## Outputs
    ### create_post
        post_url: URL of the created WordPress post
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Wordpress>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "create_post": {
            "inputs": [
                {
                    "field": "wordpress_url",
                    "type": "string",
                    "value": "",
                    "label": "Wordpress URL",
                    "placeholder": "test.wordpress.com",
                    "helper_text": "Wordpress domain URL",
                    "agent_field_type": "static",
                },
                {
                    "field": "post_title",
                    "type": "string",
                    "value": "",
                    "label": "Post Title",
                    "placeholder": "An overview of Generative AI",
                    "helper_text": "The title of the post",
                },
                {
                    "field": "post_content",
                    "type": "string",
                    "value": "",
                    "label": "Post Content",
                    "placeholder": "This is an overview...",
                    "helper_text": "The content of the post",
                },
            ],
            "outputs": [
                {
                    "field": "post_url",
                    "type": "string",
                    "helper_text": "URL of the created WordPress post",
                }
            ],
            "name": "create_post",
            "task_name": "tasks.wordpress.create_post",
            "description": "Create post on Wordpress site",
            "label": "Post to Wordpress",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        post_content: str = "",
        post_title: str = "",
        wordpress_url: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_wordpress",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if wordpress_url is not None:
            self.inputs["wordpress_url"] = wordpress_url
        if post_title is not None:
            self.inputs["post_title"] = post_title
        if post_content is not None:
            self.inputs["post_content"] = post_content
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def post_url(self) -> str:
        """
        URL of the created WordPress post

        Available: create_post


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("post_url")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationWordpressNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_linkedin")
class IntegrationLinkedinNode(Node):
    """
    Linkedin

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_text_share
        post_text: Content you wanted to post on your LinkedIn

    ## Outputs
    ### create_text_share
        output: URL of the created LinkedIn post
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Linkedin>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "create_text_share": {
            "inputs": [
                {
                    "field": "post_text",
                    "type": "string",
                    "value": "",
                    "label": "Post Text",
                    "placeholder": "“I just got a new job!”",
                    "helper_text": "Content you wanted to post on your LinkedIn",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "URL of the created LinkedIn post",
                }
            ],
            "name": "create_text_share",
            "task_name": "tasks.linkedin.create_text_share",
            "description": "Create text post on LinkedIn",
            "label": "Post to LinkedIn",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        post_text: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_linkedin",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if post_text is not None:
            self.inputs["post_text"] = post_text
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        URL of the created LinkedIn post

        Available: create_text_share


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationLinkedinNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_calendar")
class IntegrationGoogleCalendarNode(Node):
    """
    Google Calendar

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'new_event'
        all_day_event: Toggle to set the event as an all-day event
        attendees: Email IDs of attendees (comma separated)
        calendar: Select the calendar to add the new event to
        description: The description of the event
        duration: The duration of the event (positive integer). Default: 30 (in minutes)
        event_name: The name of the calendar event
        location: Physical location or the meeting location (like Zoom)
        start_datetime: The start time of the calendar event (format: YYYY-MM-DD for full day event or YYYY-MM-DDTHH:MM:SS for specific time)
    ### When action = 'check_availability'
        calendar: Select the calendar to add the new event to
        end_date_and_time: The last date and end time for everyday to look for availability
        slot_duration: The duration of an individual slot to look for (in minutes). Default: 30 (in minutes)
        start_date_and_time: The first date and start time for everyday to look for availability
        timezone: IANA Time Zone code (e.g., US/Eastern)
    ### When action = 'get_events'
        calendar: Select the calendar to add the new event to
        num_messages: Specify the last n numbers of events
        query: Return only events that contain these keywords
        use_date: Toggle to use dates
    ### When action = 'get_events' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'get_events' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'get_events' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'get_events'
        attendees: List of event attendees
        details: List of event details
        end_times: List of event end times
        event_ids: List of event IDs
        locations: List of event locations
        organizers: List of event organizers
        start_times: List of event start times
        summaries: List of event summaries
    ### When action = 'new_event'
        output: Calendar event link
    ### When action = 'check_availability'
        output: List of available time slots
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Calendar>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new_event**(*)**(*)": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "enum<string>",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to add the new event to",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "event_name",
                    "type": "string",
                    "value": "",
                    "label": "Event Name",
                    "placeholder": "Meeting with John Doe",
                    "helper_text": "The name of the calendar event",
                    "order": 4,
                },
                {
                    "field": "all_day_event",
                    "type": "bool",
                    "value": False,
                    "label": "All Day Event",
                    "helper_text": "Toggle to set the event as an all-day event",
                    "order": 5,
                },
                {
                    "field": "start_datetime",
                    "type": "timestamp",
                    "value": -1,
                    "label": "Start Datetime",
                    "placeholder": "2024-06-24 (full day event) or 2024-06-24T19:00:00",
                    "helper_text": "The start time of the calendar event (format: YYYY-MM-DD for full day event or YYYY-MM-DDTHH:MM:SS for specific time)",
                    "order": 6,
                },
                {
                    "field": "duration",
                    "type": "int32",
                    "value": 30,
                    "label": "Duration",
                    "placeholder": "30 minutes",
                    "helper_text": "The duration of the event (positive integer). Default: 30 (in minutes)",
                    "order": 7,
                },
                {
                    "field": "attendees",
                    "type": "string",
                    "value": "",
                    "label": "Attendees",
                    "placeholder": "abc@example.com,xyz@example.com,",
                    "helper_text": "Email IDs of attendees (comma separated)",
                    "order": 8,
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "placeholder": "800 Howard St., San Francisco, CA 94103",
                    "helper_text": "Physical location or the meeting location (like Zoom)",
                    "order": 9,
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Monthly sync",
                    "helper_text": "The description of the event",
                    "order": 10,
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Calendar event link",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "new_event",
            "task_name": "tasks.google_calendar.create_event",
            "description": "Create a new event",
            "label": "New Event",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "event_name",
                "all_day_event",
                "start_datetime",
                "duration",
                "attendees",
                "location",
                "description",
            ],
        },
        "check_availability**(*)**(*)": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "enum<string>",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to check availability",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "start_date_and_time",
                    "type": "timestamp",
                    "value": -1,
                    "label": "Start Date & Start Work Time",
                    "placeholder": "2024-06-24",
                    "helper_text": "The first date and start time for everyday to look for availability",
                    "order": 4,
                },
                {
                    "field": "end_date_and_time",
                    "type": "timestamp",
                    "value": -1,
                    "label": "End Date & End Work Time",
                    "placeholder": "2024-06-24",
                    "helper_text": "The last date and end time for everyday to look for availability",
                    "order": 5,
                },
                {
                    "field": "slot_duration",
                    "type": "int32",
                    "value": 30,
                    "label": "Slot Duration",
                    "placeholder": "30 minutes",
                    "helper_text": "The duration of an individual slot to look for (in minutes). Default: 30 (in minutes)",
                    "order": 6,
                },
                {
                    "field": "timezone",
                    "type": "enum<string>",
                    "value": "US/Eastern",
                    "label": "Timezone",
                    "placeholder": "US/Eastern",
                    "helper_text": "IANA Time Zone code (e.g., US/Eastern)",
                    "component": {"type": "dropdown", "referenced_options": "timezone"},
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of available time slots",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "check_availability",
            "task_name": "tasks.google_calendar.check_availability",
            "description": "Check Google calendar availability",
            "label": "Check Availability",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "start_date_and_time",
                "end_date_and_time",
                "slot_duration",
                "timezone",
            ],
        },
        "get_events**(*)**(*)": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "enum<string>",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to read events from",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Events",
                    "helper_text": "Specify the last n numbers of events",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "helper_text": "Return only events that contain these keywords",
                    "placeholder": "Keywords to filter events",
                },
            ],
            "outputs": [
                {
                    "field": "event_ids",
                    "type": "vec<string>",
                    "helper_text": "List of event IDs",
                },
                {
                    "field": "summaries",
                    "type": "vec<string>",
                    "helper_text": "List of event summaries",
                },
                {
                    "field": "start_times",
                    "type": "vec<string>",
                    "helper_text": "List of event start times",
                },
                {
                    "field": "end_times",
                    "type": "vec<string>",
                    "helper_text": "List of event end times",
                },
                {
                    "field": "locations",
                    "type": "vec<string>",
                    "helper_text": "List of event locations",
                },
                {
                    "field": "organizers",
                    "type": "vec<string>",
                    "helper_text": "List of event organizers",
                },
                {
                    "field": "attendees",
                    "type": "vec<vec<string>>",
                    "helper_text": "List of event attendees",
                },
                {
                    "field": "details",
                    "type": "vec<string>",
                    "helper_text": "List of event details",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_events",
            "task_name": "tasks.google_calendar.get_events",
            "description": "Get events from Google Calendar",
            "label": "Get Events",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "query",
            ],
        },
        "get_events**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_events**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "hidden": True,
                    "label": "Date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_events**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "label": "Exact date",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        all_day_event: bool = False,
        attendees: str = "",
        calendar: Optional[str] = None,
        description: str = "",
        duration: int = 30,
        end_date_and_time: Any = -1,
        event_name: str = "",
        exact_date: Any = {"start": "", "end": ""},
        location: str = "",
        num_messages: int = 10,
        query: str = "",
        slot_duration: int = 30,
        start_date_and_time: Any = -1,
        start_datetime: Any = -1,
        timezone: str = "US/Eastern",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_google_calendar",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if calendar is not None:
            self.inputs["calendar"] = calendar
        if event_name is not None:
            self.inputs["event_name"] = event_name
        if all_day_event is not None:
            self.inputs["all_day_event"] = all_day_event
        if start_datetime is not None:
            self.inputs["start_datetime"] = start_datetime
        if duration is not None:
            self.inputs["duration"] = duration
        if attendees is not None:
            self.inputs["attendees"] = attendees
        if location is not None:
            self.inputs["location"] = location
        if description is not None:
            self.inputs["description"] = description
        if start_date_and_time is not None:
            self.inputs["start_date_and_time"] = start_date_and_time
        if end_date_and_time is not None:
            self.inputs["end_date_and_time"] = end_date_and_time
        if slot_duration is not None:
            self.inputs["slot_duration"] = slot_duration
        if timezone is not None:
            self.inputs["timezone"] = timezone
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if query is not None:
            self.inputs["query"] = query
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attendees(self) -> List[List[str]]:
        """
        List of event attendees

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attendees")

    @property
    def details(self) -> List[str]:
        """
        List of event details

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("details")

    @property
    def end_times(self) -> List[str]:
        """
        List of event end times

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("end_times")

    @property
    def event_ids(self) -> List[str]:
        """
        List of event IDs

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("event_ids")

    @property
    def locations(self) -> List[str]:
        """
        List of event locations

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("locations")

    @property
    def organizers(self) -> List[str]:
        """
        List of event organizers

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("organizers")

    @property
    def output(self) -> str:
        """
        Calendar event link

        Different behavior based on configuration:
          - Calendar event link (When action = 'new_event')
          - List of available time slots (When action = 'check_availability')


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @property
    def start_times(self) -> List[str]:
        """
        List of event start times

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("start_times")

    @property
    def summaries(self) -> List[str]:
        """
        List of event summaries

        Available: When action = 'get_events'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("summaries")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleCalendarNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_microsoft_calendar")
class IntegrationMicrosoftCalendarNode(Node):
    """
    Microsoft Calendar

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### new_event
        all_day_event: Toggle to set the event as an all-day event
        attendees: Email IDs of attendees (comma separated)
        body: Description or agenda of the event
        calendar: Select the calendar to add the new event to
        duration: The duration of the event in minutes. Default: 30 (in minutes)
        location: The location of the meeting
        start_datetime: The start date and time of the calendar event (format: YYYY-MM-DDTHH:MM:SS)
        subject: Name/Subject of the calendar event
    ### check_availability
        end_date_and_time: The last date and end time for everyday to look for availability
        slot_duration: The duration of an individual slot to look for (in minutes). Default: 30 (in minutes)
        start_date_and_time: The first date and start time for everyday to look for availability
        timezone: IANA Time Zone code (e.g., US/Eastern)

    ## Outputs
    ### new_event
        output: Calendar event link
    ### check_availability
        output: List of available time slots with start and end datetimes
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Microsoft Calendar>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "new_event": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "string",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to add the new event to",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Sprint planning",
                    "helper_text": "Name/Subject of the calendar event",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "This meeting is to discuss...",
                    "helper_text": "Description or agenda of the event",
                },
                {
                    "field": "start_datetime",
                    "type": "timestamp",
                    "value": "",
                    "label": "Start Datetime",
                    "placeholder": "2024-06-24T19:00:00",
                    "helper_text": "The start date and time of the calendar event (format: YYYY-MM-DDTHH:MM:SS)",
                },
                {
                    "field": "all_day_event",
                    "type": "bool",
                    "value": False,
                    "label": "All Day Event",
                    "helper_text": "Toggle to set the event as an all-day event",
                },
                {
                    "field": "duration",
                    "type": "int32",
                    "value": 30,
                    "label": "Duration",
                    "placeholder": "30 minutes",
                    "helper_text": "The duration of the event in minutes. Default: 30 (in minutes)",
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "placeholder": "800 Howard St., San Francisco, CA 94103",
                    "helper_text": "The location of the meeting",
                },
                {
                    "field": "attendees",
                    "type": "string",
                    "value": "",
                    "label": "Attendees",
                    "placeholder": "abc@example.com,xyz@example.com",
                    "helper_text": "Email IDs of attendees (comma separated)",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Calendar event link",
                }
            ],
            "name": "new_event",
            "task_name": "tasks.microsoft_calendar.create_event",
            "description": "Create a new calendar event",
            "label": "New Event",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "subject",
                "body",
                "all_day_event",
                "start_datetime",
                "duration",
                "location",
                "attendees",
            ],
        },
        "check_availability": {
            "inputs": [
                {
                    "field": "start_date_and_time",
                    "type": "timestamp",
                    "value": "",
                    "label": "Start Date & Start Work Time",
                    "placeholder": "2024-06-24",
                    "helper_text": "The first date and start time for everyday to look for availability",
                },
                {
                    "field": "end_date_and_time",
                    "type": "timestamp",
                    "value": "",
                    "label": "End Date & End Work Time",
                    "placeholder": "2024-06-24",
                    "helper_text": "The last date and end time for everyday to look for availability",
                },
                {
                    "field": "slot_duration",
                    "type": "int32",
                    "value": "",
                    "label": "Slot duration",
                    "placeholder": "30 minutes",
                    "helper_text": "The duration of an individual slot to look for (in minutes). Default: 30 (in minutes)",
                },
                {
                    "field": "timezone",
                    "type": "enum<string>",
                    "value": "US/Eastern",
                    "label": "Timezone",
                    "placeholder": "US/Eastern",
                    "helper_text": "IANA Time Zone code (e.g., US/Eastern)",
                    "component": {"type": "dropdown", "referenced_options": "timezone"},
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of available time slots with start and end datetimes",
                }
            ],
            "name": "check_availability",
            "task_name": "tasks.microsoft_calendar.check_availability",
            "description": "Check Microsoft calendar availability",
            "label": "Check Availability",
            "inputs_sort_order": [
                "integration",
                "action",
                "timezone",
                "start_date_and_time",
                "end_date_and_time",
                "slot_duration",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        all_day_event: bool = False,
        attendees: str = "",
        body: str = "",
        calendar: Optional[str] = None,
        duration: int = 30,
        end_date_and_time: Any = None,
        location: str = "",
        slot_duration: int = None,
        start_date_and_time: Any = None,
        start_datetime: Any = None,
        subject: str = "",
        timezone: str = "US/Eastern",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_microsoft_calendar",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if calendar is not None:
            self.inputs["calendar"] = calendar
        if subject is not None:
            self.inputs["subject"] = subject
        if body is not None:
            self.inputs["body"] = body
        if start_datetime is not None:
            self.inputs["start_datetime"] = start_datetime
        if all_day_event is not None:
            self.inputs["all_day_event"] = all_day_event
        if duration is not None:
            self.inputs["duration"] = duration
        if location is not None:
            self.inputs["location"] = location
        if attendees is not None:
            self.inputs["attendees"] = attendees
        if start_date_and_time is not None:
            self.inputs["start_date_and_time"] = start_date_and_time
        if end_date_and_time is not None:
            self.inputs["end_date_and_time"] = end_date_and_time
        if slot_duration is not None:
            self.inputs["slot_duration"] = slot_duration
        if timezone is not None:
            self.inputs["timezone"] = timezone
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Calendar event link

        Different behavior based on configuration:
          - Calendar event link (new_event)
          - List of available time slots with start and end datetimes (check_availability)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMicrosoftCalendarNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_mailgun")
class IntegrationMailgunNode(Node):
    """
    Mailgun

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### send_mail
        bcc_recipients: The email(s) of the recipient(s) you want to BCC the email to
        body: The body (message) of the email
        cc_recipients: The email(s) of the recipient(s) you want to CC the email to
        domain: Your Mailgun domain
        from_email: The email of the sender of the email
        from_name: The name of the sender of the email
        recipients: The email of the recipient you want to send the email to
        subject: The subject of the email
    ### add_contact_to_mailing_list
        email: The email of the contact to be added to the list
        list_name: The list the contact will be added to
        name: The name of contact to be added to the list

    ## Outputs
    ### send_mail
        output: Status of the email sending operation
    ### add_contact_to_mailing_list
        output: Status of the contact addition operation
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Mailgun>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "send_mail": {
            "inputs": [
                {
                    "field": "domain",
                    "type": "string",
                    "label": "Domain",
                    "agent_field_type": "static",
                    "helper_text": "Your Mailgun domain",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=domain_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Important: Your Account Update",
                    "helper_text": "The subject of the email",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Dear valued customer...",
                    "helper_text": "The body (message) of the email",
                },
                {
                    "field": "from_name",
                    "type": "string",
                    "value": "",
                    "label": "The name of the sender",
                    "placeholder": "John Smith",
                    "helper_text": "The name of the sender of the email",
                },
                {
                    "field": "from_email",
                    "type": "string",
                    "value": "",
                    "label": "The Email of the sender",
                    "placeholder": "john@company.com",
                    "helper_text": "The email of the sender of the email",
                },
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients email address",
                    "placeholder": "recipient@example.com",
                    "helper_text": "The email of the recipient you want to send the email to",
                },
                {
                    "field": "cc_recipients",
                    "type": "string",
                    "value": "",
                    "label": "CC Recipients email address",
                    "placeholder": "cc1@example.com, cc2@example.com",
                    "helper_text": "The email(s) of the recipient(s) you want to CC the email to",
                },
                {
                    "field": "bcc_recipients",
                    "type": "string",
                    "value": "",
                    "label": "BCC Recipients email address",
                    "placeholder": "bcc1@example.com, bcc2@example.com",
                    "helper_text": "The email(s) of the recipient(s) you want to BCC the email to",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Status of the email sending operation",
                }
            ],
            "name": "send_mail",
            "task_name": "tasks.mailgun.send_mail",
            "description": "Send mail ",
            "label": "Send mail",
        },
        "add_contact_to_mailing_list": {
            "inputs": [
                {
                    "field": "list_name",
                    "type": "string",
                    "value": "",
                    "label": "Name of the mailing list",
                    "placeholder": "newsletter-subscribers",
                    "helper_text": "The list the contact will be added to",
                    "agent_field_type": "static",
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name of the contact to add",
                    "placeholder": "John Smith",
                    "helper_text": "The name of contact to be added to the list",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email of the contact to add",
                    "placeholder": "john@example.com",
                    "helper_text": "The email of the contact to be added to the list",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Status of the contact addition operation",
                }
            ],
            "name": "add_contact_to_mailing_list",
            "task_name": "tasks.mailgun.add_contact_to_mailing_list",
            "description": "Adds a contact to a Mailgun Mailing list",
            "label": "Add Contact to Mailing List",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        bcc_recipients: str = "",
        body: str = "",
        cc_recipients: str = "",
        domain: Optional[str] = None,
        email: str = "",
        from_email: str = "",
        from_name: str = "",
        list_name: str = "",
        name: str = "",
        recipients: str = "",
        subject: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_mailgun",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if domain is not None:
            self.inputs["domain"] = domain
        if subject is not None:
            self.inputs["subject"] = subject
        if body is not None:
            self.inputs["body"] = body
        if from_name is not None:
            self.inputs["from_name"] = from_name
        if from_email is not None:
            self.inputs["from_email"] = from_email
        if recipients is not None:
            self.inputs["recipients"] = recipients
        if cc_recipients is not None:
            self.inputs["cc_recipients"] = cc_recipients
        if bcc_recipients is not None:
            self.inputs["bcc_recipients"] = bcc_recipients
        if list_name is not None:
            self.inputs["list_name"] = list_name
        if name is not None:
            self.inputs["name"] = name
        if email is not None:
            self.inputs["email"] = email
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Status of the email sending operation

        Different behavior based on configuration:
          - Status of the email sending operation (send_mail)
          - Status of the contact addition operation (add_contact_to_mailing_list)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMailgunNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_docs")
class IntegrationGoogleDocsNode(Node):
    """
    Google Docs

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### read_doc_url
        doc_url: Enter the public URL of the Google Doc
    ### read_doc
        file_id: Select a File to read
    ### write_to_doc
        file_id: Select a File to read
        text: The text that will be added to the File

    ## Outputs
    ### read_doc_url
        content: HTML body of the Google Doc
    ### read_doc
        text: The text content of the selected file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Docs>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_file_nodes",
        },
        "read_doc": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select a File to read",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The text content of the selected file",
                }
            ],
            "name": "read_doc",
            "task_name": "tasks.google_docs.read_doc",
            "description": "Retrieves and returns the plain text content of a user-selected Google Doc.",
            "label": "Read Google Doc",
        },
        "write_to_doc": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select a File to append the text to",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Text",
                    "placeholder": "Hello World!",
                    "helper_text": "The text that will be added to the File",
                },
            ],
            "outputs": [],
            "name": "write_to_doc",
            "task_name": "tasks.google_docs.write_to_doc",
            "description": "Append text to an existing document",
            "label": "Append Text to Document",
        },
        "read_doc_url": {
            "inputs": [
                {
                    "field": "doc_url",
                    "type": "string",
                    "value": "",
                    "label": "Google Doc URL",
                    "helper_text": "Enter the public URL of the Google Doc",
                    "placeholder": "Enter the public URL of the Google Doc",
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "content",
                    "type": "string",
                    "helper_text": "HTML body of the Google Doc",
                }
            ],
            "variant": "default_integration_nodes",
            "banner_text": 'Ensure that the Google Docs\'s permissions is set to "Anyone with the Link"',
            "name": "read_doc_url",
            "task_name": "tasks.google_docs.read_doc_url",
            "description": "Download the contents of a publicly accessible Google Docs file using its shared URL",
            "label": "Read from Doc URL",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        doc_url: str = "",
        file_id: Optional[str] = None,
        text: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_google_docs",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if file_id is not None:
            self.inputs["file_id"] = file_id
        if text is not None:
            self.inputs["text"] = text
        if doc_url is not None:
            self.inputs["doc_url"] = doc_url
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def content(self) -> str:
        """
        HTML body of the Google Doc

        Available: read_doc_url


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("content")

    @property
    def text(self) -> str:
        """
        The text content of the selected file

        Available: read_doc


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleDocsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_microsoft")
class IntegrationMicrosoftNode(Node):
    """
    One Drive

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### add_file
        content: The contents of the file
        file_name: The name of the file
        item_id: Select the folder within your OneDrive to add the file
    ### read_file
        item_id: Select the folder within your OneDrive to add the file

    ## Outputs
    ### read_file
        output: The content of the selected file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Microsoft>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_file_nodes",
        },
        "add_file": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder within your OneDrive to add the file",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "value": "",
                    "label": "File Name",
                    "placeholder": "File",
                    "helper_text": "The name of the file",
                },
                {
                    "field": "content",
                    "type": "string",
                    "value": "",
                    "label": "Contents",
                    "placeholder": "This is the file contents",
                    "helper_text": "The contents of the file",
                },
            ],
            "outputs": [],
            "name": "add_file",
            "task_name": "tasks.microsoft.add_file",
            "description": "Add file to OneDrive",
            "label": "Add File",
        },
        "read_file": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to read from OneDrive",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "endpoint": "",
                            "query": {"field": "parent_id"},
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "The content of the selected file",
                }
            ],
            "name": "read_file",
            "task_name": "tasks.microsoft.read_file",
            "description": "Read file from OneDrive",
            "label": "Read File",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        content: str = "",
        file_name: str = "",
        item_id: Optional[str] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_microsoft",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if file_name is not None:
            self.inputs["file_name"] = file_name
        if content is not None:
            self.inputs["content"] = content
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The content of the selected file

        Available: read_file


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMicrosoftNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_typeform")
class IntegrationTypeformNode(Node):
    """
    Typeform

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### get_responses
        form_id: Select the form from which to get the responses
        number_of_responses: The number of responses to fetch

    ## Outputs
    ### get_responses
        list_of_responses: The responses in list format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Typeform>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "get_responses": {
            "inputs": [
                {
                    "field": "form_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Form",
                    "helper_text": "Select the form from which to get the responses",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "number_of_responses",
                    "type": "string",
                    "value": "",
                    "label": "Number of responses",
                    "placeholder": "5",
                    "helper_text": "The number of responses to fetch",
                },
            ],
            "outputs": [
                {
                    "field": "list_of_responses",
                    "type": "vec<string>",
                    "helper_text": "The responses in list format",
                }
            ],
            "name": "get_responses",
            "task_name": "tasks.typeform.get_responses",
            "description": "Get Form Responses From Typeform",
            "label": "Get Form Responses",
            "variant": "common_integration_file_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        form_id: str = "",
        number_of_responses: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_typeform",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if form_id is not None:
            self.inputs["form_id"] = form_id
        if number_of_responses is not None:
            self.inputs["number_of_responses"] = number_of_responses
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def list_of_responses(self) -> List[str]:
        """
        The responses in list format

        Available: get_responses


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("list_of_responses")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationTypeformNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_dropbox")
class IntegrationDropboxNode(Node):
    """
    Dropbox

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### post_file
        content: The contents of the file
        file_name: The name of the file
        folder_id: Select the folder where you want to post the file to

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Dropbox>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "post_file": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder where you want to post the file to",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "value": "",
                    "label": "File Name",
                    "placeholder": "File_Name",
                    "helper_text": "The name of the file",
                },
                {
                    "field": "content",
                    "type": "string",
                    "value": "",
                    "label": "Content",
                    "placeholder": "Enter file content here",
                    "helper_text": "The contents of the file",
                },
            ],
            "outputs": [],
            "name": "post_file",
            "task_name": "tasks.dropbox.post_file",
            "description": "Post file to Dropbox",
            "label": "Post file",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "folder_id",
                "file_name",
                "content",
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        content: str = "",
        file_name: str = "",
        folder_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_dropbox",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if folder_id is not None:
            self.inputs["folder_id"] = folder_id
        if file_name is not None:
            self.inputs["file_name"] = file_name
        if content is not None:
            self.inputs["content"] = content
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationDropboxNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_box")
class IntegrationBoxNode(Node):
    """
    Box

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### upload_files
        files: The number of files to be appended. Files will be appended in successive fashion (e.g., file-1 first, then file-2, etc.)
        folder_id: Select the Folder to upload files to

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Box>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "upload_files": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the Folder to upload files to",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "files",
                    "type": "vec<file>",
                    "value": [""],
                    "label": "Files",
                    "placeholder": "Files",
                    "helper_text": "The number of files to be appended. Files will be appended in successive fashion (e.g., file-1 first, then file-2, etc.)",
                },
            ],
            "outputs": [],
            "name": "upload_files",
            "task_name": "tasks.box.upload_files",
            "description": "Upload files to Box",
            "label": "Upload files",
            "variant": "common_integration_file_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        files: List[str] = [""],
        folder_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_box",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if folder_id is not None:
            self.inputs["folder_id"] = folder_id
        if files is not None:
            self.inputs["files"] = files
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationBoxNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_drive")
class IntegrationGoogleDriveNode(Node):
    """
    Google Drive

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'get_files'
        corpora: Scope to search in: 'user' (files owned/shared to user) or 'domain' (files shared to user's domain)
        drive_id: ID of the shared drive to search
        fields: Comma-separated list of fields to include in the response
        include_items_from_all_drives: Whether to include items from all drives, including shared drives
        include_labels: Comma-separated list of label IDs to include in the response
        include_permissions_for_view: Additional view's permissions to include (only 'published' supported)
        num_messages: Specify the number of files to fetch
        order_by: Sort order for files (e.g., 'folder,name,modifiedTime desc')
        query: Search query for filtering files (see Drive API documentation for syntax)
        spaces: Comma-separated list of spaces to search ('drive', 'appDataFolder')
        supports_all_drives: Whether the application supports both My Drives and shared drives
        use_date: Toggle to use dates
    ### When action = 'get_files' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'read_file_url'
        drive_file_url: The URL of the drive file to read.
    ### When action = 'get_files' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'save_drive'
        file: The file to be added to Google Drive
        file_id: Select the file to read
        file_name: The name of the file
    ### When action = 'read_drive'
        file_id: Select the file to read
    ### When action = 'get_files' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_file_url'
        file: The file fetched from the URL.
    ### When action = 'get_files'
        files: The files of the retrieved files
    ### When action = 'read_drive'
        text: The text content of the selected file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "enum<string>",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Drive>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_file_nodes",
        },
        "read_drive**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to read",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The text content of the selected file",
                }
            ],
            "name": "read_drive",
            "task_name": "tasks.google_drive.read_drive",
            "description": "Download a user-selected file from their Google Drive using its file ID",
            "label": "Read file",
            "inputs_sort_order": ["integration", "action", "file_id"],
        },
        "save_drive**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder within your Google Drive to save the file",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "value": "",
                    "label": "File Name",
                    "placeholder": "File_Name",
                    "helper_text": "The name of the file",
                },
                {
                    "field": "file",
                    "type": "file",
                    "value": "",
                    "label": "File",
                    "placeholder": "Select a file",
                    "helper_text": "The file to be added to Google Drive",
                },
            ],
            "outputs": [],
            "name": "save_drive",
            "task_name": "tasks.google_drive.save_drive",
            "description": "Save a file to Google Drive",
            "label": "Save file",
            "inputs_sort_order": [
                "integration",
                "action",
                "file_id",
                "file_name",
                "file",
            ],
        },
        "read_file_url**(*)**(*)": {
            "inputs": [
                {
                    "field": "drive_file_url",
                    "type": "string",
                    "value": "",
                    "helper_text": "The URL of the drive file to read.",
                    "label": "File URL",
                    "placeholder": "Enter the URL of the drive file to read.",
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "file",
                    "type": "file",
                    "label": "File",
                    "helper_text": "The file fetched from the URL.",
                }
            ],
            "variant": "default_integration_nodes",
            "banner_text": 'Ensure that the Google Drive\'s permissions is set to "Anyone with the Link"',
            "name": "read_file_url",
            "task_name": "tasks.google_drive.read_file_url",
            "description": "Download the contents of a publicly accessible Google Drive file using its shared URL",
            "label": "Read file from URL",
            "inputs_sort_order": ["integration", "action", "drive_file_url"],
        },
        "get_files**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "order": 4,
                },
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Files",
                    "helper_text": "Specify the number of files to fetch",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "helper_text": "Search query for filtering files (see Drive API documentation for syntax)",
                    "placeholder": "",
                },
                {
                    "field": "order_by",
                    "type": "string",
                    "value": "",
                    "label": "Order By",
                    "helper_text": "Sort order for files (e.g., 'folder,name,modifiedTime desc')",
                    "placeholder": "",
                },
                {
                    "field": "corpora",
                    "type": "string",
                    "value": "",
                    "label": "Search Scope",
                    "helper_text": "Scope to search in: 'user' (files owned/shared to user) or 'domain' (files shared to user's domain)",
                    "placeholder": "Eg. User or Domain",
                },
                {
                    "field": "drive_id",
                    "type": "string",
                    "value": "",
                    "label": "Drive ID",
                    "helper_text": "ID of the shared drive to search",
                },
                {
                    "field": "fields",
                    "type": "string",
                    "value": "",
                    "label": "Fields to Include",
                    "helper_text": "Comma-separated list of fields to include in the response",
                    "placeholder": "Eg. name, id, size, etc.",
                },
                {
                    "field": "include_items_from_all_drives",
                    "type": "bool",
                    "value": "",
                    "label": "Include All Drives",
                    "helper_text": "Whether to include items from all drives, including shared drives",
                },
                {
                    "field": "include_labels",
                    "type": "string",
                    "value": "",
                    "label": "Include Labels",
                    "helper_text": "Comma-separated list of label IDs to include in the response",
                    "placeholder": "",
                },
                {
                    "field": "spaces",
                    "type": "string",
                    "value": "",
                    "label": "Spaces",
                    "helper_text": "Comma-separated list of spaces to search ('drive', 'appDataFolder')",
                    "placeholder": "Eg. drive, appDataFolder",
                },
                {
                    "field": "supports_all_drives",
                    "type": "bool",
                    "value": "",
                    "label": "Supports All Drives",
                    "helper_text": "Whether the application supports both My Drives and shared drives",
                    "placeholder": "",
                },
                {
                    "field": "include_permissions_for_view",
                    "type": "string",
                    "value": "",
                    "label": "Include Permissions View",
                    "helper_text": "Additional view's permissions to include (only 'published' supported)",
                    "placeholder": "",
                },
            ],
            "outputs": [
                {
                    "field": "files",
                    "type": "vec<file>",
                    "helper_text": "The files of the retrieved files",
                    "label": "Files",
                }
            ],
            "variant": "get_integration_nodes",
            "name": "get_files",
            "task_name": "tasks.google_drive.get_files",
            "description": "Search for and return a list of files from the user's Google Drive that match the specified filters",
            "label": "Get Files",
            "inputs_sort_order": [
                "integration",
                "action",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "query",
                "order_by",
                "corpora",
                "drive_id",
                "fields",
                "include_items_from_all_drives",
                "include_labels",
                "spaces",
                "supports_all_drives",
                "include_permissions_for_view",
            ],
        },
        "get_files**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_files**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "label": "Date range",
                    "component": {"type": "date_range"},
                    "order": 6,
                }
            ],
            "outputs": [],
        },
        "get_files**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "label": "Exact date",
                    "component": {"type": "date_range"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        corpora: str = "",
        drive_file_url: str = "",
        drive_id: str = "",
        exact_date: Any = {"start": "", "end": ""},
        fields: str = "",
        file: str = "",
        file_id: str = "",
        file_name: str = "",
        include_items_from_all_drives: bool = False,
        include_labels: str = "",
        include_permissions_for_view: str = "",
        num_messages: int = 10,
        order_by: str = "",
        query: str = "",
        spaces: str = "",
        supports_all_drives: bool = False,
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_google_drive",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if file_id is not None:
            self.inputs["file_id"] = file_id
        if file_name is not None:
            self.inputs["file_name"] = file_name
        if file is not None:
            self.inputs["file"] = file
        if drive_file_url is not None:
            self.inputs["drive_file_url"] = drive_file_url
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if query is not None:
            self.inputs["query"] = query
        if order_by is not None:
            self.inputs["order_by"] = order_by
        if corpora is not None:
            self.inputs["corpora"] = corpora
        if drive_id is not None:
            self.inputs["drive_id"] = drive_id
        if fields is not None:
            self.inputs["fields"] = fields
        if include_items_from_all_drives is not None:
            self.inputs["include_items_from_all_drives"] = include_items_from_all_drives
        if include_labels is not None:
            self.inputs["include_labels"] = include_labels
        if spaces is not None:
            self.inputs["spaces"] = spaces
        if supports_all_drives is not None:
            self.inputs["supports_all_drives"] = supports_all_drives
        if include_permissions_for_view is not None:
            self.inputs["include_permissions_for_view"] = include_permissions_for_view
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def file(self) -> str:
        """
        The file fetched from the URL.

        Available: When action = 'read_file_url'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("file")

    @property
    def files(self) -> List[str]:
        """
        The files of the retrieved files

        Available: When action = 'get_files'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("files")

    @property
    def text(self) -> str:
        """
        The text content of the selected file

        Available: When action = 'read_drive'


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("text")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleDriveNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_sheets")
class IntegrationGoogleSheetsNode(Node):
    """
    Google Sheets

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: The integration input
        processed_outputs: The processed_outputs input
    ### extract_to_table
        add_columns_manually: Add data points for some columns manually instead of having them extracted by the AI model.
        additional_context: Additional context for the AI model to extract the table.
        extract_multiple_rows: If checked, it will extract multiple rows of data. If unchecked, it will extract a single row.
        manual_columns: Pass in data to column names manually.
        model: The model to use for the Google Sheets integration
        provider: The provider to use for the Google Sheets integration
        sheet_id: Select the Sheet to read from
        text_for_extraction: The text to extract the table from
    ### write_to_sheet
        selected_input_dynamic_handle_names: The selected_input_dynamic_handle_names input
        sheet_id: Select the Sheet to read from
    ### write_list_to_column
        selected_input_dynamic_handle_names: The selected_input_dynamic_handle_names input
        sheet_id: Select the Sheet to read from
    ### update_rows
        selected_input_dynamic_handle_names: The selected_input_dynamic_handle_names input
        sheet_id: Select the Sheet to read from
    ### read_sheet
        sheet_id: Select the Sheet to read from
    ### read_sheet_url
        sheet_id: Select the Sheet to read from
        sheet_url: Enter the URL of your Google Spreadsheet

    ## Outputs
    ### Common Outputs
        [processed_outputs]: The [processed_outputs] output
    ### extract_to_table
        table: The table extracted from the text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Google Sheets>",
        },
        {
            "field": "processed_outputs",
            "helper_text": "The processed_outputs input",
            "value": {},
            "type": "map<string, string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "[processed_outputs]",
            "helper_text": "The [processed_outputs] output",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "google_sheet"},
        "read_sheet": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                }
            ],
            "outputs": [],
            "name": "read_sheet",
            "task_name": "tasks.google_sheets.read_sheet",
            "description": "Read specified columns from the selected sheet",
            "label": "Read from Sheet",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?sheet_id={inputs.sheet_id}",
        },
        "read_sheet_url": {
            "inputs": [
                {
                    "field": "sheet_url",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Workbook URL",
                    "helper_text": "Enter the URL of your Google Spreadsheet",
                    "component": {"type": "folder"},
                },
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {"type": "folder"},
                },
            ],
            "outputs": [],
            "banner_text": 'Ensure that the Google Sheet\'s permissions is set to "Anyone with the Link"',
            "name": "read_sheet_url",
            "task_name": "tasks.google_sheets.read_sheet_url",
            "description": "Read specified columns from the provided sheet URL",
            "label": "Read from Sheet URL",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?sheet_id={inputs.sheet_id}&sheet_url={inputs.sheet_url}",
        },
        "write_to_sheet": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "selected_input_dynamic_handle_names",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                    "component": {"type": "dynamic_handle"},
                },
            ],
            "outputs": [],
            "name": "write_to_sheet",
            "task_name": "tasks.google_sheets.write_to_sheet",
            "description": "Add a new row in the selected sheet",
            "label": "Add New Row",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?sheet_id={inputs.sheet_id}",
        },
        "write_list_to_column": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "selected_input_dynamic_handle_names",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                },
            ],
            "outputs": [],
            "name": "write_list_to_column",
            "task_name": "tasks.google_sheets.write_list_to_column",
            "description": "Fill specified columns with the input values (inputs can be list)",
            "label": "Column List Writer",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?sheet_id={inputs.sheet_id}",
        },
        "update_rows": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "selected_input_dynamic_handle_names",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                },
            ],
            "outputs": [],
            "name": "update_rows",
            "task_name": "tasks.google_sheets.update_rows",
            "description": "Update the rows matching the specified search values",
            "label": "Update Rows",
            "operation": "update",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?sheet_id={inputs.sheet_id}",
        },
        "extract_to_table": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "provider",
                    "type": "enum<string>",
                    "value": "openai",
                    "label": "Provider",
                    "placeholder": "OpenAI",
                    "helper_text": "The provider to use for the Google Sheets integration",
                },
                {
                    "field": "model",
                    "type": "enum<string>",
                    "value": "gpt-4o",
                    "label": "Model",
                    "placeholder": "GPT-4o",
                    "helper_text": "The model to use for the Google Sheets integration",
                },
                {
                    "field": "text_for_extraction",
                    "type": "string",
                    "value": "",
                    "label": "Text for Extraction",
                    "placeholder": "Extract the table from the following text",
                    "helper_text": "The text to extract the table from",
                },
                {
                    "field": "extract_multiple_rows",
                    "type": "bool",
                    "value": True,
                    "label": "Extract Multiple Rows",
                    "helper_text": "If checked, it will extract multiple rows of data. If unchecked, it will extract a single row.",
                },
                {
                    "field": "manual_columns",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                    "label": "Manual Columns",
                    "placeholder": "Manual Columns",
                    "helper_text": "Pass in data to column names manually.",
                },
                {
                    "field": "add_columns_manually",
                    "type": "bool",
                    "value": False,
                    "label": "Add Columns Manually",
                    "helper_text": "Add data points for some columns manually instead of having them extracted by the AI model.",
                },
                {
                    "field": "additional_context",
                    "type": "string",
                    "value": "",
                    "label": "Additional Context",
                    "placeholder": "Additional context for the AI model to extract the table.",
                    "helper_text": "Additional context for the AI model to extract the table.",
                },
            ],
            "outputs": [
                {
                    "field": "table",
                    "type": "file",
                    "helper_text": "The table extracted from the text",
                }
            ],
            "name": "extract_to_table",
            "task_name": "tasks.google_sheets.extract_to_table",
            "description": "Extract data from text to a table with AI",
            "label": "Extract to Table",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?sheet_id={inputs.sheet_id}",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        add_columns_manually: bool = False,
        additional_context: str = "",
        extract_multiple_rows: bool = True,
        manual_columns: List[Any] = [],
        model: str = "gpt-4o",
        processed_outputs: Dict[str, str] = {},
        provider: str = "openai",
        selected_input_dynamic_handle_names: List[Any] = [],
        sheet_id: str = "",
        sheet_url: str = "",
        text_for_extraction: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_google_sheets",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs
        if sheet_id is not None:
            self.inputs["sheet_id"] = sheet_id
        if sheet_url is not None:
            self.inputs["sheet_url"] = sheet_url
        if selected_input_dynamic_handle_names is not None:
            self.inputs["selected_input_dynamic_handle_names"] = (
                selected_input_dynamic_handle_names
            )
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if text_for_extraction is not None:
            self.inputs["text_for_extraction"] = text_for_extraction
        if extract_multiple_rows is not None:
            self.inputs["extract_multiple_rows"] = extract_multiple_rows
        if manual_columns is not None:
            self.inputs["manual_columns"] = manual_columns
        if add_columns_manually is not None:
            self.inputs["add_columns_manually"] = add_columns_manually
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def table(self) -> str:
        """
        The table extracted from the text

        Available: extract_to_table


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("table")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleSheetsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_airtable")
class IntegrationAirtableNode(Node):
    """
    Airtable

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        base_id: Name of the Airtable base
        integration: The integration input
        processed_outputs: The processed_outputs input
        table_id: Name of the table in the selected base
    ### new_record
        selected_input_dynamic_handle_names: The selected_input_dynamic_handle_names input
    ### write_list_to_column
        selected_input_dynamic_handle_names: The selected_input_dynamic_handle_names input
    ### update_records
        selected_input_dynamic_handle_names: The selected_input_dynamic_handle_names input

    ## Outputs
    ### Common Outputs
        [processed_outputs]: The [processed_outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "base_id",
            "helper_text": "Name of the Airtable base",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Airtable>",
        },
        {
            "field": "processed_outputs",
            "helper_text": "The processed_outputs input",
            "value": {},
            "type": "map<string, string>",
        },
        {
            "field": "table_id",
            "helper_text": "Name of the table in the selected base",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "[processed_outputs]",
            "helper_text": "The [processed_outputs] output",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_dynamic_nodes",
        },
        "read_table": {
            "inputs": [],
            "outputs": [],
            "name": "read_table",
            "task_name": "tasks.airtable.read_table",
            "description": "Read specified columns from the selected table",
            "label": "Read Table",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?base_id={inputs.base_id}&table_id={inputs.table_id}",
        },
        "new_record": {
            "inputs": [
                {
                    "field": "selected_input_dynamic_handle_names",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                }
            ],
            "outputs": [],
            "name": "new_record",
            "task_name": "tasks.airtable.write_to_table",
            "description": "Add new record in an Airtable database",
            "label": "Add New Record",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?base_id={inputs.base_id}&table_id={inputs.table_id}",
        },
        "write_list_to_column": {
            "inputs": [
                {
                    "field": "selected_input_dynamic_handle_names",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                }
            ],
            "outputs": [],
            "name": "write_list_to_column",
            "task_name": "tasks.airtable.write_list_to_column",
            "description": "Fill specified columns empty cells with the input values (inputs can be list)",
            "label": "Column List Writer",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?base_id={inputs.base_id}&table_id={inputs.table_id}",
        },
        "update_records": {
            "inputs": [
                {
                    "field": "selected_input_dynamic_handle_names",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                }
            ],
            "outputs": [],
            "name": "update_records",
            "task_name": "tasks.airtable.update_records",
            "description": "Update the records matching the specified search values in a table",
            "label": "Update Records",
            "operation": "update",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?base_id={inputs.base_id}&table_id={inputs.table_id}",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        base_id: str = "",
        processed_outputs: Dict[str, str] = {},
        selected_input_dynamic_handle_names: List[Any] = [],
        table_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_airtable",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if base_id is not None:
            self.inputs["base_id"] = base_id
        if table_id is not None:
            self.inputs["table_id"] = table_id
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs
        if selected_input_dynamic_handle_names is not None:
            self.inputs["selected_input_dynamic_handle_names"] = (
                selected_input_dynamic_handle_names
            )
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationAirtableNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_notion")
class IntegrationNotionNode(Node):
    """
    Notion

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
        processed_outputs: The processed_outputs input
    ### read_page
        item_id: Select the page to read
    ### write_to_database
        item_id: Select the page to read
        selected_input_dynamic_handle_names: The selected_input_dynamic_handle_names input
    ### create_new_page
        item_id: Select the page to read
        selected_input_dynamic_handle_names: The selected_input_dynamic_handle_names input
    ### create_new_block
        item_id: Select the page to read
        selected_input_dynamic_handle_names: The selected_input_dynamic_handle_names input
    ### update_database
        item_id: Select the page to read
        selected_input_dynamic_handle_names: The selected_input_dynamic_handle_names input
    ### read_database
        item_id: Select the page to read

    ## Outputs
    ### Common Outputs
        [processed_outputs]: The [processed_outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Notion>",
        },
        {
            "field": "processed_outputs",
            "helper_text": "The processed_outputs input",
            "value": {},
            "type": "map<string, string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "[processed_outputs]",
            "helper_text": "The [processed_outputs] output",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_dynamic_nodes",
        },
        "read_page": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Page",
                    "placeholder": "Choose a page",
                    "helper_text": "Select the page to read",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=page&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                }
            ],
            "outputs": [],
            "name": "read_page",
            "task_name": "tasks.notion.read_page",
            "description": "Read an existing Notion page",
            "label": "Read Notion page",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?item_id={inputs.item_id}",
        },
        "write_to_database": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Database",
                    "placeholder": "Choose a database",
                    "helper_text": "Select Notion Database",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "selected_input_dynamic_handle_names",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                },
            ],
            "outputs": [],
            "name": "write_to_database",
            "task_name": "tasks.notion.write_to_database",
            "description": "Add a page to an existing Notion database",
            "label": "Write to Database",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?item_id={inputs.item_id}",
        },
        "create_new_page": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Page",
                    "placeholder": "Choose a Page",
                    "helper_text": "Select Notion Database",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=page&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "selected_input_dynamic_handle_names",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                },
            ],
            "outputs": [],
            "name": "create_new_page",
            "task_name": "tasks.notion.create_new_page",
            "description": "Create a new page on an existing Notion page",
            "label": "Create New Page",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?item_id={inputs.item_id}",
        },
        "create_new_block": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Page",
                    "placeholder": "Choose a Page",
                    "helper_text": "Select Notion Page",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=page&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "selected_input_dynamic_handle_names",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                },
            ],
            "outputs": [],
            "name": "create_new_block",
            "task_name": "tasks.notion.create_new_block",
            "description": "Write to an existing Notion page",
            "label": "Create New Block",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?item_id={inputs.item_id}",
        },
        "update_database": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Database",
                    "placeholder": "Choose a database",
                    "helper_text": "Select Notion Database",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "selected_input_dynamic_handle_names",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                },
            ],
            "outputs": [],
            "name": "update_database",
            "task_name": "tasks.notion.update_database",
            "description": "Update a Notion database",
            "label": "Database Updater",
            "operation": "update",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?item_id={inputs.item_id}",
        },
        "read_database": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Database",
                    "placeholder": "Choose a database",
                    "helper_text": "Select Notion Database",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                }
            ],
            "outputs": [],
            "name": "read_database",
            "task_name": "tasks.notion.read_database",
            "description": "Read pages from a Notion database",
            "label": "Database Reader",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?item_id={inputs.item_id}",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        item_id: str = "",
        processed_outputs: Dict[str, str] = {},
        selected_input_dynamic_handle_names: List[Any] = [],
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_notion",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if selected_input_dynamic_handle_names is not None:
            self.inputs["selected_input_dynamic_handle_names"] = (
                selected_input_dynamic_handle_names
            )
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationNotionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_databricks")
class IntegrationDatabricksNode(Node):
    """
    Databricks

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        catalog_name: Select the name of the Catalog
        integration: The integration input
        schema_name: Select the name of the Schema
        selected_input_dynamic_handle_names: The selected_input_dynamic_handle_names input
        table_name: Select the name of Table to insert the row
        warehouse_id: Select the ID of the Warehouse to perform the action

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "catalog_name",
            "helper_text": "Select the name of the Catalog",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Databricks>",
        },
        {
            "field": "schema_name",
            "helper_text": "Select the name of the Schema",
            "value": "",
            "type": "string",
        },
        {
            "field": "selected_input_dynamic_handle_names",
            "helper_text": "The selected_input_dynamic_handle_names input",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "table_name",
            "helper_text": "Select the name of Table to insert the row",
            "value": "",
            "type": "string",
        },
        {
            "field": "warehouse_id",
            "helper_text": "Select the ID of the Warehouse to perform the action",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "insert_row": {
            "inputs": [],
            "outputs": [],
            "name": "insert_row",
            "task_name": "tasks.databricks.insert_row",
            "description": "Insert a new row into a Databricks Table",
            "label": "Insert A Row",
            "variant": "common_integration_dynamic_nodes",
            "handle_endpoint": "/{prefix}/function-specific-params/{inputs.integration.object_id}/{inputs.action}?warehouse_id={inputs.warehouse_id}&catalog_name={inputs.catalog_name}&schema_name={inputs.schema_name}&table_name={inputs.table_name}",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        catalog_name: str = "",
        schema_name: str = "",
        selected_input_dynamic_handle_names: List[Any] = [],
        table_name: str = "",
        warehouse_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_databricks",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if warehouse_id is not None:
            self.inputs["warehouse_id"] = warehouse_id
        if catalog_name is not None:
            self.inputs["catalog_name"] = catalog_name
        if schema_name is not None:
            self.inputs["schema_name"] = schema_name
        if table_name is not None:
            self.inputs["table_name"] = table_name
        if selected_input_dynamic_handle_names is not None:
            self.inputs["selected_input_dynamic_handle_names"] = (
                selected_input_dynamic_handle_names
            )
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationDatabricksNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_weaviate")
class IntegrationWeaviateNode(Node):
    """
    Weaviate

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### query_weaviate
        collection: Select the Weaviate collection to query
        embedding_model: Select the embedding model to use to embed the query
        properties: Comma-separated list of keywords to use
        query: Natural Language Query

    ## Outputs
    ### Common Outputs
        output: Output of the Query. Example: “Salmon…”
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Weaviate>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "Output of the Query. Example: “Salmon…”"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "query_weaviate": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "“Fish species in the South Pacific Ocean”",
                    "helper_text": "Natural Language Query",
                },
                {
                    "field": "embedding_model",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Embedding Model",
                    "placeholder": "Select Embedding Model",
                    "helper_text": "Select the embedding model to use to embed the query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {
                                "label": "OpenAI Text Embedding 3 Small",
                                "value": "openai/text-embedding-3-small",
                            },
                            {
                                "label": "OpenAI Text Embedding 3 Large",
                                "value": "openai/text-embedding-3-large",
                            },
                            {
                                "label": "OpenAI Text Embedding Ada 002",
                                "value": "openai/text-embedding-ada-002",
                            },
                            {
                                "label": "Cohere Embed English v3.0",
                                "value": "cohere/embed-english-v3.0",
                            },
                            {
                                "label": "Cohere Embed Multilingual v3.0",
                                "value": "cohere/embed-multilingual-v3.0",
                            },
                            {
                                "label": "Cohere Embed English Light v3.0",
                                "value": "cohere/embed-english-light-v3.0",
                            },
                            {
                                "label": "Cohere Embed Multilingual Light v3.0",
                                "value": "cohere/embed-multilingual-light-v3.0",
                            },
                        ],
                    },
                },
                {
                    "field": "collection",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Collection",
                    "placeholder": "Collection",
                    "helper_text": "Select the Weaviate collection to query",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": False,
                            "useSameEndpointForRefresh": False,
                        },
                    },
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "placeholder": "Properties",
                    "helper_text": "Comma-separated list of keywords to use",
                },
            ],
            "outputs": [],
            "name": "query_weaviate",
            "task_name": "tasks.vectordbs.integrations.weaviate.query",
            "description": "Query Weaviate data",
            "label": "Query Weaviate",
            "variant": "common_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        collection: str = "",
        embedding_model: str = "",
        properties: str = "",
        query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_weaviate",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if embedding_model is not None:
            self.inputs["embedding_model"] = embedding_model
        if collection is not None:
            self.inputs["collection"] = collection
        if properties is not None:
            self.inputs["properties"] = properties
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        Output of the Query. Example: “Salmon…”


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationWeaviateNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_bland_ai")
class IntegrationBlandAiNode(Node):
    """
    Bland AI

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### call_a_number
        first_sentence: The first sentence the AI should speak during the call
        model: LLM model that the AI should use
        pathway_id: This is the pathway ID for the pathway you have created on your dev portal.
        phone_number: The phone number of the contact you want to call
        task: The objective you want the AI to accomplish during the call
        temperature: A value between 0 and 1 that controls the randomness of the LLM. 0 will cause more deterministic outputs while 1 will cause more random
        transfer_number: A phone number that the agent can transfer to under specific conditions - such as being asked to speak to a human or supervisor
        wait_for_greeting: When checked, the agent will wait for the call recipient to speak first before responding

    ## Outputs
    ### Common Outputs
        answered_by: Possible values: Human: The call was answered by a human, Voicemail: The call was sent to voicemail, Unknown: There was not enough audio at the start of the call to make a determination, No-answer: The call was not answered, Null: Not enabled, or still processing the result
        transcript: The transcript of the call
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Bland AI>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "answered_by",
            "helper_text": "Possible values: Human: The call was answered by a human, Voicemail: The call was sent to voicemail, Unknown: There was not enough audio at the start of the call to make a determination, No-answer: The call was not answered, Null: Not enabled, or still processing the result",
        },
        {"field": "transcript", "helper_text": "The transcript of the call"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "call_a_number": {
            "inputs": [
                {
                    "field": "phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Phone Number",
                    "placeholder": "+1 6173149183",
                    "helper_text": "The phone number of the contact you want to call",
                },
                {
                    "field": "task",
                    "type": "string",
                    "value": "",
                    "label": "Task",
                    "placeholder": "Get the user's name and email",
                    "helper_text": "The objective you want the AI to accomplish during the call",
                },
                {
                    "field": "first_sentence",
                    "type": "string",
                    "value": "",
                    "label": "Enter First Sentence (Optional)",
                    "placeholder": "Hello, this is...",
                    "helper_text": "The first sentence the AI should speak during the call",
                },
                {
                    "field": "model",
                    "type": "enum<string>",
                    "value": "enhanced",
                    "label": "Select Model",
                    "placeholder": "enhanced",
                    "helper_text": "LLM model that the AI should use",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "pathway_id",
                    "type": "string",
                    "value": "",
                    "label": "Enter Pathway ID (Optional)",
                    "placeholder": "pathway_123",
                    "helper_text": "This is the pathway ID for the pathway you have created on your dev portal.",
                },
                {
                    "field": "temperature",
                    "type": "string",
                    "value": "",
                    "label": "Enter Temperature",
                    "placeholder": "0.7",
                    "helper_text": "A value between 0 and 1 that controls the randomness of the LLM. 0 will cause more deterministic outputs while 1 will cause more random",
                },
                {
                    "field": "transfer_number",
                    "type": "string",
                    "value": "",
                    "label": "Enter Transfer Number (Optional)",
                    "placeholder": "+12223334444",
                    "helper_text": "A phone number that the agent can transfer to under specific conditions - such as being asked to speak to a human or supervisor",
                },
                {
                    "field": "wait_for_greeting",
                    "type": "bool",
                    "value": False,
                    "label": "Select Wait for Greeting",
                    "placeholder": "false",
                    "helper_text": "When checked, the agent will wait for the call recipient to speak first before responding",
                },
            ],
            "outputs": [],
            "name": "call_a_number",
            "task_name": "tasks.bland_ai.call_a_number",
            "description": "Call a number using AI phone caller",
            "label": "Call a number",
            "variant": "bland_ai",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        first_sentence: str = "",
        model: str = "enhanced",
        pathway_id: str = "",
        phone_number: str = "",
        task: str = "",
        temperature: str = "",
        transfer_number: str = "",
        wait_for_greeting: bool = False,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_bland_ai",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if phone_number is not None:
            self.inputs["phone_number"] = phone_number
        if task is not None:
            self.inputs["task"] = task
        if first_sentence is not None:
            self.inputs["first_sentence"] = first_sentence
        if model is not None:
            self.inputs["model"] = model
        if pathway_id is not None:
            self.inputs["pathway_id"] = pathway_id
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if transfer_number is not None:
            self.inputs["transfer_number"] = transfer_number
        if wait_for_greeting is not None:
            self.inputs["wait_for_greeting"] = wait_for_greeting
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def answered_by(self) -> str:
        """
        Possible values: Human: The call was answered by a human, Voicemail: The call was sent to voicemail, Unknown: There was not enough audio at the start of the call to make a determination, No-answer: The call was not answered, Null: Not enabled, or still processing the result


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("answered_by")

    @property
    def transcript(self) -> str:
        """
        The transcript of the call


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("transcript")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationBlandAiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_algolia")
class IntegrationAlgoliaNode(Node):
    """
    Algolia

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### search_index
        index: An index where the data used by Algolia is stored
        query: Keyword to be searched in the index
        return_mode: Choose between returning as chunks or JSON

    ## Outputs
    ### Common Outputs
        output: Search results from the Algolia index in the specified format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Algolia>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "output",
            "helper_text": "Search results from the Algolia index in the specified format",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "search_index": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "“iPhone 16”",
                    "helper_text": "Keyword to be searched in the index",
                },
                {
                    "field": "index",
                    "type": "string",
                    "value": "",
                    "label": "Index",
                    "placeholder": "database",
                    "helper_text": "An index where the data used by Algolia is stored",
                },
                {
                    "field": "return_mode",
                    "type": "enum<string>",
                    "value": "json",
                    "label": "Return Mode",
                    "agent_field_type": "static",
                    "placeholder": "Choose between returning as chunks or JSON",
                    "helper_text": "Choose between returning as chunks or JSON",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "JSON", "value": "json"},
                            {"label": "Chunks", "value": "chunks"},
                        ],
                    },
                },
            ],
            "outputs": [],
            "name": "search_index",
            "task_name": "tasks.algolia.search_index",
            "description": "Query your Algolia index",
            "label": "Search Algolia index",
            "variant": "common_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        index: str = "",
        query: str = "",
        return_mode: str = "json",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_algolia",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if index is not None:
            self.inputs["index"] = index
        if return_mode is not None:
            self.inputs["return_mode"] = return_mode
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> Any:
        """
        Search results from the Algolia index in the specified format


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationAlgoliaNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_apollo")
class IntegrationApolloNode(Node):
    """
    Apollo

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### fetch_companies
        company_name: Name of the company to search
        keywords: Comma separated list of keywords the company should be associated with
        location: Location of the company headquarters
        max_size: Maximum number of employees in the company
        min_size: Minimum number of employees in the company
        num_results: Limit number of results
    ### enrich_contact
        company_name: Name of the company to search
        domain: Company domain
        first_name_input: Contact's first name
        last_name_input: Contact's last name
        linkedin_url_input: Contact's LinkedIn URL
    ### enrich_company
        domain: Company domain

    ## Outputs
    ### enrich_company
        annual_revenue: The company’s annual revenue e.g., 766400000000.0
        company_name: The company name e.g., Google
        country: The company’s headquartered country e.g., United States
        industry: The company’s industry e.g., information technology & services
        linkedin_url: The company’s Linkedin URL e.g., http://www.linkedin.com/company/google
        num_employees: The total number of employees e.g., 289000
        total_funding: The company’s total funding e.g., 3000000000000.0
        website: The company’s website e.g., http://www.google.com
    ### fetch_companies
        company_names: A list of company names e.g., ["VectorShift","VectorShift Studios"]
        domains: A list of domains e.g., ["vectorshift.ai","vectorshiftstudios.com"]
        linkedin_urls: A list of Linkedin URLs e.g., ["http://www.linkedin.com/company/vectorshift","http://www.linkedin.com/company/vectorshift-studios"]
        websites: A list of websites e.g., ["http://www.vectorshift.ai","http://www.vectorshiftstudios.com"]
    ### enrich_contact
        email: The person’s email address e.g., sundar@google.com
        first_name: The first name e.g., Sundar
        job_title: The person’s title e.g., CEO
        last_name: The last name e.g., Pichai
        linkedin_url: The person’s Linkedin e.g., https://www.linkedin.com/in/sundarpichai
        phone_number: The person’s phone number+10000000000
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Apollo>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "fetch_companies": {
            "inputs": [
                {
                    "field": "company_name",
                    "type": "string",
                    "value": "",
                    "label": "Company Name",
                    "placeholder": "VectorShift",
                    "helper_text": "Name of the company to search",
                },
                {
                    "field": "keywords",
                    "type": "string",
                    "value": "",
                    "label": "Keywords",
                    "placeholder": "AI, automation",
                    "helper_text": "Comma separated list of keywords the company should be associated with",
                },
                {
                    "field": "min_size",
                    "type": "string",
                    "value": "",
                    "label": "Min Size",
                    "placeholder": "10",
                    "helper_text": "Minimum number of employees in the company",
                },
                {
                    "field": "max_size",
                    "type": "string",
                    "value": "",
                    "label": "Max Size",
                    "placeholder": "100",
                    "helper_text": "Maximum number of employees in the company",
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "placeholder": "California, US",
                    "helper_text": "Location of the company headquarters",
                },
                {
                    "field": "num_results",
                    "type": "string",
                    "value": "",
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Limit number of results",
                },
            ],
            "outputs": [
                {
                    "field": "company_names",
                    "type": "string",
                    "helper_text": 'A list of company names e.g., ["VectorShift","VectorShift Studios"]',
                },
                {
                    "field": "websites",
                    "type": "string",
                    "helper_text": 'A list of websites e.g., ["http://www.vectorshift.ai","http://www.vectorshiftstudios.com"]',
                },
                {
                    "field": "domains",
                    "type": "string",
                    "helper_text": 'A list of domains e.g., ["vectorshift.ai","vectorshiftstudios.com"]',
                },
                {
                    "field": "linkedin_urls",
                    "type": "string",
                    "helper_text": 'A list of Linkedin URLs e.g., ["http://www.linkedin.com/company/vectorshift","http://www.linkedin.com/company/vectorshift-studios"]',
                },
            ],
            "name": "fetch_companies",
            "task_name": "tasks.apollo.fetch_companies",
            "description": "Search for companies via Apollo api",
            "label": "Search Companies",
        },
        "enrich_company": {
            "inputs": [
                {
                    "field": "domain",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "placeholder": "google.com",
                    "helper_text": "Company domain",
                }
            ],
            "outputs": [
                {
                    "field": "company_name",
                    "type": "string",
                    "helper_text": "The company name e.g., Google",
                },
                {
                    "field": "country",
                    "type": "string",
                    "helper_text": "The company’s headquartered country e.g., United States",
                },
                {
                    "field": "website",
                    "type": "string",
                    "helper_text": "The company’s website e.g., http://www.google.com",
                },
                {
                    "field": "industry",
                    "type": "string",
                    "helper_text": "The company’s industry e.g., information technology & services",
                },
                {
                    "field": "annual_revenue",
                    "type": "string",
                    "helper_text": "The company’s annual revenue e.g., 766400000000.0",
                },
                {
                    "field": "total_funding",
                    "type": "string",
                    "helper_text": "The company’s total funding e.g., 3000000000000.0",
                },
                {
                    "field": "num_employees",
                    "type": "string",
                    "helper_text": "The total number of employees e.g., 289000",
                },
                {
                    "field": "linkedin_url",
                    "type": "string",
                    "helper_text": "The company’s Linkedin URL e.g., http://www.linkedin.com/company/google",
                },
            ],
            "name": "enrich_company",
            "task_name": "tasks.apollo.enrich_company",
            "description": "Enrich company information via Apollo api",
            "label": "Enrich Company Information",
        },
        "enrich_contact": {
            "inputs": [
                {
                    "field": "domain",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "placeholder": "google.com",
                    "helper_text": "Contact's company domain",
                },
                {
                    "field": "first_name_input",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "Sundar",
                    "helper_text": "Contact's first name",
                },
                {
                    "field": "last_name_input",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Pichai",
                    "helper_text": "Contact's last name",
                },
                {
                    "field": "company_name",
                    "type": "string",
                    "value": "",
                    "label": "Company Name",
                    "placeholder": "Google",
                    "helper_text": "Contact's company name",
                },
                {
                    "field": "linkedin_url_input",
                    "type": "string",
                    "value": "",
                    "label": "LinkedIn URL",
                    "placeholder": "https://www.linkedin.com/in/sundarpichai",
                    "helper_text": "Contact's LinkedIn URL",
                },
            ],
            "outputs": [
                {
                    "field": "first_name",
                    "type": "string",
                    "helper_text": "The first name e.g., Sundar",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "helper_text": "The last name e.g., Pichai",
                },
                {
                    "field": "job_title",
                    "type": "string",
                    "helper_text": "The person’s title e.g., CEO",
                },
                {
                    "field": "phone_number",
                    "type": "string",
                    "helper_text": "The person’s phone number+10000000000",
                },
                {
                    "field": "email",
                    "type": "string",
                    "helper_text": "The person’s email address e.g., sundar@google.com",
                },
                {
                    "field": "linkedin_url",
                    "type": "string",
                    "helper_text": "The person’s Linkedin e.g., https://www.linkedin.com/in/sundarpichai",
                },
            ],
            "name": "enrich_contact",
            "task_name": "tasks.apollo.enrich_contact",
            "description": "Enrich a contact via Apollo api",
            "label": "Enrich Contact Details",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        company_name: str = "",
        domain: str = "",
        first_name_input: str = "",
        keywords: str = "",
        last_name_input: str = "",
        linkedin_url_input: str = "",
        location: str = "",
        max_size: str = "",
        min_size: str = "",
        num_results: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_apollo",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if company_name is not None:
            self.inputs["company_name"] = company_name
        if keywords is not None:
            self.inputs["keywords"] = keywords
        if min_size is not None:
            self.inputs["min_size"] = min_size
        if max_size is not None:
            self.inputs["max_size"] = max_size
        if location is not None:
            self.inputs["location"] = location
        if num_results is not None:
            self.inputs["num_results"] = num_results
        if domain is not None:
            self.inputs["domain"] = domain
        if first_name_input is not None:
            self.inputs["first_name_input"] = first_name_input
        if last_name_input is not None:
            self.inputs["last_name_input"] = last_name_input
        if linkedin_url_input is not None:
            self.inputs["linkedin_url_input"] = linkedin_url_input
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def annual_revenue(self) -> str:
        """
        The company’s annual revenue e.g., 766400000000.0

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("annual_revenue")

    @property
    def company_name(self) -> str:
        """
        The company name e.g., Google

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("company_name")

    @property
    def company_names(self) -> str:
        """
        A list of company names e.g., ["VectorShift","VectorShift Studios"]

        Available: fetch_companies


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("company_names")

    @property
    def country(self) -> str:
        """
        The company’s headquartered country e.g., United States

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("country")

    @property
    def domains(self) -> str:
        """
        A list of domains e.g., ["vectorshift.ai","vectorshiftstudios.com"]

        Available: fetch_companies


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("domains")

    @property
    def email(self) -> str:
        """
        The person’s email address e.g., sundar@google.com

        Available: enrich_contact


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email")

    @property
    def first_name(self) -> str:
        """
        The first name e.g., Sundar

        Available: enrich_contact


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("first_name")

    @property
    def industry(self) -> str:
        """
        The company’s industry e.g., information technology & services

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("industry")

    @property
    def job_title(self) -> str:
        """
        The person’s title e.g., CEO

        Available: enrich_contact


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("job_title")

    @property
    def last_name(self) -> str:
        """
        The last name e.g., Pichai

        Available: enrich_contact


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("last_name")

    @property
    def linkedin_url(self) -> str:
        """
        The company’s Linkedin URL e.g., http://www.linkedin.com/company/google

        Different behavior based on configuration:
          - The company’s Linkedin URL e.g., http://www.linkedin.com/company/google (enrich_company)
          - The person’s Linkedin e.g., https://www.linkedin.com/in/sundarpichai (enrich_contact)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("linkedin_url")

    @property
    def linkedin_urls(self) -> str:
        """
        A list of Linkedin URLs e.g., ["http://www.linkedin.com/company/vectorshift","http://www.linkedin.com/company/vectorshift-studios"]

        Available: fetch_companies


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("linkedin_urls")

    @property
    def num_employees(self) -> str:
        """
        The total number of employees e.g., 289000

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("num_employees")

    @property
    def phone_number(self) -> str:
        """
        The person’s phone number+10000000000

        Available: enrich_contact


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("phone_number")

    @property
    def total_funding(self) -> str:
        """
        The company’s total funding e.g., 3000000000000.0

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("total_funding")

    @property
    def website(self) -> str:
        """
        The company’s website e.g., http://www.google.com

        Available: enrich_company


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("website")

    @property
    def websites(self) -> str:
        """
        A list of websites e.g., ["http://www.vectorshift.ai","http://www.vectorshiftstudios.com"]

        Available: fetch_companies


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("websites")

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationApolloNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("zapier")
class ZapierNode(Node):
    """


    ## Inputs
    ### Common Inputs
        payload: Text/JSON payload to deliver
        webhook_url: the Zapier URL to deliver the payload to

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "payload",
            "helper_text": "Text/JSON payload to deliver",
            "value": "",
            "type": "string",
        },
        {
            "field": "webhook_url",
            "helper_text": "the Zapier URL to deliver the payload to",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        payload: str = "",
        webhook_url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="zapier",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if payload is not None:
            self.inputs["payload"] = payload
        if webhook_url is not None:
            self.inputs["webhook_url"] = webhook_url

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "ZapierNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("make")
class MakeNode(Node):
    """


    ## Inputs
    ### Common Inputs
        payload: Text/JSON payload to deliver
        webhook_url: the Make URL to deliver the payload to

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "payload",
            "helper_text": "Text/JSON payload to deliver",
            "value": "",
            "type": "string",
        },
        {
            "field": "webhook_url",
            "helper_text": "the Make URL to deliver the payload to",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        payload: str = "",
        webhook_url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="make",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if payload is not None:
            self.inputs["payload"] = payload
        if webhook_url is not None:
            self.inputs["webhook_url"] = webhook_url

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "MakeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("text_manipulation")
class TextManipulationNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="text_manipulation",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "TextManipulationNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("file_operations")
class FileOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="file_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "FileOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_operations")
class AiOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="ai_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "AiOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("file_to_text")
class FileToTextNode(Node):
    """
    Convert data from type File to type Text

    ## Inputs
    ### Common Inputs
        chunk_text: Whether to chunk the text into smaller pieces.
        file: The file to convert to text.
        file_parser: The type of file parser to use.
        loader_type: The type of file to load.
    ### When chunk_text = True
        chunk_overlap: The overlap of each chunk of text.
        chunk_size: The size of each chunk of text.

    ## Outputs
    ### When chunk_text = True
        processed_text: The text as a list of chunks.
    ### When chunk_text = False
        processed_text: The text as a string.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_text",
            "helper_text": "Whether to chunk the text into smaller pieces.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "file",
            "helper_text": "The file to convert to text.",
            "value": None,
            "type": "file",
        },
        {
            "field": "file_parser",
            "helper_text": "The type of file parser to use.",
            "value": "default",
            "type": "enum<string>",
        },
        {
            "field": "loader_type",
            "helper_text": "The type of file to load.",
            "value": "File",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "chunk_size",
                    "type": "int32",
                    "value": 1024,
                    "helper_text": "The size of each chunk of text.",
                },
                {
                    "field": "chunk_overlap",
                    "type": "int32",
                    "value": 400,
                    "helper_text": "The overlap of each chunk of text.",
                },
            ],
            "outputs": [
                {
                    "field": "processed_text",
                    "type": "vec<string>",
                    "helper_text": "The text as a list of chunks.",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "processed_text",
                    "type": "string",
                    "helper_text": "The text as a string.",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["chunk_text"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_text: bool = False,
        chunk_overlap: int = 400,
        chunk_size: int = 1024,
        file: Optional[str] = None,
        file_parser: str = "default",
        loader_type: str = "File",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["chunk_text"] = chunk_text

        super().__init__(
            node_type="file_to_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file is not None:
            self.inputs["file"] = file
        if chunk_text is not None:
            self.inputs["chunk_text"] = chunk_text
        if file_parser is not None:
            self.inputs["file_parser"] = file_parser
        if loader_type is not None:
            self.inputs["loader_type"] = loader_type
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def processed_text(self) -> List[str]:
        """
        The text as a list of chunks.

        Different behavior based on configuration:
          - The text as a list of chunks. (When chunk_text = True)
          - The text as a string. (When chunk_text = False)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_text")

    @classmethod
    def from_dict(cls, data: dict) -> "FileToTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("code_execution")
class CodeExecutionNode(Node):
    """


    ## Inputs
    ### Common Inputs
        code: The code input
        language: The language input

    ## Outputs
    ### Common Outputs
        outputs: The outputs output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "code",
            "helper_text": "The code input",
            "value": "",
            "type": "string",
        },
        {
            "field": "language",
            "helper_text": "The language input",
            "value": 0,
            "type": "enum<int32>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "outputs", "helper_text": "The outputs output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        code: str = "",
        language: int = 0,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="code_execution",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if code is not None:
            self.inputs["code"] = code
        if language is not None:
            self.inputs["language"] = language

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def outputs(self) -> str:
        """
        The outputs output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("outputs")

    @classmethod
    def from_dict(cls, data: dict) -> "CodeExecutionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("chunking")
class ChunkingNode(Node):
    """
    Split text into chunks. Supports different chunking strategies like markdown-aware, sentence-based, or dynamic sizing.

    ## Inputs
    ### Common Inputs
        chunk_overlap: The overlap of each chunk of text.
        chunk_size: The size of each chunk of text.
        splitter_method: Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.
        text: The text to chunk
    ### dynamic
        segmentation_method: The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.

    ## Outputs
    ### Common Outputs
        chunks: The chunks output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_overlap",
            "helper_text": "The overlap of each chunk of text.",
            "value": 0,
            "type": "int32",
        },
        {
            "field": "chunk_size",
            "helper_text": "The size of each chunk of text.",
            "value": 512,
            "type": "int32",
        },
        {
            "field": "splitter_method",
            "helper_text": "Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.",
            "value": "markdown",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to chunk",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "chunks", "helper_text": "The chunks output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "dynamic": {
            "inputs": [
                {
                    "field": "segmentation_method",
                    "type": "enum<string>",
                    "value": "words",
                    "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["splitter_method"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        splitter_method: str = "markdown",
        chunk_overlap: int = 0,
        chunk_size: int = 512,
        segmentation_method: str = "words",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["splitter_method"] = splitter_method

        super().__init__(
            node_type="chunking",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap
        if splitter_method is not None:
            self.inputs["splitter_method"] = splitter_method
        if segmentation_method is not None:
            self.inputs["segmentation_method"] = segmentation_method

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def chunks(self) -> List[str]:
        """
        The chunks output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("chunks")

    @classmethod
    def from_dict(cls, data: dict) -> "ChunkingNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("notifications")
class NotificationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="notifications",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "NotificationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("custom_smtp_email_sender")
class CustomSmtpEmailSenderNode(Node):
    """
    Send emails via SMTP

    ## Inputs
    ### Common Inputs
        connection_type: Security type: SSL, TLS, or STARTTLS
        email_body: Email content
        email_subject: Subject line of the email
        recipient_email: Recipient email address(es), comma-separated
        send_as_html: Send email in HTML format
        sender_email: Sender email address
        sender_name: Display name for sender (optional)
        sender_password: SMTP server password
        smtp_server: SMTP server hostname or IP
        smtp_server_port: SMTP server port (25, 465, 587)

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "connection_type",
            "helper_text": "Security type: SSL, TLS, or STARTTLS",
            "value": "SSL",
            "type": "enum<string>",
        },
        {
            "field": "email_body",
            "helper_text": "Email content",
            "value": "",
            "type": "string",
        },
        {
            "field": "email_subject",
            "helper_text": "Subject line of the email",
            "value": "",
            "type": "string",
        },
        {
            "field": "recipient_email",
            "helper_text": "Recipient email address(es), comma-separated",
            "value": "",
            "type": "string",
        },
        {
            "field": "send_as_html",
            "helper_text": "Send email in HTML format",
            "value": "",
            "type": "bool",
        },
        {
            "field": "sender_email",
            "helper_text": "Sender email address",
            "value": "",
            "type": "string",
        },
        {
            "field": "sender_name",
            "helper_text": "Display name for sender (optional)",
            "value": "",
            "type": "string",
        },
        {
            "field": "sender_password",
            "helper_text": "SMTP server password",
            "value": "",
            "type": "string",
        },
        {
            "field": "smtp_server",
            "helper_text": "SMTP server hostname or IP",
            "value": "",
            "type": "string",
        },
        {
            "field": "smtp_server_port",
            "helper_text": "SMTP server port (25, 465, 587)",
            "value": 465,
            "type": "int32",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        connection_type: str = "SSL",
        email_body: str = "",
        email_subject: str = "",
        recipient_email: str = "",
        send_as_html: bool = False,
        sender_email: str = "",
        sender_name: str = "",
        sender_password: str = "",
        smtp_server: str = "",
        smtp_server_port: int = 465,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="custom_smtp_email_sender",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if recipient_email is not None:
            self.inputs["recipient_email"] = recipient_email
        if email_subject is not None:
            self.inputs["email_subject"] = email_subject
        if email_body is not None:
            self.inputs["email_body"] = email_body
        if send_as_html is not None:
            self.inputs["send_as_html"] = send_as_html
        if smtp_server is not None:
            self.inputs["smtp_server"] = smtp_server
        if smtp_server_port is not None:
            self.inputs["smtp_server_port"] = smtp_server_port
        if sender_email is not None:
            self.inputs["sender_email"] = sender_email
        if sender_password is not None:
            self.inputs["sender_password"] = sender_password
        if sender_name is not None:
            self.inputs["sender_name"] = sender_name
        if connection_type is not None:
            self.inputs["connection_type"] = connection_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "CustomSmtpEmailSenderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("email_notification")
class EmailNotificationNode(Node):
    """
    Send email notifications from no-reply@vectorshiftmail.com

    ## Inputs
    ### Common Inputs
        email_body: Email content
        email_subject: Subject line of the email
        recipient_email: Recipient email address(es), comma-separated
        send_as_html: Send email in HTML format

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "email_body",
            "helper_text": "Email content",
            "value": "",
            "type": "string",
        },
        {
            "field": "email_subject",
            "helper_text": "Subject line of the email",
            "value": "",
            "type": "string",
        },
        {
            "field": "recipient_email",
            "helper_text": "Recipient email address(es), comma-separated",
            "value": "",
            "type": "string",
        },
        {
            "field": "send_as_html",
            "helper_text": "Send email in HTML format",
            "value": "",
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        email_body: str = "",
        email_subject: str = "",
        recipient_email: str = "",
        send_as_html: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="email_notification",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if recipient_email is not None:
            self.inputs["recipient_email"] = recipient_email
        if email_subject is not None:
            self.inputs["email_subject"] = email_subject
        if email_body is not None:
            self.inputs["email_body"] = email_body
        if send_as_html is not None:
            self.inputs["send_as_html"] = send_as_html

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "EmailNotificationNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("sms_notification")
class SmsNotificationNode(Node):
    """
    Send text message notifications.

    ## Inputs
    ### Common Inputs
        message: SMS message content
        phone_number: US phone number in country code (+1)

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "message",
            "helper_text": "SMS message content",
            "value": "",
            "type": "string",
        },
        {
            "field": "phone_number",
            "helper_text": "US phone number in country code (+1)",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        message: str = "",
        phone_number: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="sms_notification",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if phone_number is not None:
            self.inputs["phone_number"] = phone_number
        if message is not None:
            self.inputs["message"] = message

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "SmsNotificationNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_filter_list")
class AiFilterListNode(Node):
    """
    Filter items in a list given a specific AI condition. Example, Filter (Red, White, Boat) by whether it is a color: (Red, White)

    ## Inputs
    ### Common Inputs
        ai_condition: Write in natural language the condition to filter each item in the list
        filter_by: The items to filter the list by
        list_to_filter: The list to filter
        model: The specific model for filtering
        output_blank_value: If true, output a blank value for values that do not meet the filter condition. If false, nothing will be outputted
        provider: The model provider

    ## Outputs
    ### Common Outputs
        output: The filtered list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "ai_condition",
            "helper_text": "Write in natural language the condition to filter each item in the list",
            "value": "",
            "type": "string",
        },
        {
            "field": "filter_by",
            "helper_text": "The items to filter the list by",
            "value": "",
            "type": "vec<string>",
        },
        {
            "field": "list_to_filter",
            "helper_text": "The list to filter",
            "value": "",
            "type": "vec<string>",
        },
        {
            "field": "model",
            "helper_text": "The specific model for filtering",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "output_blank_value",
            "helper_text": "If true, output a blank value for values that do not meet the filter condition. If false, nothing will be outputted",
            "value": False,
            "type": "bool",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The filtered list"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        ai_condition: str = "",
        filter_by: List[str] = [],
        list_to_filter: List[str] = [],
        model: str = "gpt-4o",
        output_blank_value: bool = False,
        provider: str = "openai",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="ai_filter_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if list_to_filter is not None:
            self.inputs["list_to_filter"] = list_to_filter
        if filter_by is not None:
            self.inputs["filter_by"] = filter_by
        if ai_condition is not None:
            self.inputs["ai_condition"] = ai_condition
        if output_blank_value is not None:
            self.inputs["output_blank_value"] = output_blank_value
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[str]:
        """
        The filtered list


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "AiFilterListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("filter_list")
class FilterListNode(Node):
    """
    Filter a list given a specific condition. Example, Filter (Red, White, Blue) by (100, 95, 80)>90 is (Red, White)

    ## Inputs
    ### Common Inputs
        condition_type: The type of condition to apply
        condition_value: The value to compare the list items against
        output_blank_value: If true, output a blank value for values that do not meet the filter condition. If false, nothing will be outputted
        type: The type of the list
    ### <T>
        filter_by: The items to filter the list by
        list_to_filter: The list to filter

    ## Outputs
    ### <T>
        output: The filtered list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "condition_type",
            "helper_text": "The type of condition to apply",
            "value": "IsEmpty",
            "type": "enum<string>",
        },
        {
            "field": "condition_value",
            "helper_text": "The value to compare the list items against",
            "value": "",
            "type": "string",
        },
        {
            "field": "output_blank_value",
            "helper_text": "If true, output a blank value for values that do not meet the filter condition. If false, nothing will be outputted",
            "value": False,
            "type": "bool",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list_to_filter",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The list to filter",
                },
                {
                    "field": "filter_by",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The items to filter the list by",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The filtered list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        condition_type: str = "IsEmpty",
        condition_value: str = "",
        filter_by: List[Any] = [],
        list_to_filter: List[Any] = [],
        output_blank_value: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="filter_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if condition_type is not None:
            self.inputs["condition_type"] = condition_type
        if condition_value is not None:
            self.inputs["condition_value"] = condition_value
        if output_blank_value is not None:
            self.inputs["output_blank_value"] = output_blank_value
        if list_to_filter is not None:
            self.inputs["list_to_filter"] = list_to_filter
        if filter_by is not None:
            self.inputs["filter_by"] = filter_by

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> List[Any]:
        """
        The filtered list

        Available: <T>


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "FilterListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("sales_data_enrichment")
class SalesDataEnrichmentNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="sales_data_enrichment",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "SalesDataEnrichmentNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("email_validator")
class EmailValidatorNode(Node):
    """
    Validate an email address

    ## Inputs
    ### Common Inputs
        email_to_validate: The email you want to validate
        model: The validation model to use
    ### custom-validator
        api_key: The API key to use
        provider: The validation provider to use

    ## Outputs
    ### Common Outputs
        status: Whether the email is valid
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "email_to_validate",
            "helper_text": "The email you want to validate",
            "value": "",
            "type": "string",
        },
        {
            "field": "model",
            "helper_text": "The validation model to use",
            "value": "regex",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "status", "helper_text": "Whether the email is valid"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "custom-validator": {
            "inputs": [
                {
                    "field": "provider",
                    "type": "enum<string>",
                    "value": "hunter",
                    "helper_text": "The validation provider to use",
                },
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "The API key to use",
                },
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["model"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        model: str = "regex",
        api_key: str = "",
        email_to_validate: str = "",
        provider: str = "hunter",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["model"] = model

        super().__init__(
            node_type="email_validator",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if email_to_validate is not None:
            self.inputs["email_to_validate"] = email_to_validate
        if model is not None:
            self.inputs["model"] = model
        if provider is not None:
            self.inputs["provider"] = provider
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def status(self) -> bool:
        """
        Whether the email is valid


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("status")

    @classmethod
    def from_dict(cls, data: dict) -> "EmailValidatorNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("combine_text")
class CombineTextNode(Node):
    """
    Combine text inputs into a singular output.

    ## Inputs
    ### Common Inputs
        text: The text to combine

    ## Outputs
    ### Common Outputs
        processed_text: The combined text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "text",
            "helper_text": "The text to combine",
            "value": ["", ""],
            "type": "vec<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "processed_text", "helper_text": "The combined text"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        text: List[str] = ["", ""],
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="combine_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def processed_text(self) -> str:
        """
        The combined text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_text")

    @classmethod
    def from_dict(cls, data: dict) -> "CombineTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("find_and_replace")
class FindAndReplaceNode(Node):
    """
    Find and replace words in a given text.

    ## Inputs
    ### Common Inputs
        replacements: The replacements input
        text_to_manipulate: The text to find and replace words in

    ## Outputs
    ### Common Outputs
        processed_text: The final text with found words replaced
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "replacements",
            "helper_text": "The replacements input",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "text_to_manipulate",
            "helper_text": "The text to find and replace words in",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "processed_text",
            "helper_text": "The final text with found words replaced",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        replacements: List[Any] = [],
        text_to_manipulate: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="find_and_replace",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text_to_manipulate is not None:
            self.inputs["text_to_manipulate"] = text_to_manipulate
        if replacements is not None:
            self.inputs["replacements"] = replacements

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def processed_text(self) -> str:
        """
        The final text with found words replaced


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("processed_text")

    @classmethod
    def from_dict(cls, data: dict) -> "FindAndReplaceNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_fill_pdf")
class AiFillPdfNode(Node):
    """
    Fill out a PDF with form fields using AI. The AI will understand and fill each field using provided context. To convert your PDF to have fillable input fields, use: https://www.sejda.com/pdf-forms

    ## Inputs
    ### Common Inputs
        context: Context used by LLM to fill PDF fields
        file: The PDF with form fields to be filled
        model: The specific model for filling the PDF
        provider: The model provider
        select_pages: Whether to select specific pages to fill
    ### When select_pages = True
        selected_pages: PDF page range

    ## Outputs
    ### Common Outputs
        filled_pdf: Filled PDF
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "context",
            "helper_text": "Context used by LLM to fill PDF fields",
            "value": "",
            "type": "string",
        },
        {
            "field": "file",
            "helper_text": "The PDF with form fields to be filled",
            "value": None,
            "type": "file",
        },
        {
            "field": "model",
            "helper_text": "The specific model for filling the PDF",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "select_pages",
            "helper_text": "Whether to select specific pages to fill",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "filled_pdf", "helper_text": "Filled PDF"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "selected_pages",
                    "type": "string",
                    "value": "",
                    "helper_text": "PDF page range",
                }
            ],
            "outputs": [],
        },
        "false": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["select_pages"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        select_pages: bool = False,
        context: str = "",
        file: Optional[str] = None,
        model: str = "gpt-4o",
        provider: str = "openai",
        selected_pages: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["select_pages"] = select_pages

        super().__init__(
            node_type="ai_fill_pdf",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file is not None:
            self.inputs["file"] = file
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if select_pages is not None:
            self.inputs["select_pages"] = select_pages
        if context is not None:
            self.inputs["context"] = context
        if selected_pages is not None:
            self.inputs["selected_pages"] = selected_pages

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def filled_pdf(self) -> str:
        """
        Filled PDF


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("filled_pdf")

    @classmethod
    def from_dict(cls, data: dict) -> "AiFillPdfNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("extract_to_table")
class ExtractToTableNode(Node):
    """
    Extract data to a CSV using AI

    ## Inputs
    ### Common Inputs
        add_columns_manually: Add data points for some columns manually instead of having them extracted by the AI model.
        additional_context: Provide any additional context that may help the AI model extract the data.
        extract_multiple_rows: Choose the mode of extraction. If checked, it will extract multiple rows of data. If unchecked, it will extract a single row.
        file: Your file should contain headers in the first row.
        manual_columns: Pass in data to column names manually.
        model: The specific model for extracting the table
        provider: The model provider
        text_for_extraction: Text to extract table from

    ## Outputs
    ### Common Outputs
        table: The table extracted from the text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "add_columns_manually",
            "helper_text": "Add data points for some columns manually instead of having them extracted by the AI model.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "additional_context",
            "helper_text": "Provide any additional context that may help the AI model extract the data.",
            "value": "",
            "type": "string",
        },
        {
            "field": "extract_multiple_rows",
            "helper_text": "Choose the mode of extraction. If checked, it will extract multiple rows of data. If unchecked, it will extract a single row.",
            "value": True,
            "type": "bool",
        },
        {
            "field": "file",
            "helper_text": "Your file should contain headers in the first row.",
            "value": "",
            "type": "file",
        },
        {
            "field": "manual_columns",
            "helper_text": "Pass in data to column names manually.",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "model",
            "helper_text": "The specific model for extracting the table",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text_for_extraction",
            "helper_text": "Text to extract table from",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "table", "helper_text": "The table extracted from the text"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        add_columns_manually: bool = False,
        additional_context: str = "",
        extract_multiple_rows: bool = True,
        file: str = "",
        manual_columns: List[Any] = [],
        model: str = "gpt-4o",
        provider: str = "openai",
        text_for_extraction: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="extract_to_table",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text_for_extraction is not None:
            self.inputs["text_for_extraction"] = text_for_extraction
        if extract_multiple_rows is not None:
            self.inputs["extract_multiple_rows"] = extract_multiple_rows
        if add_columns_manually is not None:
            self.inputs["add_columns_manually"] = add_columns_manually
        if manual_columns is not None:
            self.inputs["manual_columns"] = manual_columns
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if file is not None:
            self.inputs["file"] = file

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def table(self) -> str:
        """
        The table extracted from the text


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("table")

    @classmethod
    def from_dict(cls, data: dict) -> "ExtractToTableNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("sort_csv")
class SortCsvNode(Node):
    """
    Sort a CSV based on a column

    ## Inputs
    ### Common Inputs
        file: The CSV file to sort.
        has_headers: Whether the CSV has headers.
        is_file_variable: Whether the file is a variable.
        reverse_sort: Whether to reverse the sort.
    ### When is_file_variable = True
        column_index: The index of the column to sort by.
    ### When is_file_variable = False and has_headers = False
        column_index: The index of the column to sort by.
    ### When is_file_variable = False and has_headers = True
        column_to_sort_by: The column to sort by.

    ## Outputs
    ### Common Outputs
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file",
            "helper_text": "The CSV file to sort.",
            "value": None,
            "type": "file",
        },
        {
            "field": "has_headers",
            "helper_text": "Whether the CSV has headers.",
            "value": True,
            "type": "bool",
        },
        {
            "field": "is_file_variable",
            "helper_text": "Whether the file is a variable.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "reverse_sort",
            "helper_text": "Whether to reverse the sort.",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The output output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**(*)": {
            "inputs": [
                {
                    "field": "column_index",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The index of the column to sort by.",
                }
            ],
            "outputs": [],
        },
        "false**true": {
            "inputs": [
                {
                    "field": "column_to_sort_by",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "The column to sort by.",
                }
            ],
            "outputs": [],
        },
        "false**false": {
            "inputs": [
                {
                    "field": "column_index",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The index of the column to sort by.",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["is_file_variable", "has_headers"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        is_file_variable: bool = False,
        has_headers: bool = True,
        column_index: int = 0,
        column_to_sort_by: str = "",
        file: Optional[str] = None,
        reverse_sort: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["is_file_variable"] = is_file_variable
        params["has_headers"] = has_headers

        super().__init__(
            node_type="sort_csv",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if is_file_variable is not None:
            self.inputs["is_file_variable"] = is_file_variable
        if file is not None:
            self.inputs["file"] = file
        if has_headers is not None:
            self.inputs["has_headers"] = has_headers
        if reverse_sort is not None:
            self.inputs["reverse_sort"] = reverse_sort
        if column_index is not None:
            self.inputs["column_index"] = column_index
        if column_to_sort_by is not None:
            self.inputs["column_to_sort_by"] = column_to_sort_by

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def output(self) -> str:
        """
        The output output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("output")

    @classmethod
    def from_dict(cls, data: dict) -> "SortCsvNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("trigger_outlook")
class TriggerOutlookNode(Node):
    """
    Outlook Trigger

    ## Inputs
    ### Common Inputs
        event: The event input
        integration: The integration input
        item_id: Select the Trigger
        trigger_enabled: Enable/Disable Automation

    ## Outputs
    ### new_email
        attachments: The attachments output
        contents_of_email: The contents_of_email output
        email_id: The email_id output
        received_time: The received_time output
        recipient_email: The recipient_email output
        sender_email: The sender_email output
        subject: The subject output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "event",
            "helper_text": "The event input",
            "value": "",
            "type": "enum<string>",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Outlook>",
        },
        {
            "field": "item_id",
            "helper_text": "Select the Trigger",
            "value": "",
            "type": "string",
        },
        {
            "field": "trigger_enabled",
            "helper_text": "Enable/Disable Automation",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new_email": {
            "inputs": [],
            "outputs": [
                {"field": "email_id", "type": "string"},
                {"field": "subject", "type": "string"},
                {"field": "sender_email", "type": "string"},
                {"field": "recipient_email", "type": "string"},
                {"field": "received_time", "type": "string"},
                {"field": "contents_of_email", "type": "string"},
                {"field": "attachments", "type": "vec<file>"},
            ],
            "name": "new_email",
            "task_name": "tasks.outlook.new_email",
            "description": "Triggers when new email appears in the specified mailbox",
            "label": "New Email",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["event"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        event: str = "",
        item_id: str = "",
        trigger_enabled: bool = True,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["event"] = event

        super().__init__(
            node_type="trigger_outlook",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if event is not None:
            self.inputs["event"] = event
        if trigger_enabled is not None:
            self.inputs["trigger_enabled"] = trigger_enabled
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attachments(self) -> List[str]:
        """
        The attachments output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attachments")

    @property
    def contents_of_email(self) -> str:
        """
        The contents_of_email output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("contents_of_email")

    @property
    def email_id(self) -> str:
        """
        The email_id output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_id")

    @property
    def received_time(self) -> str:
        """
        The received_time output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("received_time")

    @property
    def recipient_email(self) -> str:
        """
        The recipient_email output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("recipient_email")

    @property
    def sender_email(self) -> str:
        """
        The sender_email output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("sender_email")

    @property
    def subject(self) -> str:
        """
        The subject output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("subject")

    @classmethod
    def from_dict(cls, data: dict) -> "TriggerOutlookNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("trigger_gmail")
class TriggerGmailNode(Node):
    """
    Gmail Trigger

    ## Inputs
    ### Common Inputs
        event: The event input
        integration: The integration input
        item_id: Select the Trigger
        trigger_enabled: Enable/Disable Automation

    ## Outputs
    ### new_email
        attachments: The attachments output
        contents_of_email: The contents_of_email output
        email_id: The email_id output
        received_time: The received_time output
        recipient_email: The recipient_email output
        sender_email: The sender_email output
        subject: The subject output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "event",
            "helper_text": "The event input",
            "value": "",
            "type": "enum<string>",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Gmail>",
        },
        {
            "field": "item_id",
            "helper_text": "Select the Trigger",
            "value": "",
            "type": "string",
        },
        {
            "field": "trigger_enabled",
            "helper_text": "Enable/Disable Automation",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new_email": {
            "inputs": [],
            "outputs": [
                {"field": "email_id", "type": "string"},
                {"field": "subject", "type": "string"},
                {"field": "sender_email", "type": "string"},
                {"field": "recipient_email", "type": "string"},
                {"field": "received_time", "type": "string"},
                {"field": "contents_of_email", "type": "string"},
                {"field": "attachments", "type": "vec<file>"},
            ],
            "name": "new_email",
            "task_name": "tasks.gmail.new_email",
            "description": "Triggers when new email appears in the specified mailbox",
            "label": "New Email",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["event"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        event: str = "",
        item_id: str = "",
        trigger_enabled: bool = True,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["event"] = event

        super().__init__(
            node_type="trigger_gmail",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if event is not None:
            self.inputs["event"] = event
        if trigger_enabled is not None:
            self.inputs["trigger_enabled"] = trigger_enabled
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attachments(self) -> List[str]:
        """
        The attachments output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attachments")

    @property
    def contents_of_email(self) -> str:
        """
        The contents_of_email output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("contents_of_email")

    @property
    def email_id(self) -> str:
        """
        The email_id output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("email_id")

    @property
    def received_time(self) -> str:
        """
        The received_time output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("received_time")

    @property
    def recipient_email(self) -> str:
        """
        The recipient_email output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("recipient_email")

    @property
    def sender_email(self) -> str:
        """
        The sender_email output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("sender_email")

    @property
    def subject(self) -> str:
        """
        The subject output

        Available: new_email


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("subject")

    @classmethod
    def from_dict(cls, data: dict) -> "TriggerGmailNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("trigger_cron")
class TriggerCronNode(Node):
    """
    Cron Trigger

    ## Inputs
    ### Common Inputs
        event: The event input
        integration: The integration input
        item_id: Custom cron expression
        timezone: Timezone for the cron trigger
        trigger_enabled: Enable/Disable Automation
    ### monthly
        day_of_month: Day of the month to trigger
        time_of_day: Time of day to trigger (HH:MM)
    ### weekly
        day_of_week: Day of the week to trigger
        time_of_day: Time of day to trigger (HH:MM)
    ### daily
        time_of_day: Time of day to trigger (HH:MM)
        trigger_on_weekends: Trigger on weekends

    ## Outputs
    ### Common Outputs
        timestamp: The timestamp output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "event",
            "helper_text": "The event input",
            "value": "",
            "type": "enum<string>",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": {"object_type": 20, "object_id": "6809a715ad4615eeb652a551"},
            "type": "integration<Cron>",
        },
        {
            "field": "item_id",
            "helper_text": "Custom cron expression",
            "value": "0 0 * * *",
            "type": "string",
        },
        {
            "field": "timezone",
            "helper_text": "Timezone for the cron trigger",
            "value": "UTC",
            "type": "enum<string>",
        },
        {
            "field": "trigger_enabled",
            "helper_text": "Enable/Disable Automation",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "timestamp", "helper_text": "The timestamp output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "daily": {
            "inputs": [
                {
                    "field": "time_of_day",
                    "type": "string",
                    "value": "00:00",
                    "label": "Time of day",
                    "placeholder": "HH:MM",
                    "helper_text": "Time of day to trigger (HH:MM)",
                },
                {
                    "field": "trigger_on_weekends",
                    "type": "bool",
                    "value": False,
                    "label": "Trigger on weekends",
                    "helper_text": "Trigger on weekends",
                },
            ],
            "outputs": [],
            "name": "daily",
            "task_name": "tasks.cron.daily",
            "description": "Triggers once a day at a specified time",
            "label": "Daily",
        },
        "weekly": {
            "inputs": [
                {
                    "field": "day_of_week",
                    "type": "enum<string>",
                    "value": "Monday",
                    "label": "Day of the week",
                    "placeholder": "Select a day",
                    "helper_text": "Day of the week to trigger",
                },
                {
                    "field": "time_of_day",
                    "type": "string",
                    "value": "00:00",
                    "label": "Time of day",
                    "placeholder": "HH:MM",
                    "helper_text": "Time of day to trigger (HH:MM)",
                },
            ],
            "outputs": [],
            "name": "weekly",
            "task_name": "tasks.cron.weekly",
            "description": "Triggers once a week on a specified day and time",
            "label": "Weekly",
        },
        "monthly": {
            "inputs": [
                {
                    "field": "day_of_month",
                    "type": "int32",
                    "value": 1,
                    "label": "Day of the month",
                    "placeholder": "Select a day",
                    "helper_text": "Day of the month to trigger",
                },
                {
                    "field": "time_of_day",
                    "type": "string",
                    "value": "00:00",
                    "label": "Time of day",
                    "placeholder": "HH:MM",
                    "helper_text": "Time of day to trigger (HH:MM)",
                },
            ],
            "outputs": [],
            "name": "monthly",
            "task_name": "tasks.cron.monthly",
            "description": "Triggers once a month on a specified day and time",
            "label": "Monthly",
        },
        "custom": {
            "inputs": [],
            "outputs": [],
            "name": "custom",
            "task_name": "tasks.cron.custom",
            "description": "Triggers based on a custom cron expression",
            "label": "Custom Cron Expression",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["event"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        event: str = "",
        day_of_month: int = 1,
        day_of_week: str = "Monday",
        item_id: str = "0 0 * * *",
        time_of_day: str = "00:00",
        timezone: str = "UTC",
        trigger_enabled: bool = True,
        trigger_on_weekends: bool = False,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["event"] = event

        super().__init__(
            node_type="trigger_cron",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if event is not None:
            self.inputs["event"] = event
        if trigger_enabled is not None:
            self.inputs["trigger_enabled"] = trigger_enabled
        if timezone is not None:
            self.inputs["timezone"] = timezone
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if time_of_day is not None:
            self.inputs["time_of_day"] = time_of_day
        if trigger_on_weekends is not None:
            self.inputs["trigger_on_weekends"] = trigger_on_weekends
        if day_of_week is not None:
            self.inputs["day_of_week"] = day_of_week
        if day_of_month is not None:
            self.inputs["day_of_month"] = day_of_month
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def timestamp(self) -> str:
        """
        The timestamp output


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("timestamp")

    @classmethod
    def from_dict(cls, data: dict) -> "TriggerCronNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("trigger_slack")
class TriggerSlackNode(Node):
    """
    Slack Trigger

    ## Inputs
    ### Common Inputs
        channel: The name of the Slack channel
        event: The event input
        integration: The integration input
        item_id: The item_id input
        team: The name of the Slack team
        trigger_enabled: Enable/Disable Automation

    ## Outputs
    ### new_message
        attachments: Files attached to the message
        channel_id: Unique identifier of the channel where the message was sent
        channel_name: Name of the channel where the message was sent
        message: The content of the message
        message_id: Unique identifier for the message
        permalink: Direct link to access this message
        timestamp: When the message was sent
        user_id: Unique identifier of the message sender
        user_name: Display name of the message sender
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "channel",
            "helper_text": "The name of the Slack channel",
            "value": "",
            "type": "string",
        },
        {
            "field": "event",
            "helper_text": "The event input",
            "value": "",
            "type": "enum<string>",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Slack>",
        },
        {
            "field": "item_id",
            "helper_text": "The item_id input",
            "value": "",
            "type": "string",
        },
        {
            "field": "team",
            "helper_text": "The name of the Slack team",
            "value": "",
            "type": "string",
        },
        {
            "field": "trigger_enabled",
            "helper_text": "Enable/Disable Automation",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new_message": {
            "inputs": [],
            "outputs": [
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "The content of the message",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "Unique identifier for the message",
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "helper_text": "When the message was sent",
                },
                {
                    "field": "user_name",
                    "type": "string",
                    "helper_text": "Display name of the message sender",
                },
                {
                    "field": "user_id",
                    "type": "string",
                    "helper_text": "Unique identifier of the message sender",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "helper_text": "Files attached to the message",
                },
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "Unique identifier of the channel where the message was sent",
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "helper_text": "Name of the channel where the message was sent",
                },
                {
                    "field": "permalink",
                    "type": "string",
                    "helper_text": "Direct link to access this message",
                },
            ],
            "name": "new_message",
            "task_name": "tasks.slack.new_message",
            "description": "Triggers when new message appears in the specified channel",
            "label": "New Message",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["event"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        event: str = "",
        channel: str = "",
        item_id: str = "",
        team: str = "",
        trigger_enabled: bool = True,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["event"] = event

        super().__init__(
            node_type="trigger_slack",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if event is not None:
            self.inputs["event"] = event
        if trigger_enabled is not None:
            self.inputs["trigger_enabled"] = trigger_enabled
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if team is not None:
            self.inputs["team"] = team
        if channel is not None:
            self.inputs["channel"] = channel
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def attachments(self) -> List[str]:
        """
        Files attached to the message

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("attachments")

    @property
    def channel_id(self) -> str:
        """
        Unique identifier of the channel where the message was sent

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("channel_id")

    @property
    def channel_name(self) -> str:
        """
        Name of the channel where the message was sent

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("channel_name")

    @property
    def message(self) -> str:
        """
        The content of the message

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("message")

    @property
    def message_id(self) -> str:
        """
        Unique identifier for the message

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("message_id")

    @property
    def permalink(self) -> str:
        """
        Direct link to access this message

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("permalink")

    @property
    def timestamp(self) -> str:
        """
        When the message was sent

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("timestamp")

    @property
    def user_id(self) -> str:
        """
        Unique identifier of the message sender

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("user_id")

    @property
    def user_name(self) -> str:
        """
        Display name of the message sender

        Available: new_message


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("user_name")

    @classmethod
    def from_dict(cls, data: dict) -> "TriggerSlackNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base_actions")
class KnowledgeBaseActionsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="knowledge_base_actions",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseActionsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base_sync")
class KnowledgeBaseSyncNode(Node):
    """
    Automatically trigger a sync to the integrations in the selected knowledge base

    ## Inputs
    ### Common Inputs
        knowledge_base: The knowledge base to sync

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "knowledge_base",
            "helper_text": "The knowledge base to sync",
            "value": {},
            "type": "knowledge_base",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        knowledge_base: Any = {},
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="knowledge_base_sync",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if knowledge_base is not None:
            self.inputs["knowledge_base"] = knowledge_base

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseSyncNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base_create")
class KnowledgeBaseCreateNode(Node):
    """
    Dynamically create a Knowledge Base with configured options

    ## Inputs
    ### Common Inputs
        analyze_documents: To analyze document contents and enrich them when parsing
        apify_key: Apify API Key for scraping URLs (optional)
        chunk_overlap: The overlap of the chunks to store in the knowledge base
        chunk_size: The size of the chunks to store in the knowledge base
        collection_name: The name of the collection to store the knowledge base in
        embedding_model: LLM model to use for embedding documents in the KB
        embedding_provider: The embedding provider to use
        file_processing_implementation: The file processing implementation to use
        is_hybrid: Whether to create a hybrid knowledge base
        name: The name of the knowledge base
        precision: The precision to use for the knowledge base
        segmentation_method: The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.
        sharded: Whether to shard the knowledge base
        splitter_method: Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.
        vector_db_provider: The vector database provider to use

    ## Outputs
    ### Common Outputs
        knowledge_base: The created knowledge base
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "analyze_documents",
            "helper_text": "To analyze document contents and enrich them when parsing",
            "value": False,
            "type": "bool",
        },
        {
            "field": "apify_key",
            "helper_text": "Apify API Key for scraping URLs (optional)",
            "value": "",
            "type": "string",
        },
        {
            "field": "chunk_overlap",
            "helper_text": "The overlap of the chunks to store in the knowledge base",
            "value": 0,
            "type": "int32",
        },
        {
            "field": "chunk_size",
            "helper_text": "The size of the chunks to store in the knowledge base",
            "value": 400,
            "type": "int32",
        },
        {
            "field": "collection_name",
            "helper_text": "The name of the collection to store the knowledge base in",
            "value": "text-embedding-3-small",
            "type": "string",
        },
        {
            "field": "embedding_model",
            "helper_text": "LLM model to use for embedding documents in the KB",
            "value": "text-embedding-3-small",
            "type": "string",
        },
        {
            "field": "embedding_provider",
            "helper_text": "The embedding provider to use",
            "value": "openai",
            "type": "string",
        },
        {
            "field": "file_processing_implementation",
            "helper_text": "The file processing implementation to use",
            "value": "default",
            "type": "string",
        },
        {
            "field": "is_hybrid",
            "helper_text": "Whether to create a hybrid knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "name",
            "helper_text": "The name of the knowledge base",
            "value": "",
            "type": "string",
        },
        {
            "field": "precision",
            "helper_text": "The precision to use for the knowledge base",
            "value": "Float16",
            "type": "string",
        },
        {
            "field": "segmentation_method",
            "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
            "value": "words",
            "type": "enum<string>",
        },
        {
            "field": "sharded",
            "helper_text": "Whether to shard the knowledge base",
            "value": True,
            "type": "bool",
        },
        {
            "field": "splitter_method",
            "helper_text": "Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.",
            "value": "markdown",
            "type": "enum<string>",
        },
        {
            "field": "vector_db_provider",
            "helper_text": "The vector database provider to use",
            "value": "qdrant",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "knowledge_base", "helper_text": "The created knowledge base"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "advanced": {
            "inputs": [
                {
                    "field": "segmentation_method",
                    "type": "enum<string>",
                    "value": "words",
                    "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["splitter_method"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        splitter_method: str = "markdown",
        analyze_documents: bool = False,
        apify_key: str = "",
        chunk_overlap: int = 0,
        chunk_size: int = 400,
        collection_name: str = "text-embedding-3-small",
        embedding_model: str = "text-embedding-3-small",
        embedding_provider: str = "openai",
        file_processing_implementation: str = "default",
        is_hybrid: bool = False,
        name: str = "",
        precision: str = "Float16",
        segmentation_method: str = "words",
        sharded: bool = True,
        vector_db_provider: str = "qdrant",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["splitter_method"] = splitter_method

        super().__init__(
            node_type="knowledge_base_create",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if name is not None:
            self.inputs["name"] = name
        if file_processing_implementation is not None:
            self.inputs["file_processing_implementation"] = (
                file_processing_implementation
            )
        if vector_db_provider is not None:
            self.inputs["vector_db_provider"] = vector_db_provider
        if collection_name is not None:
            self.inputs["collection_name"] = collection_name
        if embedding_model is not None:
            self.inputs["embedding_model"] = embedding_model
        if embedding_provider is not None:
            self.inputs["embedding_provider"] = embedding_provider
        if precision is not None:
            self.inputs["precision"] = precision
        if sharded is not None:
            self.inputs["sharded"] = sharded
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap
        if splitter_method is not None:
            self.inputs["splitter_method"] = splitter_method
        if segmentation_method is not None:
            self.inputs["segmentation_method"] = segmentation_method
        if analyze_documents is not None:
            self.inputs["analyze_documents"] = analyze_documents
        if is_hybrid is not None:
            self.inputs["is_hybrid"] = is_hybrid
        if apify_key is not None:
            self.inputs["apify_key"] = apify_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def knowledge_base(self) -> Any:
        """
        The created knowledge base


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("knowledge_base")

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseCreateNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("share_object")
class ShareObjectNode(Node):
    """
    Share a VectorShift object with another user

    ## Inputs
    ### Common Inputs
        object_type: The object_type input
        org_name: Enter the name of the organization of the user (leave blank if not part of org)
        user_identifier: Enter the username or email of the user you want to share with
    ### knowledge_base
        object: The object input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "object_type",
            "helper_text": "The object_type input",
            "value": "knowledge_base",
            "type": "enum<string>",
        },
        {
            "field": "org_name",
            "helper_text": "Enter the name of the organization of the user (leave blank if not part of org)",
            "value": "",
            "type": "string",
        },
        {
            "field": "user_identifier",
            "helper_text": "Enter the username or email of the user you want to share with",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "knowledge_base": {
            "inputs": [{"field": "object", "type": "knowledge_base"}],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["object_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        object_type: str = "knowledge_base",
        object: Optional[Any] = None,
        org_name: str = "",
        user_identifier: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["object_type"] = object_type

        super().__init__(
            node_type="share_object",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if object_type is not None:
            self.inputs["object_type"] = object_type
        if user_identifier is not None:
            self.inputs["user_identifier"] = user_identifier
        if org_name is not None:
            self.inputs["org_name"] = org_name
        if object is not None:
            self.inputs["object"] = object

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "ShareObjectNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("rename_file")
class RenameFileNode(Node):
    """
    Rename an existing file, assigning a new name along with the file extension

    ## Inputs
    ### Common Inputs
        file: The file to rename.
        new_name: The new name of the file, including its extension (e.g., file.txt, file.pdf, file.csv)

    ## Outputs
    ### Common Outputs
        renamed_file: The renamed file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file",
            "helper_text": "The file to rename.",
            "value": None,
            "type": "file",
        },
        {
            "field": "new_name",
            "helper_text": "The new name of the file, including its extension (e.g., file.txt, file.pdf, file.csv)",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "renamed_file", "helper_text": "The renamed file"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        file: Optional[str] = None,
        new_name: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="rename_file",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file is not None:
            self.inputs["file"] = file
        if new_name is not None:
            self.inputs["new_name"] = new_name

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def renamed_file(self) -> str:
        """
        The renamed file


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("renamed_file")

    @classmethod
    def from_dict(cls, data: dict) -> "RenameFileNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("start_flag")
class StartFlagNode(Node):
    """
    Start Flag

    ## Inputs
        None

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = []

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="start_flag",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "StartFlagNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("talk")
class TalkNode(Node):
    """
    Send a given message at a stage in a conversation.

    ## Inputs
    ### Common Inputs
        is_iframe: The is_iframe input
        variant: The variant input
    ### When variant = 'card'
        button: The button input
        content: The text to send to the user.
        description: The card’s description.
        image_url: The image to be sent at this step in the conversation.
        title: The card’s title.
    ### When variant = 'carousel'
        cards: The cards input
    ### When variant = 'message' and is_iframe = False
        content: The text to send to the user.
    ### When variant = 'message' and is_iframe = True
        content: The text to send to the user.
    ### When variant = 'image'
        image_url: The image to be sent at this step in the conversation.

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "is_iframe",
            "helper_text": "The is_iframe input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "variant",
            "helper_text": "The variant input",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "message**false": {
            "title": "Message",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/message",
            "helper_text": "Send a given message at a stage in a conversation.",
            "short_description": "Send a given message at a stage in a conversation.",
            "inputs": [
                {
                    "field": "content",
                    "type": "string",
                    "helper_text": "The text to send to the user.",
                    "value": "",
                },
                {"field": "variant", "type": "string", "value": "message"},
            ],
            "outputs": [],
        },
        "message**true": {
            "title": "Message",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/message",
            "helper_text": "Send a given message at a stage in a conversation.",
            "short_description": "Send a given iframe at a stage in a conversation.",
            "inputs": [
                {
                    "field": "content",
                    "type": "string",
                    "helper_text": "The text to send to the user.",
                    "value": "<iframe src='ENTER_URL_HERE' width='320px' height='400px'></iframe>",
                },
                {"field": "variant", "type": "string", "value": "message"},
            ],
            "outputs": [],
            "banner_text": "Please add your url in 'ENTER_URL_HERE'. Iframe width should be 320px",
        },
        "image**(*)": {
            "title": "Image",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/image",
            "helper_text": "Send an image in chat at this step in the conversation.",
            "short_description": "Send an image in chat at this step in the conversation.",
            "inputs": [
                {"field": "variant", "type": "string", "value": "image"},
                {
                    "field": "image_url",
                    "type": "image",
                    "helper_text": "The image to be sent at this step in the conversation.",
                },
            ],
            "outputs": [],
        },
        "card**(*)": {
            "title": "Card",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/card",
            "helper_text": "Send a card (a component with image, title, description, and button) in chat at this step in the conversation.",
            "short_description": "Send a card (a component with image, title, description, and button) in chat at this step in the conversation.",
            "inputs": [
                {"field": "variant", "type": "string", "value": "card"},
                {"field": "content", "type": "string", "value": "This is content"},
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "helper_text": "The card’s title.",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "helper_text": "The card’s description.",
                },
                {
                    "field": "button",
                    "type": "Dict[str, Any]",
                    "value": {
                        "id": "asfkwewkfmdke",
                        "name": "Submit",
                        "url": "https://vectorshift.ai/",
                        "actionType": "Link",
                    },
                    "table": {
                        "name": {"helper_text": "The name of the button."},
                        "url": {
                            "helper_text": "The URL to navigate to when the button is clicked."
                        },
                        "actionType": {
                            "helper_text": "Select the action to occur when the button is clicked."
                        },
                    },
                },
                {
                    "field": "image_url",
                    "type": "image",
                    "helper_text": "The card’s image.",
                },
            ],
            "outputs": [],
        },
        "carousel**(*)": {
            "title": "Carousel",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/carousel",
            "helper_text": "Send a carousel (a gallery of multiple cards) in chat at this step in the conversation.",
            "short_description": "Send a carousel (a gallery of multiple cards) in chat at this step in the conversation.",
            "inputs": [
                {"field": "variant", "type": "string", "value": "carousel"},
                {
                    "field": "cards",
                    "type": "vec<Dict[str, Any] }>",
                    "value": [
                        {
                            "id": "afgj3rf4fmo3i4jrf43rgfm",
                            "title": "Card 1",
                            "description": "This is a description",
                            "image_url": {},
                            "button": {
                                "id": "fref43jrfn",
                                "name": "Submit",
                                "url": "https://vectorshift.ai/",
                                "actionType": "Link",
                            },
                        }
                    ],
                    "table": {
                        "title": {"helper_text": "The card’s title."},
                        "description": {"helper_text": "The card’s description."},
                        "image_url": {"helper_text": "The card’s image URL."},
                        "button": {
                            "name": {"helper_text": "The name of the button."},
                            "url": {
                                "helper_text": "The URL to navigate to when the button is clicked."
                            },
                            "actionType": {
                                "helper_text": "Select the action to occur when the button is clicked."
                            },
                        },
                    },
                },
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["variant", "is_iframe"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        variant: str = "",
        is_iframe: bool = False,
        button: Any = {
            "id": "asfkwewkfmdke",
            "name": "Submit",
            "url": "https://vectorshift.ai/",
            "actionType": "Link",
        },
        cards: List[Any] = [
            {
                "id": "afgj3rf4fmo3i4jrf43rgfm",
                "title": "Card 1",
                "description": "This is a description",
                "image_url": {},
                "button": {
                    "id": "fref43jrfn",
                    "name": "Submit",
                    "url": "https://vectorshift.ai/",
                    "actionType": "Link",
                },
            }
        ],
        content: str = "",
        description: str = "",
        image_url: Optional[Any] = None,
        title: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["variant"] = variant
        params["is_iframe"] = is_iframe

        super().__init__(
            node_type="talk",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if variant is not None:
            self.inputs["variant"] = variant
        if is_iframe is not None:
            self.inputs["is_iframe"] = is_iframe
        if content is not None:
            self.inputs["content"] = content
        if image_url is not None:
            self.inputs["image_url"] = image_url
        if title is not None:
            self.inputs["title"] = title
        if description is not None:
            self.inputs["description"] = description
        if button is not None:
            self.inputs["button"] = button
        if cards is not None:
            self.inputs["cards"] = cards

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "TalkNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("listen")
class ListenNode(Node):
    """
    Listen for user input at a stage in the conversation.

    ## Inputs
    ### Common Inputs
        variant: The variant input
    ### button
        allow_user_message: The allow_user_message input
        buttons: The buttons input
        processed_outputs: The processed_outputs input

    ## Outputs
    ### button
        [processed_outputs]: The [processed_outputs] output
    ### capture
        response: The user message.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "variant",
            "helper_text": "The variant input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "button": {
            "title": "Button",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/listen/button",
            "helper_text": "Present users with clickable buttons during a conversation at this step and wait for the user to select one.",
            "short_description": "Present users with clickable buttons during a conversation at this step and wait for the user to select one.",
            "inputs": [
                {
                    "field": "buttons",
                    "type": "vec<Dict[str, Any]>",
                    "value": [{"name": "Button 1", "id": "8awi58eyqirm8ik9aq3"}],
                },
                {
                    "field": "processed_outputs",
                    "type": "map<string, string>",
                    "value": {"button_1": "path"},
                },
                {"field": "variant", "type": "string", "value": "button"},
                {"field": "allow_user_message", "type": "bool", "value": False},
            ],
            "outputs": [{"field": "[processed_outputs]", "type": ""}],
        },
        "capture": {
            "title": "Capture",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/listen/capture",
            "helper_text": "The conversation will pause at this step in the conversation and wait for the user to respond in chat. The user response will be stored in the capture response variable.",
            "short_description": "The conversation will pause at this step in the conversation and wait for the user to respond in chat. The user response will be stored in the capture response variable.",
            "inputs": [{"field": "variant", "type": "string", "value": "capture"}],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "value": "",
                    "helper_text": "The user message.",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["variant"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        variant: str = "",
        allow_user_message: bool = False,
        buttons: List[Any] = [{"name": "Button 1", "id": "8awi58eyqirm8ik9aq3"}],
        processed_outputs: Dict[str, str] = {"button_1": "path"},
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["variant"] = variant

        super().__init__(
            node_type="listen",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if variant is not None:
            self.inputs["variant"] = variant
        if buttons is not None:
            self.inputs["buttons"] = buttons
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs
        if allow_user_message is not None:
            self.inputs["allow_user_message"] = allow_user_message

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def response(self) -> str:
        """
        The user message.

        Available: capture


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("response")

    @classmethod
    def from_dict(cls, data: dict) -> "ListenNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("add_node")
class AddNodeNode(Node):
    """
    Add Node

    ## Inputs
        None

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = []

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="add_node",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "AddNodeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("convert_type")
class ConvertTypeNode(Node):
    """
    Convert value from source type to target type.

    ## Inputs
    ### Common Inputs
        source_type: The type of the value to convert.
        target_type: The type to convert the value to.
        value: The value to convert

    ## Outputs
    ### int32
        converted_value: The converted value in Integer type
    ### float
        converted_value: The converted value in Decimal type
    ### bool
        converted_value: The converted value in Boolean type
    ### timestamp
        converted_value: The converted value in Timestamp type
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "source_type",
            "helper_text": "The type of the value to convert.",
            "value": "string",
            "type": "enum<string>",
        },
        {
            "field": "target_type",
            "helper_text": "The type to convert the value to.",
            "value": "int32",
            "type": "enum<string>",
        },
        {
            "field": "value",
            "helper_text": "The value to convert",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "int32": {
            "inputs": [
                {
                    "field": "target_type",
                    "type": "enum<string>",
                    "value": "int32",
                    "helper_text": "The type to convert the value to.",
                }
            ],
            "outputs": [
                {
                    "field": "converted_value",
                    "type": "int32",
                    "helper_text": "The converted value in Integer type",
                }
            ],
        },
        "float": {
            "inputs": [
                {
                    "field": "target_type",
                    "type": "enum<string>",
                    "value": "float",
                    "helper_text": "The type to convert the value to.",
                }
            ],
            "outputs": [
                {
                    "field": "converted_value",
                    "type": "float",
                    "helper_text": "The converted value in Decimal type",
                }
            ],
        },
        "bool": {
            "inputs": [
                {
                    "field": "target_type",
                    "type": "enum<string>",
                    "value": "bool",
                    "helper_text": "The type to convert the value to.",
                }
            ],
            "outputs": [
                {
                    "field": "converted_value",
                    "type": "bool",
                    "helper_text": "The converted value in Boolean type",
                }
            ],
        },
        "timestamp": {
            "inputs": [
                {
                    "field": "target_type",
                    "type": "enum<string>",
                    "value": "timestamp",
                    "helper_text": "The type to convert the value to.",
                }
            ],
            "outputs": [
                {
                    "field": "converted_value",
                    "type": "timestamp",
                    "helper_text": "The converted value in Timestamp type",
                }
            ],
            "banner_text": "Timestamp format: YYYY-MM-DDTHH:MM:SS",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["target_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        target_type: str = "int32",
        source_type: str = "string",
        value: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["target_type"] = target_type

        super().__init__(
            node_type="convert_type",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if value is not None:
            self.inputs["value"] = value
        if source_type is not None:
            self.inputs["source_type"] = source_type
        if target_type is not None:
            self.inputs["target_type"] = target_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def converted_value(self) -> int:
        """
        The converted value in Integer type

        Different behavior based on configuration:
          - The converted value in Integer type (int32)
          - The converted value in Decimal type (float)
          - The converted value in Boolean type (bool)
          - The converted value in Timestamp type (timestamp)


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("converted_value")

    @classmethod
    def from_dict(cls, data: dict) -> "ConvertTypeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("set_variable")
class SetVariableNode(Node):
    """
    Set a variable to a new value

    ## Inputs
    ### Common Inputs
        scope: The scope of the variable
        variable_id: The ID of the variable to set
        variable_set_id: The ID of the variable set
    ### When variable_set_id = '[variable_sets._id.<A>]' and scope = '<Scope>' and variable_id = '<VariableId>'
        value: The new value to set the variable to

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "scope",
            "helper_text": "The scope of the variable",
            "value": "",
            "type": "string",
        },
        {
            "field": "variable_id",
            "helper_text": "The ID of the variable to set",
            "value": "",
            "type": "string",
        },
        {
            "field": "variable_set_id",
            "helper_text": "The ID of the variable set",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "[variable_sets._id.<A>]**<Scope>**<VariableId>": {
            "inputs": [
                {
                    "field": "value",
                    "type": "{<A>.variables.<Scope>.<VariableId>.data_type}",
                    "helper_text": "The new value to set the variable to",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["variable_set_id", "scope", "variable_id"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        variable_set_id: str = "",
        scope: str = "",
        variable_id: str = "",
        value: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["variable_set_id"] = variable_set_id
        params["scope"] = scope
        params["variable_id"] = variable_id

        super().__init__(
            node_type="set_variable",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if variable_set_id is not None:
            self.inputs["variable_set_id"] = variable_set_id
        if variable_id is not None:
            self.inputs["variable_id"] = variable_id
        if scope is not None:
            self.inputs["scope"] = scope
        if value is not None:
            self.inputs["value"] = value
        if value is not None:
            self.inputs["value"] = value

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @classmethod
    def from_dict(cls, data: dict) -> "SetVariableNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("list_deduplicator")
class ListDeduplicatorNode(Node):
    """
    Remove duplicate items from a list. Outputs a list of unique items.

    ## Inputs
    ### Common Inputs
        type: The type of the list
    ### <T>
        list: The list to deduplicate

    ## Outputs
    ### <T>
        unique_items: The list of unique items
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": [],
                    "helper_text": "The list to deduplicate",
                }
            ],
            "outputs": [
                {
                    "field": "unique_items",
                    "type": "vec<<T>>",
                    "helper_text": "The list of unique items",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        list: List[Any] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="list_deduplicator",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()

    @property
    def unique_items(self) -> List[Any]:
        """
        The list of unique items

        Available: <T>


        Raises:
            AttributeError: If this output is not available for the current parameter values
        """
        return self.__getattr__("unique_items")

    @classmethod
    def from_dict(cls, data: dict) -> "ListDeduplicatorNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


__all__ = [
    "AppendFilesNode",
    "StickyNoteNode",
    "CustomGroupNode",
    "TransformationNode",
    "ChatFileReaderNode",
    "PipelineNode",
    "AgentNode",
    "ChatMemoryNode",
    "LlmNode",
    "InputNode",
    "OutputNode",
    "CategorizerNode",
    "ExtractDataNode",
    "DataCollectorNode",
    "ScorerNode",
    "SpeechToTextNode",
    "FileSaveNode",
    "ImageGenNode",
    "FileNode",
    "GetListItemNode",
    "LlmOpenAiVisionNode",
    "LlmGoogleVisionNode",
    "SplitTextNode",
    "SummarizerNode",
    "TextNode",
    "TextToFileNode",
    "TimeNode",
    "TranslatorNode",
    "TtsElevenLabsNode",
    "TtsOpenAiNode",
    "AiAudioOperationsNode",
    "AiTextToSpeechNode",
    "AiSpeechToTextNode",
    "AiImageOperationsNode",
    "AiImageToTextNode",
    "AiTextToImageNode",
    "LlmAnthropicVisionNode",
    "SemanticSearchNode",
    "KnowledgeBaseNode",
    "KnowledgeBaseLoaderNode",
    "MapNode",
    "MergeNode",
    "ConditionNode",
    "NlToSqlNode",
    "ReadJsonValuesNode",
    "WriteJsonValueNode",
    "ApiNode",
    "UrlLoaderNode",
    "WikipediaNode",
    "YoutubeNode",
    "ArxivNode",
    "SerpApiNode",
    "YouDotComNode",
    "ExaAiNode",
    "GoogleSearchNode",
    "GoogleAlertRssReaderNode",
    "RssFeedReaderNode",
    "CsvQueryNode",
    "CsvReaderNode",
    "CsvWriterNode",
    "CreateListNode",
    "CombineListNode",
    "ListTrimmerNode",
    "DuplicateListNode",
    "FlattenListNode",
    "JoinListItemNode",
    "CsvToExcelNode",
    "TextFormatterNode",
    "JsonOperationsNode",
    "ListOperationsNode",
    "IntegrationGmailNode",
    "IntegrationCopperNode",
    "IntegrationDiscordNode",
    "IntegrationLinearNode",
    "IntegrationOutlookNode",
    "IntegrationSalesforceNode",
    "IntegrationSlackNode",
    "IntegrationJiraNode",
    "IntegrationSugarCrmNode",
    "IntegrationGithubNode",
    "IntegrationZendeskNode",
    "IntegrationTeamsNode",
    "IntegrationXNode",
    "IntegrationGohighlevelNode",
    "IntegrationPeopledatalabsNode",
    "IntegrationHubspotNode",
    "IntegrationSnowflakeNode",
    "IntegrationElasticsearchNode",
    "IntegrationMongodbNode",
    "IntegrationPineconeNode",
    "IntegrationPostgresNode",
    "IntegrationMysqlNode",
    "IntegrationWordpressNode",
    "IntegrationLinkedinNode",
    "IntegrationGoogleCalendarNode",
    "IntegrationMicrosoftCalendarNode",
    "IntegrationMailgunNode",
    "IntegrationGoogleDocsNode",
    "IntegrationMicrosoftNode",
    "IntegrationTypeformNode",
    "IntegrationDropboxNode",
    "IntegrationBoxNode",
    "IntegrationGoogleDriveNode",
    "IntegrationGoogleSheetsNode",
    "IntegrationAirtableNode",
    "IntegrationNotionNode",
    "IntegrationDatabricksNode",
    "IntegrationWeaviateNode",
    "IntegrationBlandAiNode",
    "IntegrationAlgoliaNode",
    "IntegrationApolloNode",
    "ZapierNode",
    "MakeNode",
    "TextManipulationNode",
    "FileOperationsNode",
    "AiOperationsNode",
    "FileToTextNode",
    "CodeExecutionNode",
    "ChunkingNode",
    "NotificationsNode",
    "CustomSmtpEmailSenderNode",
    "EmailNotificationNode",
    "SmsNotificationNode",
    "AiFilterListNode",
    "FilterListNode",
    "SalesDataEnrichmentNode",
    "EmailValidatorNode",
    "CombineTextNode",
    "FindAndReplaceNode",
    "AiFillPdfNode",
    "ExtractToTableNode",
    "SortCsvNode",
    "TriggerOutlookNode",
    "TriggerGmailNode",
    "TriggerCronNode",
    "TriggerSlackNode",
    "KnowledgeBaseActionsNode",
    "KnowledgeBaseSyncNode",
    "KnowledgeBaseCreateNode",
    "ShareObjectNode",
    "RenameFileNode",
    "StartFlagNode",
    "TalkNode",
    "ListenNode",
    "AddNodeNode",
    "ConvertTypeNode",
    "SetVariableNode",
    "ListDeduplicatorNode",
]
