import argparse
import os
import shutil
import sqlite3
import sys
import uuid
import warnings
from datetime import datetime

from concrete import fhe

# Placed above imports to suppress warnings generated by subsequent packages
warnings.filterwarnings("ignore")

import cmd2
import gnureadline as readline

from ncrypt.commands import (
    complete_cd,
    complete_lcd,
    complete_lls,
    complete_ls,
    complete_mv,
    complete_rm,
    complete_rmdir,
    do_cd,
    do_get,
    do_lcd,
    do_lls,
    do_lmkdir,
    do_lpwd,
    do_ls,
    do_meta,
    do_mkdir,
    do_mv,
    do_put,
    do_pwd,
    do_rm,
    do_rmdir,
    do_rot,
    do_search,
)
from ncrypt.utils import (
    EMBED_PATH,
    SEARCH_PATH,
    PasswordError,
    UploadError,
    create_db,
    file_exists,
    get_password,
    upload_file,
)


class NcryptShell(cmd2.Cmd):
    def __init__(self, init_path: str, is_remote: bool):
        super().__init__()

        # Custom variables
        self.is_remote: bool = is_remote
        self.root_dir: str = os.path.join(os.path.expanduser("~"), ".ncrypt")
        self.key_dir: str = os.path.join(self.root_dir, "keys")
        self.dir: str = "/"
        self.ldir: str = os.path.abspath(init_path)
        self.kek: bytes | None = get_password()
        self.conn: sqlite3.Connection = sqlite3.connect(os.path.join(self.root_dir, "ncrypt.remote")) if self.is_remote else sqlite3.connect(os.path.join(self.root_dir, "ncrypt.local"))

        if not self.kek:
            raise PasswordError("The ncrypt tool cannot be run without an encryption key.")

        if os.path.exists(os.path.join(self.root_dir, "tmp")):
            shutil.rmtree(os.path.join(self.root_dir, "tmp"))

        if not os.path.exists(self.root_dir):
            self.poutput(f"Creating '{self.root_dir}'...")

            os.makedirs(self.root_dir)

        if self.is_remote and not os.path.exists(os.path.join(self.root_dir, "ncrypt.remote")):
            create_db(path=self.root_dir, is_remote=self.is_remote)

        else:
            local_file_path: str = os.path.join(self.root_dir, "local_files")
            create_db(path=self.root_dir, is_remote=self.is_remote)

            if not os.path.exists(local_file_path):
                self.poutput("Creating local filesystem...")

                os.makedirs(os.path.join(self.root_dir, "local_files"))

        if self.is_remote and not os.path.exists(self.key_dir):
            self.poutput("Creating public keys...")

            os.makedirs(self.key_dir)

        search_key_path: str = os.path.join(self.key_dir, "search")
        embed_key_path: str = os.path.join(self.key_dir, "embed")

        if self.is_remote:
            self._load_eval_keys(search_key_path, SEARCH_PATH)
            self._load_eval_keys(embed_key_path, EMBED_PATH)

        # Built-in variables
        self.intro = "Welcome to ncrypt! Type ? or help to list commands.\n"
        self.continuation_prompt = ">"
        self.persistent_history_file: str = os.path.join(self.root_dir, ".ncrypt_history")
        self.debug = False

        # Remove built-in commands that are unused
        del cmd2.Cmd.do_edit
        del cmd2.Cmd.do_shell
        del cmd2.Cmd.do_macro
        del cmd2.Cmd.do_run_script
        del cmd2.Cmd.do_run_pyscript
        del cmd2.Cmd.do_set
        del cmd2.Cmd.do_shortcuts
        del cmd2.Cmd.do_alias

    @property
    def prompt(self) -> str:
        return f"({self.dir}) ncrypt> "

    def do_clear(self, _arg) -> None:
        """
        Clear the terminal screen. Usage: clear
        """
        try:
            os.system("cls" if os.name == "nt" else "clear")

        except Exception as e:
            self.perror(f"Failed to clear screen: {e}")

    def preloop(self) -> None:
        if os.path.isfile(self.persistent_history_file):
            readline.read_history_file(self.persistent_history_file)

        else:
            with open(self.persistent_history_file, "w+") as _:
                pass

    def postloop(self) -> None:
        readline.set_history_length(1000)
        readline.write_history_file(self.persistent_history_file)

    def _load_eval_keys(self, key_path: str, model_path: str):
        client = fhe.Client.load(model_path)
        client.keys.load_if_exists_generate_and_save_otherwise(key_path)

        try:
            cursor = self.conn.cursor()

            # Check the directory exists and is a directory
            cursor.execute("""
                        SELECT name, local_path, virtual_path FROM keys
                        WHERE local_path = ?
                    """, (key_path,))
            result = cursor.fetchone()
            now: datetime = datetime.now()

            if not result:
                file_name: str = str(uuid.uuid4())
                virtual_path = f"{file_name}.json"
                local_path = key_path

                cursor.execute("""
                    INSERT INTO keys (
                        name, local_path, virtual_path, created_at, modified_at
                    )
                    VALUES (?, ?, ?, ?, ?)
                """, (
                    file_name,
                    local_path,
                    virtual_path,
                    now,
                    now
                ))

                self.conn.commit()

            else:
                file_name, local_path, virtual_path = result

            print(virtual_path)
            if not file_exists(virtual_path):
                cursor.execute("""
                    UPDATE filesystem
                    SET modified_at = ?
                    WHERE virtual_path = ?
                """, (now, virtual_path))

                eval_keys: bytes = client.evaluation_keys.serialize()
                size: int = len(eval_keys)
                completed, message, _ = upload_file(virtual_path, size, eval_keys, [])

                if not completed:
                    raise UploadError(message)

                self.conn.commit()

        except (sqlite3.Error, UploadError) as e:
            self.perror(f"File system error: {e}")


def main():
    parser = argparse.ArgumentParser(description="The ncrypt file manager")
    parser.add_argument("--remote", action="store_true", help="Enable remote mode (default is local)")
    args = parser.parse_args()
    init_path = os.getcwd()

    # Remove recognized args from sys.argv to prevent cmd2 from processing them
    sys.argv = [sys.argv[0]]

    # User defined functions
    NcryptShell.do_lls = do_lls
    NcryptShell.complete_lls = complete_lls

    NcryptShell.do_lcd = do_lcd
    NcryptShell.complete_lcd = complete_lcd

    NcryptShell.do_lpwd = do_lpwd

    NcryptShell.do_lmkdir = do_lmkdir

    NcryptShell.do_ls = do_ls
    NcryptShell.complete_ls = complete_ls

    NcryptShell.do_cd = do_cd
    NcryptShell.complete_cd = complete_cd

    NcryptShell.do_rmdir = do_rmdir
    NcryptShell.complete_rmdir = complete_rmdir

    NcryptShell.do_rm = do_rm
    NcryptShell.complete_rm = complete_rm

    NcryptShell.do_mv = do_mv
    NcryptShell.complete_mv = complete_mv

    NcryptShell.do_mkdir = do_mkdir

    NcryptShell.do_pwd = do_pwd

    NcryptShell.do_put = do_put

    NcryptShell.do_get = do_get

    NcryptShell.do_rot = do_rot

    NcryptShell.do_meta = do_meta

    NcryptShell.do_search = do_search

    app = NcryptShell(is_remote=args.remote, init_path=init_path)
    app.cmdloop()


if __name__ == "__main__":
    main()
