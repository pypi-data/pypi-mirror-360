"""
动态专家生成系统 - 提供专家推荐的原则性指导
"""

from typing import Any


class DynamicExpertManager:
    """动态专家管理器 - 管理当前会话的专家"""

    def __init__(self, data_dir: str | None = None):
        # 保留data_dir参数以兼容现有代码，但实际不使用
        self.current_experts: dict[str, Any] = {}

    def set_current_experts(self, experts: dict[str, Any]) -> None:
        """设置当前会话的专家"""
        self.current_experts = experts

    def get_current_experts(self) -> dict[str, Any]:
        """获取当前会话的专家"""
        return self.current_experts

    def clear_current_experts(self) -> None:
        """清除当前专家"""
        self.current_experts = {}

    def validate_expert_data(self, expert_data: dict[str, Any] | None) -> bool:
        """验证专家数据完整性"""
        if expert_data is None:
            return False

        required_fields = [
            "name",
            "description",
            "core_traits",
            "speaking_style",
            "base_prompt",
        ]

        for field in required_fields:
            if field not in expert_data or not expert_data[field]:
                return False

        # 添加默认emoji
        if "emoji" not in expert_data:
            expert_data["emoji"] = "👤"

        return True

    def format_expert_list(self, experts: dict[str, Any]) -> list[dict[str, Any]]:
        """格式化专家列表用于显示"""
        return [
            {
                "name": expert["name"],
                "emoji": expert.get("emoji", "👤"),
                "description": expert["description"],
                "core_traits": expert["core_traits"],
                "speaking_style": expert["speaking_style"],
                # 移除硬编码的真实人物判断，交给MCP Host端LLM处理
                # "is_real_person": self._is_likely_real_person(expert),
            }
            for expert in experts.values()
        ]


def get_question_analysis_guidance() -> str:
    """获取问题分析指导原则（供MCP Host端LLM使用）"""
    return """
# 问题分析指导原则

## 分析维度
请从以下维度分析问题：

### 1. 问题复杂度
- 简单问题：表述清晰、答案相对明确
- 中等复杂度：涉及多个因素、需要权衡
- 高复杂度：多领域交叉、存在争议、需要深度思考

### 2. 问题类型
- 方法咨询："如何"、"怎么"类问题
- 原因分析："为什么"、"原因"类问题
- 决策支持："选择"、"决策"类问题
- 趋势预测："未来"、"趋势"类问题
- 对比分析："比较"、"对比"类问题

### 3. 领域识别
识别问题所涉及的主要领域：
- 商业管理：企业经营、投资、市场营销
- 科技创新：技术发展、人工智能、数字化
- 哲学思辨：价值观、道德伦理、存在意义
- 心理行为：情绪管理、认知偏差、人际关系
- 教育成长：学习方法、知识体系、能力培养
- 社会文化：制度设计、文化传承、公共政策
- 健康生活：身心健康、生活方式、养生保健
- 创新设计：创意思维、产品设计、用户体验
- 领导管理：团队建设、决策制定、沟通协调
- 战略规划：长期发展、竞争优势、资源配置

## 分析要求
- 准确识别问题的核心要素
- 判断问题的复杂程度和讨论深度需求
- 识别相关的知识领域和专业背景
- 考虑不同视角和观点的价值
"""


def get_expert_recommendation_guidance(
    question: str = "", expert_preferences: str = ""
) -> str:
    """获取专家推荐指导原则（供MCP Host端LLM使用）"""

    # 构建基础指导内容
    base_guidance = f"""
# 专家推荐指导原则

## 当前任务信息
**用户问题**: {question}
"""

    # 如果提供了显式的专家偏好，添加到指导中
    if expert_preferences:
        base_guidance += f"**用户明确指定的专家偏好**: {expert_preferences}\n"

    # 添加专家偏好提取指导
    base_guidance += """
## 🔍 第一步：分析问题中的专家偏好

请仔细分析用户问题，提取其中包含的专家偏好信息：

### 偏好提取要点
1. **直接表达的偏好**：
   - "请两位人工智能领域的专家..."
   - "希望有哲学家和科学家参与..."
   - "需要商业领域的大师..."

2. **隐含的领域需求**：
   - 问题涉及的专业领域（AI、哲学、心理学、商业等）
   - 问题的复杂程度和深度需求
   - 需要的思维视角和方法论

3. **数量和类型要求**：
   - 专家的数量要求
   - 专家的类型组合
   - 特定的背景要求

### 偏好分析结果
请分析用户问题后，总结提取到的专家偏好：
- **明确的偏好**: [从问题中直接提取的专家要求]
- **隐含的需求**: [根据问题内容推断的专家类型需求]
- **推荐策略**: [基于分析的专家组合建议]
"""

    base_guidance += """
## 核心原则：真实人物优先

### 1. 专家选择优先级
**第一优先：真实人物**
- 优先从真实存在或存在过的知名人物中选择
- 包括已故的历史人物和在世的当代名人
- 这些人物应在其领域有公认的成就和独特的思想体系
- 能够提供具有权威性和一致性的观点

**第二优先：虚拟专家**
- 只有当某个特定视角找不到合适的真实人物时，才创建虚拟专家
- 虚拟专家应代表某种特定的专业视角或方法论
- 命名应专业化，避免过于通俗（如"认知科学专家"而非"王心理"）

### 2. 真实人物推荐指南

#### 哲学思辨领域
- **古典哲学**：苏格拉底、柏拉图、亚里士多德、孔子、老子
- **现代哲学**：尼采、康德、黑格尔、罗素、维特根斯坦
- **东方智慧**：王阳明、朱熹、禅宗大师、甘地
- **当代思想**：萨特、福柯、哈贝马斯、阿伦特

#### 商业管理领域
- **管理学大师**：彼得·德鲁克、迈克尔·波特、克里斯滕森
- **企业家**：乔布斯、马斯克、比尔·盖茨、贝佐斯、马云、任正非
- **投资大师**：巴菲特、芒格、格雷厄姆、达里奥
- **经济学家**：凯恩斯、弗里德曼、萨缪尔森、克鲁格曼

#### 科技创新领域
- **计算机科学**：图灵、冯·诺依曼、香农、高德纳
- **人工智能**：辛顿、本吉奥、李飞飞、吴恩达
- **物理学家**：爱因斯坦、费曼、霍金、杨振宁
- **发明家**：爱迪生、特斯拉、达芬奇

#### 心理行为领域
- **心理学大师**：弗洛伊德、荣格、阿德勒、马斯洛
- **认知科学**：卡尼曼、塔勒布、丹尼尔·西蒙斯
- **行为经济学**：理查德·塞勒、丹·艾瑞里

#### 教育成长领域
- **教育家**：杜威、蒙台梭利、陶行知、苏霍姆林斯基
- **学习专家**：维果茨基、布鲁姆、加德纳（多元智能）
- **当代教育思想**：肯·罗宾逊、萨尔曼·可汗

## 专家组合策略

### 1. 多样性原则
- 确保专家背景多元化，避免观点单一
- 平衡理论专家与实践专家
- 考虑不同文化背景和思维方式（东西方平衡）

### 2. 互补性原则
- 选择能够相互补充的专家组合
- 确保覆盖问题的主要方面
- 避免专家之间过度重叠

### 3. 针对性原则
- 根据问题类型选择合适的专家
- 考虑问题的复杂度和深度需求
- 匹配专家的专业能力与问题需求

### 4. 平衡性原则
- 避免某一种观点过于主导
- 确保不同立场都有代表
- 维持讨论的客观性和公正性
"""

    # 如果用户有专家偏好，添加特殊指导
    if expert_preferences:
        base_guidance += f"""

## 🎯 用户专家偏好处理指导

**用户偏好**: {expert_preferences}

### 偏好解析要求
1. **精确理解用户意图**：
   - 仔细分析用户偏好描述中的关键词和领域
   - 识别用户希望的专家类型、数量、特征
   - 理解是完全指定还是部分建议

2. **智能匹配策略**：
   - 如果用户指定了具体领域（如"人工智能专家"），优先从该领域的顶级真实人物中选择
   - 如果用户指定了专家类型（如"哲学家和科学家"），确保组合中包含这些类型
   - 如果用户给出了模糊描述，根据问题内容智能解释和扩展

3. **偏好与质量平衡**：
   - 在满足用户偏好的前提下，确保专家组合的质量和多样性
   - 如果用户偏好过于局限，适当建议互补的专家类型
   - 保持真实人物优先的原则

### 常见偏好类型处理示例
- **"人工智能专家"** → 优先选择：辛顿、本吉奥、李飞飞等AI领域权威
- **"哲学家和科学家"** → 组合包含哲学家（如苏格拉底、尼采）和科学家（如爱因斯坦、费曼）
- **"商业领域的大师"** → 选择德鲁克、乔布斯、巴菲特等商业界权威
- **"东方智慧的代表"** → 优先选择孔子、老子、王阳明等东方思想家

### 注意事项
- 始终在满足用户偏好的基础上保证辩论的价值和深度
- 如果偏好描述不够清晰，做出合理的解释和扩展
- 确保最终的专家组合既符合偏好又能产生有价值的思辨
"""

    base_guidance += """

## 专家组合示例

### 示例1：AI时代的个人突破
**推荐组合（真实人物优先）：**
- 尼采（哲学家）- 超人哲学，自我超越思想
- 德鲁克（管理学大师）- 知识工作者理论，自我管理
- 辛顿（AI之父）- 人工智能技术视角，未来适应

### 示例2：企业创新管理
**推荐组合：**
- 克里斯滕森（创新理论）- 颠覆性创新理论
- 乔布斯（企业家）- 产品创新和用户体验
- 德鲁克（管理学）- 组织管理和执行力

### 示例3：哲学伦理问题
**推荐组合：**
- 亚里士多德（古典哲学）- 伦理学基础
- 康德（现代哲学）- 道德义务论
- 孔子（东方智慧）- 仁义礼智信

## 质量检查

### 必要条件
- 每位专家都有明确的专业背景和代表性思想
- 专家之间具有差异化的观点和方法论
- 专家组合能够覆盖问题的主要方面

### 优化建议
- 优先选择在该领域有突出贡献的真实人物
- 确保专家特质的多样性和思维方式的差异
- 平衡不同文化背景（东西方平衡）
- 考虑历史性和当代性的结合
- 避免过于相似的专家组合

### 虚拟专家使用规范
当必须使用虚拟专家时：
- 使用专业化的角色定位而非个人姓名
- 明确标注为"虚拟专家"或"专业视角"
- 基于真实的专业领域和方法论
- 避免过于具体的个人化特征
"""

    return base_guidance


def should_trigger_smart_recommendation(personas: list[Any]) -> bool:
    """
    简单检查是否需要触发智能专家推荐（只做基本参数验证）
    """

    # 检查是否提供了完整的专家数据
    if not personas or len(personas) != 3:
        return True

    # 检查专家数据是否完整
    for persona in personas:
        if not isinstance(persona, dict):
            return True

        required_fields = [
            "name",
            "emoji",
            "description",
            "core_traits",
            "speaking_style",
            "base_prompt",
        ]
        for field in required_fields:
            if field not in persona or not persona[field]:
                return True

    return False
