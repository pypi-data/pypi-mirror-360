"""
    --- AUTO-GENERATED DOCSTRING ---
    Table of content is automatically generated by Agent Docstrings v1.3.2
    
    Classes/Functions:
        - SignatureInfo (line 17):
        - ClassInfo (line 21):
        - CommentStyle (line 27):
        - remove_agent_docstring(text: str, language: str) -> str (line 46)
    --- END AUTO-GENERATED DOCSTRING ---
"""
from __future__ import annotations
import re
from typing import List, Tuple, Dict, NamedTuple

DOCSTRING_START_MARKER = "--- AUTO-GENERATED DOCSTRING ---"
DOCSTRING_END_MARKER = "--- END AUTO-GENERATED DOCSTRING ---"

class SignatureInfo(NamedTuple):
    """Stores information about a parsed function or method signature."""
    signature: str
    line: int

class ClassInfo(NamedTuple):
    """Stores information about a parsed class, including its methods."""
    name: str
    line: int
    methods: List[SignatureInfo]
    inner_classes: List["ClassInfo"]

class CommentStyle(NamedTuple):
    """Stores language-specific comment formatting information."""
    start: str
    end: str
    prefix: str
    indent: str

COMMENT_STYLES: Dict[str, CommentStyle] = {
    "python": CommentStyle('"""', '"""', "    ", "    "),
    "kotlin": CommentStyle('/**', ' */', ' * ', "    "),
    "javascript": CommentStyle('/**', ' */', ' * ', "  "),
    "typescript": CommentStyle('/**', ' */', ' * ', "  "),
    "csharp": CommentStyle('/*', ' */', ' * ', "    "),
    "cpp": CommentStyle('/*', ' */', ' * ', "  "),
    "c": CommentStyle('/*', ' */', ' * ', "  "),
    "java": CommentStyle('/**', ' */', ' * ', "  "),
    "go": CommentStyle('/*', ' */', ' * ', "\t"),
    "powershell": CommentStyle('<#', '#>', ' # ', "    "),
    "delphi": CommentStyle('(*', '*)', ' * ', "  "),
}

def remove_agent_docstring(text: str, language: str) -> str:
    """Remove a previously generated docstring from *text*."""
    style = COMMENT_STYLES[language]
    start_marker_escaped = re.escape(DOCSTRING_START_MARKER)
    end_marker_escaped = re.escape(DOCSTRING_END_MARKER)
    if language == "python":
        def replacer(match):
            docstring_content = match.group(0)
            auto_content_pattern = re.compile(
                rf'\s*{start_marker_escaped}[\s\S]*?{end_marker_escaped}\s*?\n?',
                re.DOTALL
            )
            cleaned_docstring = auto_content_pattern.sub('', docstring_content)
            temp_cleaned = cleaned_docstring.replace('"""', '').replace("'''", '').strip()
            if not temp_cleaned:
                return ''  # Remove empty docstring
            # Ensure single newline padding for non-empty manual comments
            return f'"""\n{temp_cleaned}\n"""'
        docstring_pattern = re.compile(r'^\s*("""[\s\S]*?"""|'r"'''[\s\S]*?''')")
        # Iteratively clean the text
        cleaned_text = docstring_pattern.sub(replacer, text)
        cleaned_text = docstring_pattern.sub(replacer, cleaned_text) # Run again to handle adjacent blocks
        # Collapse whitespace and return
        return cleaned_text.strip()
    else:
        # For C-style comments, be more flexible with the format
        # Handle both compact (/**---...---*/) and expanded formats
        start_escaped = re.escape(style.start.rstrip())  # Remove trailing spaces
        # Handle different possible endings (with or without space before *)
        end_patterns = [
            re.escape(style.end),  # Original format with space
            re.escape(style.end.strip()),  # Without space
        ]
        # Try each possible end pattern
        for end_pattern in end_patterns:
            pattern = re.compile(
                rf'^\s*{start_escaped}[\s\S]*?{start_marker_escaped}[\s\S]*?{end_marker_escaped}[\s\S]*?{end_pattern}\s*\n?',
                re.DOTALL
            )
            match = pattern.search(text)
            if match:
                return text[match.end():]
    
    return text