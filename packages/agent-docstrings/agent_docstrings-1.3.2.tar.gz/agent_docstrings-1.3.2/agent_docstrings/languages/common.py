"""
    --- AUTO-GENERATED DOCSTRING ---
    Table of content is automatically generated by Agent Docstrings v1.3.0
    
    Classes/Functions:
        - SignatureInfo (line 20):
        - ClassInfo (line 26):
        - CommentStyle (line 34):
        - remove_agent_docstring(text: str, language: str) -> str (line 57)
    --- END AUTO-GENERATED DOCSTRING ---
"""
from __future__ import annotations

import re
from typing import List, Tuple, Dict, NamedTuple

DOCSTRING_START_MARKER = "--- AUTO-GENERATED DOCSTRING ---"
DOCSTRING_END_MARKER = "--- END AUTO-GENERATED DOCSTRING ---"

class SignatureInfo(NamedTuple):
    """Stores information about a parsed function or method signature."""
    signature: str
    line: int


class ClassInfo(NamedTuple):
    """Stores information about a parsed class, including its methods."""
    name: str
    line: int
    methods: List[SignatureInfo]
    inner_classes: List["ClassInfo"]


class CommentStyle(NamedTuple):
    """Stores language-specific comment formatting information."""
    start: str
    end: str
    prefix: str
    indent: str


COMMENT_STYLES: Dict[str, CommentStyle] = {
    "python": CommentStyle('"""', '"""', "    ", "    "),
    "kotlin": CommentStyle('/**', ' */', ' * ', "    "),
    "javascript": CommentStyle('/**', ' */', ' * ', "  "),
    "typescript": CommentStyle('/**', ' */', ' * ', "  "),
    "csharp": CommentStyle('/*', ' */', ' * ', "    "),
    "cpp": CommentStyle('/*', ' */', ' * ', "  "),
    "c": CommentStyle('/*', ' */', ' * ', "  "),
    "java": CommentStyle('/**', ' */', ' * ', "  "),
    "go": CommentStyle('/*', ' */', ' * ', "\t"),
    "powershell": CommentStyle('<#', '#>', ' # ', "    "),
    "delphi": CommentStyle('(*', '*)', ' * ', "  "),
}


def remove_agent_docstring(text: str, language: str) -> str:
    """Remove a previously generated docstring from *text*.

    The search uses language-specific comment patterns to find a block
    containing DOCSTRING_START_MARKER and DOCSTRING_END_MARKER at the
    beginning of the file, and removes it.

    Args:
        text (str): Full contents of the source file.
        language (str): Canonical language name (e.g. ``"python"``) used
            to pick the correct comment delimiters from
            :data:`COMMENT_STYLES`.

    Returns:
        str: *text* without the agent docstring block. If no such
        docstring is detected, *text* is returned unchanged.
    """
    style = COMMENT_STYLES[language]
    
    # ! Create a more flexible pattern that can match various formats
    start_marker_escaped = re.escape(DOCSTRING_START_MARKER)
    end_marker_escaped = re.escape(DOCSTRING_END_MARKER)
    
    if language == "python":
        # * Python uses triple quotes - check for new format first
        pattern = re.compile(
            rf'^\s*"""\s*{start_marker_escaped}.*?{end_marker_escaped}\s*"""\s*\n?',
            re.DOTALL
        )
        match = pattern.search(text)
        if match:
            return text[match.end():]
        
        # * Also check for old format (without proper markers)
        old_format_pattern = re.compile(
            rf'^\s*"""\s*Classes/Functions:.*?"""\s*\n?',
            re.DOTALL
        )
        match = old_format_pattern.search(text)
        if match:
            return text[match.end():]
    else:
        # * For C-style comments, be more flexible with the format
        # * Handle both compact (/**---...---*/) and expanded formats
        start_escaped = re.escape(style.start.rstrip())  # Remove trailing spaces
        
        # * Handle different possible endings (with or without space before *)
        end_patterns = [
            re.escape(style.end),  # Original format with space
            re.escape(style.end.strip()),  # Without space
        ]
        
        # * Try each possible end pattern
        for end_pattern in end_patterns:
            pattern = re.compile(
                rf'^\s*{start_escaped}.*?{start_marker_escaped}.*?{end_marker_escaped}.*?{end_pattern}\s*\n?',
                re.DOTALL
            )
            match = pattern.search(text)
            if match:
                return text[match.end():]
    
    return text