
"""
Trait definitions in the 'timeDomain' namespace.

Traits that are concerned with describing how data changes or is
parameterised over time.
"""

# WARNING: This file is auto-generated by openassetio-traitgen, do not edit.

from typing import Union

from openassetio.trait import TraitsData


class FrameRangedTrait:
    """
    The data varies over a number of discrete frames.
    Usage: entity
    """
    kId = "openassetio-mediacreation:timeDomain.FrameRanged"

    def __init__(self, traitsData):
        """
        Construct this trait view, wrapping the given data.

        @param traitsData @fqref{TraitsData}} "TraitsData" The target
        data that holds/will hold the traits properties.
        """
        self.__data = traitsData

    def isImbued(self):
        """
        Checks whether the data this trait has been applied to
        actually has this trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return self.isImbuedTo(self.__data)

    @classmethod
    def isImbuedTo(cls, traitsData):
        """
        Checks whether the given data actually has this trait.
        @param traitsData: Data to check for trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return traitsData.hasTrait(cls.kId)

    def imbue(self):
        """
        Adds this trait to the held data.

        If the data already has this trait, it is a no-op.
        """
        self.__data.addTrait(self.kId)

    @classmethod
    def imbueTo(cls, traitsData):
        """
        Adds this trait to the provided data.

        If the data already has this trait, it is a no-op.
        """
        traitsData.addTrait(cls.kId)

    
    def setEndFrame(self, endFrame: int):
        """
        Sets the endFrame property.

        The last frame covered by the entity data (inclusive).
        """
        if not type(endFrame) is int:
            raise TypeError("endFrame must be a 'int'.")
        self.__data.setTraitProperty(self.kId, "endFrame", endFrame)

    def getEndFrame(self, defaultValue: int=None) -> Union[int, None]:
        """
        Gets the value of the endFrame property or the supplied default.

        The last frame covered by the entity data (inclusive).
        """
        value = self.__data.getTraitProperty(self.kId, "endFrame")
        if value is None:
            return defaultValue

        if not type(value) is int:
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'int'.")
            return defaultValue
        return value
        
    def setFramesPerSecond(self, framesPerSecond: float):
        """
        Sets the framesPerSecond property.

        The number of frames that occur within one second.
        """
        if not type(framesPerSecond) is float:
            raise TypeError("framesPerSecond must be a 'float'.")
        self.__data.setTraitProperty(self.kId, "framesPerSecond", framesPerSecond)

    def getFramesPerSecond(self, defaultValue: float=None) -> Union[float, None]:
        """
        Gets the value of the framesPerSecond property or the supplied default.

        The number of frames that occur within one second.
        """
        value = self.__data.getTraitProperty(self.kId, "framesPerSecond")
        if value is None:
            return defaultValue

        if not type(value) is float:
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'float'.")
            return defaultValue
        return value
        
    def setInFrame(self, inFrame: int):
        """
        Sets the inFrame property.

        The first frame to be used within startFrame/endFrame
        (inclusive).
        """
        if not type(inFrame) is int:
            raise TypeError("inFrame must be a 'int'.")
        self.__data.setTraitProperty(self.kId, "inFrame", inFrame)

    def getInFrame(self, defaultValue: int=None) -> Union[int, None]:
        """
        Gets the value of the inFrame property or the supplied default.

        The first frame to be used within startFrame/endFrame
        (inclusive).
        """
        value = self.__data.getTraitProperty(self.kId, "inFrame")
        if value is None:
            return defaultValue

        if not type(value) is int:
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'int'.")
            return defaultValue
        return value
        
    def setOutFrame(self, outFrame: int):
        """
        Sets the outFrame property.

        The last frame to be used within startFrame/endFrame
        (inclusive).
        """
        if not type(outFrame) is int:
            raise TypeError("outFrame must be a 'int'.")
        self.__data.setTraitProperty(self.kId, "outFrame", outFrame)

    def getOutFrame(self, defaultValue: int=None) -> Union[int, None]:
        """
        Gets the value of the outFrame property or the supplied default.

        The last frame to be used within startFrame/endFrame
        (inclusive).
        """
        value = self.__data.getTraitProperty(self.kId, "outFrame")
        if value is None:
            return defaultValue

        if not type(value) is int:
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'int'.")
            return defaultValue
        return value
        
    def setStartFrame(self, startFrame: int):
        """
        Sets the startFrame property.

        The first frame covered by the entity data (inclusive).
        """
        if not type(startFrame) is int:
            raise TypeError("startFrame must be a 'int'.")
        self.__data.setTraitProperty(self.kId, "startFrame", startFrame)

    def getStartFrame(self, defaultValue: int=None) -> Union[int, None]:
        """
        Gets the value of the startFrame property or the supplied default.

        The first frame covered by the entity data (inclusive).
        """
        value = self.__data.getTraitProperty(self.kId, "startFrame")
        if value is None:
            return defaultValue

        if not type(value) is int:
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'int'.")
            return defaultValue
        return value
        
    def setStep(self, step: int):
        """
        Sets the step property.

        The interval between frames of the entity's data. A startFrame
        of 21 and a step of 10 would indicate that the entity data only
        covers frames 21, 31, 41, ...
        """
        if not type(step) is int:
            raise TypeError("step must be a 'int'.")
        self.__data.setTraitProperty(self.kId, "step", step)

    def getStep(self, defaultValue: int=None) -> Union[int, None]:
        """
        Gets the value of the step property or the supplied default.

        The interval between frames of the entity's data. A startFrame
        of 21 and a step of 10 would indicate that the entity data only
        covers frames 21, 31, 41, ...
        """
        value = self.__data.getTraitProperty(self.kId, "step")
        if value is None:
            return defaultValue

        if not type(value) is int:
            if defaultValue is None:
                raise TypeError(f"Invalid stored value type: '{type(value).__name__}' should be 'int'.")
            return defaultValue
        return value
        
    


class StaticTrait:
    """
    The data does not vary over time.
    Usage: entity
    """
    kId = "openassetio-mediacreation:timeDomain.Static"

    def __init__(self, traitsData):
        """
        Construct this trait view, wrapping the given data.

        @param traitsData @fqref{TraitsData}} "TraitsData" The target
        data that holds/will hold the traits properties.
        """
        self.__data = traitsData

    def isImbued(self):
        """
        Checks whether the data this trait has been applied to
        actually has this trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return self.isImbuedTo(self.__data)

    @classmethod
    def isImbuedTo(cls, traitsData):
        """
        Checks whether the given data actually has this trait.
        @param traitsData: Data to check for trait.
        @return `True` if the underlying data has this trait, `False`
        otherwise.
        """
        return traitsData.hasTrait(cls.kId)

    def imbue(self):
        """
        Adds this trait to the held data.

        If the data already has this trait, it is a no-op.
        """
        self.__data.addTrait(self.kId)

    @classmethod
    def imbueTo(cls, traitsData):
        """
        Adds this trait to the provided data.

        If the data already has this trait, it is a no-op.
        """
        traitsData.addTrait(cls.kId)

    

