from pathlib import Path
from collections import namedtuple


class LammpsData:
    def __init__(self, filepath=None):
        self.filepath = Path(filepath) if filepath else None
        self.headers = {
            'atoms': 0,
            'bonds': 0,
            'angles': 0,
            'dihedrals': 0,
            'impropers': 0,
            'atom types': 0,
            'bond types': 0,
            'angle types': 0,
            'dihedral types': 0,
            'improper types': 0,
            'xlo': 0.0, 'xhi': 0.0,
            'ylo': 0.0, 'yhi': 0.0,
            'zlo': 0.0, 'zhi': 0.0,
            'xy': 0.0, 'xz': 0.0, 'yz': 0.0
        }
    
        self.header_mapping = {
            'atoms': 'atoms',
            'bonds': 'bonds',
            'angles': 'angles',
            'dihedrals': 'dihedrals',
            'impropers': 'impropers',
            'atom types': 'atom types',
            'bond types': 'bond types',
            'angle types': 'angle types',
            'dihedral types': 'dihedral types',
            'improper types': 'improper types',
            'xlo xhi': ('xlo', 'xhi'),
            'ylo yhi': ('ylo', 'yhi'),
            'zlo zhi': ('zlo', 'zhi'),
            'xy xz yz': ('xy', 'xz', 'yz')
        }

        self.sections_order = []
        
        self.sections = {
            'Masses': {},
            'Pair Coeffs': {},
            'Bond Coeffs': {},
            'Angle Coeffs': {},
            'Dihedral Coeffs': {},
            'Improper Coeffs': {},
            'Atoms': [],
            'Bonds': [],
            'Angles': [],
            'Dihedrals': [],
            'Impropers': [],
            'Velocities': []
        }
        self.Atom = namedtuple('Atom', ['id', 'mol', 'type', 'charge', 'x', 'y', 'z'])

        if self.filepath and self.filepath.exists():
            self.read(self.filepath)

    def read(self, filepath):
        self.filepath = Path(filepath)
        current_section = None
        
        with open(self.filepath, 'r') as f:
            for line in f:
                line = line.strip()
                
                if not line or line.startswith('#'):
                    continue
                
                if any(line.startswith(s) for s in self.sections):
                    current_section = line
                    self.sections_order.append(current_section)
                    continue
                
                header_processed = False
                for pattern, keys in self.header_mapping.items():
                    if pattern in line:
                        parts = line.split()
                        if isinstance(keys, tuple):  
                            for i, key in enumerate(keys):
                                self.headers[key] = float(parts[i])
                        else:  
                            self.headers[keys] = int(parts[0])
                        header_processed = True
                        break
                    
                if header_processed:
                    continue
                
                if current_section:
                    if current_section in ['Masses', 'Pair Coeffs', 'Bond Coeffs', 
                                         'Angle Coeffs', 'Dihedral Coeffs', 'Improper Coeffs']:
                        parts = line.split('#')[0].split()
                        if parts:
                            self.sections[current_section][int(parts[0])] = [float(x) for x in parts[1:]]
                    else:
                        self.sections[current_section].append(line)

    def write(self, filepath):
        self._update_headers()
        
        with open(filepath, 'w') as f:
            f.write(f"Generated by lammps-data-parser v0.1.0\n\n")
            
            for key in ['atoms', 'bonds', 'angles', 'dihedrals', 'impropers']:
                f.write(f"{self.headers[key]} {key}\n")
            f.write("\n")

            for key in ['atom types', 'bond types', 'angle types', 
                       'dihedral types', 'improper types']:
                f.write(f"{self.headers[key]} {key}\n")
            f.write("\n")

            f.write(f"{self.headers['xlo']:.6f} {self.headers['xhi']:.6f} xlo xhi\n")
            f.write(f"{self.headers['ylo']:.6f} {self.headers['yhi']:.6f} ylo yhi\n")
            f.write(f"{self.headers['zlo']:.6f} {self.headers['zhi']:.6f} zlo zhi\n")
            f.write(f"{self.headers['xy']:.6f} {self.headers['xz']:.6f} {self.headers['yz']:.6f} xy xz yz\n\n")
            
            for section in self.sections_order:
                if section in self.sections and (isinstance(self.sections[section], dict) and self.sections[section] or 
                                               isinstance(self.sections[section], list) and self.sections[section]):
                    f.write(f"{section}\n\n")
                    
                    if isinstance(self.sections[section], dict):
                        for key in sorted(self.sections[section].keys()):
                            values = ' '.join([f"{x:.6f}" if isinstance(x, float) else str(x) for x in self.sections[section][key]])
                            f.write(f"{key} {values}\n")
                    else:
                        for line in self.sections[section]:
                            f.write(f"{line}\n")
                    f.write("\n")

    def _update_headers(self):

        self.headers['atoms'] = len(self.sections['Atoms'])
        self.headers['bonds'] = len(self.sections['Bonds'])
        self.headers['angles'] = len(self.sections['Angles'])
        self.headers['dihedrals'] = len(self.sections['Dihedrals'])
        self.headers['impropers'] = len(self.sections['Impropers'])


        self.headers['atom types'] = self._get_max_type('Atoms', 2)  
        self.headers['bond types'] = self._get_max_type('Bonds', 1)  
        self.headers['angle types'] = self._get_max_type('Angles', 1)
        self.headers['dihedral types'] = self._get_max_type('Dihedrals', 1)
        self.headers['improper types'] = self._get_max_type('Impropers', 1)

    def _get_max_type(self, section, type_pos):
        if not self.sections[section]:
            return 0

        max_type = 0
        for entry in self.sections[section]:
            parts = entry.split()
            if len(parts) > type_pos:
                try:
                    current_type = int(parts[type_pos])
                    if current_type > max_type:
                        max_type = current_type
                except ValueError:
                    continue
        return max_type


    
    @property
    def bonds(self):
        return self.sections['Bonds']
    
    
    @property
    def angles(self):
        return self.sections['Angles']
    
    @property
    def dihedrals(self):
        return self.sections['Dihedrals']
    
    @property
    def impropers(self):
        return self.sections['Impropers']
    
    @property
    def masses(self):
        return self.sections['Masses']
    
    @property
    def velocities(self):
        return self.sections.get('Velocities', [])

    @velocities.setter
    def velocities(self, value):
        if value is None:
            if 'Velocities' in self.sections:
                del self.sections['Velocities']
        else:
            self.sections['Velocities'] = value

    @property
    def pair_coeffs(self):
        return self.sections['Pair Coeffs']
    
    @property
    def bond_coeffs(self):
        return self.sections['Bond Coeffs']
    
    @property
    def angle_coeffs(self):
        return self.sections['Angle Coeffs']
    
    @property
    def dihedral_coeffs(self):
        return self.sections['Dihedral Coeffs']
    
    @property
    def improper_coeffs(self):
        return self.sections['Improper Coeffs']

    @property
    def box(self):
        return {
            'xlo': self.headers.get('xlo', 0.0),
            'xhi': self.headers.get('xhi', 0.0),
            'ylo': self.headers.get('ylo', 0.0),
            'yhi': self.headers.get('yhi', 0.0),
            'zlo': self.headers.get('zlo', 0.0),
            'zhi': self.headers.get('zhi', 0.0),
            'xy': self.headers.get('xy', 0.0),
            'xz': self.headers.get('xz', 0.0),
            'yz': self.headers.get('yz', 0.0)
        }
    
    @property
    def atoms(self):
        parsed_atoms = []
        for atom_line in self.sections['Atoms']:
            parts = atom_line.split()
            try:
                atom = self.Atom(
                    id=int(parts[0]),
                    mol=int(parts[1]),
                    type=int(parts[2]),
                    charge=float(parts[3]),
                    x=float(parts[4]),
                    y=float(parts[5]),
                    z=float(parts[6])
                )
                parsed_atoms.append(atom)
            except (IndexError, ValueError) as e:
                print(f"Error: {atom_line}.")
        return parsed_atoms
    
    @atoms.setter
    def atoms(self, value):
        new_atoms = []
        for atom in value:
            atom_str = f"{atom.id} {atom.mol} {atom.type} {atom.charge:.6f} {atom.x:.6f} {atom.y:.6f} {atom.z:.6f}"
            new_atoms.append(atom_str)
        self.sections['Atoms'] = new_atoms


    def __repr__(self):
        return (f"LammpsData(filepath={self.filepath}, atoms={len(self.atoms)}, "
                f"bonds={len(self.bonds)}, angles={len(self.angles)})")