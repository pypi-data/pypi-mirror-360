---
description: Rules and guidelines for isospec-data-tools library development
globs: ["**/*.py", "**/*.md", "**/*.json"]
alwaysApply: false
---

# IsoSpec Data Tools Development Rules

## Context Initialization
Before starting any development work:
- Read @.notes/project_overview.md for system architecture
- Read @.notes/task_list.md for implementation phase
- Review @.notes/meeting_notes.md for context continuity
- Check @.docs/modules/*.md for module documentation
- Check @.docs/index.md for project overview

## Development Protocol

### Before Any Code Changes
1. Verify module responsibility in architecture
2. Check dependencies with other modules
3. Review formatting requirements
4. Ensure MECE principle adherence
5. Log session start in @.notes/meeting_notes.md

### Code Changes Requirements
- Maintain module interface consistency
- Follow established formatting patterns
- Implement proper error handling
- Add appropriate type hints
- Update relevant tests
- Document changes in @.notes/meeting_notes.md
- Update the relevant @.docs/modules/*.md with new documentation

### Safety Requirements
- ALWAYS validate input/output formats
- ALWAYS implement error handling for module interactions
- ALWAYS maintain knowledge verification steps
- ALWAYS document module behaviors in @docs/modules
- NEVER skip formatter implementation
- ALWAYS log decisions in @.notes/meeting_notes.md

## Coding Guidelines


### Project Structure
- Use src-layout with `src/your_package_name/`
- Place tests in `tests/` directory parallel to `src/`
- Keep configuration in `config/` or as environment variables
- Store requirements in `pyproject.toml`
- Place static files in `static/` directory

### 1. Pythonic Practices

- **Elegance and Readability:** Strive for elegant and Pythonic code that is easy to understand and maintain.
- **PEP 8 Compliance:** Adhere to PEP 8 guidelines for code style, with Ruff as the primary linter and formatter.
- **Explicit over Implicit:** Favor explicit code that clearly communicates its intent over implicit, overly concise code.
- **Zen of Python:** Keep the Zen of Python in mind when making design decisions.

### 2. Modular Design

- **Single Responsibility Principle:** Each module/file should have a well-defined, single responsibility.
- **Reusable Components:** Develop reusable functions and classes, favoring composition over inheritance.
- **Package Structure:** Organize code into logical packages and modules.

### 3. Code Quality

- **Comprehensive Type Annotations:** All functions, methods, and class members must have type annotations, using the most specific types possible.
- **Detailed Docstrings:** All functions, methods, and classes must have Google-style docstrings, thoroughly explaining their purpose, parameters, return values, and any exceptions raised. Include usage examples where helpful.
- **Thorough Unit Testing:** Aim for high test coverage (90% or higher) using `pytest`. Test both common cases and edge cases.
- **Robust Exception Handling:** Use specific exception types, provide informative error messages, and handle exceptions gracefully. Implement custom exception classes when needed. Avoid bare `except` clauses.
- **Logging:** Employ the `logging` module judiciously to log important events, warnings, and errors.

### Code Example Requirements

- All functions must include type annotations.
- Must provide clear, Google-style docstrings.
- Key logic should be annotated with comments.
- Provide usage examples (e.g., in the `tests/` directory or as a `__main__` section).
- Include error handling.
- Use `ruff` for code formatting.

### Documentation
- Use Google-style docstrings
- Document all public APIs
- Keep **/README.md updated
- Use proper inline comments
- Generate API documentation
- Document environment setup

## Session Logging Format
Location: @.notes/meeting_notes.md
Required format:
```markdown
## [DATE] - [COMPONENT] Development
### Context
### Changes Made
### Decisions
### Testing
### Next Steps
```
