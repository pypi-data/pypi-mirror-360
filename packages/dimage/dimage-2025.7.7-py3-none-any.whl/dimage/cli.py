from __future__ import annotations
from typing import Dict, Set
import argparse
import json
import logging
import os

from tqdm import tqdm

from .config import Config
from .extractor import extract_media_from_json
from .filesystem import create_directories, get_paths, process_media_item


def run(config: Config) -> None:
	"""
	Main execution logic for the script.
	Iterates through JSON files, extracts media, and processes them.

	:param config: The application configuration.
	"""
	os.makedirs(config.input_folder, exist_ok=True)
	visited_urls: Set[str] = set()
	file_use_counter: Dict[str, int] = {}
	json_files = [f for f in os.listdir(config.input_folder) if f.endswith(".json")]
	if not json_files:
		logging.warning(
			f"No .json files found in input directory: {config.input_folder}"
		)
		return
	for filename in tqdm(json_files, desc="Processing JSON files"):
		filepath = os.path.join(config.input_folder, filename)
		json_filename = os.path.splitext(filename)[0]
		paths = get_paths(config, json_filename)
		create_directories(config, paths)
		try:
			with open(filepath, "r", encoding="utf-8") as f:
				data = json.load(f)
			media_to_process = extract_media_from_json(data, config, visited_urls)
			for item in tqdm(
				media_to_process, desc=f"Processing {filename}", leave=False
			):
				process_media_item(item, config, paths, json_filename, file_use_counter)
		except FileNotFoundError:
			logging.error(f"Input file not found: '{filepath}'")
		except json.JSONDecodeError as e:
			logging.error(
				f"Could not parse '{filename}'. File may be corrupt. Details: {e}"
			)
		except IOError as e:
			logging.error(f"I/O error occurred while processing '{filename}': {e}")


def main() -> None:
	"""Parses command-line arguments and starts the download process."""
	arg_parser = argparse.ArgumentParser(
		description="Downloads all media assets from JSON files generated by DiscordChatExporter"
	)
	arg_parser.add_argument(
		"-i",
		"--input",
		default="json",
		help="Path to the input directory containing `.json` files. Default: `json`.",
	)
	arg_parser.add_argument(
		"-o",
		"--output",
		default="downloads",
		help="Path to the root output directory for downloads. Default: `downloads`.",
	)
	arg_parser.add_argument(
		"--no-guild-icon",
		action="store_false",
		dest="guild_icon",
		help="Skip downloading the guild/server icon.",
	)
	arg_parser.add_argument(
		"--no-avatars",
		action="store_false",
		dest="avatars",
		help="Skip downloading message author avatars.",
	)
	arg_parser.add_argument(
		"--no-mentions",
		action="store_false",
		dest="mentions",
		help="Skip downloading avatars of mentioned users.",
	)
	arg_parser.add_argument(
		"--no-reactions",
		action="store_false",
		dest="reactions",
		help="Skip downloading avatars of users who reacted.",
	)
	arg_parser.add_argument(
		"--no-reactions-emojis",
		action="store_false",
		dest="reactions_emojis",
		help="Skip downloading custom emojis used in reactions.",
	)
	arg_parser.add_argument(
		"--no-inline-emojis",
		action="store_false",
		dest="inline_emojis",
		help="Skip downloading custom emojis used inline in messages.",
	)
	arg_parser.add_argument(
		"--no-attachments",
		action="store_false",
		dest="attachments",
		help="Skip downloading message attachments.",
	)
	arg_parser.add_argument(
		"--no-dupes",
		action="store_true",
		help="Avoid downloading duplicate files based on URL.",
	)
	arg_parser.add_argument(
		"--skip",
		type=str,
		default="",
		help="Skip files with specified comma-separated extensions.",
	)
	arg_parser.add_argument(
		"--timestamp-only",
		action="store_true",
		help="Set timestamps on existing files without downloading.",
	)
	arg_parser.add_argument(
		"--organize",
		action="store_true",
		help="Organize files into categories: `icons`, `avatars`, `emojis`, and `channels` (for attachments).",
	)
	arg_parser.add_argument(
		"--loglevel",
		type=str.upper,
		choices=["NOTSET", "DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
		default="ERROR",
		help="Set the logging level. Default: ERROR.",
	)
	args = arg_parser.parse_args()
	logging.basicConfig(level=args.loglevel, format="%(levelname)s: %(message)s")
	config = Config(args)
	run(config)


if __name__ == "__main__":
	main()
