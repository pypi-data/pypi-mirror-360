import os
import sys

class_name = "__Main__"


def _init():
    import gdsbin.__init__

    __init__ = type(gdsbin.__init__)(gdsbin.__init__.__name__, gdsbin.__init__.__doc__)
    __init__.__dict__.update(gdsbin.__init__.__dict__)
    for arg in sys.argv:
        if arg == "version":
            version_info()
            return
        if arg == "help":
            help()
            return
        if arg == "test=vector2":
            run_vector2()
            return
        if arg == "benchmark":
            run_benchmark()
            return
        if arg == "test=parser":
            run_parser()
            return
        path_format_arg = "format="
        if arg.startswith(path_format_arg) and arg.endswith(".gd"):
            format = True
            comp = False
            start(arg, format, comp, __init__.package_name)
            ESCAPE = ""
            sys.stdout.write(ESCAPE + "[2K\r")
            return
        path_binary_arg = "gen_api="
        if arg.startswith(path_binary_arg):
            arg = arg.replace(path_binary_arg, "")
            gen_api(arg)
            return
        path_exp_arg = "exp="
        if arg.startswith(path_exp_arg):
            start_exp(arg, __init__.package_name)
            print("")
            return
        path_tree_arg = "tree="
        if arg.startswith(path_tree_arg):
            start_tree(arg, __init__.package_name)
            return
        compile_arg = "compile="
        if arg.startswith(compile_arg) and arg.endswith(".gd"):
            format = True
            comp = True
            start(arg, format, comp, __init__.package_name)
            ESCAPE = ""
            sys.stdout.write(ESCAPE + "[2K\r")
            return
        setup_arg = "setup="
        if arg.startswith(setup_arg):
            setup(
                __init__.setuptools_min_ver,
                __init__.package_name,
                __init__.author,
                __init__.author_email,
                __init__.project_url,
                __init__.download_url,
                __init__.documentation_url,
                __init__.source_url,
                __init__.tracker_url,
                __init__.description,
                __init__.proj_license,
            )
            return
    help()
    return


def gen_api(program):
    import gdsbin.application

    application = type(gdsbin.application)(
        gdsbin.application.__name__, gdsbin.application.__doc__
    )
    application.__dict__.update(gdsbin.application.__dict__)
    version = application.execute(program, ["--headless", "--quit"])
    version = version[0].split("\n")[0]
    info = {
        "major": 4,
        "minor": 4,
        "patch": 1,
        "hex": 263169,
        "status": "stable",
        "build": "gentoo",
        "hash": "49a5bc7b616bd04689a2c89e89bda41f50241464",
        "timestamp": 0,
        "string": "4.4.1-stable (gentoo)",
    }
    major = info.get("major")
    minor = info.get("minor")
    patch = info.get("patch")
    status = info.get("status")
    build = info.get("build")
    id = info.get("hash")
    compat = "v"
    compat += str(major)
    compat += "."
    compat += str(minor)
    compat += "."
    if patch != 0:
        compat += str(patch)
        compat += "."
    compat += status
    compat += "."
    compat += build
    compat += "."
    compat += left(id, 9)
    col = version.split(" ")
    if len(col) < 3:
        print("Invalid godot4 executable")
        return
    if compat != col[2]:
        print("Invalid godot4 executable")
        return
    print("Generating GDScript files from extension api...")
    application.execute(program, ["--headless", "--dump-extension-api"])
    save_extension_api()


def save_extension_api():
    import gdsbin.transpiler

    transpiler = type(gdsbin.transpiler)(
        gdsbin.transpiler.__name__, gdsbin.transpiler.__doc__
    )
    transpiler.__dict__.update(gdsbin.transpiler.__dict__)
    content = transpiler.read("extension_api.json").split("\n")
    save_enum_from_api(content, "Variant.Operator")
    save_enum_from_api(content, "Variant.Type")
    save_enum_from_api(content, "Key")


def save_enum_from_api(content, search):
    script_name = search.lower()
    script_name = script_name.replace(".", "_")
    sl = len(script_name)
    classn = script_name[0].upper()
    classn += right(script_name, sl - 1)
    out = "## GDScript Transpiler Properties Class"
    out += "\n\n"
    out += "# Autogenerated class (gen_api)"
    out += "\n"
    out += "# See https://raw.githubusercontent.com/godotengine/godot-cpp/master/gdextension/extension_api.json"
    out += "\n\n"
    out += "class_name %s" % classn
    out += "\n\n"
    line = 0
    l = len(content)
    for i in range(0, l):
        if 0 <= content[i].find(search):
            line = i + 1
            break
    for i in range(line, l):
        if content[i].endswith("["):
            line = i + 1
            break
    for i in range(line, l):
        if 0 <= content[i].find("name"):
            res = content[i].split(" ")[1]
            res = res.split('"')[1]
            out += "const %s: int = " % res
            continue
        if 0 <= content[i].find("value"):
            res = content[i].split(" ")[1]
            out += res
            out += "\n"
            continue
        if content[i].endswith("]"):
            break
        else:
            continue
    pathstr = "gdsbin/" + script_name
    path = "" + pathstr + ".gd"
    import gdsbin.transpiler

    transpiler = type(gdsbin.transpiler)(
        gdsbin.transpiler.__name__, gdsbin.transpiler.__doc__
    )
    transpiler.__dict__.update(gdsbin.transpiler.__dict__)
    transpiler.save(path, out)


def compile(arg):
    path_end = arg.split("=")[1]
    args = path_end.split(".")
    c = len(args)
    pathstr = ""
    for path_str in args:
        c -= 1
        if c != 0:
            pathstr += path_str + "."
    nopt = []
    nopt.append(pathstr + "py")
    nopt.append("--onefile")
    nopt.append("--no-progressbar")
    nopt.append("--show-scons")
    nopt.append("--quiet")
    nopt.append("--remove-output")
    nopt.append("--lto=yes")
    nopt.append("--deployment")
    nopt.append("--static-libpython=auto")
    nopt.append("--clang")
    nopt.append("--assume-yes-for-downloads")
    print("\n")
    print("Compiling " + pathstr + "py...")
    print("Info: Running " + "'" + " ".join(nopt) + "'")
    import gdsbin.application

    application = type(gdsbin.application)(
        gdsbin.application.__name__, gdsbin.application.__doc__
    )
    application.__dict__.update(gdsbin.application.__dict__)
    application.execute_pipe("python3.13", ["-c", nopttoarg(nopt)])


def nopttoarg(nopt):
    opts = []
    opts.append("import nuitka.__main__")
    opts.append("import sys")
    args = "sys.argv=[sys.executable,"
    for opt in nopt:
        args += "'%s'," % opt
    args += "]"
    opts.append(args)
    # AttributeError: module '__main__' has no attribute '__file__'. Did you mean: '__name__'?
    opts.append("sys.modules['__main__'].__file__=sys.modules['__main__'].__name__")
    opts.append("nuitka.__main__.main()")
    out = ";".join(opts)
    return out


def start_exp(arg, _package_name):
    path_end = arg.split("=")[1]
    path = "" + path_end
    import gdsbin.transpiler

    transpiler = type(gdsbin.transpiler)(
        gdsbin.transpiler.__name__, gdsbin.transpiler.__doc__
    )
    transpiler.__dict__.update(gdsbin.transpiler.__dict__)
    content = transpiler.read(path)
    import gdsbin.tokenizer

    tokenizer = type(gdsbin.tokenizer)(
        gdsbin.tokenizer.__name__, gdsbin.tokenizer.__doc__
    )
    tokenizer.__dict__.update(gdsbin.tokenizer.__dict__)
    con = content.split("\n")
    unit = []
    for line in con:
        tokens = tokenizer.tokenize(line)
        unit.append(tokens)
    import gdsbin.ast

    ast = type(gdsbin.ast)(gdsbin.ast.__name__, gdsbin.ast.__doc__)
    ast.__dict__.update(gdsbin.ast.__dict__)
    import gdsbin.root

    root = type(gdsbin.root)(gdsbin.root.__name__, gdsbin.root.__doc__)
    root.__dict__.update(gdsbin.root.__dict__)
    ast_res = ast.ast(0, len(unit), 0, root, unit, con)
    import gdsbin.parsertree

    parsertree = type(gdsbin.parsertree)(
        gdsbin.parsertree.__name__, gdsbin.parsertree.__doc__
    )
    parsertree.__dict__.update(gdsbin.parsertree.__dict__)
    string_res = parsertree.printpt(ast_res, 0)
    print(string_res)


def start_tree(arg, _package_name):
    path_end = arg.split("=")[1]
    path = "" + path_end
    import gdsbin.transpiler

    transpiler = type(gdsbin.transpiler)(
        gdsbin.transpiler.__name__, gdsbin.transpiler.__doc__
    )
    transpiler.__dict__.update(gdsbin.transpiler.__dict__)
    content = transpiler.read(path)
    import gdsbin.tokenizer

    tokenizer = type(gdsbin.tokenizer)(
        gdsbin.tokenizer.__name__, gdsbin.tokenizer.__doc__
    )
    tokenizer.__dict__.update(gdsbin.tokenizer.__dict__)
    con = content.split("\n")
    unit = []
    for line in con:
        tokens = tokenizer.tokenize(line)
        unit.append(tokens)
    import gdsbin.ast

    ast = type(gdsbin.ast)(gdsbin.ast.__name__, gdsbin.ast.__doc__)
    ast.__dict__.update(gdsbin.ast.__dict__)
    import gdsbin.root

    root = type(gdsbin.root)(gdsbin.root.__name__, gdsbin.root.__doc__)
    root.__dict__.update(gdsbin.root.__dict__)
    ast_res = ast.ast(0, len(unit), 0, root, unit, con)
    import gdsbin.parsertree

    parsertree = type(gdsbin.parsertree)(
        gdsbin.parsertree.__name__, gdsbin.parsertree.__doc__
    )
    parsertree.__dict__.update(gdsbin.parsertree.__dict__)
    e = parsertree.printtree(ast_res, 0)
    string_res = parsertree.printrec(e, "")
    print(string_res)


def token_tree(arg, _package_name):
    path_end = arg.split("=")[1]
    path = "" + path_end
    import gdsbin.transpiler

    transpiler = type(gdsbin.transpiler)(
        gdsbin.transpiler.__name__, gdsbin.transpiler.__doc__
    )
    transpiler.__dict__.update(gdsbin.transpiler.__dict__)
    content = transpiler.read(path)
    import gdsbin.tokenizer

    tokenizer = type(gdsbin.tokenizer)(
        gdsbin.tokenizer.__name__, gdsbin.tokenizer.__doc__
    )
    tokenizer.__dict__.update(gdsbin.tokenizer.__dict__)
    con = content.split("\n")
    e = {}
    for i in range(0, len(con)):
        l = {}
        tokens = tokenizer.tokenize(con[i])
        for ii in range(0, len(tokens)):
            l["Token" + str(ii)] = {
                "id": {str(tokens[ii].id): None},
                "value": {tokens[ii].value: None},
            }
        e["line " + str(i)] = l
    import gdsbin.parsertree

    parsertree = type(gdsbin.parsertree)(
        gdsbin.parsertree.__name__, gdsbin.parsertree.__doc__
    )
    parsertree.__dict__.update(gdsbin.parsertree.__dict__)
    string_res = parsertree.printrec(e, "")
    print(string_res)


def setup(
    setuptools_min_ver,
    package_name,
    author,
    author_email,
    project_url,
    download_url,
    documentation_url,
    source_url,
    tracker_url,
    description,
    proj_license,
):
    import gdsbin.transpiler

    transpiler = type(gdsbin.transpiler)(
        gdsbin.transpiler.__name__, gdsbin.transpiler.__doc__
    )
    transpiler.__dict__.update(gdsbin.transpiler.__dict__)
    pyproject_path = "" + "pyproject" + "." + "toml"
    transpiler.generate_pyproject(pyproject_path, setuptools_min_ver)
    setup_path = "" + "setup" + "." + "py"
    transpiler.generate_setup(
        setup_path,
        package_name,
        author,
        author_email,
        project_url,
        download_url,
        documentation_url,
        source_url,
        tracker_url,
        description,
        proj_license,
    )


def start(arg, stage2, stage3, package_name):
    path_end = arg.split("=")[1]
    path = "" + path_end
    args = path_end.split(".")
    c = len(args)
    pathstr = ""
    for path_str in args:
        c -= 1
        if c != 0:
            pathstr += path_str + "."
    if 0 <= pathstr.find("/.."):
        paths = pathstr.split("/")
        pathstr = ""
        index = 0
        for path_arg in paths:
            if path_arg == ".." and index > 0:
                path_size = len(pathstr)
                previous = paths[index - 1]
                previous_size = len(previous)
                # remove "/"
                pathstr = left(pathstr, path_size - 1)
                path_size = len(pathstr)
                # remove previous path
                pathstr = left(pathstr, path_size - previous_size)
            else:
                pathstr += path_arg
                pathstr += "/"
            index += 1
        pathstr = left(pathstr, len(pathstr) - 1)
    if stage2:
        ESCAPE = ""
        sys.stdout.write(ESCAPE + "[2K\r" + "Transpiling " + pathstr + "gd...")
    path2 = "" + pathstr + "py"
    import gdsbin.transpiler

    transpiler = type(gdsbin.transpiler)(
        gdsbin.transpiler.__name__, gdsbin.transpiler.__doc__
    )
    transpiler.__dict__.update(gdsbin.transpiler.__dict__)
    transpiler.set_def([])
    content = transpiler.read(path)
    out = transpiler.transpile(content, package_name)
    if transpiler.defs.verbose:
        print(out)
    transpiler.save(path2, out)
    deps = []
    for dep in transpiler.props.gds_deps:
        deps.append(dep)
    transpiler.props.gds_deps = []
    if stage2:
        import gdsbin.application

        application = type(gdsbin.application)(
            gdsbin.application.__name__, gdsbin.application.__doc__
        )
        application.__dict__.update(gdsbin.application.__dict__)
        application.execute("ruff", ["format", pathstr + "py"])
    for dep in deps:
        if dep != deps[0]:
            path_arr = pathstr.split("/")
            size = len(path_arr)
            path_arr[size - 1] = dep.lower() + "."
            result_str = ""
            for string in path_arr:
                result_str += string
                result_str += "/"
            result_str = left(result_str, len(result_str) - 1)
            result_str += "gd"
            comp = False
            transpiler.set_def(start("dep=" + result_str, stage2, comp, package_name))
    if stage3:
        compile(arg)
    return transpiler.get_def()


def version_info():
    info = {
        "major": 4,
        "minor": 4,
        "patch": 1,
        "hex": 263169,
        "status": "stable",
        "build": "gentoo",
        "hash": "49a5bc7b616bd04689a2c89e89bda41f50241464",
        "timestamp": 0,
        "string": "4.4.1-stable (gentoo)",
    }
    major = info.get("major")
    minor = info.get("minor")
    patch = info.get("patch")
    status = info.get("status")
    build = info.get("build")
    id = info.get("hash")
    import gdsbin.version

    version = type(gdsbin.version)(gdsbin.version.__name__, gdsbin.version.__doc__)
    version.__dict__.update(gdsbin.version.__dict__)
    ESCAPE = ""
    COLOR_RESET = "[0m"
    CYAN = "[0;36m"
    WHITE_BOLD = "[1;37m"
    print(
        CYAN
        + "GDScript Transpiler "
        + version.__version__
        + ESCAPE
        + COLOR_RESET
        + "\n"
    )
    GDV = str(major) + "." + str(minor) + "." + str(patch)
    print(WHITE_BOLD + "Compatible with Godot" + ESCAPE + COLOR_RESET)
    print(GDV + "." + status + "." + build + "." + left(id, 9))
    out = []
    import gdsbin.application

    application = type(gdsbin.application)(
        gdsbin.application.__name__, gdsbin.application.__doc__
    )
    application.__dict__.update(gdsbin.application.__dict__)
    print(WHITE_BOLD + "Python" + ESCAPE + COLOR_RESET)
    out = application.execute("python3.13", ["-c", "import sys;print(sys.version)"])
    print(out[0].split("\n")[0])
    print(WHITE_BOLD + "Nuitka" + ESCAPE + COLOR_RESET)
    out = application.execute(
        "python3.13",
        ["-c", "from nuitka import Version;print(Version.getNuitkaVersion())"],
    )
    print(out[0].split("\n")[0])
    print(WHITE_BOLD + "Ruff" + ESCAPE + COLOR_RESET)
    out = application.execute("ruff", ["version"])
    print(out[0].split("\n")[0].split(" ")[1])
    print(WHITE_BOLD + "Zig" + ESCAPE + COLOR_RESET)
    out = application.execute("zig", ["version"])
    print(out[0].split("\n")[0])


def help():
    VER_DESC = "show program's version number and exit"
    HELP_DESC = "show this help message and exit"
    FMT_DESC = "transpile and format GDScript files recursively"
    COMP_DESC = "compile GDScript file to binary using Clang/Nuitka"
    EXP_DESC = "experimental option to tokenize GDScript file"
    SETUP_DESC = "generate a setup.py and pyproject.toml file to install Python project"
    VEC2_DESC = "testing Vector2 implementation"
    PARSER_DESC = "running GDScript tests (not working yet)"
    BENCH_DESC = "running benchmark to compare performance"
    GEN_API = "generate API bindings"
    ESCAPE = ""
    COLOR_RESET = "[0m"
    GREEN = "[0;32m"
    CYAN = "[0;36m"
    print(
        "Usage: "
        + CYAN
        + "gds"
        + ESCAPE
        + COLOR_RESET
        + " [ "
        + GREEN
        + "options"
        + ESCAPE
        + COLOR_RESET
        + " ]"
        + "\n"
    )
    print("Options:")
    print(
        "  "
        + GREEN
        + "version"
        + ESCAPE
        + COLOR_RESET
        + "                           "
        + VER_DESC
    )
    print(
        "  "
        + GREEN
        + "help"
        + ESCAPE
        + COLOR_RESET
        + "                              "
        + HELP_DESC
    )
    print(
        "  "
        + GREEN
        + "format"
        + ESCAPE
        + COLOR_RESET
        + "="
        + CYAN
        + "../path/to/file.gd"
        + ESCAPE
        + COLOR_RESET
        + "         "
        + FMT_DESC
    )
    print(
        "  "
        + GREEN
        + "compile"
        + ESCAPE
        + COLOR_RESET
        + "="
        + CYAN
        + "../path/to/file.gd"
        + ESCAPE
        + COLOR_RESET
        + "        "
        + COMP_DESC
    )
    print(
        "  "
        + GREEN
        + "exp"
        + ESCAPE
        + COLOR_RESET
        + "="
        + CYAN
        + "../path/to/file.gd"
        + ESCAPE
        + COLOR_RESET
        + "            "
        + EXP_DESC
    )
    print(
        "  "
        + GREEN
        + "setup"
        + ESCAPE
        + COLOR_RESET
        + "="
        + CYAN
        + "../path/setup.py"
        + ESCAPE
        + COLOR_RESET
        + "            "
        + SETUP_DESC
    )
    print(
        "  "
        + GREEN
        + "test"
        + ESCAPE
        + COLOR_RESET
        + "="
        + CYAN
        + "vector2"
        + ESCAPE
        + COLOR_RESET
        + "                      "
        + VEC2_DESC
    )
    print(
        "  "
        + GREEN
        + "test"
        + ESCAPE
        + COLOR_RESET
        + "="
        + CYAN
        + "parser"
        + ESCAPE
        + COLOR_RESET
        + "                       "
        + PARSER_DESC
    )
    print(
        "  "
        + GREEN
        + "benchmark"
        + ESCAPE
        + COLOR_RESET
        + "                         "
        + BENCH_DESC
    )
    print(
        "  "
        + GREEN
        + "gen_api"
        + ESCAPE
        + COLOR_RESET
        + "="
        + CYAN
        + "../path/to/godot4"
        + ESCAPE
        + COLOR_RESET
        + "         "
        + GEN_API
    )


def run_benchmark():
    gdsbin = {"test": {}}
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.benchmark

    gdsbin.test.benchmark.run()


def run_parser():
    gdsbin = {"test": {}}
    # gdsbin.test.advanced_expression_matching = Advanced_expression_matching.new()
    # gdsbin.test.advanced_expression_matching.test()
    # gdsbin.test.arrays = Arrays.new()
    # gdsbin.test.arrays.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.arrays_dictionaries_nested_const

    gdsbin.test.arrays_dictionaries_nested_const.test()
    # gdsbin.test.basic_expression_matching = Basic_expression_matching.new()
    # gdsbin.test.basic_expression_matching.test()
    # gdsbin.test.bitwise_operators = Bitwise_operators.new()
    # gdsbin.test.bitwise_operators.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.concatenation

    gdsbin.test.concatenation.test()
    # gdsbin.test.constants = Constants.new()
    # gdsbin.test.constants.test()
    # gdsbin.test.dictionaries = Dictionaries.new()
    # gdsbin.test.dictionaries.test()
    # gdsbin.test.dictionary_lua_style = Dictionary_lua_style.new()
    # gdsbin.test.dictionary_lua_style.test()
    # gdsbin.test.dictionary_mixed_syntax = Dictionary_mixed_syntax.new()
    # gdsbin.test.dictionary_mixed_syntax.test()
    # gdsbin.test.dollar_and_percent_get_node = Dollar_and_percent_get_node.new()
    # gdsbin.test.dollar_and_percent_get_node.test()
    # gdsbin.test.dollar_node_paths = Dollar_node_paths.new()
    # gdsbin.test.dollar_node_paths.test()
    # gdsbin.test.enums = Enums.new()
    # gdsbin.test.enums.test()
    # gdsbin.test.export_variable = Export_variable.new()
    # gdsbin.test.export_variable.test()
    # gdsbin.test.float_notation = Float_notation.new()
    # gdsbin.test.float_notation.test()
    # gdsbin.test.for_range = For_range.new()
    # gdsbin.test.for_range.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.function_default_parameter_type_inference

    gdsbin.test.function_default_parameter_type_inference.test()
    # gdsbin.test.function_many_parameters = Function_many_parameters.new()
    # gdsbin.test.function_many_parameters.test()
    # gdsbin.test.if_after_lambda = If_after_lambda.new()
    # gdsbin.test.if_after_lambda.test()
    # gdsbin.test.ins = Ins.new()
    # gdsbin.test.ins.test()
    # gdsbin.test.lambda_callable = Lambda_callable.new()
    # gdsbin.test.lambda_callable.test()
    # gdsbin.test.lambda_capture_callable = Lambda_capture_callable.new()
    # gdsbin.test.lambda_capture_callable.test()
    # gdsbin.test.lambda_default_parameter_capture = Lambda_default_parameter_capture.new()
    # gdsbin.test.lambda_default_parameter_capture.test()
    # gdsbin.test.lambda_named_callable = Lambda_named_callable.new()
    # gdsbin.test.lambda_named_callable.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.matches

    gdsbin.test.matches.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.match_bind_unused

    gdsbin.test.match_bind_unused.test()
    # gdsbin.test.match_dictionary = Match_dictionary.new()
    # gdsbin.test.match_dictionary.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.match_multiple_patterns_with_array

    gdsbin.test.match_multiple_patterns_with_array.test()
    # gdsbin.test.match_multiple_variable_binds_in_pattern = Match_multiple_variable_binds_in_pattern.new()
    # gdsbin.test.match_multiple_variable_binds_in_pattern.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.multiline_arrays

    gdsbin.test.multiline_arrays.test()
    # gdsbin.test.multiline_dictionaries = Multiline_dictionaries.new()
    # gdsbin.test.multiline_dictionaries.test()
    # gdsbin.test.multiline_if = Multiline_if.new()
    # gdsbin.test.multiline_if.test()
    # gdsbin.test.multiline_strings = Multiline_strings.new()
    # gdsbin.test.multiline_strings.test()
    # gdsbin.test.multiline_vector = Multiline_vector.new()
    # gdsbin.test.multiline_vector.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.nested_arithmetic

    gdsbin.test.nested_arithmetic.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.nested_array

    gdsbin.test.nested_array.test()
    # gdsbin.test.nested_dictionary = Nested_dictionary.new()
    # gdsbin.test.nested_dictionary.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.nested_function_calls

    gdsbin.test.nested_function_calls.test()
    # gdsbin.test.nested_if = Nested_if.new()
    # gdsbin.test.nested_if.test()
    # gdsbin.test.nested_match = Nested_match.new()
    # gdsbin.test.nested_match.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.nested_parentheses

    gdsbin.test.nested_parentheses.test()
    # gdsbin.test.number_separators = Number_separators.new()
    # gdsbin.test.number_separators.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.operator_assign

    gdsbin.test.operator_assign.test()
    # gdsbin.test.property_setter_getter = Property_setter_getter.new()
    # gdsbin.test.property_setter_getter.test()
    # gdsbin.test.semicolon_as_end_statement = Semicolon_as_end_statement.new()
    # gdsbin.test.semicolon_as_end_statement.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.semicolon_as_terminator

    gdsbin.test.semicolon_as_terminator.test()
    # gdsbin.test.signal_declaration = Signal_declaration.new()
    # gdsbin.test.signal_declaration.test()
    # gdsbin.test.static_typing = Static_typing.new()
    # gdsbin.test.static_typing.test()
    # gdsbin.test.string_formatting = String_formatting.new()
    # gdsbin.test.string_formatting.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.str_preserves_case

    gdsbin.test.str_preserves_case.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.trailing_comma_in_function_args

    gdsbin.test.trailing_comma_in_function_args.test()
    # gdsbin.test.truthiness = Truthiness.new()
    # gdsbin.test.truthiness.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.typed_arrays

    gdsbin.test.typed_arrays.test()
    # gdsbin.test.variable_declaration = Variable_declaration.new()
    # gdsbin.test.variable_declaration.test()
    sys.path.insert(0, os.path.normpath(os.path.join(os.path.dirname(__file__), "..")))
    import gdsbin.test.whiles

    gdsbin.test.whiles.test()


def run_vector2():
    import gdsbin.vector2

    vector2 = type(gdsbin.vector2)(gdsbin.vector2.__name__, gdsbin.vector2.__doc__)
    vector2.__dict__.update(gdsbin.vector2.__dict__)
    vector2.x = 3
    vector2.y = 5
    print("x -> " + str(vector2.x))
    print("y -> " + str(vector2.y))
    print("angle() -> " + str(vector2.angle(vector2)))
    vector2_res = vector2.from_angle(30)
    print(
        "from_angle(30) -> "
        + "("
        + str(vector2_res.x)
        + ", "
        + str(vector2_res.y)
        + ")"
    )
    print("vec_length() -> " + str(vector2.vec_length(vector2)))
    print("length_squared() -> " + str(vector2.length_squared(vector2)))
    vector2_res2 = vector2.normalized(vector2)
    print(
        "normalized() -> "
        + "("
        + str(vector2_res2.x)
        + ", "
        + str(vector2_res2.y)
        + ")"
    )
    print("is_normalized() -> " + str(vector2_res2.is_normalized(vector2)))
    print("distance_to() -> " + str(vector2.distance_to(vector2, vector2)))
    print(
        "distance_squared_to() -> " + str(vector2.distance_squared_to(vector2, vector2))
    )
    print("angle_to() -> " + str(vector2.angle_to(vector2, vector2)))
    print("angle_to_point() -> " + str(vector2.angle_to_point(vector2, vector2)))
    print("dot() -> " + str(vector2.dot(vector2, vector2)))
    print("cross() -> " + str(vector2.cross(vector2, vector2)))
    vec_rot = vector2.rotated(vector2, 1)
    print("rotated() -> " + "(" + str(vec_rot.x) + ", " + str(vec_rot.y) + ")")
    vec_proj = vector2.project(vector2, vector2)
    print("project() -> " + "(" + str(vec_proj.x) + ", " + str(vec_proj.y) + ")")
    vec_lim = vector2.limit_length(vector2, 2, vector2)
    print("limit_length() -> " + "(" + str(vec_lim.x) + ", " + str(vec_lim.y) + ")")


def left(s, amount):
    return s[:amount]


def right(s, amount):
    return s[len(s) - amount :]


if __name__ == "__main__":
    _init()


def get_script():
    class Script:
        def get_global_name():
            return class_name

    return Script
