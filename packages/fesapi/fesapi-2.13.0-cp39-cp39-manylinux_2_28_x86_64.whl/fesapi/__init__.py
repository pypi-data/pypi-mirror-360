# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _fesapi
else:
    import _fesapi

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class Int64Array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "long long"):
        _fesapi.Int64Array_swiginit(self, _fesapi.new_Int64Array(nelements))
    __swig_destroy__ = _fesapi.delete_Int64Array

    def getitem(self, index: "long long") -> "int64_t":
        return _fesapi.Int64Array_getitem(self, index)

    def setitem(self, index: "long long", value: "int64_t") -> "void":
        return _fesapi.Int64Array_setitem(self, index, value)

    def cast(self) -> "int64_t *":
        return _fesapi.Int64Array_cast(self)

    @staticmethod
    def frompointer(t: "int64_t *") -> "Int64Array *":
        return _fesapi.Int64Array_frompointer(t)

# Register Int64Array in _fesapi:
_fesapi.Int64Array_swigregister(Int64Array)
class UInt64Array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "long long"):
        _fesapi.UInt64Array_swiginit(self, _fesapi.new_UInt64Array(nelements))
    __swig_destroy__ = _fesapi.delete_UInt64Array

    def getitem(self, index: "long long") -> "uint64_t":
        return _fesapi.UInt64Array_getitem(self, index)

    def setitem(self, index: "long long", value: "uint64_t") -> "void":
        return _fesapi.UInt64Array_setitem(self, index, value)

    def cast(self) -> "uint64_t *":
        return _fesapi.UInt64Array_cast(self)

    @staticmethod
    def frompointer(t: "uint64_t *") -> "UInt64Array *":
        return _fesapi.UInt64Array_frompointer(t)

# Register UInt64Array in _fesapi:
_fesapi.UInt64Array_swigregister(UInt64Array)
class Int32Array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "long long"):
        _fesapi.Int32Array_swiginit(self, _fesapi.new_Int32Array(nelements))
    __swig_destroy__ = _fesapi.delete_Int32Array

    def getitem(self, index: "long long") -> "int32_t":
        return _fesapi.Int32Array_getitem(self, index)

    def setitem(self, index: "long long", value: "int32_t") -> "void":
        return _fesapi.Int32Array_setitem(self, index, value)

    def cast(self) -> "int32_t *":
        return _fesapi.Int32Array_cast(self)

    @staticmethod
    def frompointer(t: "int32_t *") -> "Int32Array *":
        return _fesapi.Int32Array_frompointer(t)

# Register Int32Array in _fesapi:
_fesapi.Int32Array_swigregister(Int32Array)
class UInt32Array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "long long"):
        _fesapi.UInt32Array_swiginit(self, _fesapi.new_UInt32Array(nelements))
    __swig_destroy__ = _fesapi.delete_UInt32Array

    def getitem(self, index: "long long") -> "uint32_t":
        return _fesapi.UInt32Array_getitem(self, index)

    def setitem(self, index: "long long", value: "uint32_t") -> "void":
        return _fesapi.UInt32Array_setitem(self, index, value)

    def cast(self) -> "uint32_t *":
        return _fesapi.UInt32Array_cast(self)

    @staticmethod
    def frompointer(t: "uint32_t *") -> "UInt32Array *":
        return _fesapi.UInt32Array_frompointer(t)

# Register UInt32Array in _fesapi:
_fesapi.UInt32Array_swigregister(UInt32Array)
class Int16Array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "long long"):
        _fesapi.Int16Array_swiginit(self, _fesapi.new_Int16Array(nelements))
    __swig_destroy__ = _fesapi.delete_Int16Array

    def getitem(self, index: "long long") -> "int16_t":
        return _fesapi.Int16Array_getitem(self, index)

    def setitem(self, index: "long long", value: "int16_t") -> "void":
        return _fesapi.Int16Array_setitem(self, index, value)

    def cast(self) -> "int16_t *":
        return _fesapi.Int16Array_cast(self)

    @staticmethod
    def frompointer(t: "int16_t *") -> "Int16Array *":
        return _fesapi.Int16Array_frompointer(t)

# Register Int16Array in _fesapi:
_fesapi.Int16Array_swigregister(Int16Array)
class UInt16Array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "long long"):
        _fesapi.UInt16Array_swiginit(self, _fesapi.new_UInt16Array(nelements))
    __swig_destroy__ = _fesapi.delete_UInt16Array

    def getitem(self, index: "long long") -> "uint16_t":
        return _fesapi.UInt16Array_getitem(self, index)

    def setitem(self, index: "long long", value: "uint16_t") -> "void":
        return _fesapi.UInt16Array_setitem(self, index, value)

    def cast(self) -> "uint16_t *":
        return _fesapi.UInt16Array_cast(self)

    @staticmethod
    def frompointer(t: "uint16_t *") -> "UInt16Array *":
        return _fesapi.UInt16Array_frompointer(t)

# Register UInt16Array in _fesapi:
_fesapi.UInt16Array_swigregister(UInt16Array)
class Int8Array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "long long"):
        _fesapi.Int8Array_swiginit(self, _fesapi.new_Int8Array(nelements))
    __swig_destroy__ = _fesapi.delete_Int8Array

    def getitem(self, index: "long long") -> "int8_t":
        return _fesapi.Int8Array_getitem(self, index)

    def setitem(self, index: "long long", value: "int8_t") -> "void":
        return _fesapi.Int8Array_setitem(self, index, value)

    def cast(self) -> "int8_t *":
        return _fesapi.Int8Array_cast(self)

    @staticmethod
    def frompointer(t: "int8_t *") -> "Int8Array *":
        return _fesapi.Int8Array_frompointer(t)

# Register Int8Array in _fesapi:
_fesapi.Int8Array_swigregister(Int8Array)
class UInt8Array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "long long"):
        _fesapi.UInt8Array_swiginit(self, _fesapi.new_UInt8Array(nelements))
    __swig_destroy__ = _fesapi.delete_UInt8Array

    def getitem(self, index: "long long") -> "uint8_t":
        return _fesapi.UInt8Array_getitem(self, index)

    def setitem(self, index: "long long", value: "uint8_t") -> "void":
        return _fesapi.UInt8Array_setitem(self, index, value)

    def cast(self) -> "uint8_t *":
        return _fesapi.UInt8Array_cast(self)

    @staticmethod
    def frompointer(t: "uint8_t *") -> "UInt8Array *":
        return _fesapi.UInt8Array_frompointer(t)

# Register UInt8Array in _fesapi:
_fesapi.UInt8Array_swigregister(UInt8Array)
class FloatArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "long long"):
        _fesapi.FloatArray_swiginit(self, _fesapi.new_FloatArray(nelements))
    __swig_destroy__ = _fesapi.delete_FloatArray

    def getitem(self, index: "long long") -> "float":
        return _fesapi.FloatArray_getitem(self, index)

    def setitem(self, index: "long long", value: "float") -> "void":
        return _fesapi.FloatArray_setitem(self, index, value)

    def cast(self) -> "float *":
        return _fesapi.FloatArray_cast(self)

    @staticmethod
    def frompointer(t: "float *") -> "FloatArray *":
        return _fesapi.FloatArray_frompointer(t)

# Register FloatArray in _fesapi:
_fesapi.FloatArray_swigregister(FloatArray)
class DoubleArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "long long"):
        _fesapi.DoubleArray_swiginit(self, _fesapi.new_DoubleArray(nelements))
    __swig_destroy__ = _fesapi.delete_DoubleArray

    def getitem(self, index: "long long") -> "double":
        return _fesapi.DoubleArray_getitem(self, index)

    def setitem(self, index: "long long", value: "double") -> "void":
        return _fesapi.DoubleArray_setitem(self, index, value)

    def cast(self) -> "double *":
        return _fesapi.DoubleArray_cast(self)

    @staticmethod
    def frompointer(t: "double *") -> "DoubleArray *":
        return _fesapi.DoubleArray_frompointer(t)

# Register DoubleArray in _fesapi:
_fesapi.DoubleArray_swigregister(DoubleArray)
class BoolArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "long long"):
        _fesapi.BoolArray_swiginit(self, _fesapi.new_BoolArray(nelements))
    __swig_destroy__ = _fesapi.delete_BoolArray

    def getitem(self, index: "long long") -> "bool":
        return _fesapi.BoolArray_getitem(self, index)

    def setitem(self, index: "long long", value: "bool") -> "void":
        return _fesapi.BoolArray_setitem(self, index, value)

    def cast(self) -> "bool *":
        return _fesapi.BoolArray_cast(self)

    @staticmethod
    def frompointer(t: "bool *") -> "BoolArray *":
        return _fesapi.BoolArray_frompointer(t)

# Register BoolArray in _fesapi:
_fesapi.BoolArray_swigregister(BoolArray)
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _fesapi.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _fesapi.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _fesapi.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _fesapi.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _fesapi.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _fesapi.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _fesapi.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _fesapi.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _fesapi.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _fesapi.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _fesapi.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _fesapi.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _fesapi.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _fesapi.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _fesapi.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _fesapi.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _fesapi:
_fesapi.SwigPyIterator_swigregister(SwigPyIterator)
class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fesapi.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fesapi.StringVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fesapi.StringVector___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _fesapi.StringVector___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _fesapi.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fesapi.StringVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _fesapi.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fesapi.StringVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _fesapi.StringVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fesapi.StringVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _fesapi.StringVector_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _fesapi.StringVector_append(self, x)

    def empty(self) -> "bool":
        return _fesapi.StringVector_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _fesapi.StringVector_size(self)

    def swap(self, v: "StringVector") -> "void":
        return _fesapi.StringVector_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _fesapi.StringVector_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _fesapi.StringVector_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _fesapi.StringVector_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _fesapi.StringVector_rend(self)

    def clear(self) -> "void":
        return _fesapi.StringVector_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _fesapi.StringVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fesapi.StringVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _fesapi.StringVector_erase(self, *args)

    def __init__(self, *args):
        _fesapi.StringVector_swiginit(self, _fesapi.new_StringVector(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _fesapi.StringVector_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _fesapi.StringVector_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _fesapi.StringVector_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _fesapi.StringVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fesapi.StringVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fesapi.StringVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _fesapi.StringVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _fesapi.StringVector_capacity(self)
    __swig_destroy__ = _fesapi.delete_StringVector

# Register StringVector in _fesapi:
_fesapi.StringVector_swigregister(StringVector)
class Int32Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fesapi.Int32Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fesapi.Int32Vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fesapi.Int32Vector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _fesapi.Int32Vector___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _fesapi.Int32Vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fesapi.Int32Vector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _fesapi.Int32Vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fesapi.Int32Vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _fesapi.Int32Vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fesapi.Int32Vector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _fesapi.Int32Vector_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _fesapi.Int32Vector_append(self, x)

    def empty(self) -> "bool":
        return _fesapi.Int32Vector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _fesapi.Int32Vector_size(self)

    def swap(self, v: "Int32Vector") -> "void":
        return _fesapi.Int32Vector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _fesapi.Int32Vector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _fesapi.Int32Vector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _fesapi.Int32Vector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _fesapi.Int32Vector_rend(self)

    def clear(self) -> "void":
        return _fesapi.Int32Vector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _fesapi.Int32Vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fesapi.Int32Vector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _fesapi.Int32Vector_erase(self, *args)

    def __init__(self, *args):
        _fesapi.Int32Vector_swiginit(self, _fesapi.new_Int32Vector(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _fesapi.Int32Vector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _fesapi.Int32Vector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _fesapi.Int32Vector_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _fesapi.Int32Vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fesapi.Int32Vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fesapi.Int32Vector_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _fesapi.Int32Vector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _fesapi.Int32Vector_capacity(self)
    __swig_destroy__ = _fesapi.delete_Int32Vector

# Register Int32Vector in _fesapi:
_fesapi.Int32Vector_swigregister(Int32Vector)
class UInt32Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fesapi.UInt32Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fesapi.UInt32Vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fesapi.UInt32Vector___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        return _fesapi.UInt32Vector___len__(self)

    def __getslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        return _fesapi.UInt32Vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fesapi.UInt32Vector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "void":
        return _fesapi.UInt32Vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fesapi.UInt32Vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        return _fesapi.UInt32Vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fesapi.UInt32Vector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        return _fesapi.UInt32Vector_pop(self)

    def append(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _fesapi.UInt32Vector_append(self, x)

    def empty(self) -> "bool":
        return _fesapi.UInt32Vector_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        return _fesapi.UInt32Vector_size(self)

    def swap(self, v: "UInt32Vector") -> "void":
        return _fesapi.UInt32Vector_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        return _fesapi.UInt32Vector_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        return _fesapi.UInt32Vector_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _fesapi.UInt32Vector_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _fesapi.UInt32Vector_rend(self)

    def clear(self) -> "void":
        return _fesapi.UInt32Vector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        return _fesapi.UInt32Vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fesapi.UInt32Vector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        return _fesapi.UInt32Vector_erase(self, *args)

    def __init__(self, *args):
        _fesapi.UInt32Vector_swiginit(self, _fesapi.new_UInt32Vector(*args))

    def push_back(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _fesapi.UInt32Vector_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        return _fesapi.UInt32Vector_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        return _fesapi.UInt32Vector_back(self)

    def assign(self, n: "std::vector< unsigned int >::size_type", x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _fesapi.UInt32Vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fesapi.UInt32Vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fesapi.UInt32Vector_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned int >::size_type") -> "void":
        return _fesapi.UInt32Vector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        return _fesapi.UInt32Vector_capacity(self)
    __swig_destroy__ = _fesapi.delete_UInt32Vector

# Register UInt32Vector in _fesapi:
_fesapi.UInt32Vector_swigregister(UInt32Vector)
class FloatVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fesapi.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fesapi.FloatVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fesapi.FloatVector___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _fesapi.FloatVector___len__(self)

    def __getslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "std::vector< float,std::allocator< float > > *":
        return _fesapi.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fesapi.FloatVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "void":
        return _fesapi.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fesapi.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _fesapi.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fesapi.FloatVector___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _fesapi.FloatVector_pop(self)

    def append(self, x: "std::vector< float >::value_type const &") -> "void":
        return _fesapi.FloatVector_append(self, x)

    def empty(self) -> "bool":
        return _fesapi.FloatVector_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _fesapi.FloatVector_size(self)

    def swap(self, v: "FloatVector") -> "void":
        return _fesapi.FloatVector_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _fesapi.FloatVector_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _fesapi.FloatVector_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _fesapi.FloatVector_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _fesapi.FloatVector_rend(self)

    def clear(self) -> "void":
        return _fesapi.FloatVector_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _fesapi.FloatVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fesapi.FloatVector_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _fesapi.FloatVector_erase(self, *args)

    def __init__(self, *args):
        _fesapi.FloatVector_swiginit(self, _fesapi.new_FloatVector(*args))

    def push_back(self, x: "std::vector< float >::value_type const &") -> "void":
        return _fesapi.FloatVector_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _fesapi.FloatVector_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _fesapi.FloatVector_back(self)

    def assign(self, n: "std::vector< float >::size_type", x: "std::vector< float >::value_type const &") -> "void":
        return _fesapi.FloatVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fesapi.FloatVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fesapi.FloatVector_insert(self, *args)

    def reserve(self, n: "std::vector< float >::size_type") -> "void":
        return _fesapi.FloatVector_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _fesapi.FloatVector_capacity(self)
    __swig_destroy__ = _fesapi.delete_FloatVector

# Register FloatVector in _fesapi:
_fesapi.FloatVector_swigregister(FloatVector)
class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fesapi.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fesapi.DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fesapi.DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _fesapi.DoubleVector___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        return _fesapi.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fesapi.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        return _fesapi.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fesapi.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _fesapi.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fesapi.DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _fesapi.DoubleVector_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _fesapi.DoubleVector_append(self, x)

    def empty(self) -> "bool":
        return _fesapi.DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _fesapi.DoubleVector_size(self)

    def swap(self, v: "DoubleVector") -> "void":
        return _fesapi.DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _fesapi.DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _fesapi.DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _fesapi.DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _fesapi.DoubleVector_rend(self)

    def clear(self) -> "void":
        return _fesapi.DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _fesapi.DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fesapi.DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _fesapi.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _fesapi.DoubleVector_swiginit(self, _fesapi.new_DoubleVector(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _fesapi.DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _fesapi.DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _fesapi.DoubleVector_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        return _fesapi.DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fesapi.DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fesapi.DoubleVector_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _fesapi.DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _fesapi.DoubleVector_capacity(self)
    __swig_destroy__ = _fesapi.delete_DoubleVector

# Register DoubleVector in _fesapi:
_fesapi.DoubleVector_swigregister(DoubleVector)
class BoolVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fesapi.BoolVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fesapi.BoolVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fesapi.BoolVector___bool__(self)

    def __len__(self) -> "std::vector< bool >::size_type":
        return _fesapi.BoolVector___len__(self)

    def __getslice__(self, i: "std::vector< bool >::difference_type", j: "std::vector< bool >::difference_type") -> "std::vector< bool,std::allocator< bool > > *":
        return _fesapi.BoolVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fesapi.BoolVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< bool >::difference_type", j: "std::vector< bool >::difference_type") -> "void":
        return _fesapi.BoolVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fesapi.BoolVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< bool >::value_type":
        return _fesapi.BoolVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fesapi.BoolVector___setitem__(self, *args)

    def pop(self) -> "std::vector< bool >::value_type":
        return _fesapi.BoolVector_pop(self)

    def append(self, x: "std::vector< bool >::value_type") -> "void":
        return _fesapi.BoolVector_append(self, x)

    def empty(self) -> "bool":
        return _fesapi.BoolVector_empty(self)

    def size(self) -> "std::vector< bool >::size_type":
        return _fesapi.BoolVector_size(self)

    def swap(self, v: "BoolVector") -> "void":
        return _fesapi.BoolVector_swap(self, v)

    def begin(self) -> "std::vector< bool >::iterator":
        return _fesapi.BoolVector_begin(self)

    def end(self) -> "std::vector< bool >::iterator":
        return _fesapi.BoolVector_end(self)

    def rbegin(self) -> "std::vector< bool >::reverse_iterator":
        return _fesapi.BoolVector_rbegin(self)

    def rend(self) -> "std::vector< bool >::reverse_iterator":
        return _fesapi.BoolVector_rend(self)

    def clear(self) -> "void":
        return _fesapi.BoolVector_clear(self)

    def get_allocator(self) -> "std::vector< bool >::allocator_type":
        return _fesapi.BoolVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fesapi.BoolVector_pop_back(self)

    def erase(self, *args) -> "std::vector< bool >::iterator":
        return _fesapi.BoolVector_erase(self, *args)

    def __init__(self, *args):
        _fesapi.BoolVector_swiginit(self, _fesapi.new_BoolVector(*args))

    def push_back(self, x: "std::vector< bool >::value_type") -> "void":
        return _fesapi.BoolVector_push_back(self, x)

    def front(self) -> "std::vector< bool >::value_type":
        return _fesapi.BoolVector_front(self)

    def back(self) -> "std::vector< bool >::value_type":
        return _fesapi.BoolVector_back(self)

    def assign(self, n: "std::vector< bool >::size_type", x: "std::vector< bool >::value_type") -> "void":
        return _fesapi.BoolVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fesapi.BoolVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fesapi.BoolVector_insert(self, *args)

    def reserve(self, n: "std::vector< bool >::size_type") -> "void":
        return _fesapi.BoolVector_reserve(self, n)

    def capacity(self) -> "std::vector< bool >::size_type":
        return _fesapi.BoolVector_capacity(self)
    __swig_destroy__ = _fesapi.delete_BoolVector

# Register BoolVector in _fesapi:
_fesapi.BoolVector_swigregister(BoolVector)
class DataObjectReference(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def isEmpty(self) -> "bool":
        r"""
        Checks if this reference is empty (i.e. it points to nothing)

        :rtype: boolean
        :return: True if this reference empty, false if it is not.
        """
        return _fesapi.DataObjectReference_isEmpty(self)

    def getUuid(self) -> "std::string":
        r"""
        Gets the referenced data object UUID

        :rtype: string
        :return: The UUID of the referenced data object if it exists, otherwise empty string.
        """
        return _fesapi.DataObjectReference_getUuid(self)

    def getTitle(self) -> "std::string":
        r"""
        Gets the referenced data object title (i.e. its name)

        :rtype: string
        :return: The title of the referenced data object if it exists, otherwise empty string.
        """
        return _fesapi.DataObjectReference_getTitle(self)

    def getVersion(self) -> "std::string":
        r"""
        Gets the referenced data object version

        :rtype: string
        :return: The version of the referenced data object if it exists, otherwise empty string.
        """
        return _fesapi.DataObjectReference_getVersion(self)

    def getContentType(self) -> "std::string":
        r"""
        Gets the referenced data object type

        :rtype: string
        :return: The content type of the referenced data object if it exists, otherwise empty string.
        """
        return _fesapi.DataObjectReference_getContentType(self)
    __swig_destroy__ = _fesapi.delete_DataObjectReference

# Register DataObjectReference in _fesapi:
_fesapi.DataObjectReference_swigregister(DataObjectReference)
class AbstractObject(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    numericalDatatypeEnum_UNKNOWN = _fesapi.AbstractObject_numericalDatatypeEnum_UNKNOWN
    numericalDatatypeEnum_DOUBLE = _fesapi.AbstractObject_numericalDatatypeEnum_DOUBLE
    numericalDatatypeEnum_FLOAT = _fesapi.AbstractObject_numericalDatatypeEnum_FLOAT
    numericalDatatypeEnum_INT64 = _fesapi.AbstractObject_numericalDatatypeEnum_INT64
    numericalDatatypeEnum_UINT64 = _fesapi.AbstractObject_numericalDatatypeEnum_UINT64
    numericalDatatypeEnum_INT32 = _fesapi.AbstractObject_numericalDatatypeEnum_INT32
    numericalDatatypeEnum_UINT32 = _fesapi.AbstractObject_numericalDatatypeEnum_UINT32
    numericalDatatypeEnum_INT16 = _fesapi.AbstractObject_numericalDatatypeEnum_INT16
    numericalDatatypeEnum_UINT16 = _fesapi.AbstractObject_numericalDatatypeEnum_UINT16
    numericalDatatypeEnum_INT8 = _fesapi.AbstractObject_numericalDatatypeEnum_INT8
    numericalDatatypeEnum_UINT8 = _fesapi.AbstractObject_numericalDatatypeEnum_UINT8
    __swig_destroy__ = _fesapi.delete_AbstractObject

    def isPartial(self) -> "bool":
        r"""
        Indicates if this data object is actually a partial object. A partial object just contains a mime
        type, an UUID and a title as a minimum amount of information. A partial object is never
        explicit in an EPC document: it is not a file

        :rtype: boolean
        :return: True if is partial, false if is not.
        """
        return _fesapi.AbstractObject_isPartial(self)

    def getUuid(self) -> "std::string":
        r"""
        Gets the UUID (https://tools.ietf.org/html/rfc4122#page-3) of this data object. The UUID
        intends to give an id to the "thing" (i.e. the business object), not to this instance

        :raises: std::invalid_argument	If no available gSOAP proxy instance is associated to
            										this data object.

        :rtype: string
        :return: The UUID of this data object.
        """
        return _fesapi.AbstractObject_getUuid(self)

    def getTitle(self) -> "std::string":
        r"""
        Gets the title (i.e. the name) of this data object. This is the equivalent of
        ``CI_Citation.title`` in ISO 19115

        :raises: std::invalid_argument	If no available gSOAP proxy instance is associated to
            										this data object.

        :rtype: string
        :return: The title of this data object.
        """
        return _fesapi.AbstractObject_getTitle(self)

    def getEditor(self) -> "std::string":
        r"""
        Gets the name (or other human-readable identifier) of the last person who updated the object.
        In ISO 19115, this is equivalent to the ``CI_Individual.name`` or the ``CI_Organization.name`` of
        the ``citedResponsibleParty`` whose role is ``editor``

        :raises: std::invalid_argument	If this instance is actually a partial object.

        :rtype: string
        :return: The editor of this data object if it is defined, else empty string.
        """
        return _fesapi.AbstractObject_getEditor(self)

    def getCreation(self) -> "time_t":
        r"""
        Gets the date and time the data object was created in the source application or, if that
        information is not available, when it was saved to the file. This is the equivalent of the
        ISO 19115 ``CI_Date`` where the ``CI_DateTypeCode`` is ``creation``

        :raises: std::invalid_argument	If this instance is actually a partial object or if no
            										available gSOAP proxy instance is associated to this data
            										object.

        :rtype: int
        :return: The creation date and time of the data object.
        """
        return _fesapi.AbstractObject_getCreation(self)

    def getOriginator(self) -> "std::string":
        r"""
        Gets the name (or other human-readable identifier) of the person who initially originated
        this data object or document in the source application. If that information is not available,
        then this is the user of the session during the file creation. The originator remains the
        same as the object is subsequently edited. This is the equivalent in ISO 19115 to the
        ``CI_Individual.name`` or the ``CI_Organization.name`` of the ``citedResponsibleParty`` whose role
        is ``originator``

        :raises: std::invalid_argument	If this instance is actually a partial object or if no
            										available gSOAP proxy instance is associated to this data
            										object.

        :rtype: string
        :return: The originator name or identifier.
        """
        return _fesapi.AbstractObject_getOriginator(self)

    def getDescription(self) -> "std::string":
        r"""
        Gets the user descriptive comments about this data object. Intended for end-user use (human
        readable); not necessarily meant to be used by software. This is the equivalent of the ISO
        19115 ``abstract.CharacterString``

        :raises: std::invalid_argument	If this instance is actually a partial object.

        :rtype: string
        :return: The description of this data object if it is defined, else empty string.
        """
        return _fesapi.AbstractObject_getDescription(self)

    def getLastUpdate(self) -> "time_t":
        r"""
        Gets the date and time the data object was last modified in the source application or, if
        that information is not available, when it was last saved to the file. This is the equivalent
        of the ISO 19115 ``CI_Date`` where the ``CI_DateTypeCode`` is ``lastUpdate``

        :raises: std::invalid_argument	If this instance is actually a partial object.

        :rtype: int
        :return: The last update date and time of the data object.
        """
        return _fesapi.AbstractObject_getLastUpdate(self)

    def getFormat(self) -> "std::string":
        r"""
        Gets the identifier of the software or service that was used to originate the data object and
        to create the file. Must be human and machine readable and unambiguously identify the
        software by including the company name, software name and software version. This is the
        equivalent in ISO 19115 to the ``istributionFormat.MD_Format``. The ISO format for this is
         [vendor:applicationName]/fileExtension  where the application name includes the
        version number of the application. In our case, ``fileExtension`` is not relevant and will be
        ignored if present. ``vendor`` and ``applicationName`` are mandatory

        :raises: std::invalid_argument	If this instance is actually a partial object or if no
            										available gSOAP proxy instance is associated to this data
            										object.

        :rtype: string
        :return: The identifier of the software or service that was used to originate the data object
            			and to create the file.
        """
        return _fesapi.AbstractObject_getFormat(self)

    def getDescriptiveKeywords(self) -> "std::string":
        r"""
        Gets the key words to describe the activity, for example, history match or volumetric
        calculations, relevant to this data object. Intended to be used in a search function by
        software. This is the equivalent in ISO 19115 of ``descriptiveKeywords.MD_Keywords``

        :raises: std::invalid_argument	If this instance is actually a partial object.

        :rtype: string
        :return: The key words to describe the activity relevant to this data object if they are
            			defined, else empty string.
        """
        return _fesapi.AbstractObject_getDescriptiveKeywords(self)

    def getVersion(self) -> "std::string":
        r"""
        Gets the version of this data object. An empty version indicates that this is the latest (and
        ideally also the unique) version of this data object.

        :rtype: string
        :return: The version of this object, empty string means latest version.
        """
        return _fesapi.AbstractObject_getVersion(self)

    def setTitle(self, title: "std::string const &") -> "void":
        r"""
        Sets the title (i.e. the name) of this data object. This is the equivalent of
        ``CI_Citation.title`` in ISO 19115

        :raises: std::invalid_argument	If this instance is actually a partial object.
        :raises: std::range_error	 	If ``title`` is more than 256 chars long.

        :type title: string
        :param title:	The title to set to this data object. If empty then "unknown" title will be
            					set.
        """
        return _fesapi.AbstractObject_setTitle(self, title)

    def setEditor(self, editor: "std::string const &") -> "void":
        r"""
        Sets the name (or other human-readable identifier) of the last person who updated the object.
        In ISO 19115, this is equivalent to the ``CI_Individual.name`` or the ``CI_Organization.name``
        of the ``citedResponsibleParty`` whose role is ``editor``

        :raises: std::invalid_argument	If this instance is actually a partial object.
        :raises: std::range_error	 	If ``editor`` is more than 64 chars long.

        :type editor: string
        :param editor:	The editor to set to this data object.
        """
        return _fesapi.AbstractObject_setEditor(self, editor)

    def setCreation(self, creation: "time_t") -> "void":
        r"""
        Sets the date and time the data object was created in the source application or, if that
        information is not available, when it was saved to the file. This is the equivalent of the
        ISO 19115 ``CI_Date`` where the ``CI_DateTypeCode`` is ``creation``

        :raises: std::invalid_argument	If this instance is actually a partial object.

        :type creation: int
        :param creation:	The creation date and time to set to this data object.
        """
        return _fesapi.AbstractObject_setCreation(self, creation)

    def setOriginator(self, originator: "std::string const &") -> "void":
        r"""
        Sets the name (or other human-readable identifier) of the person who initially originated
        this data object or document in the source application. If that information is not available,
        then this is the user of the session during the file creation. The originator remains the
        same as the object is subsequently edited. This is the equivalent in ISO 19115 to the
        ``CI_Individual.name`` or the ``CI_Organization.name`` of the ``citedResponsibleParty`` whose role
        is ``originator``

        :raises: std::invalid_argument	If this instance is actually a partial object.
        :raises: std::range_error	 	If ``originator`` is more than 64 chars long.

        :type originator: string
        :param originator:	The originator name or identifier to set to this data object. If empty,
            						the user id is set if available, "unknown" if it is not.
        """
        return _fesapi.AbstractObject_setOriginator(self, originator)

    def setDescription(self, description: "std::string const &") -> "void":
        r"""
        Sets a user descriptive comments about this data object. Intended for end-user use (human
        readable); not necessarily meant to be used by software. This is the equivalent of the ISO
        19115 ``abstract.CharacterString``

        :raises: std::invalid_argument	If this instance is actually a partial object.
        :raises: std::range_error	 	If ``description`` is too long (more than 4000 chars for
            										RESQML2.0 or more than 2000 chars for EML2.1 and EML2.2).

        :type description: string
        :param description:	The description to set to this data object.
        """
        return _fesapi.AbstractObject_setDescription(self, description)

    def setLastUpdate(self, lastUpdate: "time_t") -> "void":
        r"""
        Sets the date and time the data object was last modified in the source application or, if
        that information is not available, when it was last saved to the file. This is the equivalent
        of the ISO 19115 ``CI_Date`` where the ``CI_DateTypeCode`` is ``lastUpdate``

        :raises: std::invalid_argument	If this instance is actually a partial object.

        :type lastUpdate: int
        :param lastUpdate:	The last update date and time to set to this data object.
        """
        return _fesapi.AbstractObject_setLastUpdate(self, lastUpdate)

    @staticmethod
    def setFormat(vendor: "std::string const &", applicationName: "std::string const &", applicationVersionNumber: "std::string const &") -> "void":
        r"""
        Sets the default citation format which is going to be written in each created object. A
        maximum of 256 chars is allowed.

        :raises: std::range_error	If the format is more than 256 chars long.

        :type vendor: string
        :param vendor:						The name of the vendor which is exporting the data
            										objects.
        :type applicationName: string
        :param applicationName:				The name of the application which is exporting the data
            										objects.
        :type applicationVersionNumber: string
        :param applicationVersionNumber:	The version of the application which is exporting the
            										data objects.
        """
        return _fesapi.AbstractObject_setFormat(vendor, applicationName, applicationVersionNumber)

    def setDescriptiveKeywords(self, descriptiveKeywords: "std::string const &") -> "void":
        r"""
        Set the key words to describe the activity, for example, history match or volumetric
        calculations, relevant to this object. Intended to be used in a search function by software.
        This is the equivalent in ISO 19115 of descriptiveKeywords.MD_Keywords

        :raises: std::invalid_argument	If this instance is actually a partial object.
        :raises: std::range_error	 	If ``descriptiveKeywords`` is too long (more than 4000 chars for
            										RESQML2.0 or more than 2000 chars for EML2.1 and EML2.2).

        :type descriptiveKeywords: string
        :param descriptiveKeywords:	The key words to describe the activity relevant to this data
            								object.
        """
        return _fesapi.AbstractObject_setDescriptiveKeywords(self, descriptiveKeywords)

    def setVersion(self, version: "std::string const &") -> "void":
        r"""
        Set the version of this data object

        :raises: std::invalid_argument	If ``version`` is empty.
        :raises: std::range_error	 	If ``version`` is more than 64 chars long.

        :type version: string
        :param version:	The version to set to this data object.
        """
        return _fesapi.AbstractObject_setVersion(self, version)

    def setMetadata(self, title: "std::string const &", editor: "std::string const &", creation: "time_t", originator: "std::string const &", description: "std::string const &", lastUpdate: "time_t", descriptiveKeywords: "std::string const &") -> "void":
        r"""
        Sets a title and other common metadata for this instance.

        :raises: std::invalid_argument	If this instance is actually a partial object.
        :raises: std::range_error	 	If ``title`` is more than 256 chars long.
        :raises: std::range_error	 	If ``editor`` title is more than 64 chars long.
        :raises: std::range_error	 	If ``originator`` title is more than 64 chars long.
        :raises: std::range_error	 	If ``description`` is too long (more than 4000 chars for
            										RESQML2.0 or more than 2000 chars for EML2.1 and EML2.2).
        :raises: std::range_error	 	If ``descriptiveKeywords`` is too long (more than 4000
            										chars for RESQML2.0 or more than 2000 chars for EML2.1
            										and EML2.2).

        :type title: string
        :param title:			   	The title to set to this instance. If empty then "unknown"
            								title will be set.
        :type editor: string
        :param editor:			   	The editor to set to this instance. Set to empty string or zero
            								if you don't want to use.
        :type creation: int
        :param creation:		   	The creation date and time to set to this instance.
        :type originator: string
        :param originator:		   	The originator name or identifier to set to this instance. If
            								empty, the user id is set if available, "unknown" if it is not.
        :type description: string
        :param description:		   	The description to set to this instance. Set to empty string or
            								zero if you don't want to use.
        :type lastUpdate: int
        :param lastUpdate:		   	The last update date and time to set to this data object.
        :type descriptiveKeywords: string
        :param descriptiveKeywords:	The key words to describe the activity relevant to this data
            								object. Set to empty string or zero if you don't want to use.
        """
        return _fesapi.AbstractObject_setMetadata(self, title, editor, creation, originator, description, lastUpdate, descriptiveKeywords)

    def getRepository(self) -> "common::DataObjectRepository *":
        r"""
        Returns the data object repository which contains this instance

        :rtype: :py:class:`DataObjectRepository`
        :return: A pointer to the data object repository.
        """
        return _fesapi.AbstractObject_getRepository(self)

    def getXmlNamespace(self) -> "std::string":
        r"""
        Gets the XML namespace for the tags for the XML serialization of this instance

        :rtype: string
        :return: The XML namespace of this instance.
        """
        return _fesapi.AbstractObject_getXmlNamespace(self)

    def getXmlTag(self) -> "std::string":
        r"""
        Gets the standard XML tag without XML namespace for serializing this data object.

        :rtype: string
        :return: The XML tag.
        """
        return _fesapi.AbstractObject_getXmlTag(self)

    def getXmlNamespaceVersion(self) -> "std::string":
        r"""
        Gets the version of the XML namespace (i.e. WITSML, RESQML, PRODML) for the XML serialization
        of this instance

        :rtype: string
        :return: The XML namespace version of this instance.
        """
        return _fesapi.AbstractObject_getXmlNamespaceVersion(self)

    def getQualifiedType(self) -> "std::string":
        r"""
        Get the qualified type of the instance i.e. "namespace.datatype"

        :rtype: string
        :return: The qualified type of the instance i.e. "namespace.datatype"
        """
        return _fesapi.AbstractObject_getQualifiedType(self)

    def serializeIntoString(self) -> "std::string":
        r"""
        Serializes the gSOAP proxy of this instance into a string

        :rtype: string
        :return: The string result of the serialization process.
        """
        return _fesapi.AbstractObject_serializeIntoString(self)

    def addAlias(self, authority: "std::string const &", title: "std::string const &") -> "void":
        r"""
        Adds an alias for this data object

        :raises: std::invalid_argument	If this instance is actually a partial object.
        :raises: std::range_error	 	If ``authority`` or ``title`` is more than 64 chars long.

        :type authority: string
        :param authority:	The authority of the alias.
        :type title: string
        :param title:	 	The title of the alias.
        """
        return _fesapi.AbstractObject_addAlias(self, authority, title)

    def getAliasCount(self) -> "uint64_t":
        r"""
        Gets the count of aliases in this instance

        :raises: std::invalid_argument	If this instance is actually a partial object.

        :rtype: int
        :return: The alias count of this instance.
        """
        return _fesapi.AbstractObject_getAliasCount(self)

    def getAliasAuthorityAtIndex(self, index: "uint64_t") -> "std::string":
        r"""
        Gets the alias authority at a particular index in the aliases set

        :raises: std::invalid_argument	If this instance is actually a partial object or if there
            										is no underlying gSOAP proxy.
        :raises: std::out_of_range	 	If ``index`` is out of range.

        :type index: int
        :param index:	Zero-based index of the asked alias authority.

        :rtype: string
        :return: The alias authority at ``index``.
        """
        return _fesapi.AbstractObject_getAliasAuthorityAtIndex(self, index)

    def getAliasTitleAtIndex(self, index: "uint64_t") -> "std::string":
        r"""
        Gets the alias title at a particular index in the aliases set

        :raises: std::invalid_argument	If this instance is actually a partial object or if there
            										is no underlying gSOAP proxy.
        :raises: std::out_of_range	 	If ``index`` is out of range.

        :type index: int
        :param index:	Zero-based index of the asked alias title.

        :rtype: string
        :return: The alias title at ``index``.
        """
        return _fesapi.AbstractObject_getAliasTitleAtIndex(self, index)

    def getActivityCount(self) -> "uint64_t":
        r"""
        Gets the count of the activities where this instance is involved

        :rtype: int
        :return: The count of all activities involving this instance.
        """
        return _fesapi.AbstractObject_getActivityCount(self)

    def getActivity(self, index: "uint64_t") -> "eml2::Activity *":
        r"""
        Gets an associated activity at a particular index

        :raises: std::invalid_argument	If this instance is actually a partial object or if there
            										is no underlying gSOAP proxy.
        :raises: std::out_of_range	 	If ``index`` is out of range.

        :type index: int
        :param index:	Zero-based index of the asked activity.

        :rtype: :py:class:`Activity`
        :return: The associated activity at ``index``.
        """
        return _fesapi.AbstractObject_getActivity(self, index)

    def pushBackExtraMetadata(self, key: "std::string const &", value: "std::string const &") -> "void":
        r"""
        Pushes back an extra metadata (not a standard one) onto this instance

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0, EML2.1 or EML2.2 one.

        :type key: string
        :param key:  	The key of the metadata.
        :type value: string
        :param value:	The value of the metadata.
        """
        return _fesapi.AbstractObject_pushBackExtraMetadata(self, key, value)

    def getExtraMetadata(self, key: "std::string const &") -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Gets an extra metadata of this instance according to its key

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0 one.

        :type key: string
        :param key:	The key of an extra metadata.

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: The vector of all metadata values sharing this ``key`` (empty vector if there is no such value).
        """
        return _fesapi.AbstractObject_getExtraMetadata(self, key)

    def getExtraMetadataCount(self) -> "uint64_t":
        r"""
        Get the count of extra metadata in this instance

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0 or EML2.2 one.

        :rtype: int
        :return: The extra metadata count of this instance.
        """
        return _fesapi.AbstractObject_getExtraMetadataCount(self)

    def getExtraMetadataKeyAtIndex(self, index: "uint64_t") -> "std::string":
        r"""
        Get the key of a key value pair at a particular index in the extra metadata set of this
        instance

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0 or EML2.2 one.

        :type index: int
        :param index:	Zero-based index of the asked key.

        :rtype: string
        :return: The extra metadata key at ``index``.
        """
        return _fesapi.AbstractObject_getExtraMetadataKeyAtIndex(self, index)

    def getExtraMetadataStringValueAtIndex(self, index: "uint64_t") -> "std::string":
        r"""
        Get the value of a key value pair at a particular index in the extra metadata set of this
        instance

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0 or EML2.2 one.

        :type index: int
        :param index:	Zero-based index of the asked value.

        :rtype: string
        :return: The extra metadata value at ``index``.
        """
        return _fesapi.AbstractObject_getExtraMetadataStringValueAtIndex(self, index)

    def buildEtp12Uri(self) -> "std::string":
        r"""
        Build and return an ETP1.2 URI from an Energistics dataobject.
        :rtype: string
        :return: The ETP1.2 URI built from the Energistics dataobject
        """
        return _fesapi.AbstractObject_buildEtp12Uri(self)

    def setUriSource(self, uriSource: "std::string const &") -> "void":
        r"""Set the EPC document absolute path or the ETP dataspace URI where this dataobject comes from."""
        return _fesapi.AbstractObject_setUriSource(self, uriSource)

    def getUriSource(self) -> "std::string const &":
        r"""Get the EPC document absolute path or the ETP dataspace URI where this dataobject comes from."""
        return _fesapi.AbstractObject_getUriSource(self)
    def __disown__(self):
        self.this.disown()
        _fesapi.disown_AbstractObject(self)
        return weakref.proxy(self)

# Register AbstractObject in _fesapi:
_fesapi.AbstractObject_swigregister(AbstractObject)
class HdfProxyFactory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == HdfProxyFactory:
            _self = None
        else:
            _self = self
        _fesapi.HdfProxyFactory_swiginit(self, _fesapi.new_HdfProxyFactory(_self, ))
    __swig_destroy__ = _fesapi.delete_HdfProxyFactory

    def make(self, *args) -> "eml2::AbstractHdfProxy *":
        return _fesapi.HdfProxyFactory_make(self, *args)
    def __disown__(self):
        self.this.disown()
        _fesapi.disown_HdfProxyFactory(self)
        return weakref.proxy(self)

# Register HdfProxyFactory in _fesapi:
_fesapi.HdfProxyFactory_swigregister(HdfProxyFactory)
eml23__AxisOrder2d_easting_x0020northing = _fesapi.eml23__AxisOrder2d_easting_x0020northing
eml23__AxisOrder2d_easting_x0020southing = _fesapi.eml23__AxisOrder2d_easting_x0020southing
eml23__AxisOrder2d_southing_x0020easting = _fesapi.eml23__AxisOrder2d_southing_x0020easting
eml23__AxisOrder2d_northing_x0020easting = _fesapi.eml23__AxisOrder2d_northing_x0020easting
eml23__AxisOrder2d_westing_x0020southing = _fesapi.eml23__AxisOrder2d_westing_x0020southing
eml23__AxisOrder2d_southing_x0020westing = _fesapi.eml23__AxisOrder2d_southing_x0020westing
eml23__AxisOrder2d_northing_x0020westing = _fesapi.eml23__AxisOrder2d_northing_x0020westing
eml23__AxisOrder2d_westing_x0020northing = _fesapi.eml23__AxisOrder2d_westing_x0020northing
class EpcExternalPartReference(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_EpcExternalPartReference

# Register EpcExternalPartReference in _fesapi:
_fesapi.EpcExternalPartReference_swigregister(EpcExternalPartReference)
class Eml2_AbstractHdfProxy(EpcExternalPartReference):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Eml2_AbstractHdfProxy

    def setRootPath(self, rootPath: "std::string const &") -> "void":
        r"""
        Sets the path of the directory containing the EPC file associated to this HDF5 file

        :type rootPath: string
        :param rootPath:	Path of the directory containing the EPC file.
        """
        return _fesapi.Eml2_AbstractHdfProxy_setRootPath(self, rootPath)

    def setRelativePath(self, relPath: "std::string const &") -> "void":
        r"""
        Sets the relative path of the HDF5 file regarding the path of the directory containing the EPC
        file associated to this HDF5 file

        :type relPath: string
        :param relPath:	Relative path of the HDF5 file.
        """
        return _fesapi.Eml2_AbstractHdfProxy_setRelativePath(self, relPath)

    def setOpeningMode(self, openingMode_: "common::DataObjectRepository::openingMode") -> "void":
        r"""
        Sets the rights when opening the HDF5 file

        :type openingMode_: int
        :param openingMode_:	The opening mode of the HDF5 file.
        """
        return _fesapi.Eml2_AbstractHdfProxy_setOpeningMode(self, openingMode_)

    def getRelativePath(self) -> "std::string":
        r"""
        Gets the relative path of the HDF5 file regarding the path of the directory containing the
        EPC file associated to this HDF5 file

        :rtype: string
        :return: The relative path of the HDF5 file.
        """
        return _fesapi.Eml2_AbstractHdfProxy_getRelativePath(self)

    def open(self) -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_open(self)

    def isOpened(self) -> "bool":
        r"""
        Checks if the HDF5 file is open or not

        :rtype: boolean
        :return: True if opened, false if not.
        """
        return _fesapi.Eml2_AbstractHdfProxy_isOpened(self)

    def close(self) -> "void":
        r""" Closes the HDF5 file"""
        return _fesapi.Eml2_AbstractHdfProxy_close(self)

    def getNumericalDatatype(self, datasetName: "std::string const &") -> "common::AbstractObject::numericalDatatypeEnum":
        r"""
        Gets the native datatype of a dataset

        :type datasetName: string
        :param datasetName:	Name of the dataset.

        :rtype: int
        :return: The native datatype identifier of the dataset if successful, otherwise returns unknown.
        """
        return _fesapi.Eml2_AbstractHdfProxy_getNumericalDatatype(self, datasetName)

    def getHdfDatatypeClassInDataset(self, datasetName: "std::string const &") -> "int":
        r"""
        Gets the datatype class (``H5T_INTEGER``, ``H5T_FLOAT``, ``H5T_STRING``, etc.) of a dataset

        :type datasetName: string
        :param datasetName:	Name of the dataset.

        :rtype: int
        :return: The HDF5 datatype class identifier if successful, otherwise ``H5T_NO_CLASS`` (-1).
        """
        return _fesapi.Eml2_AbstractHdfProxy_getHdfDatatypeClassInDataset(self, datasetName)

    def writeItemizedListOfList(self, groupName: "std::string const &", name: "std::string const &", cumulativeLengthDatatype: "common::AbstractObject::numericalDatatypeEnum", cumulativeLength: "void const *", cumulativeLengthSize: "uint64_t", elementsDatatype: "common::AbstractObject::numericalDatatypeEnum", elements: "void const *", elementsSize: "uint64_t") -> "void":
        r"""
        Writes an itemized list of lists into the HDF5 file by means of a single group containing two
        datasets: one for the elements and one for the cumulative lengths of the lists of elements.

        :type groupName: string
        :param groupName:					The name of the group where to create the itemized list
            										of lists. This name must not contain '/' character and must
            										be directly contained in the RESQML group.
        :type name: string
        :param name:						The name of the itemized list of lists HDF5 group.
        :type cumulativeLengthDatatype: int
        :param cumulativeLengthDatatype:	The datatype of the cumulative lengths dataset to write.
        :type cumulativeLength: void
        :param cumulativeLength:			1d array of positive integers containing for each list
            										the sum of all the previous lists lengths including the
            										current one.
        :type cumulativeLengthSize: int
        :param cumulativeLengthSize:		Size of the cumulative lengths array.
        :type elementsDatatype: int
        :param elementsDatatype:			The datatype of the elements to write.
        :type elements: void
        :param elements:					1d array of elements containing the aggregation of
            										individual lists contents.
        :type elementsSize: int
        :param elementsSize:				Size of the elements array. It must be equal to
            										cumulativeLength[cumulativeLengthSize-1].
        """
        return _fesapi.Eml2_AbstractHdfProxy_writeItemizedListOfList(self, groupName, name, cumulativeLengthDatatype, cumulativeLength, cumulativeLengthSize, elementsDatatype, elements, elementsSize)

    def getDimensionCount(self, datasetName: "std::string const &") -> "uint64_t":
        r"""
        Gets the number of dimensions in an HDF5 dataset of the proxy.

        :type datasetName: string
        :param datasetName:	The absolute name (not relative to a group) of the dataset we want to get
            						the number of dimensions.

        :rtype: int
        :return: The number of dimensions of the dataset if successful, otherwise returns a negative
            			value.
        """
        return _fesapi.Eml2_AbstractHdfProxy_getDimensionCount(self, datasetName)

    def getElementCountPerDimension(self, datasetName: "std::string const &") -> "std::vector< uint32_t,std::allocator< uint32_t > >":
        r"""
        Get the number of elements in each dimension of an HDF5 dataset.
        :type datasetName: string
        :param datasetName:	The absolute name of the dataset which we want to get the number of elements from.
        """
        return _fesapi.Eml2_AbstractHdfProxy_getElementCountPerDimension(self, datasetName)

    def getElementCount(self, datasetName: "std::string const &") -> "uint64_t":
        r"""
        Gets the number of elements in an HDF5 dataset of the proxy. The number of elements is got
        from all dimensions.

        :type datasetName: string
        :param datasetName:	The absolute name (not relative to a group) of the dataset we want to get
            						the number of elements.

        :rtype: int
        :return: The number of elements of the dataset if successful, otherwise returns a negative
            			value.
        """
        return _fesapi.Eml2_AbstractHdfProxy_getElementCount(self, datasetName)

    def setCompressionLevel(self, newCompressionLevel: "unsigned int") -> "void":
        r"""
        Sets the new compression level which will be used for all data to be written

        :type newCompressionLevel: int
        :param newCompressionLevel:	The new compression level in range [0..9]. Lower compression
            								levels are faster but result in less compression.
        """
        return _fesapi.Eml2_AbstractHdfProxy_setCompressionLevel(self, newCompressionLevel)

    def writeArrayNdOfFloatValues(self, groupName: "std::string const &", name: "std::string const &", floatValues: "float const *", numValuesInEachDimension: "uint64_t const *", numDimensions: "unsigned int") -> "void":
        r"""
        Writes an nd array of float values into the HDF5 file by means of a single dataset

        :type groupName: string
        :param groupName:					The name of the group where to create the nd array of
            										float values. This name must not contain '/' character and
            										must be directly contained in RESQML group.
        :type name: string
        :param name:						The name of the nd array HDF5 dataset. It must not
            										already exist.
        :type floatValues: float
        :param floatValues:					1d array of float values ordered firstly by fastest
            										direction.
        :type numValuesInEachDimension: int
        :param numValuesInEachDimension:	Number of values in each dimension of the nd array to
            										write. They are ordered from fastest index to slowest index.
        :type numDimensions: int
        :param numDimensions:				The number of dimensions (n) of the nd array to write.
        """
        return _fesapi.Eml2_AbstractHdfProxy_writeArrayNdOfFloatValues(self, groupName, name, floatValues, numValuesInEachDimension, numDimensions)

    def writeArrayNdOfDoubleValues(self, groupName: "std::string const &", name: "std::string const &", dblValues: "double const *", numValuesInEachDimension: "uint64_t const *", numDimensions: "unsigned int") -> "void":
        r"""
        Writes an nd array of double values into the HDF5 file by means of a single dataset

        :type groupName: string
        :param groupName:					The name of the group where to create the nd array of
            										double values. This name must not contain '/' character and
            										must be directly contained in RESQML group.
        :type name: string
        :param name:						The name of the nd array HDF5 dataset. It must not
            										already exist.
        :type dblValues: float
        :param dblValues:					1d array of double values ordered firstly by fastest
            										direction.
        :type numValuesInEachDimension: int
        :param numValuesInEachDimension:	Number of values in each dimension of the nd array to
            										write. They are ordered from fastest index to slowest index.
        :type numDimensions: int
        :param numDimensions:				The number of dimensions (n) of the nd array to write.
        """
        return _fesapi.Eml2_AbstractHdfProxy_writeArrayNdOfDoubleValues(self, groupName, name, dblValues, numValuesInEachDimension, numDimensions)

    def writeArrayNdOfInt8Values(self, groupName: "std::string const &", name: "std::string const &", intValues: "int8_t const *", numValuesInEachDimension: "uint64_t const *", numDimensions: "unsigned int") -> "void":
        r"""
        Writes an nd array of int 8 bits values into the HDF5 file by means of a single dataset

        :type groupName: string
        :param groupName:					The name of the group where to create the nd array of int
            										values. This name must not contain '/' character and must be
            										directly contained in RESQML group.
        :type name: string
        :param name:						The name of the nd array HDF5 dataset. It must not
            										already exist.
        :type intValues: int8_t
        :param intValues:					1d array of int 8 bits values ordered firstly by fastest
            										direction.
        :type numValuesInEachDimension: int
        :param numValuesInEachDimension:	Number of values in each dimension of the nd array to
            										write. They are ordered from fastest index to slowest index.
        :type numDimensions: int
        :param numDimensions:				The number of the dimensions (n) of the nd array to write.
        """
        return _fesapi.Eml2_AbstractHdfProxy_writeArrayNdOfInt8Values(self, groupName, name, intValues, numValuesInEachDimension, numDimensions)

    def writeArrayNdOfIntValues(self, groupName: "std::string const &", name: "std::string const &", intValues: "int const *", numValuesInEachDimension: "uint64_t const *", numDimensions: "unsigned int") -> "void":
        r"""
        Writes an nd array of int values into the HDF5 file by means of a single dataset

        :type groupName: string
        :param groupName:					The name of the group where to create the nd array of int
            										values. This name must not contain '/' character and must be
            										directly contained in RESQML group.
        :type name: string
        :param name:						The name of the nd array HDF5 dataset. It must not
            										already exist.
        :type intValues: int
        :param intValues:					1d array of int values ordered firstly by fastest
            										direction.
        :type numValuesInEachDimension: int
        :param numValuesInEachDimension:	Number of values in each dimension of the nd array to
            										write. They are ordered from fastest index to slowest index.
        :type numDimensions: int
        :param numDimensions:				The number of the dimensions (n) of the nd array to write.
        """
        return _fesapi.Eml2_AbstractHdfProxy_writeArrayNdOfIntValues(self, groupName, name, intValues, numValuesInEachDimension, numDimensions)

    def writeArrayNdOfInt64Values(self, groupName: "std::string const &", name: "std::string const &", values: "int64_t const *", numValuesInEachDimension: "uint64_t const *", numDimensions: "unsigned int") -> "void":
        r"""
        Writes an nd array of integer 64 values into the HDF5 file by means of a single
        dataset

        :type groupName: string
        :param groupName:					The name of the group where to create the nd array of
            										gSOAP unsigned long 64 values. This name must not contain '/'
            										character and must be directly contained in RESQML group.
        :type name: string
        :param name:						The name of the nd array HDF5 dataset. It must not
            										already exist.
        :type values: int
        :param values:						1d array of integer 64 values ordered firstly
            										by fastest direction.
        :type numValuesInEachDimension: int
        :param numValuesInEachDimension:	Number of values in each dimension of the nd array to
            										write. They are ordered from fastest index to slowest index.
        :type numDimensions: int
        :param numDimensions:				The number of the dimensions (n) of the nd array to write.
        """
        return _fesapi.Eml2_AbstractHdfProxy_writeArrayNdOfInt64Values(self, groupName, name, values, numValuesInEachDimension, numDimensions)

    def writeArrayNdOfUInt64Values(self, groupName: "std::string const &", name: "std::string const &", values: "uint64_t const *", numValuesInEachDimension: "uint64_t const *", numDimensions: "unsigned int") -> "void":
        r"""
        Writes an nd array of unsigned integer 64 values into the HDF5 file by means of a single
        dataset

        :type groupName: string
        :param groupName:					The name of the group where to create the nd array of
            										gSOAP unsigned long 64 values. This name must not contain '/'
            										character and must be directly contained in RESQML group.
        :type name: string
        :param name:						The name of the nd array HDF5 dataset. It must not
            										already exist.
        :type values: int
        :param values:						1d array of unsigned integer 64 values ordered firstly
            										by fastest direction.
        :type numValuesInEachDimension: int
        :param numValuesInEachDimension:	Number of values in each dimension of the nd array to
            										write. They are ordered from fastest index to slowest index.
        :type numDimensions: int
        :param numDimensions:				The number of the dimensions (n) of the nd array to write.
        """
        return _fesapi.Eml2_AbstractHdfProxy_writeArrayNdOfUInt64Values(self, groupName, name, values, numValuesInEachDimension, numDimensions)

    def writeArrayNd(self, groupName: "std::string const &", name: "std::string const &", datatype: "common::AbstractObject::numericalDatatypeEnum", values: "void const *", numValuesInEachDimension: "uint64_t const *", numDimensions: "unsigned int") -> "void":
        r"""
        Writes an nd array of a specific datatype into the HDF5 file by means of a single dataset

        :type groupName: string
        :param groupName:					The name of the group where to create the nd array of
            										specific datatype values. This name must not contain '/'
            										character and must be directly contained in RESQML group.
        :type name: string
        :param name:						The name of the nd array HDF5 dataset. It must not
            										already exist.
        :type datatype: int
        :param datatype:					The specific datatype of the values to write.
        :type values: void
        :param values:						1d array of specific datatype values ordered firstly by
            										fastest direction.
        :type numValuesInEachDimension: int
        :param numValuesInEachDimension:	Number of values in each dimension of the nd array to
            										write. They are ordered from fastest index to slowest index.
        :type numDimensions: int
        :param numDimensions:				The number of the dimensions (n) of the nd array to write.
        """
        return _fesapi.Eml2_AbstractHdfProxy_writeArrayNd(self, groupName, name, datatype, values, numValuesInEachDimension, numDimensions)

    def createArrayNd(self, groupName: "std::string const &", name: "std::string const &", datatype: "common::AbstractObject::numericalDatatypeEnum", numValuesInEachDimension: "uint64_t const *", numDimensions: "unsigned int") -> "void":
        r"""
        Creates an nd array of a specific datatype into the HDF5 file by means of a single dataset.
        Values are not yet written to this array

        :type groupName: string
        :param groupName:					The name of the group where to create the nd array of
            										specific datatype values. This name must not contain '/'
            										character and must be directly contained in RESQML group.
        :type name: string
        :param name:						The name of the nd array HDF5 dataset. It must not exist.
        :type datatype: int
        :param datatype:					The specific datatype of the nd array values.
        :type numValuesInEachDimension: int
        :param numValuesInEachDimension:	Number of values in each dimension of the nd array. They
            										are ordered from fastest index to slowest index.
        :type numDimensions: int
        :param numDimensions:				The number of the dimensions (n) of the nd array to
            										create.
        """
        return _fesapi.Eml2_AbstractHdfProxy_createArrayNd(self, groupName, name, datatype, numValuesInEachDimension, numDimensions)

    def writeArrayNdSlab(self, groupName: "std::string const &", name: "std::string const &", datatype: "common::AbstractObject::numericalDatatypeEnum", values: "void const *", numValuesInEachDimension: "uint64_t const *", offsetValuesInEachDimension: "uint64_t const *", numDimensions: "unsigned int") -> "void":
        r"""
        Finds the nd array associated with ``groupName`` and ``name`` and writes into it

        :type groupName: string
        :param groupName:				   	The name of the group associated with the nd array.
        :type name: string
        :param name:					   	The name of the nd array dataset.
        :type datatype: int
        :param datatype:				   	The datatype of the nd array values.
        :type values: void
        :param values:					   	1d array of datatype values ordered firstly by fastest
            										direction.
        :type numValuesInEachDimension: int
        :param numValuesInEachDimension:   	Number of values in each dimension of the nd array to
            										write. They are ordered from fastest index to slowest
            										index.
        :type offsetValuesInEachDimension: int
        :param offsetValuesInEachDimension:	Offset values in each dimension of the nd array to write.
            										They are ordered from fastest index to slowest index.
        :type numDimensions: int
        :param numDimensions:			   	The number of the dimensions (n) of the nd array to write.
        """
        return _fesapi.Eml2_AbstractHdfProxy_writeArrayNdSlab(self, groupName, name, datatype, values, numValuesInEachDimension, offsetValuesInEachDimension, numDimensions)

    def writeGroupAttribute(self, groupName: "std::string const &", attributeName: "std::string const &", values: "StringVector") -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_writeGroupAttribute(self, groupName, attributeName, values)

    def writeGroupAttributes(self, *args) -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_writeGroupAttributes(self, *args)

    def writeDatasetAttribute(self, datasetName: "std::string const &", attributeName: "std::string const &", values: "StringVector") -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_writeDatasetAttribute(self, datasetName, attributeName, values)

    def writeDatasetAttributes(self, *args) -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_writeDatasetAttributes(self, *args)

    def readStringAttribute(self, obj_name: "std::string const &", attr_name: "std::string const &") -> "std::string":
        return _fesapi.Eml2_AbstractHdfProxy_readStringAttribute(self, obj_name, attr_name)

    def readStringArrayAttribute(self, obj_name: "std::string const &", attr_name: "std::string const &") -> "std::vector< std::string,std::allocator< std::string > >":
        return _fesapi.Eml2_AbstractHdfProxy_readStringArrayAttribute(self, obj_name, attr_name)

    def readDoubleAttribute(self, obj_name: "std::string const &", attr_name: "std::string const &") -> "double":
        return _fesapi.Eml2_AbstractHdfProxy_readDoubleAttribute(self, obj_name, attr_name)

    def readInt64Attribute(self, obj_name: "std::string const &", attr_name: "std::string const &") -> "int64_t":
        return _fesapi.Eml2_AbstractHdfProxy_readInt64Attribute(self, obj_name, attr_name)

    def selectArrayNdOfValues(self, datasetName: "std::string const &", blockCountPerDimension: "uint64_t const *", offsetInEachDimension: "uint64_t const *", strideInEachDimension: "uint64_t const *", blockSizeInEachDimension: "uint64_t const *", numDimensions: "unsigned int", newSelection: "bool", dataset: "hdf5_hid_t &", filespace: "hdf5_hid_t &") -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_selectArrayNdOfValues(self, datasetName, blockCountPerDimension, offsetInEachDimension, strideInEachDimension, blockSizeInEachDimension, numDimensions, newSelection, dataset, filespace)

    def readArrayNdOfDoubleValues(self, *args) -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_readArrayNdOfDoubleValues(self, *args)

    def readArrayNdOfFloatValues(self, *args) -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_readArrayNdOfFloatValues(self, *args)

    def readArrayNdOfInt64Values(self, *args) -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_readArrayNdOfInt64Values(self, *args)

    def readArrayNdOfUInt64Values(self, datasetName: "std::string const &", values: "uint64_t *") -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_readArrayNdOfUInt64Values(self, datasetName, values)

    def readArrayNdOfIntValues(self, *args) -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_readArrayNdOfIntValues(self, *args)

    def readArrayNdOfUIntValues(self, datasetName: "std::string const &", values: "unsigned int *") -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_readArrayNdOfUIntValues(self, datasetName, values)

    def readArrayNdOfShortValues(self, datasetName: "std::string const &", values: "short *") -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_readArrayNdOfShortValues(self, datasetName, values)

    def readArrayNdOfUShortValues(self, datasetName: "std::string const &", values: "unsigned short *") -> "void":
        r"""
        Reads an nd array of unsigned short values stored in a specific dataset

        :raises: std::invalid_argument	If the nd array dataset cannot be opened or read.

        :type datasetName: string
        :param datasetName:	The absolute name of the nd array dataset.
        :param [out]:	values	   	1d array of unsigned short values ordered firstly by fastest
            							direction. The values must be pre-allocated and won't be freed by
            							this method.
        """
        return _fesapi.Eml2_AbstractHdfProxy_readArrayNdOfUShortValues(self, datasetName, values)

    def readArrayNdOfInt8Values(self, datasetName: "std::string const &", values: "int8_t *") -> "void":
        r"""
        Reads an nd array of int 8 bits values stored in a specific dataset

        :raises: std::invalid_argument	If the nd array dataset cannot be opened or read.

        :type datasetName: string
        :param datasetName:	The absolute name of the nd array dataset.
        :param [out]:	values	   	1d array of int 8 bits values ordered firstly by fastest direction. The
            							values must be pre-allocated and won't be freed by this method.
        """
        return _fesapi.Eml2_AbstractHdfProxy_readArrayNdOfInt8Values(self, datasetName, values)

    def readArrayNdOfUInt8Values(self, datasetName: "std::string const &", values: "uint8_t *") -> "void":
        r"""
        Reads an nd array of unsigned int 8 bits values stored in a specific dataset

        :raises: std::invalid_argument	If the nd array dataset cannot be opened or read.

        :type datasetName: string
        :param datasetName:	The absolute name of the nd array dataset.
        :param [out]:	values	   	1d array of unsigned int 8 bits values ordered firstly by fastest
            							direction. The values must be pre-allocated and won't be freed by
            							this method.
        """
        return _fesapi.Eml2_AbstractHdfProxy_readArrayNdOfUInt8Values(self, datasetName, values)

    def exist(self, absolutePathInHdfFile: "std::string const &") -> "bool":
        return _fesapi.Eml2_AbstractHdfProxy_exist(self, absolutePathInHdfFile)

    def isCompressed(self, datasetName: "std::string const &") -> "bool":
        return _fesapi.Eml2_AbstractHdfProxy_isCompressed(self, datasetName)

    def setMaxChunkSize(self, newMaxChunkSize: "unsigned int") -> "void":
        r"""
        Set the maximum size for a chunk of a dataset only in case the HDF5 file is compressed.
        Chunk dimensions, and consequently actual size, will be computed from this maximum chunk memory size.
        Chunks dimensions are computed by reducing dataset dimensions from slowest to fastest until the max chunk size is honored.

        Example : Let's take a 3d property 4x3x2 (fastest from slowest) of double with a max chunk size of 100 bytes
        The total size of this property is 4*3*2*8 = 192 bytes which is greater than 100 bytes, the max chunk size.
        The computed chunk dimension will consequently be 4*3*1 = 96 which is lower than (not equal to) 100 bytes, the max chunk size.
        If we would have set a max chunk size of 20 bytes, the chunk dimension would have been computed as 2*1*1 (16 bytes), etc...

        :type newMaxChunkSize: int
        :param newMaxChunkSize: The maximum chunk size to set in bytes.
        """
        return _fesapi.Eml2_AbstractHdfProxy_setMaxChunkSize(self, newMaxChunkSize)

    def getElementCountPerChunkDimension(self, datasetName: "std::string const &") -> "std::vector< uint32_t,std::allocator< uint32_t > >":
        r"""
        Get the number of elements in each chunk dimension of an HDF5 dataset.
        If the dataset is not compressed, then it returns an empty vector.
        :type datasetName: string
        :param datasetName:	The absolute name of the dataset which we want to get the number of elements from.
        """
        return _fesapi.Eml2_AbstractHdfProxy_getElementCountPerChunkDimension(self, datasetName)

    def initGsoapProxy(self, repo: "DataObjectRepository", guid: "std::string const &", title: "std::string const &", emlVersion: "unsigned int") -> "void":
        return _fesapi.Eml2_AbstractHdfProxy_initGsoapProxy(self, repo, guid, title, emlVersion)

    def __init__(self, *args):
        if self.__class__ == Eml2_AbstractHdfProxy:
            _self = None
        else:
            _self = self
        _fesapi.Eml2_AbstractHdfProxy_swiginit(self, _fesapi.new_Eml2_AbstractHdfProxy(_self, *args))
    def __disown__(self):
        self.this.disown()
        _fesapi.disown_Eml2_AbstractHdfProxy(self)
        return weakref.proxy(self)

# Register Eml2_AbstractHdfProxy in _fesapi:
_fesapi.Eml2_AbstractHdfProxy_swigregister(Eml2_AbstractHdfProxy)
class Eml2_AbstractLocal3dCrs(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Eml2_AbstractLocal3dCrs

    def getOriginOrdinal1(self) -> "double":
        r"""
        Gets the first origin ordinal of this local CRS. This is the X location of the origin of the
        local areal axes relative to the projected CRS origin. The unit of measure is defined by the
        unit of measure for the projected 2d CRS.

        :rtype: float
        :return: The first origin ordinal of this local CRS.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getOriginOrdinal1(self)

    def getOriginOrdinal2(self) -> "double":
        r"""
        Gets the second origin ordinal of this local CRS. This is the Y location of the origin of the
        local areal axes relative to the projected CRS origin. The unit of measure is defined by the
        unit of measure for the projected 2d CRS.

        :rtype: float
        :return: The second origin ordinal of this local CRS.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getOriginOrdinal2(self)

    def getOriginDepthOrElevation(self) -> "double":
        r"""
        Get the depth or elevation origin of this local CRS. This is Z offset of the origin of the
        local vertical axis relative to the vertical CRS origin. According to CRS type (depth or time)
        it corresponds to the depth or time datum. If this local CRS is a time CRS, this value
        defines the seismic reference datum. The unit of measure is defined by the unit of measure
        for the vertical CRS

        :rtype: float
        :return: The origin depth or elevation.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getOriginDepthOrElevation(self)

    def getArealRotation(self) -> "double":
        r"""
        Get the rotation in radians of the local Y axis relative to the global projected Y axis which
        is 90 degrees counter-clockwise from the other global axis. A positive value indicates a
        clockwise rotation from the global axis. A negative value indicates a counterclockwise
        rotation form the global axis.

        :rtype: float
        :return: The areal rotation.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getArealRotation(self)

    def isDepthOriented(self) -> "bool":
        r"""
        Indicates that Z values correspond to depth values and are increasing downward, as opposite
        to elevation values increasing upward. When the vertical CRS is known, it must correspond to
        the axis orientation of the vertical CRS.

        :rtype: boolean
        :return: True if Z values are depth oriented, false if not.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_isDepthOriented(self)

    def isProjectedCrsDefinedWithEpsg(self) -> "bool":
        r"""
        Indicates either the associated projected CRS is identified by means of an EPSG code or not.

        :rtype: boolean
        :return: True if the projected CRS is defined with an EPSG code, false if not.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_isProjectedCrsDefinedWithEpsg(self)

    def isProjectedCrsDefinedWithWkt(self) -> "bool":
        r"""
        Indicates either the associated projected CRS is given in a WKT format or not.

        :rtype: boolean
        :return: True if the projected CRS is given in a WKT format, false if not.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_isProjectedCrsDefinedWithWkt(self)

    def isProjectedCrsUnknown(self) -> "bool":
        r"""
        Indicates either the associated projected CRS is unknown or not.

        :rtype: boolean
        :return: True if projected CRS is unknown, false if not.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_isProjectedCrsUnknown(self)

    def getProjectedCrsUnknownReason(self) -> "std::string":
        r"""
        Gets the reason why the projected CRS is unknown.

        :raises: std::invalid_argument	If the associated projected CRS is not unknown.

        :rtype: string
        :return: The projected CRS unknown reason.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getProjectedCrsUnknownReason(self)

    def getProjectedCrsWkt(self) -> "std::string":
        r"""
        Gets the WKT of the projected CRS

        :raises: std::invalid_argument	If the associated projected CRS is not a WKT one.

        :rtype: string
        :return: The projected CRS WKT.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getProjectedCrsWkt(self)

    def getProjectedCrsEpsgCode(self) -> "int64_t":
        r"""
        Gets the EPSG code of the projected CRS

        :raises: std::invalid_argument	If the associated projected CRS is not an EPSG one.

        :rtype: int
        :return: The projected CRS EPSG code.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getProjectedCrsEpsgCode(self)

    def isVerticalCrsDefinedWithEpsg(self) -> "bool":
        r"""
        Indicates either the associated vertical CRS is identified by means of EPSG or not.

        :rtype: boolean
        :return: True if the vertical CRS is defined with an EPSG code, false if not.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_isVerticalCrsDefinedWithEpsg(self)

    def isVerticalCrsDefinedWithWkt(self) -> "bool":
        r"""
        Indicates either the associated vertical CRS is given in a WKT format or not.

        :rtype: boolean
        :return: True if the vertical CRS is given in a WKT format, false if not.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_isVerticalCrsDefinedWithWkt(self)

    def isVerticalCrsUnknown(self) -> "bool":
        r"""
        Indicates either the associated vertical CRS is unknown or not.

        :rtype: boolean
        :return: True if vertical CRS is unknown, false if not.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_isVerticalCrsUnknown(self)

    def getVerticalCrsUnknownReason(self) -> "std::string":
        r"""
        Gets the reason why the vertical CRS is unknown.

        :raises: std::invalid_argument	If the associated vertical CRS is not unknown.

        :rtype: string
        :return: The vertical CRS unknown reason.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getVerticalCrsUnknownReason(self)

    def getVerticalCrsWkt(self) -> "std::string":
        r"""
        Gets the WKT of the vertical CRS

        :raises: std::invalid_argument	If the associated projected CRS is not a WKT one.

        :rtype: string
        :return: The vertical CRS WKT.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getVerticalCrsWkt(self)

    def getVerticalCrsEpsgCode(self) -> "int64_t":
        r"""
        Gets the EPSG code of the vertical CRS

        :raises: std::invalid_argument	If the associated projected CRS is not an EPSG one.

        :rtype: int
        :return: The vertical CRS EPSG code.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getVerticalCrsEpsgCode(self)

    def getProjectedCrsUnit(self) -> "gsoap_resqml2_0_1::eml20__LengthUom":
        r"""
        Gets the projected CRS unit of measure.

        :rtype: int
        :return: The projected CRS unit unit of measure.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getProjectedCrsUnit(self)

    def getProjectedCrsUnitAsString(self) -> "std::string":
        r"""
        Gets the projected CRS unit of measure as a string

        :rtype: string
        :return: The projected CRS unit of measure as string.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getProjectedCrsUnitAsString(self)

    def getVerticalCrsUnit(self) -> "gsoap_resqml2_0_1::eml20__LengthUom":
        r"""
        Gets the vertical CRS unit of measure.

        :rtype: int
        :return: The vertical CRS unit of measure.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getVerticalCrsUnit(self)

    def getVerticalCrsUnitAsString(self) -> "std::string":
        r"""
        Gets the vertical CRS unit of measure as a string

        :rtype: string
        :return: The vertical CRS unit of measure as string.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getVerticalCrsUnitAsString(self)

    def isATimeCrs(self) -> "bool":
        r"""
        Check if the third axis of this local 3d CRS is in timeor not.

        :rtype: boolean
        :return: True if this local 3d CRS is a time one. False if it is a depth/elevation one.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_isATimeCrs(self)

    def getTimeUom(self) -> "gsoap_resqml2_0_1::eml20__TimeUom":
        r"""
        Gets the unit of measure of the third axis of this local CRS if it is a time CRS.
        Otherwise throw an exception (if isATimeCrs() returns false)

        :rtype: int
        :return: The time unit of measure of the third axis.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getTimeUom(self)

    def getTimeUomAsString(self) -> "std::string":
        r"""
        Gets the unit of measure as a sting of the third axis of this local CRS if it is a time CRS.
        Otherwise throw an exception (if isATimeCrs() returns false)

        :rtype: string
        :return: The time unit of measure of the third axis.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getTimeUomAsString(self)

    def getAxisOrder(self) -> "gsoap_eml2_3::eml23__AxisOrder2d":
        r"""
        Gets the axis order of the projected CRS.

        :rtype: int
        :return: The axis order of the projected CRS.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_getAxisOrder(self)

    def setAxisOrder(self, axisOrder: "gsoap_eml2_3::eml23__AxisOrder2d") -> "void":
        r"""
        Sets the axis order of the projected CRS. It defines the coordinate system axis order of the
        global projected CRS when the projected CRS is an unknown CRS, else it must correspond to the
        axis order of the projected CRS.

        :type axisOrder: int
        :param axisOrder:	The axis order to set.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_setAxisOrder(self, axisOrder)

    def convertXyzPointsToGlobalCrs(self, xyzPoints: "double *", xyzPointCount: "uint64_t", withoutTranslation: "bool"=False) -> "void":
        r"""
        Convert some xyz points from local to global CRS.

        :param [in,out]:	xyzPoints		  	An array of xyz points. The i-th point is defined by
            										(x, y, z) = (xyzPoints[i], xyzPoints[i+1],
            										xyzPoints[i+2]).
        :type xyzPointCount: int
        :param xyzPointCount:	  	The number of xyz points. Must be equal to the size of
            ``xyzPoints`` divided by 3.
        :type withoutTranslation: boolean, optional
        :param withoutTranslation:	(Optional) True to only compute the rotation (no
            										translation is computed). Default value if false.
        """
        return _fesapi.Eml2_AbstractLocal3dCrs_convertXyzPointsToGlobalCrs(self, xyzPoints, xyzPointCount, withoutTranslation)

# Register Eml2_AbstractLocal3dCrs in _fesapi:
_fesapi.Eml2_AbstractLocal3dCrs_swigregister(Eml2_AbstractLocal3dCrs)
class ActivityTemplate(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackParameter(self, *args) -> "void":
        r"""
        *Overload 1:*

        Pushes back a parameter in this activity template instance. This parameter has an
        unconstrained type.

        :raises: std::invalid_argument	If ``maxOccurs`` is strictly lesser than ``minOccurs``.

        :type title: string
        :param title:	 	The title of the parameter to push back.
        :type isInput: boolean
        :param isInput:  	True if the parameter is an input parameter, false if not.
        :type isOutput: boolean
        :param isOutput: 	True if the parameter is an output parameter, false if not.
        :type minOccurs: int
        :param minOccurs:	The minimum number of occurrences of this parameter.
        :type maxOccurs: int
        :param maxOccurs:	The maximum number of occurrences of this parameter.

        |

        *Overload 2:*

        Pushes back a parameter in the activity template instance. This parameter must be of a RESQML
        object kind.

        :raises: std::invalid_argument	If ``maxOccurs`` is strictly lesser than ``minOccurs``.

        :type title: string
        :param title:				   	The title of the parameter to push back.
        :type isInput: boolean
        :param isInput:				   	True if the parameter is an input parameter, false if not.
        :type isOutput: boolean
        :param isOutput:			   	True if the parameter is an output parameter, false if not.
        :type minOccurs: int
        :param minOccurs:			   	The minimum number of occurrences of this parameter.
        :type maxOccurs: int
        :param maxOccurs:			   	The maximum number of occurrences of this parameter.
        :type resqmlObjectContentType: string
        :param resqmlObjectContentType:	The content type of the RESQML object kind of the parameter.
            									If empty, there is no constraint on the content type of this
            									parameter.
        """
        return _fesapi.ActivityTemplate_pushBackParameter(self, *args)

    def isAnExistingParameter(self, paramTitle: "std::string const &") -> "bool":
        r"""
        Checks if this instance contains a parameter with a particular title.

        :type paramTitle: string
        :param paramTitle:	The title of the parameter we are looking for into this instance.

        :rtype: boolean
        :return: True if there exists a ``paramTitle`` parameter in this instance false if not.
        """
        return _fesapi.ActivityTemplate_isAnExistingParameter(self, paramTitle)

    def getParameterCount(self) -> "uint64_t":
        r"""
        Gets the parameter count.

        :rtype: int
        :return: The parameter count.
        """
        return _fesapi.ActivityTemplate_getParameterCount(self)

    def getParameterTitle(self, index: "uint64_t") -> "std::string":
        r"""
        Gets the title of a particular parameter.

        :raises: std::out_of_range	If ``index`` is not in the parameter range.

        :type index: int
        :param index:	Zero-based index of the parameter we look for the title.

        :rtype: string
        :return: The title of the parameter at position ``index``.
        """
        return _fesapi.ActivityTemplate_getParameterTitle(self, index)

    def getParameterAllowedKinds(self, *args) -> "std::vector< gsoap_resqml2_0_1::resqml20__ParameterKind,std::allocator< gsoap_resqml2_0_1::resqml20__ParameterKind > >":
        r"""
        *Overload 1:*

        Gets parameter allowed kinds

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: std::vector< gsoap_resqml2_0_1::resqml20__ParameterKind,std::allocator< gsoap_resqml2_0_1::resqml20__ParameterKind > >
        :return: The parameter allowed kinds.

        |

        *Overload 2:*

        Gets parameter allowed kinds

        :type paramTitle: string
        :param paramTitle:	The parameter title.

        :rtype: std::vector< gsoap_resqml2_0_1::resqml20__ParameterKind,std::allocator< gsoap_resqml2_0_1::resqml20__ParameterKind > >
        :return: The parameter allowed kinds.
        """
        return _fesapi.ActivityTemplate_getParameterAllowedKinds(self, *args)

    def getParameterIsInput(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Queries if a particular parameter is an input parameter.

        :raises: std::out_of_range	If ``index`` is not in the parameter range.

        :type index: int
        :param index:	Zero-based index of the parameter we want to know if it is an input one.

        :rtype: boolean
        :return: True is the parameter at ``index`` is an input parameter, false if not.

        |

        *Overload 2:*

        Queries if a particular parameter is an input parameter.

        :raises: std::invalid_argument	If there exists no ``paramTitle`` parameter in this
            										activity.

        :type paramTitle: string
        :param paramTitle:	The title of the parameter we want to know if it is an input one.

        :rtype: boolean
        :return: True is the parameter ``paramTitle`` is an input parameter, false if not.
        """
        return _fesapi.ActivityTemplate_getParameterIsInput(self, *args)

    def getParameterIsOutput(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Queries if a particular parameter is an output parameter.

        :raises: std::out_of_range	If ``index`` is not in the parameter range.

        :type index: int
        :param index:	Zero-based index of the parameter we want to know if it is an output one.

        :rtype: boolean
        :return: True is the parameter at ``index`` is an output parameter, false if not.

        |

        *Overload 2:*

        Queries if a particular parameter is an output parameter.

        :raises: std::invalid_argument	If there exists no ``paramTitle`` parameter in this
            										activity.

        :type paramTitle: string
        :param paramTitle:	The title of the parameter we want to know if it is an output one.

        :rtype: boolean
        :return: True is the parameter ``paramTitle`` is an output parameter, false if not.
        """
        return _fesapi.ActivityTemplate_getParameterIsOutput(self, *args)

    def getParameterMinOccurences(self, *args) -> "int64_t":
        r"""
        *Overload 1:*

        Gets the minimum occurrences of a particular parameter.

        :raises: std::out_of_range	If ``index`` is not in the parameter range.

        :type index: int
        :param index:	Zero-based index of the parameter we want to know the minimum occurrences.

        :rtype: int
        :return: The parameter minimum occurrences.

        |

        *Overload 2:*

        Gets the minimum occurrences of a particular parameter.

        :raises: std::invalid_argument	If there exists no ``paramTitle`` parameter in this
            										activity.

        :type paramTitle: string
        :param paramTitle:	The title of the parameter we want to know the minimum occurrences.

        :rtype: int
        :return: The parameter minimum occurrences.
        """
        return _fesapi.ActivityTemplate_getParameterMinOccurences(self, *args)

    def getParameterMaxOccurences(self, *args) -> "int64_t":
        r"""
        *Overload 1:*

        Gets the maximum occurrences of a particular parameter.

        :raises: std::out_of_range	If ``index`` is not in the parameter range.

        :type index: int
        :param index:	Zero-based index of the parameter we want to know the maximum occurrences.

        :rtype: int
        :return: The parameter maximum occurrences.

        |

        *Overload 2:*

        Gets the maximum occurrences of a particular parameter.

        :raises: std::invalid_argument	If there exists no ``paramTitle`` parameter in this
            										activity.

        :type paramTitle: string
        :param paramTitle:	The title of the parameter we want to know the maximum occurrences.

        :rtype: int
        :return: The parameter maximum occurrences.
        """
        return _fesapi.ActivityTemplate_getParameterMaxOccurences(self, *args)
    __swig_destroy__ = _fesapi.delete_ActivityTemplate

# Register ActivityTemplate in _fesapi:
_fesapi.ActivityTemplate_swigregister(ActivityTemplate)
class Activity(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackParameter(self, *args) -> "void":
        r"""
        *Overload 1:*

        Pushes back a string parameter in this instance. This parameter must exist in the associated
        activity template.

        :raises: std::invalid_argument	If the parameter ``title`` does not exist in the
            										associated activity template.
        :raises: std::invalid_argument	If the maximum number of occurrences has already been
            										reached for parameter ``title``.
        :raises: std::invalid_argument	If The parameter template ``title`` does not allow a
            										string datatype.

        :type title: string
        :param title:	The title of the parameter to push back.
        :type value: string
        :param value:	The value of the parameter to push back.

        |

        *Overload 2:*

        Pushes back an integer parameter in this instance. This parameter must exist in the associated
        activity template.

        :raises: std::invalid_argument	If the parameter ``title`` does not exist in the
            										associated activity template.
        :raises: std::invalid_argument	If the maximum number of occurrences has already been
            										reached for parameter ``title``.
        :raises: std::invalid_argument	If The parameter template ``title`` does not allow a
            										an integer datatype.

        :type title: string
        :param title:	The title of the parameter to push back.
        :type value: int
        :param value:	The value of the parameter to push back.

        |

        *Overload 3:*

        Pushes back a RESQML object parameter in this instance. This parameter must exist in the
        associated activity template.

        :raises: std::invalid_argument	If ``resqmlObject`` is null.
            										* :raises: std::invalid_argument	If the parameter
            ``title`` does not exist in the
            											associated activity template.
        :raises: std::invalid_argument	If the maximum number of occurrences has already been
            										reached for parameter ``title``.
        :raises: std::invalid_argument	If The parameter template ``title`` does not allow a a
            										data object datatype.

        :type title: string
        :param title:			The title of the parameter to push back.
        :param [in]:	resqmlObject	The RESQML object, value of the parameter to push back.
        """
        return _fesapi.Activity_pushBackParameter(self, *args)

    def getParameterCount(self, *args) -> "uint64_t":
        r"""
        *Overload 1:*

        Get the count of all the parameters

        :rtype: int
        :return: The parameter count.

        |

        *Overload 2:*

        Gets the count of all the parameters which have the same title.

        :type paramTitle: string
        :param paramTitle:	The title of the parameters we look for.

        :rtype: int
        :return: The parameter count.
        """
        return _fesapi.Activity_getParameterCount(self, *args)

    def getParameterTitle(self, index: "uint64_t") -> "std::string":
        r"""
        Gets the title of a given parameter

        :raises: std::out_of_range	If ``index`` is not in the parameter range.

        :type index: int
        :param index:	Zero-based index of the parameter for which we look for the title.

        :rtype: string
        :return: The parameter title.
        """
        return _fesapi.Activity_getParameterTitle(self, index)

    def getParameterIndexOfTitle(self, paramTitle: "std::string const &") -> "std::vector< uint64_t,std::allocator< uint64_t > >":
        r"""
        Gets the indices of all the parameters sharing a given title.

        :type paramTitle: string
        :param paramTitle:	The title of the parameters we look for.

        :rtype: std::vector< uint64_t,std::allocator< uint64_t > >
        :return: A vector of parameter indices.
        """
        return _fesapi.Activity_getParameterIndexOfTitle(self, paramTitle)

    def isAFloatingPointQuantityParameter(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Queries if all of the parameters sharing a given title are floating point quantity parameters.

        :raises: std::invalid_argument	If there exists no ``paramTitle`` parameter in this
            										activity.

        :type paramTitle: string
        :param paramTitle:	The title of the parameters we want to test the datatype.

        :rtype: boolean
        :return: True if all of the ``paramTitle`` parameters are floating point quantity parameters,
            			false if not.

        |

        *Overload 2:*

        Queries if a given parameter is a floating point quantity parameter.

        :raises: std::out_of_range	If ``index`` is not in the parameter range.

        :type index: int
        :param index:	Zero-based index of the parameter we want to test the datatype.

        :rtype: boolean
        :return: True if the parameter at position ``index`` is a floating point quantity parameter,
            			false if not.
        """
        return _fesapi.Activity_isAFloatingPointQuantityParameter(self, *args)

    def getFloatingPointQuantityParameterValue(self, *args) -> "double":
        r"""
        *Overload 1:*

        Gets the values of all the floating point quantity parameters sharing a given title.

        :raises: std::invalid_argument	If there exists no ``paramTitle`` parameter in this
            										activity.
        :raises: std::invalid_argument	If one ``paramTitle`` parameter contains some non double
            										values.

        :type paramTitle: string
        :param paramTitle:	The title of the floating point parameters we look for the value.

        :rtype: std::vector< double,std::allocator< double > >
        :return: A vector of the value of all the ``paramTitle`` floating point quantity parameters.

        |

        *Overload 2:*

        Gets the floating point quantity value of a given parameter.

        :raises: std::out_of_range	 	If ``index`` is not in the parameter range.
        :raises: std::invalid_argument	If the parameter at ``index`` is not a floating point
            										quantity parameter.

        :type index: int
        :param index:	Zero-based index of the parameter we look for the value. This index is taken
            					in the set of all parameters of this activity.

        :rtype: float
        :return: The floating point quantity value of the parameter at position ``index``.
        """
        return _fesapi.Activity_getFloatingPointQuantityParameterValue(self, *args)

    def isAnIntegerQuantityParameter(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Queries if all of the parameters sharing a given title are integer quantity parameters.

        :raises: std::invalid_argument	If there exists no ``paramTitle`` parameter in this
            										activity.

        :type paramTitle: string
        :param paramTitle:	The title of the parameters we want to test the datatype.

        :rtype: boolean
        :return: True if all of the ``paramTitle`` parameters are integer quantity parameters,
            			false if not.

        |

        *Overload 2:*

        Queries if a given parameter is an integer quantity parameter.

        :raises: std::out_of_range	If ``index`` is not in the parameter range.

        :type index: int
        :param index:	Zero-based index of the parameter we want to test the datatype.

        :rtype: boolean
        :return: True if the parameter at position ``index`` is an integer quantity parameter,
            			false if not.
        """
        return _fesapi.Activity_isAnIntegerQuantityParameter(self, *args)

    def getIntegerQuantityParameterValue(self, *args) -> "int64_t":
        r"""
        *Overload 1:*

        Gets the values of all the integer quantity parameters sharing a given title.

        :raises: std::invalid_argument	If there exists no ``paramTitle`` parameter in this
            										activity.
        :raises: std::invalid_argument	If one ``paramTitle`` parameter contains some non integer
            										values.

        :type paramTitle: string
        :param paramTitle:	The title of the integer parameters we look for the value.

        :rtype: std::vector< int64_t,std::allocator< int64_t > >
        :return: A vector of the value of all the ``paramTitle`` integer quantity parameters.

        |

        *Overload 2:*

        Gets the integer quantity value of a given parameter.

        :raises: std::out_of_range	 	If ``index`` is not in the parameter range.
        :raises: std::invalid_argument	If the parameter at ``index`` is not an integer quantity
            										parameter.

        :type index: int
        :param index:	Zero-based index of the parameter we look for the value. This index is taken
            					in the set of all parameters of this activity.

        :rtype: int
        :return: The integer quantity value of the parameter at position ``index``.
        """
        return _fesapi.Activity_getIntegerQuantityParameterValue(self, *args)

    def isAStringParameter(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Queries if all of the parameters sharing a given title are string parameters.

        :raises: std::invalid_argument	If there exists no ``paramTitle`` parameter in this
            										activity.

        :type paramTitle: string
        :param paramTitle:	The title of the parameters we want to test the datatype.

        :rtype: boolean
        :return: True if all of the ``paramTitle`` parameters are string parameters, false if not.

        |

        *Overload 2:*

        Queries if a given parameter is a string parameter.

        :raises: std::out_of_range	If ``index`` is not in the parameter range.

        :type index: int
        :param index:	Zero-based index of the parameter we want to test the datatype.

        :rtype: boolean
        :return: True if the parameter at position ``index`` is a string parameter,
            			false if not.
        """
        return _fesapi.Activity_isAStringParameter(self, *args)

    def getStringParameterValue(self, *args) -> "std::string":
        r"""
        *Overload 1:*

        Gets the values of all the string parameters sharing a given title.

        :raises: std::invalid_argument	If there exists no ``paramTitle`` parameter in this
            										activity.
        :raises: std::invalid_argument	If one ``paramTitle`` parameter contains some non string
            										values.

        :type paramTitle: string
        :param paramTitle:	The title of the string parameters we look for the value.

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of the value of all the ``paramTitle`` string parameters.

        |

        *Overload 2:*

        Gets the string value of a given parameter.

        :raises: std::out_of_range	 	If ``index`` is not in the parameter range.
        :raises: std::invalid_argument	If the parameter at ``index`` is not an string parameter.

        :type index: int
        :param index:	Zero-based index of the parameter we look for the value. This index is taken
            					in the set of all parameters of this activity.

        :rtype: string
        :return: The string value of the parameter at position ``index``.
        """
        return _fesapi.Activity_getStringParameterValue(self, *args)

    def isAResqmlObjectParameter(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Queries if all of the parameters sharing a given title are RESQML object parameters.

        :raises: std::invalid_argument	If there exists no ``paramTitle`` parameter in this
            										activity.

        :type paramTitle: string
        :param paramTitle:	The title of the parameters we want to test the datatype.

        :rtype: boolean
        :return: True if all of the ``paramTitle`` parameters are RESQML object parameters, false if not.

        |

        *Overload 2:*

        Queries if a given parameter is a RESQML object parameter.

        :raises: std::out_of_range	If ``index`` is not in the parameter range.

        :type index: int
        :param index:	Zero-based index of the parameter we want to test the datatype.

        :rtype: boolean
        :return: True if the parameter at position ``index`` is a RESQML object parameter,
            			false if not.
        """
        return _fesapi.Activity_isAResqmlObjectParameter(self, *args)

    def getResqmlObjectParameterValue(self, index: "uint64_t") -> "common::AbstractObject *":
        r"""
        Gets the RESQML object value of a given parameter.

        :raises: std::out_of_range	 	If ``index`` is not in the parameter range.
        :raises: std::invalid_argument	If the parameter at ``index`` is not an RESQML object
            										parameter.

        :type index: int
        :param index:	Zero-based index of the parameter we look for the value. This index is taken
            					in the set of all parameters of this activity.

        :rtype: :py:class:`AbstractObject`
        :return: The RESQML object value of the parameter at position ``index``.
        """
        return _fesapi.Activity_getResqmlObjectParameterValue(self, index)

    def setActivityTemplate(self, activityTemplate: "ActivityTemplate") -> "void":
        r"""
        Sets the activity template of this activity.

        :param [in]:	activityTemplate	If non-null, the activity template.
        """
        return _fesapi.Activity_setActivityTemplate(self, activityTemplate)

    def getActivityTemplate(self) -> "eml2::ActivityTemplate *":
        r"""
        Gets the activity template of this activity.

        :rtype: :py:class:`ActivityTemplate`
        :return: The activity template of this activity.
        """
        return _fesapi.Activity_getActivityTemplate(self)
    __swig_destroy__ = _fesapi.delete_Activity

# Register Activity in _fesapi:
_fesapi.Activity_swigregister(Activity)
class Eml2_GraphicalInformationSet(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getGraphicalInformationSetCount(self) -> "uint64_t":
        r"""
        Gets the size of this graphical information set

        :rtype: int
        :return: The size of this graphical information set.
        """
        return _fesapi.Eml2_GraphicalInformationSet_getGraphicalInformationSetCount(self)

    def getTargetObjectCount(self, graphicalInformationIndex: "uint64_t") -> "uint64_t":
        r"""
        Gets the count of data objects which are targeted by a graphical information at ``graphicalInformationIndex``.

        :raises: std::range_error	If ``index`` is out of range.

        :type graphicalInformationIndex: int
        :param graphicalInformationIndex:	Zero-based index of the graphical information in the GraphicalInformationSet

        :rtype: int
        :return: the count of data objects which are targeted by a graphical information at ``graphicalInformationIndex``.
        """
        return _fesapi.Eml2_GraphicalInformationSet_getTargetObjectCount(self, graphicalInformationIndex)

    def getTargetObjectUuid(self, graphicalInformationIndex: "uint64_t", targetIndex: "uint64_t") -> "std::string":
        r"""
        Gets the UUID of the object which receives some graphical information at a particular index
        of the graphical information set and at a particular target index.

        :raises: std::range_error	If ``index`` is out of range.

        :type graphicalInformationIndex: int
        :param graphicalInformationIndex:	Zero-based index of the graphical information in the GraphicalInformationSet
        :type targetIndex: int
        :param targetIndex:					Zero-based index of the data object reference in the graphical information

        :rtype: string
        :return: The UUUID of the object which receives some graphical information at ``graphicalInformationIndex`` and target ``targetIndex``.
        """
        return _fesapi.Eml2_GraphicalInformationSet_getTargetObjectUuid(self, graphicalInformationIndex, targetIndex)

    def getTargetObject(self, graphicalInformationIndex: "uint64_t", targetIndex: "uint64_t") -> "common::AbstractObject *":
        r"""
        Gets the data object which receives some graphical information at a particular index of the
        graphical information set and at a particular target index.

        :type graphicalInformationIndex: int
        :param graphicalInformationIndex:	Zero-based index of the graphical information in the GraphicalInformationSet
        :type targetIndex: int
        :param targetIndex:					Zero-based index of the data object reference in the graphical information

        :rtype: :py:class:`AbstractObject`
        :return: The data object which receives some graphical information at ``graphicalInformationIndex`` and target ``targetIndex``.
        """
        return _fesapi.Eml2_GraphicalInformationSet_getTargetObject(self, graphicalInformationIndex, targetIndex)

    def hasGraphicalInformation(self, targetObject: "AbstractObject") -> "bool":
        r"""
        Query if a given data object has some graphical information. If it has no direct graphical
        information (see {hasDirectGraphicalInformation}) and it is a property, we also check
        that its property kind has some

        :raises: std::invalid_argument	If the target object is null.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object we want to test for having some graphical information.

        :rtype: boolean
        :return: True if ``targetObject`` (or its property kind) has some graphical information, else false.
        """
        return _fesapi.Eml2_GraphicalInformationSet_hasGraphicalInformation(self, targetObject)

    def hasDefaultColor(self, targetObject: "AbstractObject") -> "bool":
        r"""
        Query if a given data object has a default color. It only looks at direct color association (see
        {hasDirectGraphicalInformation})

        :raises: std::invalid_argument	If the target object is null.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object we want to test for having a default color.

        :rtype: boolean
        :return: True ``targetObject`` has one default color, else false.
        """
        return _fesapi.Eml2_GraphicalInformationSet_hasDefaultColor(self, targetObject)

    def getDefaultHue(self, targetObject: "AbstractObject") -> "double":
        r"""
        Gets the default hue of a given data object. It only looks at direct color association (see
        {hasDirectGraphicalInformation})

        :raises: std::invalid_argument	If ``targetObject`` has no default color.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for the default hue.

        :rtype: float
        :return: The default hue of ``targetObject`` in the range [0, 360].
        """
        return _fesapi.Eml2_GraphicalInformationSet_getDefaultHue(self, targetObject)

    def getDefaultSaturation(self, targetObject: "AbstractObject") -> "double":
        r"""
        Gets the default saturation of a given data object. It only looks at direct color association
        (see {hasDirectGraphicalInformation})

        :raises: std::invalid_argument	If ``targetObject`` has no default color.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for the default saturation.

        :rtype: float
        :return: The default saturation of ``targetObject`` in the range [0, 1].
        """
        return _fesapi.Eml2_GraphicalInformationSet_getDefaultSaturation(self, targetObject)

    def getDefaultValue(self, targetObject: "AbstractObject") -> "double":
        r"""
        Gets the default color value of a given data object. It only looks at direct color
        association (see {hasDirectGraphicalInformation})

        :raises: std::invalid_argument	If ``targetObject`` has no default color.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for the default color value.

        :rtype: float
        :return: The default color value of ``targetObject`` in the range [0, 1].
        """
        return _fesapi.Eml2_GraphicalInformationSet_getDefaultValue(self, targetObject)

    def getDefaultAlpha(self, targetObject: "AbstractObject") -> "double":
        r"""
        Gets the default alpha value of a given data object. It only looks at direct color
        association (see {hasDirectGraphicalInformation})

        :raises: std::invalid_argument	If ``targetObject`` has no default color.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for the default alpha value.

        :rtype: float
        :return: The default alpha value in the range [0, 1] (0 means transparent and 1 means opaque).
        """
        return _fesapi.Eml2_GraphicalInformationSet_getDefaultAlpha(self, targetObject)

    def hasDefaultColorTitle(self, targetObject: "AbstractObject") -> "bool":
        r"""
        Query if a given data object has a default color title. It only looks at direct color
        association (see {hasDirectGraphicalInformation})

        :raises: std::invalid_argument	If ``targetObject`` has no default color.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for a default color title.

        :rtype: boolean
        :return: True if ``targetObject`` has a default color title, else false.
        """
        return _fesapi.Eml2_GraphicalInformationSet_hasDefaultColorTitle(self, targetObject)

    def getDefaultColorTitle(self, targetObject: "AbstractObject") -> "std::string":
        r"""
        Gets the default color title of a given data object. It only looks at direct color
        association (see {hasDirectGraphicalInformation})

        :raises: std::invalid_argument	If ``targetObject`` has no default color or if its default
            										color has no title.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for the default color title.

        :rtype: string
        :return: The default title.
        """
        return _fesapi.Eml2_GraphicalInformationSet_getDefaultColorTitle(self, targetObject)

    def setDefaultHsvColor(self, *args) -> "void":
        r"""
        Sets the default HSV color (https://en.wikipedia.org/wiki/HSV_color_space) of a given data
        object

        :raises: std::invalid_argument	If ``targetObject`` is null or if it is not a feature,
            										interpretation, representation or wellbore marker.
        :raises: std::invalid_argument	If ``hue`` is out of range [0, 360].
        :raises: std::invalid_argument	If ``saturation``, ``value`` or ``alpha`` is out of range [0,
            										1].

        :param [in]:	targetObject	The data object which receives the color.
        :type hue: float
        :param hue:				The hue angle in degrees in range [0, 360].
        :type saturation: float
        :param saturation:  	The saturation value in range [0, 1].
        :type value: float
        :param value:			The color value in range [0, 1].
        :type alpha: float, optional
        :param alpha:			(Optional) The alpha value in range [0, 1] for transparency
            								channel (0 means transparent and 1 means opaque). Default value is 1.
        :type colorTitle: string, optional
        :param colorTitle:  	(Optional) The title of the given HSV color. It is not set if
            								title is empty (default).
        """
        return _fesapi.Eml2_GraphicalInformationSet_setDefaultHsvColor(self, *args)

    def setDefaultRgbColor(self, *args) -> "void":
        r"""
        *Overload 1:*

        Sets the default RGB color https://en.wikipedia.org/wiki/RGB_color_space of a given data
        object

        :raises: std::invalid_argument	If ``targetObject`` is null or if it is not a feature,
            										interpretation, representation or wellbore marker.
        :raises: std::invalid_argument	If ``red``, ``green``, ``blue`` or ``alpha`` is out of range
            										[0,
            										1].

        :param [in]:	targetObject	The data object which receives the color.
        :type red: float
        :param red:				Red value in range [0, 1].
        :type green: float
        :param green:			Green value in range [0, 1].
        :type blue: float
        :param blue:			Blue value in range [0, 1].
        :type alpha: float, optional
        :param alpha:			(Optional) The alpha value in range [0, 1] for transparency
            								channel (0 means transparent and 1 means opaque). Default value is 1.
        :type colorTitle: string, optional
        :param colorTitle:  	(Optional) The title of the given HSV color. It is not set if
            								title is empty (default).

        |

        *Overload 2:*

        Sets the default RGB color https://en.wikipedia.org/wiki/RGB_color_space of a given data
        object

        :raises: std::invalid_argument	If ``targetObject`` is null or if it is not a feature,
            										interpretation, representation or wellbore marker.
        :raises: std::invalid_argument	If ``red``, ``green``, ``blue`` or ``alpha`` is out of range
            										[0,
            										255].
        :raises: std::invalid_argument	If ``alpha`` is out of range [0,1].

        :param [in]:	targetObject	The data object which receives the color.
        :type red: uint8_t
        :param red:				Red value in range [0, 255].
        :type green: uint8_t
        :param green:			Green value in range [0, 255].
        :type blue: uint8_t
        :param blue:			Blue value in range [0, 255].
        :type alpha: float, optional
        :param alpha:			(Optional) The alpha value in range [0, 1] for transparency
            								channel (0 means transparent and 1 means opaque). Default value is 1.
        :type colorTitle: string, optional
        :param colorTitle:  	(Optional) The title of the given HSV color. It is not set if
            								title is empty (default).

        |

        *Overload 3:*

        Sets the default RGB color https://en.wikipedia.org/wiki/RGB_color_space of a given data
        object

        :raises: std::invalid_argument	If ``targetObject`` is null or if it is not a feature,
            										interpretation, representation or wellbore marker.
        :raises: std::invalid_argument	If ``red``, ``green``, ``blue`` or ``alpha`` is out of range
            										[0,
            										255].
        :raises: std::invalid_argument	If ``alpha`` is out of range [0,1].

        :param [in]:	targetObject	The data object which receives the color.
        :type red: uint8_t
        :param red:				Red value in range [0, 255].
        :type green: uint8_t
        :param green:			Green value in range [0, 255].
        :type blue: uint8_t
        :param blue:			Blue value in range [0, 255].
        :type alpha: float, optional
        :param alpha:			(Optional) The alpha value in range [0, 1] for transparency
            								channel (0 means transparent and 1 means opaque). Default value is 1.
        :param colorTitle:  	(Optional) The title of the given HSV color. It is not set if
            								title is empty (default).

        |

        *Overload 4:*

        Sets the default RGB color https://en.wikipedia.org/wiki/RGB_color_space of a given data
        object

        :raises: std::invalid_argument	If ``targetObject`` is null or if it is not a feature,
            										interpretation, representation or wellbore marker.
        :raises: std::invalid_argument	If ``red``, ``green``, ``blue`` or ``alpha`` is out of range
            										[0,
            										255].
        :raises: std::invalid_argument	If ``alpha`` is out of range [0,1].

        :param [in]:	targetObject	The data object which receives the color.
        :type red: uint8_t
        :param red:				Red value in range [0, 255].
        :type green: uint8_t
        :param green:			Green value in range [0, 255].
        :type blue: uint8_t
        :param blue:			Blue value in range [0, 255].
        :param alpha:			(Optional) The alpha value in range [0, 1] for transparency
            								channel (0 means transparent and 1 means opaque). Default value is 1.
        :param colorTitle:  	(Optional) The title of the given HSV color. It is not set if
            								title is empty (default).
        """
        return _fesapi.Eml2_GraphicalInformationSet_setDefaultRgbColor(self, *args)

    def hasDiscreteColorMap(self, targetObject: "AbstractObject") -> "bool":
        r"""
        Query if a given data object has a discrete color map. If it has not and it is a property, we
        also look for its property kind discrete color map

        :raises: std::invalid_argument	If ``targetObject`` is null.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for a discrete color map.

        :rtype: boolean
        :return: True if ``targetObject`` (or its property kind) has a discrete color map, else false.
        """
        return _fesapi.Eml2_GraphicalInformationSet_hasDiscreteColorMap(self, targetObject)

    def getDiscreteColorMapUuid(self, targetObject: "AbstractObject") -> "std::string":
        r"""
        Gets the discrete color map data UUID of a given data object. If the data object has no
        discrete color map and if it is a property, we also look for its property kind discrete color
        map

        :raises: std::invalid_argument	If ``targetObject`` is null or if it has no discrete color
            										map.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for a discrete color map.

        :rtype: string
        :return: The UUID of the discrete color map of ``targetObject`` (or of its property kind).
        """
        return _fesapi.Eml2_GraphicalInformationSet_getDiscreteColorMapUuid(self, targetObject)

    def getDiscreteColorMap(self, targetObject: "AbstractObject") -> "resqml2::DiscreteColorMap *":
        r"""
        Gets the discrete color map of a given data object. If the data object has no discrete color
        map and if it is a property, we also look for its property kind discrete color map

        :raises: std::invalid_argument	If ``targetObject`` is null or if it has no discrete color
            										map.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for a discrete color map.

        :rtype: :py:class:`DiscreteColorMap`
        :return: The discrete color map of ``targetObject`` (or of its property kind).
        """
        return _fesapi.Eml2_GraphicalInformationSet_getDiscreteColorMap(self, targetObject)

    def setDiscreteColorMap(self, targetObject: "AbstractObject", discreteColorMap: "Resqml2_DiscreteColorMap", useReverseMapping: "bool"=False, useLogarithmicMapping: "bool"=False) -> "void":
        r"""
        Sets a discrete color map on a given data object

        :raises: std::invalid_argument	If ``targetObject`` or ``discreteColorMap`` is null.
        :raises: std::invalid_argument	If ``targetObject`` is neither a property nor a property
            										kind.

        :param [in]:	targetObject		 	The data object on which we want to set a discrete color
            										map.
        :param [in]:	discreteColorMap	 	The discrete color map we want to set on the data object.
        :type useReverseMapping: boolean, optional
        :param useReverseMapping:	 	(Optional) It true, it indicates that the minimum value
            										of the property corresponds to the maximum index of the
            										color map and that the maximum value of the property
            										corresponds to the minimum index of the color map.
            										Default value is false.
        :type useLogarithmicMapping: boolean, optional
        :param useLogarithmicMapping:	(Optional) If true, it indicates that the log of the
            										property values are taken into account when mapped with
            										the index of the color map. Default value is false.
        """
        return _fesapi.Eml2_GraphicalInformationSet_setDiscreteColorMap(self, targetObject, discreteColorMap, useReverseMapping, useLogarithmicMapping)

    def hasContinuousColorMap(self, targetObject: "AbstractObject") -> "bool":
        r"""
        Query if a given data object has a continuous color map. If it has not and it is a property,
        we also look for its property kind continuous color map

        :raises: std::invalid_argument	If ``targetObject`` is null.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for a continuous color map.

        :rtype: boolean
        :return: True if ``targetObject`` (or its property kind) has a continuous color map, else false.
        """
        return _fesapi.Eml2_GraphicalInformationSet_hasContinuousColorMap(self, targetObject)

    def getContinuousColorMapUuid(self, targetObject: "AbstractObject") -> "std::string":
        r"""
        Gets the continuous color map data UUID of a given data object. If the data object has no
        continuous color map and if it is a property, we also look for its property kind continuous
        color map

        :raises: std::invalid_argument	If ``targetObject`` is null or if it has no continuous
            										color map.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for a continuous color map.

        :rtype: string
        :return: The UUID of the continuous color map of ``targetObject`` (or of its property kind).
        """
        return _fesapi.Eml2_GraphicalInformationSet_getContinuousColorMapUuid(self, targetObject)

    def getContinuousColorMap(self, targetObject: "AbstractObject") -> "resqml2::ContinuousColorMap *":
        r"""
        Gets the continuous color map of a given data object. If the data object has no continuous
        color map and if it is a property, we also look for its property kind continuous color map

        :raises: std::invalid_argument	If ``targetObject`` is null or if it has no continuous
            										color map.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for a continuous color map.

        :rtype: :py:class:`ContinuousColorMap`
        :return: The continuous color map of ``targetObject`` (or of its property kind).
        """
        return _fesapi.Eml2_GraphicalInformationSet_getContinuousColorMap(self, targetObject)

    def setContinuousColorMap(self, targetObject: "AbstractObject", continuousColorMap: "Resqml2_ContinuousColorMap", useReverseMapping: "bool"=False, useLogarithmicMapping: "bool"=False) -> "void":
        r"""
        Sets a continuous color map on a given data object

        :raises: std::invalid_argument	If ``targetObject`` or ``continuous`` is null.
        :raises: std::invalid_argument	If ``targetObject`` is neither a property nor a property
            										kind.

        :param [in]:	targetObject		 	The data object on which we want to set a continuous
            										color map.
        :param [in]:	continuousColorMap   	The continuous color map we want to set on the data
            										object.
        :type useReverseMapping: boolean, optional
        :param useReverseMapping:	 	(Optional) It true, it indicates that the minimum value
            										of the property corresponds to the maximum index of the
            										color map and that the maximum value of the property
            										corresponds to the minimum index of the color map.
            										Default value is false.
        :type useLogarithmicMapping: boolean, optional
        :param useLogarithmicMapping:	(Optional) If true, it indicates that the log of the
            										property values are taken into account when mapped with
            										the index of the color map. Default value is false.
        """
        return _fesapi.Eml2_GraphicalInformationSet_setContinuousColorMap(self, targetObject, continuousColorMap, useReverseMapping, useLogarithmicMapping)

    def hasColorMapMinMax(self, targetObject: "AbstractObject") -> "bool":
        r"""
        Query if a given data object has minimum and maximum values to map with a color map. It only
        looks at direct color association (see {hasDirectGraphicalInformation})

        :raises: std::invalid_argument	If ``targetObject`` is null or if it has no color
            										information.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for the minimum and maximum values.

        :rtype: boolean
        :return: True if minimum and maximum values exist, else false.
        """
        return _fesapi.Eml2_GraphicalInformationSet_hasColorMapMinMax(self, targetObject)

    def getColorMapMin(self, targetObject: "AbstractObject") -> "double":
        r"""
        Gets the minimum value to map with a color map for a given data object. It only looks at
        direct color association (see {hasDirectGraphicalInformation})

        :raises: std::invalid_argument	If the color information associated ``targetObject`` has
            										no minimum value.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for the minimum value.

        :rtype: float
        :return: The minimum value.
        """
        return _fesapi.Eml2_GraphicalInformationSet_getColorMapMin(self, targetObject)

    def getColorMapMax(self, targetObject: "AbstractObject") -> "double":
        r"""
        Gets the maximum value to map with a color map for a given data object. It only looks at
        direct color association (see {hasDirectGraphicalInformation})

        :raises: std::invalid_argument	If the color information associated ``targetObject`` has
            										no maximum value.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for the maximum value.

        :rtype: float
        :return: The maximum value.
        """
        return _fesapi.Eml2_GraphicalInformationSet_getColorMapMax(self, targetObject)

    def setColorMapMinMax(self, targetObject: "AbstractObject", min: "double", max: "double") -> "void":
        r"""
        Sets the minimum and maximum values to map with a color map for a given data object

        :raises: std::invalid_argument	If ``targetObject`` has no color information.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we want to set the minimum and maximum
            							values to map with a color map.
        :type min: float
        :param min:				The minimum value.
        :type max: float
        :param max:				The maximum value.
        """
        return _fesapi.Eml2_GraphicalInformationSet_setColorMapMinMax(self, targetObject, min, max)

    def hasValueVectorIndex(self, targetObject: "AbstractObject") -> "bool":
        r"""
        Query if a given data object indicates which value vector index to look when mapping with a
        color map. It is especially useful for vectorial property and for geometry

        :raises: std::invalid_argument	If ``targetObject`` is null or if it has no color
            										information.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for a value vector index to look
            							when mapping with a color map.

        :rtype: boolean
        :return: True if a value vector index exists, else false.
        """
        return _fesapi.Eml2_GraphicalInformationSet_hasValueVectorIndex(self, targetObject)

    def getValueVectorIndex(self, targetObject: "AbstractObject") -> "int64_t":
        r"""
        Gets the value vector index to look when mapping with a color map. It is especially useful
        for vectorial property and for geometry

        :raises: std::invalid_argument	If the color information associated to ``targetObject``
            										has no value vector index.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:	The data object for which we look for a value vector index to look
            							when mapping with a color map.

        :rtype: int
        :return: The value vector index.
        """
        return _fesapi.Eml2_GraphicalInformationSet_getValueVectorIndex(self, targetObject)

    def setValueVectorIndex(self, targetObject: "AbstractObject", valueVectorIndex: "int64_t") -> "void":
        r"""
        Sets the value vector index to look when mapping with a color map. It is especially useful
        for vectorial property and for geometry

        :raises: std::invalid_argument	If ``targetObject`` has no color information.

        :type targetObject: :py:class:`AbstractObject`
        :param targetObject:		The data object for which we want to set the value vector index
            								to look when mapping with a color map.
        :type valueVectorIndex: int
        :param valueVectorIndex:	The value vector index to set.
        """
        return _fesapi.Eml2_GraphicalInformationSet_setValueVectorIndex(self, targetObject, valueVectorIndex)
    __swig_destroy__ = _fesapi.delete_Eml2_GraphicalInformationSet

# Register Eml2_GraphicalInformationSet in _fesapi:
_fesapi.Eml2_GraphicalInformationSet_swigregister(Eml2_GraphicalInformationSet)
class PropertyKind(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNamingSystem(self) -> "std::string":
        r"""
        Gets (in read only mode) the naming system of this property type. It is the name of the
        dictionary within which the property is unique. This also defines the name of the controlling
        authority. It is an URN of the form urn:x-resqml:domainOrEmail:dictionaryName

        :rtype: string
        :return: The naming system.
        """
        return _fesapi.PropertyKind_getNamingSystem(self)

    def getBaseUomAsString(self) -> "std::string":
        r"""
        Get the base unit of measure for conversion of the values of this property kind as a string.

        :rtype: string
        :return: The unit or measure of the values of this property kind as a string.
        """
        return _fesapi.PropertyKind_getBaseUomAsString(self)

    def getParentPropertyKind(self) -> "eml2::PropertyKind *":
        r"""
        Gets the parent local property kind

        :raises: std::invalid_argument	If the parent property kind is not a local one (it is an
            										Energistics standard one).

        :rtype: :py:class:`PropertyKind`
        :return: The parent local property kind.
        """
        return _fesapi.PropertyKind_getParentPropertyKind(self)

    def setParentPropertyKind(self, parentPropertyKind: "PropertyKind") -> "void":
        r"""
        Sets the parent property kind of this property kind

        :raises: std::invalid_argument	If ``parentPropertyKind`` is null.

        :param [in]:	parentPropertyKind	The parent property kind to set to this property kind.
        """
        return _fesapi.PropertyKind_setParentPropertyKind(self, parentPropertyKind)

    def isAbstract(self) -> "bool":
        r"""
        Checks if this property kind is abstract or not

        :rtype: boolean
        :return: True if abstract, false if not.
        """
        return _fesapi.PropertyKind_isAbstract(self)
    __swig_destroy__ = _fesapi.delete_PropertyKind

# Register PropertyKind in _fesapi:
_fesapi.PropertyKind_swigregister(PropertyKind)
class TimeSeries(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackTimestamp(self, timestamp: "time_t") -> "void":
        r"""
        Pushes back an timestamp into this time series.

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0 one.

        :type timestamp: int
        :param timestamp:	The timestamp to push back.
        """
        return _fesapi.TimeSeries_pushBackTimestamp(self, timestamp)

    def getTimestampIndex(self, timestamp: "time_t", yearOffset: "LONG64"=0) -> "uint64_t":
        r"""
        Gets the index of a given timestamp in this time series.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``timestamp`` has not been found in this time series.

        :type timestamp: int
        :param timestamp:	The timestamp we look for.
        :type yearOffset: LONG64, optional
        :param yearOffset:	Indicates that the dateTime attribute must be translated according to this value.

        :rtype: int
        :return: The index of ``timestamp`` in this time series.
        """
        return _fesapi.TimeSeries_getTimestampIndex(self, timestamp, yearOffset)

    def getTimestampCount(self) -> "uint64_t":
        r"""
        Get the count of timestamps in this time series.

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0 one.

        :rtype: int
        :return: The timestamp count.
        """
        return _fesapi.TimeSeries_getTimestampCount(self)

    def getTimestamp(self, index: "uint64_t") -> "time_t":
        r"""
        Gets a timestamp at a particular index of this time series.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``index`` is out of range.

        :type index: int
        :param index:	Zero-based index of the timestamp we look for.

        :rtype: int
        :return: The timestamp at position ``index``.
        """
        return _fesapi.TimeSeries_getTimestamp(self, index)
    __swig_destroy__ = _fesapi.delete_TimeSeries

# Register TimeSeries in _fesapi:
_fesapi.TimeSeries_swigregister(TimeSeries)
class GraphicalInformationSetVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fesapi.GraphicalInformationSetVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fesapi.GraphicalInformationSetVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fesapi.GraphicalInformationSetVector___bool__(self)

    def __len__(self) -> "std::vector< eml2_3::GraphicalInformationSet * >::size_type":
        return _fesapi.GraphicalInformationSetVector___len__(self)

    def __getslice__(self, i: "std::vector< eml2_3::GraphicalInformationSet * >::difference_type", j: "std::vector< eml2_3::GraphicalInformationSet * >::difference_type") -> "std::vector< eml2_3::GraphicalInformationSet *,std::allocator< eml2_3::GraphicalInformationSet * > > *":
        return _fesapi.GraphicalInformationSetVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fesapi.GraphicalInformationSetVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< eml2_3::GraphicalInformationSet * >::difference_type", j: "std::vector< eml2_3::GraphicalInformationSet * >::difference_type") -> "void":
        return _fesapi.GraphicalInformationSetVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fesapi.GraphicalInformationSetVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< eml2_3::GraphicalInformationSet * >::value_type":
        return _fesapi.GraphicalInformationSetVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fesapi.GraphicalInformationSetVector___setitem__(self, *args)

    def pop(self) -> "std::vector< eml2_3::GraphicalInformationSet * >::value_type":
        return _fesapi.GraphicalInformationSetVector_pop(self)

    def append(self, x: "Eml23_GraphicalInformationSet") -> "void":
        return _fesapi.GraphicalInformationSetVector_append(self, x)

    def empty(self) -> "bool":
        return _fesapi.GraphicalInformationSetVector_empty(self)

    def size(self) -> "std::vector< eml2_3::GraphicalInformationSet * >::size_type":
        return _fesapi.GraphicalInformationSetVector_size(self)

    def swap(self, v: "GraphicalInformationSetVector") -> "void":
        return _fesapi.GraphicalInformationSetVector_swap(self, v)

    def begin(self) -> "std::vector< eml2_3::GraphicalInformationSet * >::iterator":
        return _fesapi.GraphicalInformationSetVector_begin(self)

    def end(self) -> "std::vector< eml2_3::GraphicalInformationSet * >::iterator":
        return _fesapi.GraphicalInformationSetVector_end(self)

    def rbegin(self) -> "std::vector< eml2_3::GraphicalInformationSet * >::reverse_iterator":
        return _fesapi.GraphicalInformationSetVector_rbegin(self)

    def rend(self) -> "std::vector< eml2_3::GraphicalInformationSet * >::reverse_iterator":
        return _fesapi.GraphicalInformationSetVector_rend(self)

    def clear(self) -> "void":
        return _fesapi.GraphicalInformationSetVector_clear(self)

    def get_allocator(self) -> "std::vector< eml2_3::GraphicalInformationSet * >::allocator_type":
        return _fesapi.GraphicalInformationSetVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fesapi.GraphicalInformationSetVector_pop_back(self)

    def erase(self, *args) -> "std::vector< eml2_3::GraphicalInformationSet * >::iterator":
        return _fesapi.GraphicalInformationSetVector_erase(self, *args)

    def __init__(self, *args):
        _fesapi.GraphicalInformationSetVector_swiginit(self, _fesapi.new_GraphicalInformationSetVector(*args))

    def push_back(self, x: "Eml23_GraphicalInformationSet") -> "void":
        return _fesapi.GraphicalInformationSetVector_push_back(self, x)

    def front(self) -> "std::vector< eml2_3::GraphicalInformationSet * >::value_type":
        return _fesapi.GraphicalInformationSetVector_front(self)

    def back(self) -> "std::vector< eml2_3::GraphicalInformationSet * >::value_type":
        return _fesapi.GraphicalInformationSetVector_back(self)

    def assign(self, n: "std::vector< eml2_3::GraphicalInformationSet * >::size_type", x: "Eml23_GraphicalInformationSet") -> "void":
        return _fesapi.GraphicalInformationSetVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fesapi.GraphicalInformationSetVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fesapi.GraphicalInformationSetVector_insert(self, *args)

    def reserve(self, n: "std::vector< eml2_3::GraphicalInformationSet * >::size_type") -> "void":
        return _fesapi.GraphicalInformationSetVector_reserve(self, n)

    def capacity(self) -> "std::vector< eml2_3::GraphicalInformationSet * >::size_type":
        return _fesapi.GraphicalInformationSetVector_capacity(self)
    __swig_destroy__ = _fesapi.delete_GraphicalInformationSetVector

# Register GraphicalInformationSetVector in _fesapi:
_fesapi.GraphicalInformationSetVector_swigregister(GraphicalInformationSetVector)
eml23__IndexableElement_cells = _fesapi.eml23__IndexableElement_cells
eml23__IndexableElement_intervals_x0020from_x0020datum = _fesapi.eml23__IndexableElement_intervals_x0020from_x0020datum
eml23__IndexableElement_column_x0020edges = _fesapi.eml23__IndexableElement_column_x0020edges
eml23__IndexableElement_columns = _fesapi.eml23__IndexableElement_columns
eml23__IndexableElement_contacts = _fesapi.eml23__IndexableElement_contacts
eml23__IndexableElement_coordinate_x0020lines = _fesapi.eml23__IndexableElement_coordinate_x0020lines
eml23__IndexableElement_edges = _fesapi.eml23__IndexableElement_edges
eml23__IndexableElement_edges_x0020per_x0020column = _fesapi.eml23__IndexableElement_edges_x0020per_x0020column
eml23__IndexableElement_enumerated_x0020elements = _fesapi.eml23__IndexableElement_enumerated_x0020elements
eml23__IndexableElement_faces = _fesapi.eml23__IndexableElement_faces
eml23__IndexableElement_faces_x0020per_x0020cell = _fesapi.eml23__IndexableElement_faces_x0020per_x0020cell
eml23__IndexableElement_interval_x0020edges = _fesapi.eml23__IndexableElement_interval_x0020edges
eml23__IndexableElement_intervals = _fesapi.eml23__IndexableElement_intervals
eml23__IndexableElement_I0 = _fesapi.eml23__IndexableElement_I0
eml23__IndexableElement_I0_x0020edges = _fesapi.eml23__IndexableElement_I0_x0020edges
eml23__IndexableElement_J0 = _fesapi.eml23__IndexableElement_J0
eml23__IndexableElement_J0_x0020edges = _fesapi.eml23__IndexableElement_J0_x0020edges
eml23__IndexableElement_layers = _fesapi.eml23__IndexableElement_layers
eml23__IndexableElement_lines = _fesapi.eml23__IndexableElement_lines
eml23__IndexableElement_nodes = _fesapi.eml23__IndexableElement_nodes
eml23__IndexableElement_nodes_x0020per_x0020cell = _fesapi.eml23__IndexableElement_nodes_x0020per_x0020cell
eml23__IndexableElement_nodes_x0020per_x0020edge = _fesapi.eml23__IndexableElement_nodes_x0020per_x0020edge
eml23__IndexableElement_nodes_x0020per_x0020face = _fesapi.eml23__IndexableElement_nodes_x0020per_x0020face
eml23__IndexableElement_patches = _fesapi.eml23__IndexableElement_patches
eml23__IndexableElement_pillars = _fesapi.eml23__IndexableElement_pillars
eml23__IndexableElement_regions = _fesapi.eml23__IndexableElement_regions
eml23__IndexableElement_representation = _fesapi.eml23__IndexableElement_representation
eml23__IndexableElement_subnodes = _fesapi.eml23__IndexableElement_subnodes
eml23__IndexableElement_triangles = _fesapi.eml23__IndexableElement_triangles
eml23__AnglePerLengthUom__0_x002e01_x0020dega_x002fft = _fesapi.eml23__AnglePerLengthUom__0_x002e01_x0020dega_x002fft
eml23__AnglePerLengthUom__1_x002f30_x0020dega_x002fft = _fesapi.eml23__AnglePerLengthUom__1_x002f30_x0020dega_x002fft
eml23__AnglePerLengthUom__1_x002f30_x0020dega_x002fm = _fesapi.eml23__AnglePerLengthUom__1_x002f30_x0020dega_x002fm
eml23__AnglePerLengthUom_dega_x002fft = _fesapi.eml23__AnglePerLengthUom_dega_x002fft
eml23__AnglePerLengthUom_dega_x002fm = _fesapi.eml23__AnglePerLengthUom_dega_x002fm
eml23__AnglePerLengthUom_rad_x002fft = _fesapi.eml23__AnglePerLengthUom_rad_x002fft
eml23__AnglePerLengthUom_rad_x002fm = _fesapi.eml23__AnglePerLengthUom_rad_x002fm
eml23__AnglePerLengthUom_rev_x002fft = _fesapi.eml23__AnglePerLengthUom_rev_x002fft
eml23__AnglePerLengthUom_rev_x002fm = _fesapi.eml23__AnglePerLengthUom_rev_x002fm
eml23__DataIndexKind_measured_x0020depth = _fesapi.eml23__DataIndexKind_measured_x0020depth
eml23__DataIndexKind_true_x0020vertical_x0020depth = _fesapi.eml23__DataIndexKind_true_x0020vertical_x0020depth
eml23__DataIndexKind_pass_x0020indexed_x0020depth = _fesapi.eml23__DataIndexKind_pass_x0020indexed_x0020depth
eml23__DataIndexKind_date_x0020time = _fesapi.eml23__DataIndexKind_date_x0020time
eml23__DataIndexKind_elapsed_x0020time = _fesapi.eml23__DataIndexKind_elapsed_x0020time
eml23__DataIndexKind_temperature = _fesapi.eml23__DataIndexKind_temperature
eml23__DataIndexKind_pressure = _fesapi.eml23__DataIndexKind_pressure
eml23__DataIndexKind_scalar = _fesapi.eml23__DataIndexKind_scalar
eml23__DimensionlessUom__x0025 = _fesapi.eml23__DimensionlessUom__x0025
eml23__DimensionlessUom_cEuc = _fesapi.eml23__DimensionlessUom_cEuc
eml23__DimensionlessUom_dEuc = _fesapi.eml23__DimensionlessUom_dEuc
eml23__DimensionlessUom_EEuc = _fesapi.eml23__DimensionlessUom_EEuc
eml23__DimensionlessUom_Euc = _fesapi.eml23__DimensionlessUom_Euc
eml23__DimensionlessUom_fEuc = _fesapi.eml23__DimensionlessUom_fEuc
eml23__DimensionlessUom_GEuc = _fesapi.eml23__DimensionlessUom_GEuc
eml23__DimensionlessUom_kEuc = _fesapi.eml23__DimensionlessUom_kEuc
eml23__DimensionlessUom_MEuc = _fesapi.eml23__DimensionlessUom_MEuc
eml23__DimensionlessUom_mEuc = _fesapi.eml23__DimensionlessUom_mEuc
eml23__DimensionlessUom_nEuc = _fesapi.eml23__DimensionlessUom_nEuc
eml23__DimensionlessUom_pEuc = _fesapi.eml23__DimensionlessUom_pEuc
eml23__DimensionlessUom_ppk = _fesapi.eml23__DimensionlessUom_ppk
eml23__DimensionlessUom_ppm = _fesapi.eml23__DimensionlessUom_ppm
eml23__DimensionlessUom_TEuc = _fesapi.eml23__DimensionlessUom_TEuc
eml23__DimensionlessUom_uEuc = _fesapi.eml23__DimensionlessUom_uEuc
eml23__LengthUom_m = _fesapi.eml23__LengthUom_m
eml23__LengthUom__0_x002e1_x0020ft = _fesapi.eml23__LengthUom__0_x002e1_x0020ft
eml23__LengthUom__0_x002e1_x0020ft_x005bUS_x005d = _fesapi.eml23__LengthUom__0_x002e1_x0020ft_x005bUS_x005d
eml23__LengthUom__0_x002e1_x0020in = _fesapi.eml23__LengthUom__0_x002e1_x0020in
eml23__LengthUom__0_x002e1_x0020yd = _fesapi.eml23__LengthUom__0_x002e1_x0020yd
eml23__LengthUom__1_x002f16_x0020in = _fesapi.eml23__LengthUom__1_x002f16_x0020in
eml23__LengthUom__1_x002f2_x0020ft = _fesapi.eml23__LengthUom__1_x002f2_x0020ft
eml23__LengthUom__1_x002f32_x0020in = _fesapi.eml23__LengthUom__1_x002f32_x0020in
eml23__LengthUom__1_x002f64_x0020in = _fesapi.eml23__LengthUom__1_x002f64_x0020in
eml23__LengthUom__10_x0020ft = _fesapi.eml23__LengthUom__10_x0020ft
eml23__LengthUom__10_x0020in = _fesapi.eml23__LengthUom__10_x0020in
eml23__LengthUom__10_x0020km = _fesapi.eml23__LengthUom__10_x0020km
eml23__LengthUom__100_x0020ft = _fesapi.eml23__LengthUom__100_x0020ft
eml23__LengthUom__100_x0020km = _fesapi.eml23__LengthUom__100_x0020km
eml23__LengthUom__1000_x0020ft = _fesapi.eml23__LengthUom__1000_x0020ft
eml23__LengthUom__30_x0020ft = _fesapi.eml23__LengthUom__30_x0020ft
eml23__LengthUom__30_x0020m = _fesapi.eml23__LengthUom__30_x0020m
eml23__LengthUom_angstrom = _fesapi.eml23__LengthUom_angstrom
eml23__LengthUom_chain = _fesapi.eml23__LengthUom_chain
eml23__LengthUom_chain_x005bBnA_x005d = _fesapi.eml23__LengthUom_chain_x005bBnA_x005d
eml23__LengthUom_chain_x005bBnB_x005d = _fesapi.eml23__LengthUom_chain_x005bBnB_x005d
eml23__LengthUom_chain_x005bCla_x005d = _fesapi.eml23__LengthUom_chain_x005bCla_x005d
eml23__LengthUom_chain_x005bInd37_x005d = _fesapi.eml23__LengthUom_chain_x005bInd37_x005d
eml23__LengthUom_chain_x005bSe_x005d = _fesapi.eml23__LengthUom_chain_x005bSe_x005d
eml23__LengthUom_chain_x005bSeT_x005d = _fesapi.eml23__LengthUom_chain_x005bSeT_x005d
eml23__LengthUom_chain_x005bUS_x005d = _fesapi.eml23__LengthUom_chain_x005bUS_x005d
eml23__LengthUom_cm = _fesapi.eml23__LengthUom_cm
eml23__LengthUom_dam = _fesapi.eml23__LengthUom_dam
eml23__LengthUom_dm = _fesapi.eml23__LengthUom_dm
eml23__LengthUom_Em = _fesapi.eml23__LengthUom_Em
eml23__LengthUom_fathom = _fesapi.eml23__LengthUom_fathom
eml23__LengthUom_fm = _fesapi.eml23__LengthUom_fm
eml23__LengthUom_ft = _fesapi.eml23__LengthUom_ft
eml23__LengthUom_ft_x005bBnA_x005d = _fesapi.eml23__LengthUom_ft_x005bBnA_x005d
eml23__LengthUom_ft_x005bBnB_x005d = _fesapi.eml23__LengthUom_ft_x005bBnB_x005d
eml23__LengthUom_ft_x005bBr36_x005d = _fesapi.eml23__LengthUom_ft_x005bBr36_x005d
eml23__LengthUom_ft_x005bBr65_x005d = _fesapi.eml23__LengthUom_ft_x005bBr65_x005d
eml23__LengthUom_ft_x005bCla_x005d = _fesapi.eml23__LengthUom_ft_x005bCla_x005d
eml23__LengthUom_ft_x005bGC_x005d = _fesapi.eml23__LengthUom_ft_x005bGC_x005d
eml23__LengthUom_ft_x005bInd_x005d = _fesapi.eml23__LengthUom_ft_x005bInd_x005d
eml23__LengthUom_ft_x005bInd37_x005d = _fesapi.eml23__LengthUom_ft_x005bInd37_x005d
eml23__LengthUom_ft_x005bInd62_x005d = _fesapi.eml23__LengthUom_ft_x005bInd62_x005d
eml23__LengthUom_ft_x005bInd75_x005d = _fesapi.eml23__LengthUom_ft_x005bInd75_x005d
eml23__LengthUom_ft_x005bSe_x005d = _fesapi.eml23__LengthUom_ft_x005bSe_x005d
eml23__LengthUom_ft_x005bSeT_x005d = _fesapi.eml23__LengthUom_ft_x005bSeT_x005d
eml23__LengthUom_ft_x005bUS_x005d = _fesapi.eml23__LengthUom_ft_x005bUS_x005d
eml23__LengthUom_fur_x005bUS_x005d = _fesapi.eml23__LengthUom_fur_x005bUS_x005d
eml23__LengthUom_Gm = _fesapi.eml23__LengthUom_Gm
eml23__LengthUom_hm = _fesapi.eml23__LengthUom_hm
eml23__LengthUom__in = _fesapi.eml23__LengthUom__in
eml23__LengthUom_in_x005bUS_x005d = _fesapi.eml23__LengthUom_in_x005bUS_x005d
eml23__LengthUom_km = _fesapi.eml23__LengthUom_km
eml23__LengthUom_link = _fesapi.eml23__LengthUom_link
eml23__LengthUom_link_x005bBnA_x005d = _fesapi.eml23__LengthUom_link_x005bBnA_x005d
eml23__LengthUom_link_x005bBnB_x005d = _fesapi.eml23__LengthUom_link_x005bBnB_x005d
eml23__LengthUom_link_x005bCla_x005d = _fesapi.eml23__LengthUom_link_x005bCla_x005d
eml23__LengthUom_link_x005bSe_x005d = _fesapi.eml23__LengthUom_link_x005bSe_x005d
eml23__LengthUom_link_x005bSeT_x005d = _fesapi.eml23__LengthUom_link_x005bSeT_x005d
eml23__LengthUom_link_x005bUS_x005d = _fesapi.eml23__LengthUom_link_x005bUS_x005d
eml23__LengthUom_m_x005bGer_x005d = _fesapi.eml23__LengthUom_m_x005bGer_x005d
eml23__LengthUom_mi = _fesapi.eml23__LengthUom_mi
eml23__LengthUom_mi_x005bnaut_x005d = _fesapi.eml23__LengthUom_mi_x005bnaut_x005d
eml23__LengthUom_mi_x005bnautUK_x005d = _fesapi.eml23__LengthUom_mi_x005bnautUK_x005d
eml23__LengthUom_mi_x005bUS_x005d = _fesapi.eml23__LengthUom_mi_x005bUS_x005d
eml23__LengthUom_mil = _fesapi.eml23__LengthUom_mil
eml23__LengthUom_mm = _fesapi.eml23__LengthUom_mm
eml23__LengthUom_Mm = _fesapi.eml23__LengthUom_Mm
eml23__LengthUom_nm = _fesapi.eml23__LengthUom_nm
eml23__LengthUom_pm = _fesapi.eml23__LengthUom_pm
eml23__LengthUom_rod_x005bUS_x005d = _fesapi.eml23__LengthUom_rod_x005bUS_x005d
eml23__LengthUom_Tm = _fesapi.eml23__LengthUom_Tm
eml23__LengthUom_um = _fesapi.eml23__LengthUom_um
eml23__LengthUom_yd = _fesapi.eml23__LengthUom_yd
eml23__LengthUom_yd_x005bBnA_x005d = _fesapi.eml23__LengthUom_yd_x005bBnA_x005d
eml23__LengthUom_yd_x005bBnB_x005d = _fesapi.eml23__LengthUom_yd_x005bBnB_x005d
eml23__LengthUom_yd_x005bCla_x005d = _fesapi.eml23__LengthUom_yd_x005bCla_x005d
eml23__LengthUom_yd_x005bInd_x005d = _fesapi.eml23__LengthUom_yd_x005bInd_x005d
eml23__LengthUom_yd_x005bInd37_x005d = _fesapi.eml23__LengthUom_yd_x005bInd37_x005d
eml23__LengthUom_yd_x005bInd62_x005d = _fesapi.eml23__LengthUom_yd_x005bInd62_x005d
eml23__LengthUom_yd_x005bInd75_x005d = _fesapi.eml23__LengthUom_yd_x005bInd75_x005d
eml23__LengthUom_yd_x005bSe_x005d = _fesapi.eml23__LengthUom_yd_x005bSe_x005d
eml23__LengthUom_yd_x005bSeT_x005d = _fesapi.eml23__LengthUom_yd_x005bSeT_x005d
eml23__LengthUom_yd_x005bUS_x005d = _fesapi.eml23__LengthUom_yd_x005bUS_x005d
eml23__LinearAccelerationUom_cm_x002fs2 = _fesapi.eml23__LinearAccelerationUom_cm_x002fs2
eml23__LinearAccelerationUom_ft_x002fs2 = _fesapi.eml23__LinearAccelerationUom_ft_x002fs2
eml23__LinearAccelerationUom_Gal = _fesapi.eml23__LinearAccelerationUom_Gal
eml23__LinearAccelerationUom_gn = _fesapi.eml23__LinearAccelerationUom_gn
eml23__LinearAccelerationUom_in_x002fs2 = _fesapi.eml23__LinearAccelerationUom_in_x002fs2
eml23__LinearAccelerationUom_m_x002fs2 = _fesapi.eml23__LinearAccelerationUom_m_x002fs2
eml23__LinearAccelerationUom_mGal = _fesapi.eml23__LinearAccelerationUom_mGal
eml23__LinearAccelerationUom_mgn = _fesapi.eml23__LinearAccelerationUom_mgn
eml23__MagneticFluxDensityUom_T = _fesapi.eml23__MagneticFluxDensityUom_T
eml23__MagneticFluxDensityUom_cgauss = _fesapi.eml23__MagneticFluxDensityUom_cgauss
eml23__MagneticFluxDensityUom_cT = _fesapi.eml23__MagneticFluxDensityUom_cT
eml23__MagneticFluxDensityUom_dgauss = _fesapi.eml23__MagneticFluxDensityUom_dgauss
eml23__MagneticFluxDensityUom_dT = _fesapi.eml23__MagneticFluxDensityUom_dT
eml23__MagneticFluxDensityUom_Egauss = _fesapi.eml23__MagneticFluxDensityUom_Egauss
eml23__MagneticFluxDensityUom_ET = _fesapi.eml23__MagneticFluxDensityUom_ET
eml23__MagneticFluxDensityUom_fgauss = _fesapi.eml23__MagneticFluxDensityUom_fgauss
eml23__MagneticFluxDensityUom_fT = _fesapi.eml23__MagneticFluxDensityUom_fT
eml23__MagneticFluxDensityUom_gauss = _fesapi.eml23__MagneticFluxDensityUom_gauss
eml23__MagneticFluxDensityUom_Ggauss = _fesapi.eml23__MagneticFluxDensityUom_Ggauss
eml23__MagneticFluxDensityUom_GT = _fesapi.eml23__MagneticFluxDensityUom_GT
eml23__MagneticFluxDensityUom_kgauss = _fesapi.eml23__MagneticFluxDensityUom_kgauss
eml23__MagneticFluxDensityUom_kT = _fesapi.eml23__MagneticFluxDensityUom_kT
eml23__MagneticFluxDensityUom_mgauss = _fesapi.eml23__MagneticFluxDensityUom_mgauss
eml23__MagneticFluxDensityUom_Mgauss = _fesapi.eml23__MagneticFluxDensityUom_Mgauss
eml23__MagneticFluxDensityUom_mT = _fesapi.eml23__MagneticFluxDensityUom_mT
eml23__MagneticFluxDensityUom_ngauss = _fesapi.eml23__MagneticFluxDensityUom_ngauss
eml23__MagneticFluxDensityUom_nT = _fesapi.eml23__MagneticFluxDensityUom_nT
eml23__MagneticFluxDensityUom_pgauss = _fesapi.eml23__MagneticFluxDensityUom_pgauss
eml23__MagneticFluxDensityUom_pT = _fesapi.eml23__MagneticFluxDensityUom_pT
eml23__MagneticFluxDensityUom_Tgauss = _fesapi.eml23__MagneticFluxDensityUom_Tgauss
eml23__MagneticFluxDensityUom_TT = _fesapi.eml23__MagneticFluxDensityUom_TT
eml23__MagneticFluxDensityUom_ugauss = _fesapi.eml23__MagneticFluxDensityUom_ugauss
eml23__MagneticFluxDensityUom_uT = _fesapi.eml23__MagneticFluxDensityUom_uT
eml23__MassPerLengthUom_kg_x002em_x002fcm2 = _fesapi.eml23__MassPerLengthUom_kg_x002em_x002fcm2
eml23__MassPerLengthUom_kg_x002fm = _fesapi.eml23__MassPerLengthUom_kg_x002fm
eml23__MassPerLengthUom_klbm_x002fin = _fesapi.eml23__MassPerLengthUom_klbm_x002fin
eml23__MassPerLengthUom_lbm_x002fft = _fesapi.eml23__MassPerLengthUom_lbm_x002fft
eml23__MassPerLengthUom_Mg_x002fin = _fesapi.eml23__MassPerLengthUom_Mg_x002fin
eml23__QuantityClassKind_absorbed_x0020dose = _fesapi.eml23__QuantityClassKind_absorbed_x0020dose
eml23__QuantityClassKind_activity_x0020of_x0020radioactivity = _fesapi.eml23__QuantityClassKind_activity_x0020of_x0020radioactivity
eml23__QuantityClassKind_activity_x0020of_x0020radioactivity_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_activity_x0020of_x0020radioactivity_x0020per_x0020volume
eml23__QuantityClassKind_amount_x0020of_x0020substance = _fesapi.eml23__QuantityClassKind_amount_x0020of_x0020substance
eml23__QuantityClassKind_amount_x0020of_x0020substance_x0020per_x0020amount_x0020of_x0020substance = _fesapi.eml23__QuantityClassKind_amount_x0020of_x0020substance_x0020per_x0020amount_x0020of_x0020substance
eml23__QuantityClassKind_amount_x0020of_x0020substance_x0020per_x0020area = _fesapi.eml23__QuantityClassKind_amount_x0020of_x0020substance_x0020per_x0020area
eml23__QuantityClassKind_amount_x0020of_x0020substance_x0020per_x0020time = _fesapi.eml23__QuantityClassKind_amount_x0020of_x0020substance_x0020per_x0020time
eml23__QuantityClassKind_amount_x0020of_x0020substance_x0020per_x0020time_x0020per_x0020area = _fesapi.eml23__QuantityClassKind_amount_x0020of_x0020substance_x0020per_x0020time_x0020per_x0020area
eml23__QuantityClassKind_amount_x0020of_x0020substance_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_amount_x0020of_x0020substance_x0020per_x0020volume
eml23__QuantityClassKind_angle_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_angle_x0020per_x0020length
eml23__QuantityClassKind_angle_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_angle_x0020per_x0020volume
eml23__QuantityClassKind_angular_x0020acceleration = _fesapi.eml23__QuantityClassKind_angular_x0020acceleration
eml23__QuantityClassKind_angular_x0020velocity = _fesapi.eml23__QuantityClassKind_angular_x0020velocity
eml23__QuantityClassKind_api_x0020gamma_x0020ray = _fesapi.eml23__QuantityClassKind_api_x0020gamma_x0020ray
eml23__QuantityClassKind_api_x0020gravity = _fesapi.eml23__QuantityClassKind_api_x0020gravity
eml23__QuantityClassKind_api_x0020neutron = _fesapi.eml23__QuantityClassKind_api_x0020neutron
eml23__QuantityClassKind_area = _fesapi.eml23__QuantityClassKind_area
eml23__QuantityClassKind_area_x0020per_x0020amount_x0020of_x0020substance = _fesapi.eml23__QuantityClassKind_area_x0020per_x0020amount_x0020of_x0020substance
eml23__QuantityClassKind_area_x0020per_x0020area = _fesapi.eml23__QuantityClassKind_area_x0020per_x0020area
eml23__QuantityClassKind_area_x0020per_x0020count = _fesapi.eml23__QuantityClassKind_area_x0020per_x0020count
eml23__QuantityClassKind_area_x0020per_x0020mass = _fesapi.eml23__QuantityClassKind_area_x0020per_x0020mass
eml23__QuantityClassKind_area_x0020per_x0020time = _fesapi.eml23__QuantityClassKind_area_x0020per_x0020time
eml23__QuantityClassKind_area_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_area_x0020per_x0020volume
eml23__QuantityClassKind_attenuation_x0020per_x0020frequency_x0020interval = _fesapi.eml23__QuantityClassKind_attenuation_x0020per_x0020frequency_x0020interval
eml23__QuantityClassKind_capacitance = _fesapi.eml23__QuantityClassKind_capacitance
eml23__QuantityClassKind_cation_x0020exchange_x0020capacity = _fesapi.eml23__QuantityClassKind_cation_x0020exchange_x0020capacity
eml23__QuantityClassKind_data_x0020transfer_x0020speed = _fesapi.eml23__QuantityClassKind_data_x0020transfer_x0020speed
eml23__QuantityClassKind_diffusion_x0020coefficient = _fesapi.eml23__QuantityClassKind_diffusion_x0020coefficient
eml23__QuantityClassKind_diffusive_x0020time_x0020of_x0020flight = _fesapi.eml23__QuantityClassKind_diffusive_x0020time_x0020of_x0020flight
eml23__QuantityClassKind_digital_x0020storage = _fesapi.eml23__QuantityClassKind_digital_x0020storage
eml23__QuantityClassKind_dimensionless = _fesapi.eml23__QuantityClassKind_dimensionless
eml23__QuantityClassKind_dipole_x0020moment = _fesapi.eml23__QuantityClassKind_dipole_x0020moment
eml23__QuantityClassKind_dose_x0020equivalent = _fesapi.eml23__QuantityClassKind_dose_x0020equivalent
eml23__QuantityClassKind_dynamic_x0020viscosity = _fesapi.eml23__QuantityClassKind_dynamic_x0020viscosity
eml23__QuantityClassKind_electric_x0020charge = _fesapi.eml23__QuantityClassKind_electric_x0020charge
eml23__QuantityClassKind_electric_x0020charge_x0020per_x0020area = _fesapi.eml23__QuantityClassKind_electric_x0020charge_x0020per_x0020area
eml23__QuantityClassKind_electric_x0020charge_x0020per_x0020mass = _fesapi.eml23__QuantityClassKind_electric_x0020charge_x0020per_x0020mass
eml23__QuantityClassKind_electric_x0020charge_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_electric_x0020charge_x0020per_x0020volume
eml23__QuantityClassKind_electric_x0020conductance = _fesapi.eml23__QuantityClassKind_electric_x0020conductance
eml23__QuantityClassKind_electric_x0020conductivity = _fesapi.eml23__QuantityClassKind_electric_x0020conductivity
eml23__QuantityClassKind_electric_x0020current = _fesapi.eml23__QuantityClassKind_electric_x0020current
eml23__QuantityClassKind_electric_x0020current_x0020density = _fesapi.eml23__QuantityClassKind_electric_x0020current_x0020density
eml23__QuantityClassKind_electric_x0020field_x0020strength = _fesapi.eml23__QuantityClassKind_electric_x0020field_x0020strength
eml23__QuantityClassKind_electric_x0020potential_x0020difference = _fesapi.eml23__QuantityClassKind_electric_x0020potential_x0020difference
eml23__QuantityClassKind_electric_x0020resistance = _fesapi.eml23__QuantityClassKind_electric_x0020resistance
eml23__QuantityClassKind_electric_x0020resistance_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_electric_x0020resistance_x0020per_x0020length
eml23__QuantityClassKind_electrical_x0020resistivity = _fesapi.eml23__QuantityClassKind_electrical_x0020resistivity
eml23__QuantityClassKind_electromagnetic_x0020moment = _fesapi.eml23__QuantityClassKind_electromagnetic_x0020moment
eml23__QuantityClassKind_energy = _fesapi.eml23__QuantityClassKind_energy
eml23__QuantityClassKind_energy_x0020length_x0020per_x0020area = _fesapi.eml23__QuantityClassKind_energy_x0020length_x0020per_x0020area
eml23__QuantityClassKind_energy_x0020length_x0020per_x0020time_x0020area_x0020temperature = _fesapi.eml23__QuantityClassKind_energy_x0020length_x0020per_x0020time_x0020area_x0020temperature
eml23__QuantityClassKind_energy_x0020per_x0020area = _fesapi.eml23__QuantityClassKind_energy_x0020per_x0020area
eml23__QuantityClassKind_energy_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_energy_x0020per_x0020length
eml23__QuantityClassKind_energy_x0020per_x0020mass = _fesapi.eml23__QuantityClassKind_energy_x0020per_x0020mass
eml23__QuantityClassKind_energy_x0020per_x0020mass_x0020per_x0020time = _fesapi.eml23__QuantityClassKind_energy_x0020per_x0020mass_x0020per_x0020time
eml23__QuantityClassKind_energy_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_energy_x0020per_x0020volume
eml23__QuantityClassKind_force = _fesapi.eml23__QuantityClassKind_force
eml23__QuantityClassKind_force_x0020area = _fesapi.eml23__QuantityClassKind_force_x0020area
eml23__QuantityClassKind_force_x0020length_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_force_x0020length_x0020per_x0020length
eml23__QuantityClassKind_force_x0020per_x0020force = _fesapi.eml23__QuantityClassKind_force_x0020per_x0020force
eml23__QuantityClassKind_force_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_force_x0020per_x0020length
eml23__QuantityClassKind_force_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_force_x0020per_x0020volume
eml23__QuantityClassKind_frequency = _fesapi.eml23__QuantityClassKind_frequency
eml23__QuantityClassKind_frequency_x0020interval = _fesapi.eml23__QuantityClassKind_frequency_x0020interval
eml23__QuantityClassKind_heat_x0020capacity = _fesapi.eml23__QuantityClassKind_heat_x0020capacity
eml23__QuantityClassKind_heat_x0020flow_x0020rate = _fesapi.eml23__QuantityClassKind_heat_x0020flow_x0020rate
eml23__QuantityClassKind_heat_x0020transfer_x0020coefficient = _fesapi.eml23__QuantityClassKind_heat_x0020transfer_x0020coefficient
eml23__QuantityClassKind_illuminance = _fesapi.eml23__QuantityClassKind_illuminance
eml23__QuantityClassKind_inductance = _fesapi.eml23__QuantityClassKind_inductance
eml23__QuantityClassKind_isothermal_x0020compressibility = _fesapi.eml23__QuantityClassKind_isothermal_x0020compressibility
eml23__QuantityClassKind_kinematic_x0020viscosity = _fesapi.eml23__QuantityClassKind_kinematic_x0020viscosity
eml23__QuantityClassKind_length = _fesapi.eml23__QuantityClassKind_length
eml23__QuantityClassKind_length_x0020per_x0020angle = _fesapi.eml23__QuantityClassKind_length_x0020per_x0020angle
eml23__QuantityClassKind_length_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_length_x0020per_x0020length
eml23__QuantityClassKind_length_x0020per_x0020mass = _fesapi.eml23__QuantityClassKind_length_x0020per_x0020mass
eml23__QuantityClassKind_length_x0020per_x0020pressure = _fesapi.eml23__QuantityClassKind_length_x0020per_x0020pressure
eml23__QuantityClassKind_length_x0020per_x0020temperature = _fesapi.eml23__QuantityClassKind_length_x0020per_x0020temperature
eml23__QuantityClassKind_length_x0020per_x0020time = _fesapi.eml23__QuantityClassKind_length_x0020per_x0020time
eml23__QuantityClassKind_length_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_length_x0020per_x0020volume
eml23__QuantityClassKind_light_x0020exposure = _fesapi.eml23__QuantityClassKind_light_x0020exposure
eml23__QuantityClassKind_linear_x0020acceleration = _fesapi.eml23__QuantityClassKind_linear_x0020acceleration
eml23__QuantityClassKind_linear_x0020thermal_x0020expansion = _fesapi.eml23__QuantityClassKind_linear_x0020thermal_x0020expansion
eml23__QuantityClassKind_logarithmic_x0020power_x0020ratio = _fesapi.eml23__QuantityClassKind_logarithmic_x0020power_x0020ratio
eml23__QuantityClassKind_logarithmic_x0020power_x0020ratio_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_logarithmic_x0020power_x0020ratio_x0020per_x0020length
eml23__QuantityClassKind_luminance = _fesapi.eml23__QuantityClassKind_luminance
eml23__QuantityClassKind_luminous_x0020efficacy = _fesapi.eml23__QuantityClassKind_luminous_x0020efficacy
eml23__QuantityClassKind_luminous_x0020flux = _fesapi.eml23__QuantityClassKind_luminous_x0020flux
eml23__QuantityClassKind_luminous_x0020intensity = _fesapi.eml23__QuantityClassKind_luminous_x0020intensity
eml23__QuantityClassKind_magnetic_x0020dipole_x0020moment = _fesapi.eml23__QuantityClassKind_magnetic_x0020dipole_x0020moment
eml23__QuantityClassKind_magnetic_x0020field_x0020strength = _fesapi.eml23__QuantityClassKind_magnetic_x0020field_x0020strength
eml23__QuantityClassKind_magnetic_x0020flux = _fesapi.eml23__QuantityClassKind_magnetic_x0020flux
eml23__QuantityClassKind_magnetic_x0020flux_x0020density = _fesapi.eml23__QuantityClassKind_magnetic_x0020flux_x0020density
eml23__QuantityClassKind_magnetic_x0020flux_x0020density_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_magnetic_x0020flux_x0020density_x0020per_x0020length
eml23__QuantityClassKind_magnetic_x0020permeability = _fesapi.eml23__QuantityClassKind_magnetic_x0020permeability
eml23__QuantityClassKind_magnetic_x0020vector_x0020potential = _fesapi.eml23__QuantityClassKind_magnetic_x0020vector_x0020potential
eml23__QuantityClassKind_mass = _fesapi.eml23__QuantityClassKind_mass
eml23__QuantityClassKind_mass_x0020length = _fesapi.eml23__QuantityClassKind_mass_x0020length
eml23__QuantityClassKind_mass_x0020per_x0020area = _fesapi.eml23__QuantityClassKind_mass_x0020per_x0020area
eml23__QuantityClassKind_mass_x0020per_x0020energy = _fesapi.eml23__QuantityClassKind_mass_x0020per_x0020energy
eml23__QuantityClassKind_mass_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_mass_x0020per_x0020length
eml23__QuantityClassKind_mass_x0020per_x0020mass = _fesapi.eml23__QuantityClassKind_mass_x0020per_x0020mass
eml23__QuantityClassKind_mass_x0020per_x0020time = _fesapi.eml23__QuantityClassKind_mass_x0020per_x0020time
eml23__QuantityClassKind_mass_x0020per_x0020time_x0020per_x0020area = _fesapi.eml23__QuantityClassKind_mass_x0020per_x0020time_x0020per_x0020area
eml23__QuantityClassKind_mass_x0020per_x0020time_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_mass_x0020per_x0020time_x0020per_x0020length
eml23__QuantityClassKind_mass_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_mass_x0020per_x0020volume
eml23__QuantityClassKind_mass_x0020per_x0020volume_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_mass_x0020per_x0020volume_x0020per_x0020length
eml23__QuantityClassKind_mass_x0020per_x0020volume_x0020per_x0020pressure = _fesapi.eml23__QuantityClassKind_mass_x0020per_x0020volume_x0020per_x0020pressure
eml23__QuantityClassKind_mass_x0020per_x0020volume_x0020per_x0020temperature = _fesapi.eml23__QuantityClassKind_mass_x0020per_x0020volume_x0020per_x0020temperature
eml23__QuantityClassKind_mobility = _fesapi.eml23__QuantityClassKind_mobility
eml23__QuantityClassKind_molar_x0020energy = _fesapi.eml23__QuantityClassKind_molar_x0020energy
eml23__QuantityClassKind_molar_x0020heat_x0020capacity = _fesapi.eml23__QuantityClassKind_molar_x0020heat_x0020capacity
eml23__QuantityClassKind_molar_x0020volume = _fesapi.eml23__QuantityClassKind_molar_x0020volume
eml23__QuantityClassKind_molecular_x0020weight = _fesapi.eml23__QuantityClassKind_molecular_x0020weight
eml23__QuantityClassKind_moment_x0020of_x0020force = _fesapi.eml23__QuantityClassKind_moment_x0020of_x0020force
eml23__QuantityClassKind_moment_x0020of_x0020inertia = _fesapi.eml23__QuantityClassKind_moment_x0020of_x0020inertia
eml23__QuantityClassKind_momentum = _fesapi.eml23__QuantityClassKind_momentum
eml23__QuantityClassKind_normalized_x0020power = _fesapi.eml23__QuantityClassKind_normalized_x0020power
eml23__QuantityClassKind_pressure_x0020per_x0020flowrate = _fesapi.eml23__QuantityClassKind_pressure_x0020per_x0020flowrate
eml23__QuantityClassKind_pressure_x0020per_x0020flowrate_x0020squared = _fesapi.eml23__QuantityClassKind_pressure_x0020per_x0020flowrate_x0020squared
eml23__QuantityClassKind_permeability_x0020length = _fesapi.eml23__QuantityClassKind_permeability_x0020length
eml23__QuantityClassKind_permeability_x0020rock = _fesapi.eml23__QuantityClassKind_permeability_x0020rock
eml23__QuantityClassKind_permittivity = _fesapi.eml23__QuantityClassKind_permittivity
eml23__QuantityClassKind_plane_x0020angle = _fesapi.eml23__QuantityClassKind_plane_x0020angle
eml23__QuantityClassKind_potential_x0020difference_x0020per_x0020power_x0020drop = _fesapi.eml23__QuantityClassKind_potential_x0020difference_x0020per_x0020power_x0020drop
eml23__QuantityClassKind_power = _fesapi.eml23__QuantityClassKind_power
eml23__QuantityClassKind_power_x0020per_x0020area = _fesapi.eml23__QuantityClassKind_power_x0020per_x0020area
eml23__QuantityClassKind_power_x0020per_x0020power = _fesapi.eml23__QuantityClassKind_power_x0020per_x0020power
eml23__QuantityClassKind_power_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_power_x0020per_x0020volume
eml23__QuantityClassKind_pressure = _fesapi.eml23__QuantityClassKind_pressure
eml23__QuantityClassKind_pressure_x0020per_x0020pressure = _fesapi.eml23__QuantityClassKind_pressure_x0020per_x0020pressure
eml23__QuantityClassKind_pressure_x0020per_x0020time = _fesapi.eml23__QuantityClassKind_pressure_x0020per_x0020time
eml23__QuantityClassKind_pressure_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_pressure_x0020per_x0020volume
eml23__QuantityClassKind_pressure_x0020squared = _fesapi.eml23__QuantityClassKind_pressure_x0020squared
eml23__QuantityClassKind_pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area = _fesapi.eml23__QuantityClassKind_pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area
eml23__QuantityClassKind_pressure_x0020time_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_pressure_x0020time_x0020per_x0020volume
eml23__QuantityClassKind_quantity_x0020of_x0020light = _fesapi.eml23__QuantityClassKind_quantity_x0020of_x0020light
eml23__QuantityClassKind_radiance = _fesapi.eml23__QuantityClassKind_radiance
eml23__QuantityClassKind_radiant_x0020intensity = _fesapi.eml23__QuantityClassKind_radiant_x0020intensity
eml23__QuantityClassKind_reciprocal_x0020area = _fesapi.eml23__QuantityClassKind_reciprocal_x0020area
eml23__QuantityClassKind_reciprocal_x0020electric_x0020potential_x0020difference = _fesapi.eml23__QuantityClassKind_reciprocal_x0020electric_x0020potential_x0020difference
eml23__QuantityClassKind_reciprocal_x0020force = _fesapi.eml23__QuantityClassKind_reciprocal_x0020force
eml23__QuantityClassKind_reciprocal_x0020length = _fesapi.eml23__QuantityClassKind_reciprocal_x0020length
eml23__QuantityClassKind_reciprocal_x0020mass = _fesapi.eml23__QuantityClassKind_reciprocal_x0020mass
eml23__QuantityClassKind_reciprocal_x0020mass_x0020time = _fesapi.eml23__QuantityClassKind_reciprocal_x0020mass_x0020time
eml23__QuantityClassKind_reciprocal_x0020pressure = _fesapi.eml23__QuantityClassKind_reciprocal_x0020pressure
eml23__QuantityClassKind_reciprocal_x0020time = _fesapi.eml23__QuantityClassKind_reciprocal_x0020time
eml23__QuantityClassKind_reciprocal_x0020volume = _fesapi.eml23__QuantityClassKind_reciprocal_x0020volume
eml23__QuantityClassKind_reluctance = _fesapi.eml23__QuantityClassKind_reluctance
eml23__QuantityClassKind_second_x0020moment_x0020of_x0020area = _fesapi.eml23__QuantityClassKind_second_x0020moment_x0020of_x0020area
eml23__QuantityClassKind_signaling_x0020event_x0020per_x0020time = _fesapi.eml23__QuantityClassKind_signaling_x0020event_x0020per_x0020time
eml23__QuantityClassKind_solid_x0020angle = _fesapi.eml23__QuantityClassKind_solid_x0020angle
eml23__QuantityClassKind_specific_x0020heat_x0020capacity = _fesapi.eml23__QuantityClassKind_specific_x0020heat_x0020capacity
eml23__QuantityClassKind_temperature_x0020interval = _fesapi.eml23__QuantityClassKind_temperature_x0020interval
eml23__QuantityClassKind_temperature_x0020interval_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_temperature_x0020interval_x0020per_x0020length
eml23__QuantityClassKind_temperature_x0020interval_x0020per_x0020pressure = _fesapi.eml23__QuantityClassKind_temperature_x0020interval_x0020per_x0020pressure
eml23__QuantityClassKind_temperature_x0020interval_x0020per_x0020time = _fesapi.eml23__QuantityClassKind_temperature_x0020interval_x0020per_x0020time
eml23__QuantityClassKind_thermal_x0020conductance = _fesapi.eml23__QuantityClassKind_thermal_x0020conductance
eml23__QuantityClassKind_thermal_x0020conductivity = _fesapi.eml23__QuantityClassKind_thermal_x0020conductivity
eml23__QuantityClassKind_thermal_x0020diffusivity = _fesapi.eml23__QuantityClassKind_thermal_x0020diffusivity
eml23__QuantityClassKind_thermal_x0020insulance = _fesapi.eml23__QuantityClassKind_thermal_x0020insulance
eml23__QuantityClassKind_thermal_x0020resistance = _fesapi.eml23__QuantityClassKind_thermal_x0020resistance
eml23__QuantityClassKind_thermodynamic_x0020temperature = _fesapi.eml23__QuantityClassKind_thermodynamic_x0020temperature
eml23__QuantityClassKind_thermodynamic_x0020temperature_x0020per_x0020thermodynamic_x0020temperature = _fesapi.eml23__QuantityClassKind_thermodynamic_x0020temperature_x0020per_x0020thermodynamic_x0020temperature
eml23__QuantityClassKind_time = _fesapi.eml23__QuantityClassKind_time
eml23__QuantityClassKind_time_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_time_x0020per_x0020length
eml23__QuantityClassKind_time_x0020per_x0020mass = _fesapi.eml23__QuantityClassKind_time_x0020per_x0020mass
eml23__QuantityClassKind_time_x0020per_x0020time = _fesapi.eml23__QuantityClassKind_time_x0020per_x0020time
eml23__QuantityClassKind_time_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_time_x0020per_x0020volume
eml23__QuantityClassKind_vertical_x0020coordinate = _fesapi.eml23__QuantityClassKind_vertical_x0020coordinate
eml23__QuantityClassKind_volume = _fesapi.eml23__QuantityClassKind_volume
eml23__QuantityClassKind_volume_x0020flow_x0020rate_x0020per_x0020volume_x0020flow_x0020rate = _fesapi.eml23__QuantityClassKind_volume_x0020flow_x0020rate_x0020per_x0020volume_x0020flow_x0020rate
eml23__QuantityClassKind_volume_x0020per_x0020area = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020area
eml23__QuantityClassKind_volume_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020length
eml23__QuantityClassKind_volume_x0020per_x0020mass = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020mass
eml23__QuantityClassKind_volume_x0020per_x0020pressure = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020pressure
eml23__QuantityClassKind_volume_x0020per_x0020rotation = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020rotation
eml23__QuantityClassKind_volume_x0020per_x0020time = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020time
eml23__QuantityClassKind_volume_x0020per_x0020time_x0020length = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020time_x0020length
eml23__QuantityClassKind_volume_x0020per_x0020time_x0020per_x0020area = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020time_x0020per_x0020area
eml23__QuantityClassKind_volume_x0020per_x0020time_x0020per_x0020length = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020time_x0020per_x0020length
eml23__QuantityClassKind_volume_x0020per_x0020time_x0020per_x0020pressure = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020time_x0020per_x0020pressure
eml23__QuantityClassKind_volume_x0020per_x0020time_x0020per_x0020pressure_x0020length = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020time_x0020per_x0020pressure_x0020length
eml23__QuantityClassKind_volume_x0020per_x0020time_x0020per_x0020time = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020time_x0020per_x0020time
eml23__QuantityClassKind_volume_x0020per_x0020time_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020time_x0020per_x0020volume
eml23__QuantityClassKind_volume_x0020per_x0020volume = _fesapi.eml23__QuantityClassKind_volume_x0020per_x0020volume
eml23__QuantityClassKind_volumetric_x0020heat_x0020transfer_x0020coefficient = _fesapi.eml23__QuantityClassKind_volumetric_x0020heat_x0020transfer_x0020coefficient
eml23__QuantityClassKind_volumetric_x0020thermal_x0020expansion = _fesapi.eml23__QuantityClassKind_volumetric_x0020thermal_x0020expansion
eml23__QuantityClassKind_unitless = _fesapi.eml23__QuantityClassKind_unitless
eml23__QuantityClassKind_not_x0020a_x0020measure = _fesapi.eml23__QuantityClassKind_not_x0020a_x0020measure
eml23__PlaneAngleUom__0_x002e001_x0020seca = _fesapi.eml23__PlaneAngleUom__0_x002e001_x0020seca
eml23__PlaneAngleUom_ccgr = _fesapi.eml23__PlaneAngleUom_ccgr
eml23__PlaneAngleUom_cgr = _fesapi.eml23__PlaneAngleUom_cgr
eml23__PlaneAngleUom_dega = _fesapi.eml23__PlaneAngleUom_dega
eml23__PlaneAngleUom_gon = _fesapi.eml23__PlaneAngleUom_gon
eml23__PlaneAngleUom_krad = _fesapi.eml23__PlaneAngleUom_krad
eml23__PlaneAngleUom_mila = _fesapi.eml23__PlaneAngleUom_mila
eml23__PlaneAngleUom_mina = _fesapi.eml23__PlaneAngleUom_mina
eml23__PlaneAngleUom_Mrad = _fesapi.eml23__PlaneAngleUom_Mrad
eml23__PlaneAngleUom_mrad = _fesapi.eml23__PlaneAngleUom_mrad
eml23__PlaneAngleUom_rad = _fesapi.eml23__PlaneAngleUom_rad
eml23__PlaneAngleUom_rev = _fesapi.eml23__PlaneAngleUom_rev
eml23__PlaneAngleUom_seca = _fesapi.eml23__PlaneAngleUom_seca
eml23__PlaneAngleUom_urad = _fesapi.eml23__PlaneAngleUom_urad
eml23__UnitOfMeasure_A = _fesapi.eml23__UnitOfMeasure_A
eml23__UnitOfMeasure_a = _fesapi.eml23__UnitOfMeasure_a
eml23__UnitOfMeasure_B = _fesapi.eml23__UnitOfMeasure_B
eml23__UnitOfMeasure_b = _fesapi.eml23__UnitOfMeasure_b
eml23__UnitOfMeasure_C = _fesapi.eml23__UnitOfMeasure_C
eml23__UnitOfMeasure_d = _fesapi.eml23__UnitOfMeasure_d
eml23__UnitOfMeasure_D = _fesapi.eml23__UnitOfMeasure_D
eml23__UnitOfMeasure_F = _fesapi.eml23__UnitOfMeasure_F
eml23__UnitOfMeasure_g = _fesapi.eml23__UnitOfMeasure_g
eml23__UnitOfMeasure_H = _fesapi.eml23__UnitOfMeasure_H
eml23__UnitOfMeasure_h = _fesapi.eml23__UnitOfMeasure_h
eml23__UnitOfMeasure_J = _fesapi.eml23__UnitOfMeasure_J
eml23__UnitOfMeasure_K = _fesapi.eml23__UnitOfMeasure_K
eml23__UnitOfMeasure_L = _fesapi.eml23__UnitOfMeasure_L
eml23__UnitOfMeasure_m = _fesapi.eml23__UnitOfMeasure_m
eml23__UnitOfMeasure_N = _fesapi.eml23__UnitOfMeasure_N
eml23__UnitOfMeasure_O = _fesapi.eml23__UnitOfMeasure_O
eml23__UnitOfMeasure_P = _fesapi.eml23__UnitOfMeasure_P
eml23__UnitOfMeasure_S = _fesapi.eml23__UnitOfMeasure_S
eml23__UnitOfMeasure_s = _fesapi.eml23__UnitOfMeasure_s
eml23__UnitOfMeasure_t = _fesapi.eml23__UnitOfMeasure_t
eml23__UnitOfMeasure_T = _fesapi.eml23__UnitOfMeasure_T
eml23__UnitOfMeasure_V = _fesapi.eml23__UnitOfMeasure_V
eml23__UnitOfMeasure_W = _fesapi.eml23__UnitOfMeasure_W
eml23__UnitOfMeasure__x0025 = _fesapi.eml23__UnitOfMeasure__x0025
eml23__UnitOfMeasure__x0025_x005barea_x005d = _fesapi.eml23__UnitOfMeasure__x0025_x005barea_x005d
eml23__UnitOfMeasure__x0025_x005bmass_x005d = _fesapi.eml23__UnitOfMeasure__x0025_x005bmass_x005d
eml23__UnitOfMeasure__x0025_x005bmolar_x005d = _fesapi.eml23__UnitOfMeasure__x0025_x005bmolar_x005d
eml23__UnitOfMeasure__x0025_x005bvol_x005d = _fesapi.eml23__UnitOfMeasure__x0025_x005bvol_x005d
eml23__UnitOfMeasure__x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = _fesapi.eml23__UnitOfMeasure__x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029
eml23__UnitOfMeasure__x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029 = _fesapi.eml23__UnitOfMeasure__x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029
eml23__UnitOfMeasure__x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029 = _fesapi.eml23__UnitOfMeasure__x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029
eml23__UnitOfMeasure__0_x002e001_x0020bbl_x002fft3 = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020bbl_x002fft3
eml23__UnitOfMeasure__0_x002e001_x0020bbl_x002fm3 = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020bbl_x002fm3
eml23__UnitOfMeasure__0_x002e001_x0020d_x002fft3 = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020d_x002fft3
eml23__UnitOfMeasure__0_x002e001_x0020gal_x005bUK_x005d_x002fbbl = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020gal_x005bUK_x005d_x002fbbl
eml23__UnitOfMeasure__0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d
eml23__UnitOfMeasure__0_x002e001_x0020gal_x005bUS_x005d_x002fbbl = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020gal_x005bUS_x005d_x002fbbl
eml23__UnitOfMeasure__0_x002e001_x0020gal_x005bUS_x005d_x002fft3 = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020gal_x005bUS_x005d_x002fft3
eml23__UnitOfMeasure__0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure__0_x002e001_x0020h_x002fft = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020h_x002fft
eml23__UnitOfMeasure__0_x002e001_x0020kPa2_x002fcP = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020kPa2_x002fcP
eml23__UnitOfMeasure__0_x002e001_x0020lbm_x002fbbl = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020lbm_x002fbbl
eml23__UnitOfMeasure__0_x002e001_x0020lbm_x002fgal_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020lbm_x002fgal_x005bUK_x005d
eml23__UnitOfMeasure__0_x002e001_x0020lbm_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020lbm_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure__0_x002e001_x0020psi_x002fft = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020psi_x002fft
eml23__UnitOfMeasure__0_x002e001_x0020pt_x005bUK_x005d_x002fbbl = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020pt_x005bUK_x005d_x002fbbl
eml23__UnitOfMeasure__0_x002e001_x0020seca = _fesapi.eml23__UnitOfMeasure__0_x002e001_x0020seca
eml23__UnitOfMeasure__0_x002e01_x0020bbl_x002fbbl = _fesapi.eml23__UnitOfMeasure__0_x002e01_x0020bbl_x002fbbl
eml23__UnitOfMeasure__0_x002e01_x0020dega_x002fft = _fesapi.eml23__UnitOfMeasure__0_x002e01_x0020dega_x002fft
eml23__UnitOfMeasure__0_x002e01_x0020degF_x002fft = _fesapi.eml23__UnitOfMeasure__0_x002e01_x0020degF_x002fft
eml23__UnitOfMeasure__0_x002e01_x0020dm3_x002fkm = _fesapi.eml23__UnitOfMeasure__0_x002e01_x0020dm3_x002fkm
eml23__UnitOfMeasure__0_x002e01_x0020ft_x002fft = _fesapi.eml23__UnitOfMeasure__0_x002e01_x0020ft_x002fft
eml23__UnitOfMeasure__0_x002e01_x0020grain_x002fft3 = _fesapi.eml23__UnitOfMeasure__0_x002e01_x0020grain_x002fft3
eml23__UnitOfMeasure__0_x002e01_x0020L_x002fkg = _fesapi.eml23__UnitOfMeasure__0_x002e01_x0020L_x002fkg
eml23__UnitOfMeasure__0_x002e01_x0020L_x002fkm = _fesapi.eml23__UnitOfMeasure__0_x002e01_x0020L_x002fkm
eml23__UnitOfMeasure__0_x002e01_x0020lbf_x002fft = _fesapi.eml23__UnitOfMeasure__0_x002e01_x0020lbf_x002fft
eml23__UnitOfMeasure__0_x002e01_x0020lbf_x002fft2 = _fesapi.eml23__UnitOfMeasure__0_x002e01_x0020lbf_x002fft2
eml23__UnitOfMeasure__0_x002e01_x0020lbm_x002fft2 = _fesapi.eml23__UnitOfMeasure__0_x002e01_x0020lbm_x002fft2
eml23__UnitOfMeasure__0_x002e01_x0020psi_x002fft = _fesapi.eml23__UnitOfMeasure__0_x002e01_x0020psi_x002fft
eml23__UnitOfMeasure__0_x002e1_x0020ft = _fesapi.eml23__UnitOfMeasure__0_x002e1_x0020ft
eml23__UnitOfMeasure__0_x002e1_x0020ft_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure__0_x002e1_x0020ft_x005bUS_x005d
eml23__UnitOfMeasure__0_x002e1_x0020gal_x005bUS_x005d_x002fbbl = _fesapi.eml23__UnitOfMeasure__0_x002e1_x0020gal_x005bUS_x005d_x002fbbl
eml23__UnitOfMeasure__0_x002e1_x0020in = _fesapi.eml23__UnitOfMeasure__0_x002e1_x0020in
eml23__UnitOfMeasure__0_x002e1_x0020L_x002fbbl = _fesapi.eml23__UnitOfMeasure__0_x002e1_x0020L_x002fbbl
eml23__UnitOfMeasure__0_x002e1_x0020lbm_x002fbbl = _fesapi.eml23__UnitOfMeasure__0_x002e1_x0020lbm_x002fbbl
eml23__UnitOfMeasure__0_x002e1_x0020pt_x005bUS_x005d_x002fbbl = _fesapi.eml23__UnitOfMeasure__0_x002e1_x0020pt_x005bUS_x005d_x002fbbl
eml23__UnitOfMeasure__0_x002e1_x0020yd = _fesapi.eml23__UnitOfMeasure__0_x002e1_x0020yd
eml23__UnitOfMeasure__1_x002f_x0028kg_x002es_x0029 = _fesapi.eml23__UnitOfMeasure__1_x002f_x0028kg_x002es_x0029
eml23__UnitOfMeasure__1_x002f16_x0020in = _fesapi.eml23__UnitOfMeasure__1_x002f16_x0020in
eml23__UnitOfMeasure__1_x002f2_x0020ft = _fesapi.eml23__UnitOfMeasure__1_x002f2_x0020ft
eml23__UnitOfMeasure__1_x002f2_x0020ms = _fesapi.eml23__UnitOfMeasure__1_x002f2_x0020ms
eml23__UnitOfMeasure__1_x002f30_x0020cm3_x002fmin = _fesapi.eml23__UnitOfMeasure__1_x002f30_x0020cm3_x002fmin
eml23__UnitOfMeasure__1_x002f30_x0020dega_x002fft = _fesapi.eml23__UnitOfMeasure__1_x002f30_x0020dega_x002fft
eml23__UnitOfMeasure__1_x002f30_x0020dega_x002fm = _fesapi.eml23__UnitOfMeasure__1_x002f30_x0020dega_x002fm
eml23__UnitOfMeasure__1_x002f30_x0020lbf_x002fm = _fesapi.eml23__UnitOfMeasure__1_x002f30_x0020lbf_x002fm
eml23__UnitOfMeasure__1_x002f30_x0020m_x002fm = _fesapi.eml23__UnitOfMeasure__1_x002f30_x0020m_x002fm
eml23__UnitOfMeasure__1_x002f30_x0020N_x002fm = _fesapi.eml23__UnitOfMeasure__1_x002f30_x0020N_x002fm
eml23__UnitOfMeasure__1_x002f32_x0020in = _fesapi.eml23__UnitOfMeasure__1_x002f32_x0020in
eml23__UnitOfMeasure__1_x002f64_x0020in = _fesapi.eml23__UnitOfMeasure__1_x002f64_x0020in
eml23__UnitOfMeasure__1_x002fa = _fesapi.eml23__UnitOfMeasure__1_x002fa
eml23__UnitOfMeasure__1_x002fangstrom = _fesapi.eml23__UnitOfMeasure__1_x002fangstrom
eml23__UnitOfMeasure__1_x002fbar = _fesapi.eml23__UnitOfMeasure__1_x002fbar
eml23__UnitOfMeasure__1_x002fbbl = _fesapi.eml23__UnitOfMeasure__1_x002fbbl
eml23__UnitOfMeasure__1_x002fcm = _fesapi.eml23__UnitOfMeasure__1_x002fcm
eml23__UnitOfMeasure__1_x002fd = _fesapi.eml23__UnitOfMeasure__1_x002fd
eml23__UnitOfMeasure__1_x002fdegC = _fesapi.eml23__UnitOfMeasure__1_x002fdegC
eml23__UnitOfMeasure__1_x002fdegF = _fesapi.eml23__UnitOfMeasure__1_x002fdegF
eml23__UnitOfMeasure__1_x002fdegR = _fesapi.eml23__UnitOfMeasure__1_x002fdegR
eml23__UnitOfMeasure__1_x002fft = _fesapi.eml23__UnitOfMeasure__1_x002fft
eml23__UnitOfMeasure__1_x002fft2 = _fesapi.eml23__UnitOfMeasure__1_x002fft2
eml23__UnitOfMeasure__1_x002fft3 = _fesapi.eml23__UnitOfMeasure__1_x002fft3
eml23__UnitOfMeasure__1_x002fg = _fesapi.eml23__UnitOfMeasure__1_x002fg
eml23__UnitOfMeasure__1_x002fgal_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure__1_x002fgal_x005bUK_x005d
eml23__UnitOfMeasure__1_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure__1_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure__1_x002fH = _fesapi.eml23__UnitOfMeasure__1_x002fH
eml23__UnitOfMeasure__1_x002fh = _fesapi.eml23__UnitOfMeasure__1_x002fh
eml23__UnitOfMeasure__1_x002fin = _fesapi.eml23__UnitOfMeasure__1_x002fin
eml23__UnitOfMeasure__1_x002fK = _fesapi.eml23__UnitOfMeasure__1_x002fK
eml23__UnitOfMeasure__1_x002fkg = _fesapi.eml23__UnitOfMeasure__1_x002fkg
eml23__UnitOfMeasure__1_x002fkm2 = _fesapi.eml23__UnitOfMeasure__1_x002fkm2
eml23__UnitOfMeasure__1_x002fkPa = _fesapi.eml23__UnitOfMeasure__1_x002fkPa
eml23__UnitOfMeasure__1_x002fL = _fesapi.eml23__UnitOfMeasure__1_x002fL
eml23__UnitOfMeasure__1_x002flbf = _fesapi.eml23__UnitOfMeasure__1_x002flbf
eml23__UnitOfMeasure__1_x002flbm = _fesapi.eml23__UnitOfMeasure__1_x002flbm
eml23__UnitOfMeasure__1_x002fm = _fesapi.eml23__UnitOfMeasure__1_x002fm
eml23__UnitOfMeasure__1_x002fm2 = _fesapi.eml23__UnitOfMeasure__1_x002fm2
eml23__UnitOfMeasure__1_x002fm3 = _fesapi.eml23__UnitOfMeasure__1_x002fm3
eml23__UnitOfMeasure__1_x002fmi = _fesapi.eml23__UnitOfMeasure__1_x002fmi
eml23__UnitOfMeasure__1_x002fmi2 = _fesapi.eml23__UnitOfMeasure__1_x002fmi2
eml23__UnitOfMeasure__1_x002fmin = _fesapi.eml23__UnitOfMeasure__1_x002fmin
eml23__UnitOfMeasure__1_x002fmm = _fesapi.eml23__UnitOfMeasure__1_x002fmm
eml23__UnitOfMeasure__1_x002fms = _fesapi.eml23__UnitOfMeasure__1_x002fms
eml23__UnitOfMeasure__1_x002fN = _fesapi.eml23__UnitOfMeasure__1_x002fN
eml23__UnitOfMeasure__1_x002fnm = _fesapi.eml23__UnitOfMeasure__1_x002fnm
eml23__UnitOfMeasure__1_x002fPa = _fesapi.eml23__UnitOfMeasure__1_x002fPa
eml23__UnitOfMeasure__1_x002fpPa = _fesapi.eml23__UnitOfMeasure__1_x002fpPa
eml23__UnitOfMeasure__1_x002fpsi = _fesapi.eml23__UnitOfMeasure__1_x002fpsi
eml23__UnitOfMeasure__1_x002fs = _fesapi.eml23__UnitOfMeasure__1_x002fs
eml23__UnitOfMeasure__1_x002fupsi = _fesapi.eml23__UnitOfMeasure__1_x002fupsi
eml23__UnitOfMeasure__1_x002fus = _fesapi.eml23__UnitOfMeasure__1_x002fus
eml23__UnitOfMeasure__1_x002fuV = _fesapi.eml23__UnitOfMeasure__1_x002fuV
eml23__UnitOfMeasure__1_x002fV = _fesapi.eml23__UnitOfMeasure__1_x002fV
eml23__UnitOfMeasure__1_x002fwk = _fesapi.eml23__UnitOfMeasure__1_x002fwk
eml23__UnitOfMeasure__1_x002fyd = _fesapi.eml23__UnitOfMeasure__1_x002fyd
eml23__UnitOfMeasure__10_x0020ft = _fesapi.eml23__UnitOfMeasure__10_x0020ft
eml23__UnitOfMeasure__10_x0020in = _fesapi.eml23__UnitOfMeasure__10_x0020in
eml23__UnitOfMeasure__10_x0020km = _fesapi.eml23__UnitOfMeasure__10_x0020km
eml23__UnitOfMeasure__10_x0020kN = _fesapi.eml23__UnitOfMeasure__10_x0020kN
eml23__UnitOfMeasure__10_x0020Mg_x002fm3 = _fesapi.eml23__UnitOfMeasure__10_x0020Mg_x002fm3
eml23__UnitOfMeasure__100_x0020ft = _fesapi.eml23__UnitOfMeasure__100_x0020ft
eml23__UnitOfMeasure__100_x0020ft_x002fdega = _fesapi.eml23__UnitOfMeasure__100_x0020ft_x002fdega
eml23__UnitOfMeasure__100_x0020ka_x005bt_x005d = _fesapi.eml23__UnitOfMeasure__100_x0020ka_x005bt_x005d
eml23__UnitOfMeasure__100_x0020km = _fesapi.eml23__UnitOfMeasure__100_x0020km
eml23__UnitOfMeasure__1000_x0020bbl = _fesapi.eml23__UnitOfMeasure__1000_x0020bbl
eml23__UnitOfMeasure__1000_x0020bbl_x002eft_x002fd = _fesapi.eml23__UnitOfMeasure__1000_x0020bbl_x002eft_x002fd
eml23__UnitOfMeasure__1000_x0020bbl_x002fd = _fesapi.eml23__UnitOfMeasure__1000_x0020bbl_x002fd
eml23__UnitOfMeasure__1000_x0020ft = _fesapi.eml23__UnitOfMeasure__1000_x0020ft
eml23__UnitOfMeasure__1000_x0020ft_x002fh = _fesapi.eml23__UnitOfMeasure__1000_x0020ft_x002fh
eml23__UnitOfMeasure__1000_x0020ft_x002fs = _fesapi.eml23__UnitOfMeasure__1000_x0020ft_x002fs
eml23__UnitOfMeasure__1000_x0020ft3 = _fesapi.eml23__UnitOfMeasure__1000_x0020ft3
eml23__UnitOfMeasure__1000_x0020ft3_x002f_x0028d_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure__1000_x0020ft3_x002f_x0028d_x002eft_x0029
eml23__UnitOfMeasure__1000_x0020ft3_x002f_x0028psi_x002ed_x0029 = _fesapi.eml23__UnitOfMeasure__1000_x0020ft3_x002f_x0028psi_x002ed_x0029
eml23__UnitOfMeasure__1000_x0020ft3_x002fbbl = _fesapi.eml23__UnitOfMeasure__1000_x0020ft3_x002fbbl
eml23__UnitOfMeasure__1000_x0020ft3_x002fd = _fesapi.eml23__UnitOfMeasure__1000_x0020ft3_x002fd
eml23__UnitOfMeasure__1000_x0020gal_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure__1000_x0020gal_x005bUK_x005d
eml23__UnitOfMeasure__1000_x0020gal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure__1000_x0020gal_x005bUS_x005d
eml23__UnitOfMeasure__1000_x0020lbf_x002eft = _fesapi.eml23__UnitOfMeasure__1000_x0020lbf_x002eft
eml23__UnitOfMeasure__1000_x0020m3 = _fesapi.eml23__UnitOfMeasure__1000_x0020m3
eml23__UnitOfMeasure__1000_x0020m3_x002f_x0028d_x002em_x0029 = _fesapi.eml23__UnitOfMeasure__1000_x0020m3_x002f_x0028d_x002em_x0029
eml23__UnitOfMeasure__1000_x0020m3_x002f_x0028h_x002em_x0029 = _fesapi.eml23__UnitOfMeasure__1000_x0020m3_x002f_x0028h_x002em_x0029
eml23__UnitOfMeasure__1000_x0020m3_x002fd = _fesapi.eml23__UnitOfMeasure__1000_x0020m3_x002fd
eml23__UnitOfMeasure__1000_x0020m3_x002fh = _fesapi.eml23__UnitOfMeasure__1000_x0020m3_x002fh
eml23__UnitOfMeasure__1000_x0020m3_x002fm3 = _fesapi.eml23__UnitOfMeasure__1000_x0020m3_x002fm3
eml23__UnitOfMeasure__1000_x0020m4_x002fd = _fesapi.eml23__UnitOfMeasure__1000_x0020m4_x002fd
eml23__UnitOfMeasure__1E12_x0020ft3 = _fesapi.eml23__UnitOfMeasure__1E12_x0020ft3
eml23__UnitOfMeasure__1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = _fesapi.eml23__UnitOfMeasure__1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029
eml23__UnitOfMeasure__1E_6_x0020acre_x002eft_x002fbbl = _fesapi.eml23__UnitOfMeasure__1E_6_x0020acre_x002eft_x002fbbl
eml23__UnitOfMeasure__1E6_x0020bbl = _fesapi.eml23__UnitOfMeasure__1E6_x0020bbl
eml23__UnitOfMeasure__1E6_x0020bbl_x002f_x0028acre_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure__1E6_x0020bbl_x002f_x0028acre_x002eft_x0029
eml23__UnitOfMeasure__1E6_x0020bbl_x002facre = _fesapi.eml23__UnitOfMeasure__1E6_x0020bbl_x002facre
eml23__UnitOfMeasure__1E6_x0020bbl_x002fd = _fesapi.eml23__UnitOfMeasure__1E6_x0020bbl_x002fd
eml23__UnitOfMeasure__1E_6_x0020bbl_x002fft3 = _fesapi.eml23__UnitOfMeasure__1E_6_x0020bbl_x002fft3
eml23__UnitOfMeasure__1E_6_x0020bbl_x002fm3 = _fesapi.eml23__UnitOfMeasure__1E_6_x0020bbl_x002fm3
eml23__UnitOfMeasure__1E6_x0020Btu_x005bIT_x005d = _fesapi.eml23__UnitOfMeasure__1E6_x0020Btu_x005bIT_x005d
eml23__UnitOfMeasure__1E6_x0020Btu_x005bIT_x005d_x002fh = _fesapi.eml23__UnitOfMeasure__1E6_x0020Btu_x005bIT_x005d_x002fh
eml23__UnitOfMeasure__1E6_x0020ft3 = _fesapi.eml23__UnitOfMeasure__1E6_x0020ft3
eml23__UnitOfMeasure__1E6_x0020ft3_x002f_x0028acre_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure__1E6_x0020ft3_x002f_x0028acre_x002eft_x0029
eml23__UnitOfMeasure__1E6_x0020ft3_x002fbbl = _fesapi.eml23__UnitOfMeasure__1E6_x0020ft3_x002fbbl
eml23__UnitOfMeasure__1E6_x0020ft3_x002fd = _fesapi.eml23__UnitOfMeasure__1E6_x0020ft3_x002fd
eml23__UnitOfMeasure__1E_6_x0020gal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure__1E_6_x0020gal_x005bUS_x005d
eml23__UnitOfMeasure__1E6_x0020lbm_x002fa = _fesapi.eml23__UnitOfMeasure__1E6_x0020lbm_x002fa
eml23__UnitOfMeasure__1E6_x0020m3 = _fesapi.eml23__UnitOfMeasure__1E6_x0020m3
eml23__UnitOfMeasure__1E_6_x0020m3_x002f_x0028m3_x002edegC_x0029 = _fesapi.eml23__UnitOfMeasure__1E_6_x0020m3_x002f_x0028m3_x002edegC_x0029
eml23__UnitOfMeasure__1E_6_x0020m3_x002f_x0028m3_x002edegF_x0029 = _fesapi.eml23__UnitOfMeasure__1E_6_x0020m3_x002f_x0028m3_x002edegF_x0029
eml23__UnitOfMeasure__1E6_x0020m3_x002fd = _fesapi.eml23__UnitOfMeasure__1E6_x0020m3_x002fd
eml23__UnitOfMeasure__1E_9_x00201_x002fft = _fesapi.eml23__UnitOfMeasure__1E_9_x00201_x002fft
eml23__UnitOfMeasure__1E9_x0020bbl = _fesapi.eml23__UnitOfMeasure__1E9_x0020bbl
eml23__UnitOfMeasure__1E9_x0020ft3 = _fesapi.eml23__UnitOfMeasure__1E9_x0020ft3
eml23__UnitOfMeasure__30_x0020ft = _fesapi.eml23__UnitOfMeasure__30_x0020ft
eml23__UnitOfMeasure__30_x0020ft_x002fdega = _fesapi.eml23__UnitOfMeasure__30_x0020ft_x002fdega
eml23__UnitOfMeasure__30_x0020m = _fesapi.eml23__UnitOfMeasure__30_x0020m
eml23__UnitOfMeasure__30_x0020m_x002fdega = _fesapi.eml23__UnitOfMeasure__30_x0020m_x002fdega
eml23__UnitOfMeasure_A_x002eh = _fesapi.eml23__UnitOfMeasure_A_x002eh
eml23__UnitOfMeasure_A_x002em2 = _fesapi.eml23__UnitOfMeasure_A_x002em2
eml23__UnitOfMeasure_A_x002es = _fesapi.eml23__UnitOfMeasure_A_x002es
eml23__UnitOfMeasure_A_x002es_x002fkg = _fesapi.eml23__UnitOfMeasure_A_x002es_x002fkg
eml23__UnitOfMeasure_A_x002es_x002fm3 = _fesapi.eml23__UnitOfMeasure_A_x002es_x002fm3
eml23__UnitOfMeasure_A_x002fcm2 = _fesapi.eml23__UnitOfMeasure_A_x002fcm2
eml23__UnitOfMeasure_A_x002fft2 = _fesapi.eml23__UnitOfMeasure_A_x002fft2
eml23__UnitOfMeasure_A_x002fm = _fesapi.eml23__UnitOfMeasure_A_x002fm
eml23__UnitOfMeasure_A_x002fm2 = _fesapi.eml23__UnitOfMeasure_A_x002fm2
eml23__UnitOfMeasure_A_x002fmm = _fesapi.eml23__UnitOfMeasure_A_x002fmm
eml23__UnitOfMeasure_A_x002fmm2 = _fesapi.eml23__UnitOfMeasure_A_x002fmm2
eml23__UnitOfMeasure_a_x005bt_x005d = _fesapi.eml23__UnitOfMeasure_a_x005bt_x005d
eml23__UnitOfMeasure_acre = _fesapi.eml23__UnitOfMeasure_acre
eml23__UnitOfMeasure_acre_x002eft = _fesapi.eml23__UnitOfMeasure_acre_x002eft
eml23__UnitOfMeasure_ag = _fesapi.eml23__UnitOfMeasure_ag
eml23__UnitOfMeasure_aJ = _fesapi.eml23__UnitOfMeasure_aJ
eml23__UnitOfMeasure_angstrom = _fesapi.eml23__UnitOfMeasure_angstrom
eml23__UnitOfMeasure_at = _fesapi.eml23__UnitOfMeasure_at
eml23__UnitOfMeasure_atm = _fesapi.eml23__UnitOfMeasure_atm
eml23__UnitOfMeasure_atm_x002fft = _fesapi.eml23__UnitOfMeasure_atm_x002fft
eml23__UnitOfMeasure_atm_x002fh = _fesapi.eml23__UnitOfMeasure_atm_x002fh
eml23__UnitOfMeasure_atm_x002fhm = _fesapi.eml23__UnitOfMeasure_atm_x002fhm
eml23__UnitOfMeasure_atm_x002fm = _fesapi.eml23__UnitOfMeasure_atm_x002fm
eml23__UnitOfMeasure_B_x002eW = _fesapi.eml23__UnitOfMeasure_B_x002eW
eml23__UnitOfMeasure_b_x002fcm3 = _fesapi.eml23__UnitOfMeasure_b_x002fcm3
eml23__UnitOfMeasure_B_x002fm = _fesapi.eml23__UnitOfMeasure_B_x002fm
eml23__UnitOfMeasure_B_x002fO = _fesapi.eml23__UnitOfMeasure_B_x002fO
eml23__UnitOfMeasure_bar = _fesapi.eml23__UnitOfMeasure_bar
eml23__UnitOfMeasure_bar_x002f_x00281000m3_x002fday_x0029 = _fesapi.eml23__UnitOfMeasure_bar_x002f_x00281000m3_x002fday_x0029
eml23__UnitOfMeasure_bar_x002f_x00281000m3_x002fday_x00292 = _fesapi.eml23__UnitOfMeasure_bar_x002f_x00281000m3_x002fday_x00292
eml23__UnitOfMeasure_bar_x002f_x0028m3_x002fday_x0029 = _fesapi.eml23__UnitOfMeasure_bar_x002f_x0028m3_x002fday_x0029
eml23__UnitOfMeasure_bar_x002f_x0028m3_x002fday_x00292 = _fesapi.eml23__UnitOfMeasure_bar_x002f_x0028m3_x002fday_x00292
eml23__UnitOfMeasure_bar_x002fh = _fesapi.eml23__UnitOfMeasure_bar_x002fh
eml23__UnitOfMeasure_bar_x002fkm = _fesapi.eml23__UnitOfMeasure_bar_x002fkm
eml23__UnitOfMeasure_bar_x002fm = _fesapi.eml23__UnitOfMeasure_bar_x002fm
eml23__UnitOfMeasure_bar2 = _fesapi.eml23__UnitOfMeasure_bar2
eml23__UnitOfMeasure_bar2_x002fcP = _fesapi.eml23__UnitOfMeasure_bar2_x002fcP
eml23__UnitOfMeasure_bbl = _fesapi.eml23__UnitOfMeasure_bbl
eml23__UnitOfMeasure_bbl_x002f_x0028acre_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure_bbl_x002f_x0028acre_x002eft_x0029
eml23__UnitOfMeasure_bbl_x002f_x0028d_x002eacre_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure_bbl_x002f_x0028d_x002eacre_x002eft_x0029
eml23__UnitOfMeasure_bbl_x002f_x0028d_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure_bbl_x002f_x0028d_x002eft_x0029
eml23__UnitOfMeasure_bbl_x002f_x0028ft_x002epsi_x002ed_x0029 = _fesapi.eml23__UnitOfMeasure_bbl_x002f_x0028ft_x002epsi_x002ed_x0029
eml23__UnitOfMeasure_bbl_x002f_x0028kPa_x002ed_x0029 = _fesapi.eml23__UnitOfMeasure_bbl_x002f_x0028kPa_x002ed_x0029
eml23__UnitOfMeasure_bbl_x002f_x0028psi_x002ed_x0029 = _fesapi.eml23__UnitOfMeasure_bbl_x002f_x0028psi_x002ed_x0029
eml23__UnitOfMeasure_bbl_x002facre = _fesapi.eml23__UnitOfMeasure_bbl_x002facre
eml23__UnitOfMeasure_bbl_x002fbbl = _fesapi.eml23__UnitOfMeasure_bbl_x002fbbl
eml23__UnitOfMeasure_bbl_x002fd = _fesapi.eml23__UnitOfMeasure_bbl_x002fd
eml23__UnitOfMeasure_bbl_x002fd2 = _fesapi.eml23__UnitOfMeasure_bbl_x002fd2
eml23__UnitOfMeasure_bbl_x002fft = _fesapi.eml23__UnitOfMeasure_bbl_x002fft
eml23__UnitOfMeasure_bbl_x002fft3 = _fesapi.eml23__UnitOfMeasure_bbl_x002fft3
eml23__UnitOfMeasure_bbl_x002fh = _fesapi.eml23__UnitOfMeasure_bbl_x002fh
eml23__UnitOfMeasure_bbl_x002fh2 = _fesapi.eml23__UnitOfMeasure_bbl_x002fh2
eml23__UnitOfMeasure_bbl_x002fin = _fesapi.eml23__UnitOfMeasure_bbl_x002fin
eml23__UnitOfMeasure_bbl_x002fm3 = _fesapi.eml23__UnitOfMeasure_bbl_x002fm3
eml23__UnitOfMeasure_bbl_x002fmi = _fesapi.eml23__UnitOfMeasure_bbl_x002fmi
eml23__UnitOfMeasure_bbl_x002fmin = _fesapi.eml23__UnitOfMeasure_bbl_x002fmin
eml23__UnitOfMeasure_bbl_x002fpsi = _fesapi.eml23__UnitOfMeasure_bbl_x002fpsi
eml23__UnitOfMeasure_bbl_x002fton_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_bbl_x002fton_x005bUK_x005d
eml23__UnitOfMeasure_bbl_x002fton_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_bbl_x002fton_x005bUS_x005d
eml23__UnitOfMeasure_Bd = _fesapi.eml23__UnitOfMeasure_Bd
eml23__UnitOfMeasure_bit = _fesapi.eml23__UnitOfMeasure_bit
eml23__UnitOfMeasure_bit_x002fs = _fesapi.eml23__UnitOfMeasure_bit_x002fs
eml23__UnitOfMeasure_Bq = _fesapi.eml23__UnitOfMeasure_Bq
eml23__UnitOfMeasure_Bq_x002fkg = _fesapi.eml23__UnitOfMeasure_Bq_x002fkg
eml23__UnitOfMeasure_Bq_x002fm3 = _fesapi.eml23__UnitOfMeasure_Bq_x002fm3
eml23__UnitOfMeasure_Btu_x005bIT_x005d = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edegF_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edegF_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edegF_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edegF_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegF_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegF_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegR_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegR_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edegF_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edegF_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edegC_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028lbm_x002edegF_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028lbm_x002edegF_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028lbm_x002edegR_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028lbm_x002edegR_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028lbmol_x002edegF_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028lbmol_x002edegF_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edegF_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edegF_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edegF_x0029 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edegF_x0029
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fbbl = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fbbl
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fft3 = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fft3
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fgal_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fgal_x005bUK_x005d
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fh = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fh
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002flbm = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002flbm
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002flbmol = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002flbmol
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fmin = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fmin
eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fs = _fesapi.eml23__UnitOfMeasure_Btu_x005bIT_x005d_x002fs
eml23__UnitOfMeasure_Btu_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_Btu_x005bth_x005d
eml23__UnitOfMeasure_Btu_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_Btu_x005bUK_x005d
eml23__UnitOfMeasure_byte = _fesapi.eml23__UnitOfMeasure_byte
eml23__UnitOfMeasure_byte_x002fs = _fesapi.eml23__UnitOfMeasure_byte_x002fs
eml23__UnitOfMeasure_C_x002em = _fesapi.eml23__UnitOfMeasure_C_x002em
eml23__UnitOfMeasure_C_x002fcm2 = _fesapi.eml23__UnitOfMeasure_C_x002fcm2
eml23__UnitOfMeasure_C_x002fcm3 = _fesapi.eml23__UnitOfMeasure_C_x002fcm3
eml23__UnitOfMeasure_C_x002fg = _fesapi.eml23__UnitOfMeasure_C_x002fg
eml23__UnitOfMeasure_C_x002fkg = _fesapi.eml23__UnitOfMeasure_C_x002fkg
eml23__UnitOfMeasure_C_x002fm2 = _fesapi.eml23__UnitOfMeasure_C_x002fm2
eml23__UnitOfMeasure_C_x002fm3 = _fesapi.eml23__UnitOfMeasure_C_x002fm3
eml23__UnitOfMeasure_C_x002fmm2 = _fesapi.eml23__UnitOfMeasure_C_x002fmm2
eml23__UnitOfMeasure_C_x002fmm3 = _fesapi.eml23__UnitOfMeasure_C_x002fmm3
eml23__UnitOfMeasure_ca = _fesapi.eml23__UnitOfMeasure_ca
eml23__UnitOfMeasure_cA = _fesapi.eml23__UnitOfMeasure_cA
eml23__UnitOfMeasure_cal_x005bIT_x005d = _fesapi.eml23__UnitOfMeasure_cal_x005bIT_x005d
eml23__UnitOfMeasure_cal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d
eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028g_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028g_x002eK_x0029
eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edegC_x0029 = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edegC_x0029
eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029 = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029
eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edegC_x0029 = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edegC_x0029
eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029 = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029
eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028mol_x002edegC_x0029 = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028mol_x002edegC_x0029
eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edegC_x0029 = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edegC_x0029
eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edegC_x0029 = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edegC_x0029
eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029 = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029
eml23__UnitOfMeasure_cal_x005bth_x005d_x002fcm3 = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002fcm3
eml23__UnitOfMeasure_cal_x005bth_x005d_x002fg = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002fg
eml23__UnitOfMeasure_cal_x005bth_x005d_x002fh = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002fh
eml23__UnitOfMeasure_cal_x005bth_x005d_x002fkg = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002fkg
eml23__UnitOfMeasure_cal_x005bth_x005d_x002flbm = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002flbm
eml23__UnitOfMeasure_cal_x005bth_x005d_x002fmL = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002fmL
eml23__UnitOfMeasure_cal_x005bth_x005d_x002fmm3 = _fesapi.eml23__UnitOfMeasure_cal_x005bth_x005d_x002fmm3
eml23__UnitOfMeasure_cC = _fesapi.eml23__UnitOfMeasure_cC
eml23__UnitOfMeasure_ccal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_ccal_x005bth_x005d
eml23__UnitOfMeasure_ccgr = _fesapi.eml23__UnitOfMeasure_ccgr
eml23__UnitOfMeasure_cd = _fesapi.eml23__UnitOfMeasure_cd
eml23__UnitOfMeasure_cd_x002fm2 = _fesapi.eml23__UnitOfMeasure_cd_x002fm2
eml23__UnitOfMeasure_cEuc = _fesapi.eml23__UnitOfMeasure_cEuc
eml23__UnitOfMeasure_ceV = _fesapi.eml23__UnitOfMeasure_ceV
eml23__UnitOfMeasure_cF = _fesapi.eml23__UnitOfMeasure_cF
eml23__UnitOfMeasure_cg = _fesapi.eml23__UnitOfMeasure_cg
eml23__UnitOfMeasure_cgauss = _fesapi.eml23__UnitOfMeasure_cgauss
eml23__UnitOfMeasure_cgr = _fesapi.eml23__UnitOfMeasure_cgr
eml23__UnitOfMeasure_cGy = _fesapi.eml23__UnitOfMeasure_cGy
eml23__UnitOfMeasure_cH = _fesapi.eml23__UnitOfMeasure_cH
eml23__UnitOfMeasure_chain = _fesapi.eml23__UnitOfMeasure_chain
eml23__UnitOfMeasure_chain_x005bBnA_x005d = _fesapi.eml23__UnitOfMeasure_chain_x005bBnA_x005d
eml23__UnitOfMeasure_chain_x005bBnB_x005d = _fesapi.eml23__UnitOfMeasure_chain_x005bBnB_x005d
eml23__UnitOfMeasure_chain_x005bCla_x005d = _fesapi.eml23__UnitOfMeasure_chain_x005bCla_x005d
eml23__UnitOfMeasure_chain_x005bInd37_x005d = _fesapi.eml23__UnitOfMeasure_chain_x005bInd37_x005d
eml23__UnitOfMeasure_chain_x005bSe_x005d = _fesapi.eml23__UnitOfMeasure_chain_x005bSe_x005d
eml23__UnitOfMeasure_chain_x005bSeT_x005d = _fesapi.eml23__UnitOfMeasure_chain_x005bSeT_x005d
eml23__UnitOfMeasure_chain_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_chain_x005bUS_x005d
eml23__UnitOfMeasure_cHz = _fesapi.eml23__UnitOfMeasure_cHz
eml23__UnitOfMeasure_Ci = _fesapi.eml23__UnitOfMeasure_Ci
eml23__UnitOfMeasure_cJ = _fesapi.eml23__UnitOfMeasure_cJ
eml23__UnitOfMeasure_cm = _fesapi.eml23__UnitOfMeasure_cm
eml23__UnitOfMeasure_cm_x002fa = _fesapi.eml23__UnitOfMeasure_cm_x002fa
eml23__UnitOfMeasure_cm_x002fs = _fesapi.eml23__UnitOfMeasure_cm_x002fs
eml23__UnitOfMeasure_cm_x002fs2 = _fesapi.eml23__UnitOfMeasure_cm_x002fs2
eml23__UnitOfMeasure_cm2 = _fesapi.eml23__UnitOfMeasure_cm2
eml23__UnitOfMeasure_cm2_x002fg = _fesapi.eml23__UnitOfMeasure_cm2_x002fg
eml23__UnitOfMeasure_cm2_x002fs = _fesapi.eml23__UnitOfMeasure_cm2_x002fs
eml23__UnitOfMeasure_cm3 = _fesapi.eml23__UnitOfMeasure_cm3
eml23__UnitOfMeasure_cm3_x002fcm3 = _fesapi.eml23__UnitOfMeasure_cm3_x002fcm3
eml23__UnitOfMeasure_cm3_x002fg = _fesapi.eml23__UnitOfMeasure_cm3_x002fg
eml23__UnitOfMeasure_cm3_x002fh = _fesapi.eml23__UnitOfMeasure_cm3_x002fh
eml23__UnitOfMeasure_cm3_x002fL = _fesapi.eml23__UnitOfMeasure_cm3_x002fL
eml23__UnitOfMeasure_cm3_x002fm3 = _fesapi.eml23__UnitOfMeasure_cm3_x002fm3
eml23__UnitOfMeasure_cm3_x002fmin = _fesapi.eml23__UnitOfMeasure_cm3_x002fmin
eml23__UnitOfMeasure_cm3_x002fs = _fesapi.eml23__UnitOfMeasure_cm3_x002fs
eml23__UnitOfMeasure_cm4 = _fesapi.eml23__UnitOfMeasure_cm4
eml23__UnitOfMeasure_cmH2O_x005b4degC_x005d = _fesapi.eml23__UnitOfMeasure_cmH2O_x005b4degC_x005d
eml23__UnitOfMeasure_cN = _fesapi.eml23__UnitOfMeasure_cN
eml23__UnitOfMeasure_cohm = _fesapi.eml23__UnitOfMeasure_cohm
eml23__UnitOfMeasure_cP = _fesapi.eml23__UnitOfMeasure_cP
eml23__UnitOfMeasure_cPa = _fesapi.eml23__UnitOfMeasure_cPa
eml23__UnitOfMeasure_crd = _fesapi.eml23__UnitOfMeasure_crd
eml23__UnitOfMeasure_cS = _fesapi.eml23__UnitOfMeasure_cS
eml23__UnitOfMeasure_cs = _fesapi.eml23__UnitOfMeasure_cs
eml23__UnitOfMeasure_cSt = _fesapi.eml23__UnitOfMeasure_cSt
eml23__UnitOfMeasure_cT = _fesapi.eml23__UnitOfMeasure_cT
eml23__UnitOfMeasure_ct = _fesapi.eml23__UnitOfMeasure_ct
eml23__UnitOfMeasure_cu = _fesapi.eml23__UnitOfMeasure_cu
eml23__UnitOfMeasure_cV = _fesapi.eml23__UnitOfMeasure_cV
eml23__UnitOfMeasure_cW = _fesapi.eml23__UnitOfMeasure_cW
eml23__UnitOfMeasure_cWb = _fesapi.eml23__UnitOfMeasure_cWb
eml23__UnitOfMeasure_cwt_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_cwt_x005bUK_x005d
eml23__UnitOfMeasure_cwt_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_cwt_x005bUS_x005d
eml23__UnitOfMeasure_D_x002eft = _fesapi.eml23__UnitOfMeasure_D_x002eft
eml23__UnitOfMeasure_D_x002em = _fesapi.eml23__UnitOfMeasure_D_x002em
eml23__UnitOfMeasure_D_x002f_x0028Pa_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_D_x002f_x0028Pa_x002es_x0029
eml23__UnitOfMeasure_d_x002fbbl = _fesapi.eml23__UnitOfMeasure_d_x002fbbl
eml23__UnitOfMeasure_D_x002fcP = _fesapi.eml23__UnitOfMeasure_D_x002fcP
eml23__UnitOfMeasure_d_x002fft3 = _fesapi.eml23__UnitOfMeasure_d_x002fft3
eml23__UnitOfMeasure_d_x002fm3 = _fesapi.eml23__UnitOfMeasure_d_x002fm3
eml23__UnitOfMeasure_D_x005bAPI_x005d = _fesapi.eml23__UnitOfMeasure_D_x005bAPI_x005d
eml23__UnitOfMeasure_dA = _fesapi.eml23__UnitOfMeasure_dA
eml23__UnitOfMeasure_dam = _fesapi.eml23__UnitOfMeasure_dam
eml23__UnitOfMeasure_daN = _fesapi.eml23__UnitOfMeasure_daN
eml23__UnitOfMeasure_daN_x002em = _fesapi.eml23__UnitOfMeasure_daN_x002em
eml23__UnitOfMeasure_dAPI = _fesapi.eml23__UnitOfMeasure_dAPI
eml23__UnitOfMeasure_dB = _fesapi.eml23__UnitOfMeasure_dB
eml23__UnitOfMeasure_dB_x002emW = _fesapi.eml23__UnitOfMeasure_dB_x002emW
eml23__UnitOfMeasure_dB_x002eMW = _fesapi.eml23__UnitOfMeasure_dB_x002eMW
eml23__UnitOfMeasure_dB_x002eW = _fesapi.eml23__UnitOfMeasure_dB_x002eW
eml23__UnitOfMeasure_dB_x002fft = _fesapi.eml23__UnitOfMeasure_dB_x002fft
eml23__UnitOfMeasure_dB_x002fkm = _fesapi.eml23__UnitOfMeasure_dB_x002fkm
eml23__UnitOfMeasure_dB_x002fm = _fesapi.eml23__UnitOfMeasure_dB_x002fm
eml23__UnitOfMeasure_dB_x002fO = _fesapi.eml23__UnitOfMeasure_dB_x002fO
eml23__UnitOfMeasure_dC = _fesapi.eml23__UnitOfMeasure_dC
eml23__UnitOfMeasure_dcal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_dcal_x005bth_x005d
eml23__UnitOfMeasure_dega = _fesapi.eml23__UnitOfMeasure_dega
eml23__UnitOfMeasure_dega_x002fft = _fesapi.eml23__UnitOfMeasure_dega_x002fft
eml23__UnitOfMeasure_dega_x002fh = _fesapi.eml23__UnitOfMeasure_dega_x002fh
eml23__UnitOfMeasure_dega_x002fm = _fesapi.eml23__UnitOfMeasure_dega_x002fm
eml23__UnitOfMeasure_dega_x002fmin = _fesapi.eml23__UnitOfMeasure_dega_x002fmin
eml23__UnitOfMeasure_dega_x002fs = _fesapi.eml23__UnitOfMeasure_dega_x002fs
eml23__UnitOfMeasure_degC = _fesapi.eml23__UnitOfMeasure_degC
eml23__UnitOfMeasure_degC_x002em2_x002eh_x002fkcal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_degC_x002em2_x002eh_x002fkcal_x005bth_x005d
eml23__UnitOfMeasure_degC_x002fft = _fesapi.eml23__UnitOfMeasure_degC_x002fft
eml23__UnitOfMeasure_degC_x002fh = _fesapi.eml23__UnitOfMeasure_degC_x002fh
eml23__UnitOfMeasure_degC_x002fhm = _fesapi.eml23__UnitOfMeasure_degC_x002fhm
eml23__UnitOfMeasure_degC_x002fkm = _fesapi.eml23__UnitOfMeasure_degC_x002fkm
eml23__UnitOfMeasure_degC_x002fkPa = _fesapi.eml23__UnitOfMeasure_degC_x002fkPa
eml23__UnitOfMeasure_degC_x002fm = _fesapi.eml23__UnitOfMeasure_degC_x002fm
eml23__UnitOfMeasure_degC_x002fmin = _fesapi.eml23__UnitOfMeasure_degC_x002fmin
eml23__UnitOfMeasure_degC_x002fs = _fesapi.eml23__UnitOfMeasure_degC_x002fs
eml23__UnitOfMeasure_degF = _fesapi.eml23__UnitOfMeasure_degF
eml23__UnitOfMeasure_degF_x002eft2_x002eh_x002fBtu_x005bIT_x005d = _fesapi.eml23__UnitOfMeasure_degF_x002eft2_x002eh_x002fBtu_x005bIT_x005d
eml23__UnitOfMeasure_degF_x002fft = _fesapi.eml23__UnitOfMeasure_degF_x002fft
eml23__UnitOfMeasure_degF_x002fh = _fesapi.eml23__UnitOfMeasure_degF_x002fh
eml23__UnitOfMeasure_degF_x002fm = _fesapi.eml23__UnitOfMeasure_degF_x002fm
eml23__UnitOfMeasure_degF_x002fmin = _fesapi.eml23__UnitOfMeasure_degF_x002fmin
eml23__UnitOfMeasure_degF_x002fpsi = _fesapi.eml23__UnitOfMeasure_degF_x002fpsi
eml23__UnitOfMeasure_degF_x002fs = _fesapi.eml23__UnitOfMeasure_degF_x002fs
eml23__UnitOfMeasure_degR = _fesapi.eml23__UnitOfMeasure_degR
eml23__UnitOfMeasure_dEuc = _fesapi.eml23__UnitOfMeasure_dEuc
eml23__UnitOfMeasure_deV = _fesapi.eml23__UnitOfMeasure_deV
eml23__UnitOfMeasure_dF = _fesapi.eml23__UnitOfMeasure_dF
eml23__UnitOfMeasure_dgauss = _fesapi.eml23__UnitOfMeasure_dgauss
eml23__UnitOfMeasure_dGy = _fesapi.eml23__UnitOfMeasure_dGy
eml23__UnitOfMeasure_dH = _fesapi.eml23__UnitOfMeasure_dH
eml23__UnitOfMeasure_dHz = _fesapi.eml23__UnitOfMeasure_dHz
eml23__UnitOfMeasure_dJ = _fesapi.eml23__UnitOfMeasure_dJ
eml23__UnitOfMeasure_dm = _fesapi.eml23__UnitOfMeasure_dm
eml23__UnitOfMeasure_dm_x002fs = _fesapi.eml23__UnitOfMeasure_dm_x002fs
eml23__UnitOfMeasure_dm3 = _fesapi.eml23__UnitOfMeasure_dm3
eml23__UnitOfMeasure_dm3_x002f_x0028kW_x002eh_x0029 = _fesapi.eml23__UnitOfMeasure_dm3_x002f_x0028kW_x002eh_x0029
eml23__UnitOfMeasure_dm3_x002fkg = _fesapi.eml23__UnitOfMeasure_dm3_x002fkg
eml23__UnitOfMeasure_dm3_x002fkmol = _fesapi.eml23__UnitOfMeasure_dm3_x002fkmol
eml23__UnitOfMeasure_dm3_x002fm = _fesapi.eml23__UnitOfMeasure_dm3_x002fm
eml23__UnitOfMeasure_dm3_x002fm3 = _fesapi.eml23__UnitOfMeasure_dm3_x002fm3
eml23__UnitOfMeasure_dm3_x002fMJ = _fesapi.eml23__UnitOfMeasure_dm3_x002fMJ
eml23__UnitOfMeasure_dm3_x002fs = _fesapi.eml23__UnitOfMeasure_dm3_x002fs
eml23__UnitOfMeasure_dm3_x002fs2 = _fesapi.eml23__UnitOfMeasure_dm3_x002fs2
eml23__UnitOfMeasure_dm3_x002ft = _fesapi.eml23__UnitOfMeasure_dm3_x002ft
eml23__UnitOfMeasure_dN = _fesapi.eml23__UnitOfMeasure_dN
eml23__UnitOfMeasure_dN_x002em = _fesapi.eml23__UnitOfMeasure_dN_x002em
eml23__UnitOfMeasure_dohm = _fesapi.eml23__UnitOfMeasure_dohm
eml23__UnitOfMeasure_dP = _fesapi.eml23__UnitOfMeasure_dP
eml23__UnitOfMeasure_dPa = _fesapi.eml23__UnitOfMeasure_dPa
eml23__UnitOfMeasure_drd = _fesapi.eml23__UnitOfMeasure_drd
eml23__UnitOfMeasure_dS = _fesapi.eml23__UnitOfMeasure_dS
eml23__UnitOfMeasure_ds = _fesapi.eml23__UnitOfMeasure_ds
eml23__UnitOfMeasure_dT = _fesapi.eml23__UnitOfMeasure_dT
eml23__UnitOfMeasure_dV = _fesapi.eml23__UnitOfMeasure_dV
eml23__UnitOfMeasure_dW = _fesapi.eml23__UnitOfMeasure_dW
eml23__UnitOfMeasure_dWb = _fesapi.eml23__UnitOfMeasure_dWb
eml23__UnitOfMeasure_dyne = _fesapi.eml23__UnitOfMeasure_dyne
eml23__UnitOfMeasure_dyne_x002ecm2 = _fesapi.eml23__UnitOfMeasure_dyne_x002ecm2
eml23__UnitOfMeasure_dyne_x002es_x002fcm2 = _fesapi.eml23__UnitOfMeasure_dyne_x002es_x002fcm2
eml23__UnitOfMeasure_dyne_x002fcm = _fesapi.eml23__UnitOfMeasure_dyne_x002fcm
eml23__UnitOfMeasure_dyne_x002fcm2 = _fesapi.eml23__UnitOfMeasure_dyne_x002fcm2
eml23__UnitOfMeasure_EA = _fesapi.eml23__UnitOfMeasure_EA
eml23__UnitOfMeasure_Ea_x005bt_x005d = _fesapi.eml23__UnitOfMeasure_Ea_x005bt_x005d
eml23__UnitOfMeasure_EC = _fesapi.eml23__UnitOfMeasure_EC
eml23__UnitOfMeasure_Ecal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_Ecal_x005bth_x005d
eml23__UnitOfMeasure_EEuc = _fesapi.eml23__UnitOfMeasure_EEuc
eml23__UnitOfMeasure_EeV = _fesapi.eml23__UnitOfMeasure_EeV
eml23__UnitOfMeasure_EF = _fesapi.eml23__UnitOfMeasure_EF
eml23__UnitOfMeasure_Eg = _fesapi.eml23__UnitOfMeasure_Eg
eml23__UnitOfMeasure_Egauss = _fesapi.eml23__UnitOfMeasure_Egauss
eml23__UnitOfMeasure_EGy = _fesapi.eml23__UnitOfMeasure_EGy
eml23__UnitOfMeasure_EH = _fesapi.eml23__UnitOfMeasure_EH
eml23__UnitOfMeasure_EHz = _fesapi.eml23__UnitOfMeasure_EHz
eml23__UnitOfMeasure_EJ = _fesapi.eml23__UnitOfMeasure_EJ
eml23__UnitOfMeasure_EJ_x002fa = _fesapi.eml23__UnitOfMeasure_EJ_x002fa
eml23__UnitOfMeasure_Em = _fesapi.eml23__UnitOfMeasure_Em
eml23__UnitOfMeasure_EN = _fesapi.eml23__UnitOfMeasure_EN
eml23__UnitOfMeasure_Eohm = _fesapi.eml23__UnitOfMeasure_Eohm
eml23__UnitOfMeasure_EP = _fesapi.eml23__UnitOfMeasure_EP
eml23__UnitOfMeasure_EPa = _fesapi.eml23__UnitOfMeasure_EPa
eml23__UnitOfMeasure_Erd = _fesapi.eml23__UnitOfMeasure_Erd
eml23__UnitOfMeasure_erg = _fesapi.eml23__UnitOfMeasure_erg
eml23__UnitOfMeasure_erg_x002fa = _fesapi.eml23__UnitOfMeasure_erg_x002fa
eml23__UnitOfMeasure_erg_x002fcm2 = _fesapi.eml23__UnitOfMeasure_erg_x002fcm2
eml23__UnitOfMeasure_erg_x002fcm3 = _fesapi.eml23__UnitOfMeasure_erg_x002fcm3
eml23__UnitOfMeasure_erg_x002fg = _fesapi.eml23__UnitOfMeasure_erg_x002fg
eml23__UnitOfMeasure_erg_x002fkg = _fesapi.eml23__UnitOfMeasure_erg_x002fkg
eml23__UnitOfMeasure_erg_x002fm3 = _fesapi.eml23__UnitOfMeasure_erg_x002fm3
eml23__UnitOfMeasure_ES = _fesapi.eml23__UnitOfMeasure_ES
eml23__UnitOfMeasure_ET = _fesapi.eml23__UnitOfMeasure_ET
eml23__UnitOfMeasure_Euc = _fesapi.eml23__UnitOfMeasure_Euc
eml23__UnitOfMeasure_eV = _fesapi.eml23__UnitOfMeasure_eV
eml23__UnitOfMeasure_EW = _fesapi.eml23__UnitOfMeasure_EW
eml23__UnitOfMeasure_EWb = _fesapi.eml23__UnitOfMeasure_EWb
eml23__UnitOfMeasure_F_x002fm = _fesapi.eml23__UnitOfMeasure_F_x002fm
eml23__UnitOfMeasure_fa = _fesapi.eml23__UnitOfMeasure_fa
eml23__UnitOfMeasure_fA = _fesapi.eml23__UnitOfMeasure_fA
eml23__UnitOfMeasure_fathom = _fesapi.eml23__UnitOfMeasure_fathom
eml23__UnitOfMeasure_fC = _fesapi.eml23__UnitOfMeasure_fC
eml23__UnitOfMeasure_fcal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_fcal_x005bth_x005d
eml23__UnitOfMeasure_fEuc = _fesapi.eml23__UnitOfMeasure_fEuc
eml23__UnitOfMeasure_feV = _fesapi.eml23__UnitOfMeasure_feV
eml23__UnitOfMeasure_fF = _fesapi.eml23__UnitOfMeasure_fF
eml23__UnitOfMeasure_fg = _fesapi.eml23__UnitOfMeasure_fg
eml23__UnitOfMeasure_fgauss = _fesapi.eml23__UnitOfMeasure_fgauss
eml23__UnitOfMeasure_fGy = _fesapi.eml23__UnitOfMeasure_fGy
eml23__UnitOfMeasure_fH = _fesapi.eml23__UnitOfMeasure_fH
eml23__UnitOfMeasure_fHz = _fesapi.eml23__UnitOfMeasure_fHz
eml23__UnitOfMeasure_fJ = _fesapi.eml23__UnitOfMeasure_fJ
eml23__UnitOfMeasure_floz_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_floz_x005bUK_x005d
eml23__UnitOfMeasure_floz_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_floz_x005bUS_x005d
eml23__UnitOfMeasure_fm = _fesapi.eml23__UnitOfMeasure_fm
eml23__UnitOfMeasure_fN = _fesapi.eml23__UnitOfMeasure_fN
eml23__UnitOfMeasure_fohm = _fesapi.eml23__UnitOfMeasure_fohm
eml23__UnitOfMeasure_footcandle = _fesapi.eml23__UnitOfMeasure_footcandle
eml23__UnitOfMeasure_footcandle_x002es = _fesapi.eml23__UnitOfMeasure_footcandle_x002es
eml23__UnitOfMeasure_fP = _fesapi.eml23__UnitOfMeasure_fP
eml23__UnitOfMeasure_fPa = _fesapi.eml23__UnitOfMeasure_fPa
eml23__UnitOfMeasure_frd = _fesapi.eml23__UnitOfMeasure_frd
eml23__UnitOfMeasure_fS = _fesapi.eml23__UnitOfMeasure_fS
eml23__UnitOfMeasure_ft = _fesapi.eml23__UnitOfMeasure_ft
eml23__UnitOfMeasure_fT = _fesapi.eml23__UnitOfMeasure_fT
eml23__UnitOfMeasure_ft_x002fbbl = _fesapi.eml23__UnitOfMeasure_ft_x002fbbl
eml23__UnitOfMeasure_ft_x002fd = _fesapi.eml23__UnitOfMeasure_ft_x002fd
eml23__UnitOfMeasure_ft_x002fdega = _fesapi.eml23__UnitOfMeasure_ft_x002fdega
eml23__UnitOfMeasure_ft_x002fdegF = _fesapi.eml23__UnitOfMeasure_ft_x002fdegF
eml23__UnitOfMeasure_ft_x002fft = _fesapi.eml23__UnitOfMeasure_ft_x002fft
eml23__UnitOfMeasure_ft_x002fft3 = _fesapi.eml23__UnitOfMeasure_ft_x002fft3
eml23__UnitOfMeasure_ft_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_ft_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure_ft_x002fh = _fesapi.eml23__UnitOfMeasure_ft_x002fh
eml23__UnitOfMeasure_ft_x002fin = _fesapi.eml23__UnitOfMeasure_ft_x002fin
eml23__UnitOfMeasure_ft_x002flbm = _fesapi.eml23__UnitOfMeasure_ft_x002flbm
eml23__UnitOfMeasure_ft_x002fm = _fesapi.eml23__UnitOfMeasure_ft_x002fm
eml23__UnitOfMeasure_ft_x002fmi = _fesapi.eml23__UnitOfMeasure_ft_x002fmi
eml23__UnitOfMeasure_ft_x002fmin = _fesapi.eml23__UnitOfMeasure_ft_x002fmin
eml23__UnitOfMeasure_ft_x002fms = _fesapi.eml23__UnitOfMeasure_ft_x002fms
eml23__UnitOfMeasure_ft_x002fpsi = _fesapi.eml23__UnitOfMeasure_ft_x002fpsi
eml23__UnitOfMeasure_ft_x002frad = _fesapi.eml23__UnitOfMeasure_ft_x002frad
eml23__UnitOfMeasure_ft_x002frev = _fesapi.eml23__UnitOfMeasure_ft_x002frev
eml23__UnitOfMeasure_ft_x002fs = _fesapi.eml23__UnitOfMeasure_ft_x002fs
eml23__UnitOfMeasure_ft_x002fs2 = _fesapi.eml23__UnitOfMeasure_ft_x002fs2
eml23__UnitOfMeasure_ft_x002fus = _fesapi.eml23__UnitOfMeasure_ft_x002fus
eml23__UnitOfMeasure_ft_x005bBnA_x005d = _fesapi.eml23__UnitOfMeasure_ft_x005bBnA_x005d
eml23__UnitOfMeasure_ft_x005bBnB_x005d = _fesapi.eml23__UnitOfMeasure_ft_x005bBnB_x005d
eml23__UnitOfMeasure_ft_x005bBr36_x005d = _fesapi.eml23__UnitOfMeasure_ft_x005bBr36_x005d
eml23__UnitOfMeasure_ft_x005bBr65_x005d = _fesapi.eml23__UnitOfMeasure_ft_x005bBr65_x005d
eml23__UnitOfMeasure_ft_x005bCla_x005d = _fesapi.eml23__UnitOfMeasure_ft_x005bCla_x005d
eml23__UnitOfMeasure_ft_x005bGC_x005d = _fesapi.eml23__UnitOfMeasure_ft_x005bGC_x005d
eml23__UnitOfMeasure_ft_x005bInd_x005d = _fesapi.eml23__UnitOfMeasure_ft_x005bInd_x005d
eml23__UnitOfMeasure_ft_x005bInd37_x005d = _fesapi.eml23__UnitOfMeasure_ft_x005bInd37_x005d
eml23__UnitOfMeasure_ft_x005bInd62_x005d = _fesapi.eml23__UnitOfMeasure_ft_x005bInd62_x005d
eml23__UnitOfMeasure_ft_x005bInd75_x005d = _fesapi.eml23__UnitOfMeasure_ft_x005bInd75_x005d
eml23__UnitOfMeasure_ft_x005bSe_x005d = _fesapi.eml23__UnitOfMeasure_ft_x005bSe_x005d
eml23__UnitOfMeasure_ft_x005bSeT_x005d = _fesapi.eml23__UnitOfMeasure_ft_x005bSeT_x005d
eml23__UnitOfMeasure_ft_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_ft_x005bUS_x005d
eml23__UnitOfMeasure_ft2 = _fesapi.eml23__UnitOfMeasure_ft2
eml23__UnitOfMeasure_ft2_x002fh = _fesapi.eml23__UnitOfMeasure_ft2_x002fh
eml23__UnitOfMeasure_ft2_x002fin3 = _fesapi.eml23__UnitOfMeasure_ft2_x002fin3
eml23__UnitOfMeasure_ft2_x002flbm = _fesapi.eml23__UnitOfMeasure_ft2_x002flbm
eml23__UnitOfMeasure_ft2_x002fs = _fesapi.eml23__UnitOfMeasure_ft2_x002fs
eml23__UnitOfMeasure_ft3 = _fesapi.eml23__UnitOfMeasure_ft3
eml23__UnitOfMeasure_ft3_x002f_x0028d_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure_ft3_x002f_x0028d_x002eft_x0029
eml23__UnitOfMeasure_ft3_x002f_x0028ft_x002epsi_x002ed_x0029 = _fesapi.eml23__UnitOfMeasure_ft3_x002f_x0028ft_x002epsi_x002ed_x0029
eml23__UnitOfMeasure_ft3_x002f_x0028min_x002eft2_x0029 = _fesapi.eml23__UnitOfMeasure_ft3_x002f_x0028min_x002eft2_x0029
eml23__UnitOfMeasure_ft3_x002f_x0028s_x002eft2_x0029 = _fesapi.eml23__UnitOfMeasure_ft3_x002f_x0028s_x002eft2_x0029
eml23__UnitOfMeasure_ft3_x002fbbl = _fesapi.eml23__UnitOfMeasure_ft3_x002fbbl
eml23__UnitOfMeasure_ft3_x002fd = _fesapi.eml23__UnitOfMeasure_ft3_x002fd
eml23__UnitOfMeasure_ft3_x002fd2 = _fesapi.eml23__UnitOfMeasure_ft3_x002fd2
eml23__UnitOfMeasure_ft3_x002fft = _fesapi.eml23__UnitOfMeasure_ft3_x002fft
eml23__UnitOfMeasure_ft3_x002fft2 = _fesapi.eml23__UnitOfMeasure_ft3_x002fft2
eml23__UnitOfMeasure_ft3_x002fft3 = _fesapi.eml23__UnitOfMeasure_ft3_x002fft3
eml23__UnitOfMeasure_ft3_x002fh = _fesapi.eml23__UnitOfMeasure_ft3_x002fh
eml23__UnitOfMeasure_ft3_x002fh2 = _fesapi.eml23__UnitOfMeasure_ft3_x002fh2
eml23__UnitOfMeasure_ft3_x002fkg = _fesapi.eml23__UnitOfMeasure_ft3_x002fkg
eml23__UnitOfMeasure_ft3_x002flbm = _fesapi.eml23__UnitOfMeasure_ft3_x002flbm
eml23__UnitOfMeasure_ft3_x002flbmol = _fesapi.eml23__UnitOfMeasure_ft3_x002flbmol
eml23__UnitOfMeasure_ft3_x002fmin = _fesapi.eml23__UnitOfMeasure_ft3_x002fmin
eml23__UnitOfMeasure_ft3_x002fmin2 = _fesapi.eml23__UnitOfMeasure_ft3_x002fmin2
eml23__UnitOfMeasure_ft3_x002frad = _fesapi.eml23__UnitOfMeasure_ft3_x002frad
eml23__UnitOfMeasure_ft3_x002fs = _fesapi.eml23__UnitOfMeasure_ft3_x002fs
eml23__UnitOfMeasure_ft3_x002fs2 = _fesapi.eml23__UnitOfMeasure_ft3_x002fs2
eml23__UnitOfMeasure_ft3_x002fsack_x005b94lbm_x005d = _fesapi.eml23__UnitOfMeasure_ft3_x002fsack_x005b94lbm_x005d
eml23__UnitOfMeasure_fur_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_fur_x005bUS_x005d
eml23__UnitOfMeasure_fV = _fesapi.eml23__UnitOfMeasure_fV
eml23__UnitOfMeasure_fW = _fesapi.eml23__UnitOfMeasure_fW
eml23__UnitOfMeasure_fWb = _fesapi.eml23__UnitOfMeasure_fWb
eml23__UnitOfMeasure_g_x002eft_x002f_x0028cm3_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_g_x002eft_x002f_x0028cm3_x002es_x0029
eml23__UnitOfMeasure_g_x002em_x002f_x0028cm3_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_g_x002em_x002f_x0028cm3_x002es_x0029
eml23__UnitOfMeasure_g_x002fcm3 = _fesapi.eml23__UnitOfMeasure_g_x002fcm3
eml23__UnitOfMeasure_g_x002fcm4 = _fesapi.eml23__UnitOfMeasure_g_x002fcm4
eml23__UnitOfMeasure_g_x002fdm3 = _fesapi.eml23__UnitOfMeasure_g_x002fdm3
eml23__UnitOfMeasure_g_x002fgal_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_g_x002fgal_x005bUK_x005d
eml23__UnitOfMeasure_g_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_g_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure_g_x002fkg = _fesapi.eml23__UnitOfMeasure_g_x002fkg
eml23__UnitOfMeasure_g_x002fL = _fesapi.eml23__UnitOfMeasure_g_x002fL
eml23__UnitOfMeasure_g_x002fm3 = _fesapi.eml23__UnitOfMeasure_g_x002fm3
eml23__UnitOfMeasure_g_x002fmol = _fesapi.eml23__UnitOfMeasure_g_x002fmol
eml23__UnitOfMeasure_g_x002fs = _fesapi.eml23__UnitOfMeasure_g_x002fs
eml23__UnitOfMeasure_g_x002ft = _fesapi.eml23__UnitOfMeasure_g_x002ft
eml23__UnitOfMeasure_GA = _fesapi.eml23__UnitOfMeasure_GA
eml23__UnitOfMeasure_Ga_x005bt_x005d = _fesapi.eml23__UnitOfMeasure_Ga_x005bt_x005d
eml23__UnitOfMeasure_Gal = _fesapi.eml23__UnitOfMeasure_Gal
eml23__UnitOfMeasure_gal_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029 = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029 = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029 = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029 = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fd = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fd
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fft3 = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fft3
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fh = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fh
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fh2 = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fh2
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002flbm = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002flbm
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fmi = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fmi
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fmin = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fmin
eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fmin2 = _fesapi.eml23__UnitOfMeasure_gal_x005bUK_x005d_x002fmin2
eml23__UnitOfMeasure_gal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029 = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029 = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029 = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029 = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fbbl = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fbbl
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fd = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fd
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fft = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fft
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fft3 = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fft3
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fh = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fh
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fh2 = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fh2
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002flbm = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002flbm
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fmi = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fmi
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fmin = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fmin
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fmin2 = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fmin2
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fton_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fton_x005bUK_x005d
eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fton_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_gal_x005bUS_x005d_x002fton_x005bUS_x005d
eml23__UnitOfMeasure_gAPI = _fesapi.eml23__UnitOfMeasure_gAPI
eml23__UnitOfMeasure_gauss = _fesapi.eml23__UnitOfMeasure_gauss
eml23__UnitOfMeasure_gauss_x002fcm = _fesapi.eml23__UnitOfMeasure_gauss_x002fcm
eml23__UnitOfMeasure_GBq = _fesapi.eml23__UnitOfMeasure_GBq
eml23__UnitOfMeasure_GC = _fesapi.eml23__UnitOfMeasure_GC
eml23__UnitOfMeasure_Gcal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_Gcal_x005bth_x005d
eml23__UnitOfMeasure_GEuc = _fesapi.eml23__UnitOfMeasure_GEuc
eml23__UnitOfMeasure_GeV = _fesapi.eml23__UnitOfMeasure_GeV
eml23__UnitOfMeasure_gf = _fesapi.eml23__UnitOfMeasure_gf
eml23__UnitOfMeasure_GF = _fesapi.eml23__UnitOfMeasure_GF
eml23__UnitOfMeasure_Gg = _fesapi.eml23__UnitOfMeasure_Gg
eml23__UnitOfMeasure_Ggauss = _fesapi.eml23__UnitOfMeasure_Ggauss
eml23__UnitOfMeasure_GGy = _fesapi.eml23__UnitOfMeasure_GGy
eml23__UnitOfMeasure_GH = _fesapi.eml23__UnitOfMeasure_GH
eml23__UnitOfMeasure_GHz = _fesapi.eml23__UnitOfMeasure_GHz
eml23__UnitOfMeasure_GJ = _fesapi.eml23__UnitOfMeasure_GJ
eml23__UnitOfMeasure_Gm = _fesapi.eml23__UnitOfMeasure_Gm
eml23__UnitOfMeasure_GN = _fesapi.eml23__UnitOfMeasure_GN
eml23__UnitOfMeasure_gn = _fesapi.eml23__UnitOfMeasure_gn
eml23__UnitOfMeasure_Gohm = _fesapi.eml23__UnitOfMeasure_Gohm
eml23__UnitOfMeasure_gon = _fesapi.eml23__UnitOfMeasure_gon
eml23__UnitOfMeasure_GP = _fesapi.eml23__UnitOfMeasure_GP
eml23__UnitOfMeasure_GPa = _fesapi.eml23__UnitOfMeasure_GPa
eml23__UnitOfMeasure_GPa_x002fcm = _fesapi.eml23__UnitOfMeasure_GPa_x002fcm
eml23__UnitOfMeasure_GPa2 = _fesapi.eml23__UnitOfMeasure_GPa2
eml23__UnitOfMeasure_grain = _fesapi.eml23__UnitOfMeasure_grain
eml23__UnitOfMeasure_grain_x002fft3 = _fesapi.eml23__UnitOfMeasure_grain_x002fft3
eml23__UnitOfMeasure_grain_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_grain_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure_Grd = _fesapi.eml23__UnitOfMeasure_Grd
eml23__UnitOfMeasure_GS = _fesapi.eml23__UnitOfMeasure_GS
eml23__UnitOfMeasure_GT = _fesapi.eml23__UnitOfMeasure_GT
eml23__UnitOfMeasure_GV = _fesapi.eml23__UnitOfMeasure_GV
eml23__UnitOfMeasure_GW = _fesapi.eml23__UnitOfMeasure_GW
eml23__UnitOfMeasure_GW_x002eh = _fesapi.eml23__UnitOfMeasure_GW_x002eh
eml23__UnitOfMeasure_GWb = _fesapi.eml23__UnitOfMeasure_GWb
eml23__UnitOfMeasure_Gy = _fesapi.eml23__UnitOfMeasure_Gy
eml23__UnitOfMeasure_h_x002fft3 = _fesapi.eml23__UnitOfMeasure_h_x002fft3
eml23__UnitOfMeasure_h_x002fkm = _fesapi.eml23__UnitOfMeasure_h_x002fkm
eml23__UnitOfMeasure_H_x002fm = _fesapi.eml23__UnitOfMeasure_H_x002fm
eml23__UnitOfMeasure_h_x002fm3 = _fesapi.eml23__UnitOfMeasure_h_x002fm3
eml23__UnitOfMeasure_ha = _fesapi.eml23__UnitOfMeasure_ha
eml23__UnitOfMeasure_ha_x002em = _fesapi.eml23__UnitOfMeasure_ha_x002em
eml23__UnitOfMeasure_hbar = _fesapi.eml23__UnitOfMeasure_hbar
eml23__UnitOfMeasure_hg = _fesapi.eml23__UnitOfMeasure_hg
eml23__UnitOfMeasure_hL = _fesapi.eml23__UnitOfMeasure_hL
eml23__UnitOfMeasure_hm = _fesapi.eml23__UnitOfMeasure_hm
eml23__UnitOfMeasure_hN = _fesapi.eml23__UnitOfMeasure_hN
eml23__UnitOfMeasure_hp = _fesapi.eml23__UnitOfMeasure_hp
eml23__UnitOfMeasure_hp_x002eh = _fesapi.eml23__UnitOfMeasure_hp_x002eh
eml23__UnitOfMeasure_hp_x002eh_x002fbbl = _fesapi.eml23__UnitOfMeasure_hp_x002eh_x002fbbl
eml23__UnitOfMeasure_hp_x002eh_x002flbm = _fesapi.eml23__UnitOfMeasure_hp_x002eh_x002flbm
eml23__UnitOfMeasure_hp_x002fft3 = _fesapi.eml23__UnitOfMeasure_hp_x002fft3
eml23__UnitOfMeasure_hp_x002fin2 = _fesapi.eml23__UnitOfMeasure_hp_x002fin2
eml23__UnitOfMeasure_hp_x005belec_x005d = _fesapi.eml23__UnitOfMeasure_hp_x005belec_x005d
eml23__UnitOfMeasure_hp_x005bhyd_x005d = _fesapi.eml23__UnitOfMeasure_hp_x005bhyd_x005d
eml23__UnitOfMeasure_hp_x005bhyd_x005d_x002fin2 = _fesapi.eml23__UnitOfMeasure_hp_x005bhyd_x005d_x002fin2
eml23__UnitOfMeasure_hp_x005bmetric_x005d = _fesapi.eml23__UnitOfMeasure_hp_x005bmetric_x005d
eml23__UnitOfMeasure_hp_x005bmetric_x005d_x002eh = _fesapi.eml23__UnitOfMeasure_hp_x005bmetric_x005d_x002eh
eml23__UnitOfMeasure_hs = _fesapi.eml23__UnitOfMeasure_hs
eml23__UnitOfMeasure_Hz = _fesapi.eml23__UnitOfMeasure_Hz
eml23__UnitOfMeasure__in = _fesapi.eml23__UnitOfMeasure__in
eml23__UnitOfMeasure_in_x002f_x0028in_x002edegF_x0029 = _fesapi.eml23__UnitOfMeasure_in_x002f_x0028in_x002edegF_x0029
eml23__UnitOfMeasure_in_x002fa = _fesapi.eml23__UnitOfMeasure_in_x002fa
eml23__UnitOfMeasure_in_x002fmin = _fesapi.eml23__UnitOfMeasure_in_x002fmin
eml23__UnitOfMeasure_in_x002fs = _fesapi.eml23__UnitOfMeasure_in_x002fs
eml23__UnitOfMeasure_in_x002fs2 = _fesapi.eml23__UnitOfMeasure_in_x002fs2
eml23__UnitOfMeasure_in_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_in_x005bUS_x005d
eml23__UnitOfMeasure_in2 = _fesapi.eml23__UnitOfMeasure_in2
eml23__UnitOfMeasure_in2_x002fft2 = _fesapi.eml23__UnitOfMeasure_in2_x002fft2
eml23__UnitOfMeasure_in2_x002fin2 = _fesapi.eml23__UnitOfMeasure_in2_x002fin2
eml23__UnitOfMeasure_in2_x002fs = _fesapi.eml23__UnitOfMeasure_in2_x002fs
eml23__UnitOfMeasure_in3 = _fesapi.eml23__UnitOfMeasure_in3
eml23__UnitOfMeasure_in3_x002fft = _fesapi.eml23__UnitOfMeasure_in3_x002fft
eml23__UnitOfMeasure_in4 = _fesapi.eml23__UnitOfMeasure_in4
eml23__UnitOfMeasure_inH2O_x005b39degF_x005d = _fesapi.eml23__UnitOfMeasure_inH2O_x005b39degF_x005d
eml23__UnitOfMeasure_inH2O_x005b60degF_x005d = _fesapi.eml23__UnitOfMeasure_inH2O_x005b60degF_x005d
eml23__UnitOfMeasure_inHg_x005b32degF_x005d = _fesapi.eml23__UnitOfMeasure_inHg_x005b32degF_x005d
eml23__UnitOfMeasure_inHg_x005b60degF_x005d = _fesapi.eml23__UnitOfMeasure_inHg_x005b60degF_x005d
eml23__UnitOfMeasure_J_x002em_x002f_x0028s_x002em2_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_J_x002em_x002f_x0028s_x002em2_x002eK_x0029
eml23__UnitOfMeasure_J_x002em_x002fm2 = _fesapi.eml23__UnitOfMeasure_J_x002em_x002fm2
eml23__UnitOfMeasure_J_x002f_x0028g_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_J_x002f_x0028g_x002eK_x0029
eml23__UnitOfMeasure_J_x002f_x0028kg_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_J_x002f_x0028kg_x002eK_x0029
eml23__UnitOfMeasure_J_x002f_x0028mol_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_J_x002f_x0028mol_x002eK_x0029
eml23__UnitOfMeasure_J_x002f_x0028s_x002em2_x002edegC_x0029 = _fesapi.eml23__UnitOfMeasure_J_x002f_x0028s_x002em2_x002edegC_x0029
eml23__UnitOfMeasure_J_x002fcm2 = _fesapi.eml23__UnitOfMeasure_J_x002fcm2
eml23__UnitOfMeasure_J_x002fdm3 = _fesapi.eml23__UnitOfMeasure_J_x002fdm3
eml23__UnitOfMeasure_J_x002fg = _fesapi.eml23__UnitOfMeasure_J_x002fg
eml23__UnitOfMeasure_J_x002fK = _fesapi.eml23__UnitOfMeasure_J_x002fK
eml23__UnitOfMeasure_J_x002fkg = _fesapi.eml23__UnitOfMeasure_J_x002fkg
eml23__UnitOfMeasure_J_x002fm = _fesapi.eml23__UnitOfMeasure_J_x002fm
eml23__UnitOfMeasure_J_x002fm2 = _fesapi.eml23__UnitOfMeasure_J_x002fm2
eml23__UnitOfMeasure_J_x002fm3 = _fesapi.eml23__UnitOfMeasure_J_x002fm3
eml23__UnitOfMeasure_J_x002fmol = _fesapi.eml23__UnitOfMeasure_J_x002fmol
eml23__UnitOfMeasure_J_x002fs = _fesapi.eml23__UnitOfMeasure_J_x002fs
eml23__UnitOfMeasure_K_x002em2_x002fkW = _fesapi.eml23__UnitOfMeasure_K_x002em2_x002fkW
eml23__UnitOfMeasure_K_x002em2_x002fW = _fesapi.eml23__UnitOfMeasure_K_x002em2_x002fW
eml23__UnitOfMeasure_K_x002fkm = _fesapi.eml23__UnitOfMeasure_K_x002fkm
eml23__UnitOfMeasure_K_x002fm = _fesapi.eml23__UnitOfMeasure_K_x002fm
eml23__UnitOfMeasure_K_x002fPa = _fesapi.eml23__UnitOfMeasure_K_x002fPa
eml23__UnitOfMeasure_K_x002fs = _fesapi.eml23__UnitOfMeasure_K_x002fs
eml23__UnitOfMeasure_K_x002fW = _fesapi.eml23__UnitOfMeasure_K_x002fW
eml23__UnitOfMeasure_kA = _fesapi.eml23__UnitOfMeasure_kA
eml23__UnitOfMeasure_ka_x005bt_x005d = _fesapi.eml23__UnitOfMeasure_ka_x005bt_x005d
eml23__UnitOfMeasure_kC = _fesapi.eml23__UnitOfMeasure_kC
eml23__UnitOfMeasure_kcal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_kcal_x005bth_x005d
eml23__UnitOfMeasure_kcal_x005bth_x005d_x002em_x002fcm2 = _fesapi.eml23__UnitOfMeasure_kcal_x005bth_x005d_x002em_x002fcm2
eml23__UnitOfMeasure_kcal_x005bth_x005d_x002f_x0028h_x002em_x002edegC_x0029 = _fesapi.eml23__UnitOfMeasure_kcal_x005bth_x005d_x002f_x0028h_x002em_x002edegC_x0029
eml23__UnitOfMeasure_kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = _fesapi.eml23__UnitOfMeasure_kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edegC_x0029
eml23__UnitOfMeasure_kcal_x005bth_x005d_x002f_x0028kg_x002edegC_x0029 = _fesapi.eml23__UnitOfMeasure_kcal_x005bth_x005d_x002f_x0028kg_x002edegC_x0029
eml23__UnitOfMeasure_kcal_x005bth_x005d_x002fcm3 = _fesapi.eml23__UnitOfMeasure_kcal_x005bth_x005d_x002fcm3
eml23__UnitOfMeasure_kcal_x005bth_x005d_x002fg = _fesapi.eml23__UnitOfMeasure_kcal_x005bth_x005d_x002fg
eml23__UnitOfMeasure_kcal_x005bth_x005d_x002fh = _fesapi.eml23__UnitOfMeasure_kcal_x005bth_x005d_x002fh
eml23__UnitOfMeasure_kcal_x005bth_x005d_x002fkg = _fesapi.eml23__UnitOfMeasure_kcal_x005bth_x005d_x002fkg
eml23__UnitOfMeasure_kcal_x005bth_x005d_x002fm3 = _fesapi.eml23__UnitOfMeasure_kcal_x005bth_x005d_x002fm3
eml23__UnitOfMeasure_kcal_x005bth_x005d_x002fmol = _fesapi.eml23__UnitOfMeasure_kcal_x005bth_x005d_x002fmol
eml23__UnitOfMeasure_kcd = _fesapi.eml23__UnitOfMeasure_kcd
eml23__UnitOfMeasure_kdyne = _fesapi.eml23__UnitOfMeasure_kdyne
eml23__UnitOfMeasure_kEuc = _fesapi.eml23__UnitOfMeasure_kEuc
eml23__UnitOfMeasure_keV = _fesapi.eml23__UnitOfMeasure_keV
eml23__UnitOfMeasure_kF = _fesapi.eml23__UnitOfMeasure_kF
eml23__UnitOfMeasure_kg = _fesapi.eml23__UnitOfMeasure_kg
eml23__UnitOfMeasure_kg_x002em = _fesapi.eml23__UnitOfMeasure_kg_x002em
eml23__UnitOfMeasure_kg_x002em_x002fcm2 = _fesapi.eml23__UnitOfMeasure_kg_x002em_x002fcm2
eml23__UnitOfMeasure_kg_x002em_x002fs = _fesapi.eml23__UnitOfMeasure_kg_x002em_x002fs
eml23__UnitOfMeasure_kg_x002em2 = _fesapi.eml23__UnitOfMeasure_kg_x002em2
eml23__UnitOfMeasure_kg_x002f_x0028kW_x002eh_x0029 = _fesapi.eml23__UnitOfMeasure_kg_x002f_x0028kW_x002eh_x0029
eml23__UnitOfMeasure_kg_x002f_x0028m_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_kg_x002f_x0028m_x002es_x0029
eml23__UnitOfMeasure_kg_x002f_x0028m2_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_kg_x002f_x0028m2_x002es_x0029
eml23__UnitOfMeasure_kg_x002fd = _fesapi.eml23__UnitOfMeasure_kg_x002fd
eml23__UnitOfMeasure_kg_x002fdm3 = _fesapi.eml23__UnitOfMeasure_kg_x002fdm3
eml23__UnitOfMeasure_kg_x002fdm4 = _fesapi.eml23__UnitOfMeasure_kg_x002fdm4
eml23__UnitOfMeasure_kg_x002fh = _fesapi.eml23__UnitOfMeasure_kg_x002fh
eml23__UnitOfMeasure_kg_x002fJ = _fesapi.eml23__UnitOfMeasure_kg_x002fJ
eml23__UnitOfMeasure_kg_x002fkg = _fesapi.eml23__UnitOfMeasure_kg_x002fkg
eml23__UnitOfMeasure_kg_x002fL = _fesapi.eml23__UnitOfMeasure_kg_x002fL
eml23__UnitOfMeasure_kg_x002fm = _fesapi.eml23__UnitOfMeasure_kg_x002fm
eml23__UnitOfMeasure_kg_x002fm2 = _fesapi.eml23__UnitOfMeasure_kg_x002fm2
eml23__UnitOfMeasure_kg_x002fm3 = _fesapi.eml23__UnitOfMeasure_kg_x002fm3
eml23__UnitOfMeasure_kg_x002fm4 = _fesapi.eml23__UnitOfMeasure_kg_x002fm4
eml23__UnitOfMeasure_kg_x002fmin = _fesapi.eml23__UnitOfMeasure_kg_x002fmin
eml23__UnitOfMeasure_kg_x002fMJ = _fesapi.eml23__UnitOfMeasure_kg_x002fMJ
eml23__UnitOfMeasure_kg_x002fmol = _fesapi.eml23__UnitOfMeasure_kg_x002fmol
eml23__UnitOfMeasure_kg_x002fs = _fesapi.eml23__UnitOfMeasure_kg_x002fs
eml23__UnitOfMeasure_kg_x002fsack_x005b94lbm_x005d = _fesapi.eml23__UnitOfMeasure_kg_x002fsack_x005b94lbm_x005d
eml23__UnitOfMeasure_kg_x002ft = _fesapi.eml23__UnitOfMeasure_kg_x002ft
eml23__UnitOfMeasure_kgauss = _fesapi.eml23__UnitOfMeasure_kgauss
eml23__UnitOfMeasure_kgf = _fesapi.eml23__UnitOfMeasure_kgf
eml23__UnitOfMeasure_kgf_x002em = _fesapi.eml23__UnitOfMeasure_kgf_x002em
eml23__UnitOfMeasure_kgf_x002em_x002fcm2 = _fesapi.eml23__UnitOfMeasure_kgf_x002em_x002fcm2
eml23__UnitOfMeasure_kgf_x002em_x002fm = _fesapi.eml23__UnitOfMeasure_kgf_x002em_x002fm
eml23__UnitOfMeasure_kgf_x002em2 = _fesapi.eml23__UnitOfMeasure_kgf_x002em2
eml23__UnitOfMeasure_kgf_x002es_x002fm2 = _fesapi.eml23__UnitOfMeasure_kgf_x002es_x002fm2
eml23__UnitOfMeasure_kgf_x002fcm = _fesapi.eml23__UnitOfMeasure_kgf_x002fcm
eml23__UnitOfMeasure_kgf_x002fcm2 = _fesapi.eml23__UnitOfMeasure_kgf_x002fcm2
eml23__UnitOfMeasure_kgf_x002fkgf = _fesapi.eml23__UnitOfMeasure_kgf_x002fkgf
eml23__UnitOfMeasure_kgf_x002fm2 = _fesapi.eml23__UnitOfMeasure_kgf_x002fm2
eml23__UnitOfMeasure_kgf_x002fmm2 = _fesapi.eml23__UnitOfMeasure_kgf_x002fmm2
eml23__UnitOfMeasure_kGy = _fesapi.eml23__UnitOfMeasure_kGy
eml23__UnitOfMeasure_kH = _fesapi.eml23__UnitOfMeasure_kH
eml23__UnitOfMeasure_kHz = _fesapi.eml23__UnitOfMeasure_kHz
eml23__UnitOfMeasure_Kibyte = _fesapi.eml23__UnitOfMeasure_Kibyte
eml23__UnitOfMeasure_kJ = _fesapi.eml23__UnitOfMeasure_kJ
eml23__UnitOfMeasure_kJ_x002em_x002f_x0028h_x002em2_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_kJ_x002em_x002f_x0028h_x002em2_x002eK_x0029
eml23__UnitOfMeasure_kJ_x002f_x0028h_x002em2_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_kJ_x002f_x0028h_x002em2_x002eK_x0029
eml23__UnitOfMeasure_kJ_x002f_x0028kg_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_kJ_x002f_x0028kg_x002eK_x0029
eml23__UnitOfMeasure_kJ_x002f_x0028kmol_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_kJ_x002f_x0028kmol_x002eK_x0029
eml23__UnitOfMeasure_kJ_x002fdm3 = _fesapi.eml23__UnitOfMeasure_kJ_x002fdm3
eml23__UnitOfMeasure_kJ_x002fkg = _fesapi.eml23__UnitOfMeasure_kJ_x002fkg
eml23__UnitOfMeasure_kJ_x002fkmol = _fesapi.eml23__UnitOfMeasure_kJ_x002fkmol
eml23__UnitOfMeasure_kJ_x002fm3 = _fesapi.eml23__UnitOfMeasure_kJ_x002fm3
eml23__UnitOfMeasure_klbf = _fesapi.eml23__UnitOfMeasure_klbf
eml23__UnitOfMeasure_klbm = _fesapi.eml23__UnitOfMeasure_klbm
eml23__UnitOfMeasure_klbm_x002fin = _fesapi.eml23__UnitOfMeasure_klbm_x002fin
eml23__UnitOfMeasure_klx = _fesapi.eml23__UnitOfMeasure_klx
eml23__UnitOfMeasure_km = _fesapi.eml23__UnitOfMeasure_km
eml23__UnitOfMeasure_km_x002fcm = _fesapi.eml23__UnitOfMeasure_km_x002fcm
eml23__UnitOfMeasure_km_x002fdm3 = _fesapi.eml23__UnitOfMeasure_km_x002fdm3
eml23__UnitOfMeasure_km_x002fh = _fesapi.eml23__UnitOfMeasure_km_x002fh
eml23__UnitOfMeasure_km_x002fL = _fesapi.eml23__UnitOfMeasure_km_x002fL
eml23__UnitOfMeasure_km_x002fs = _fesapi.eml23__UnitOfMeasure_km_x002fs
eml23__UnitOfMeasure_km2 = _fesapi.eml23__UnitOfMeasure_km2
eml23__UnitOfMeasure_km3 = _fesapi.eml23__UnitOfMeasure_km3
eml23__UnitOfMeasure_kmol = _fesapi.eml23__UnitOfMeasure_kmol
eml23__UnitOfMeasure_kmol_x002fh = _fesapi.eml23__UnitOfMeasure_kmol_x002fh
eml23__UnitOfMeasure_kmol_x002fm3 = _fesapi.eml23__UnitOfMeasure_kmol_x002fm3
eml23__UnitOfMeasure_kmol_x002fs = _fesapi.eml23__UnitOfMeasure_kmol_x002fs
eml23__UnitOfMeasure_kN = _fesapi.eml23__UnitOfMeasure_kN
eml23__UnitOfMeasure_kN_x002em = _fesapi.eml23__UnitOfMeasure_kN_x002em
eml23__UnitOfMeasure_kN_x002em2 = _fesapi.eml23__UnitOfMeasure_kN_x002em2
eml23__UnitOfMeasure_kN_x002fm = _fesapi.eml23__UnitOfMeasure_kN_x002fm
eml23__UnitOfMeasure_kN_x002fm2 = _fesapi.eml23__UnitOfMeasure_kN_x002fm2
eml23__UnitOfMeasure_knot = _fesapi.eml23__UnitOfMeasure_knot
eml23__UnitOfMeasure_kohm = _fesapi.eml23__UnitOfMeasure_kohm
eml23__UnitOfMeasure_kohm_x002em = _fesapi.eml23__UnitOfMeasure_kohm_x002em
eml23__UnitOfMeasure_kP = _fesapi.eml23__UnitOfMeasure_kP
eml23__UnitOfMeasure_kPa = _fesapi.eml23__UnitOfMeasure_kPa
eml23__UnitOfMeasure_kPa_x002es_x002fm = _fesapi.eml23__UnitOfMeasure_kPa_x002es_x002fm
eml23__UnitOfMeasure_kPa_x002fh = _fesapi.eml23__UnitOfMeasure_kPa_x002fh
eml23__UnitOfMeasure_kPa_x002fhm = _fesapi.eml23__UnitOfMeasure_kPa_x002fhm
eml23__UnitOfMeasure_kPa_x002fm = _fesapi.eml23__UnitOfMeasure_kPa_x002fm
eml23__UnitOfMeasure_kPa_x002fmin = _fesapi.eml23__UnitOfMeasure_kPa_x002fmin
eml23__UnitOfMeasure_kPa2 = _fesapi.eml23__UnitOfMeasure_kPa2
eml23__UnitOfMeasure_kPa2_x002fcP = _fesapi.eml23__UnitOfMeasure_kPa2_x002fcP
eml23__UnitOfMeasure_kpsi = _fesapi.eml23__UnitOfMeasure_kpsi
eml23__UnitOfMeasure_kpsi2 = _fesapi.eml23__UnitOfMeasure_kpsi2
eml23__UnitOfMeasure_krad = _fesapi.eml23__UnitOfMeasure_krad
eml23__UnitOfMeasure_krd = _fesapi.eml23__UnitOfMeasure_krd
eml23__UnitOfMeasure_kS = _fesapi.eml23__UnitOfMeasure_kS
eml23__UnitOfMeasure_kS_x002fm = _fesapi.eml23__UnitOfMeasure_kS_x002fm
eml23__UnitOfMeasure_kT = _fesapi.eml23__UnitOfMeasure_kT
eml23__UnitOfMeasure_kV = _fesapi.eml23__UnitOfMeasure_kV
eml23__UnitOfMeasure_kW = _fesapi.eml23__UnitOfMeasure_kW
eml23__UnitOfMeasure_kW_x002eh = _fesapi.eml23__UnitOfMeasure_kW_x002eh
eml23__UnitOfMeasure_kW_x002eh_x002f_x0028kg_x002edegC_x0029 = _fesapi.eml23__UnitOfMeasure_kW_x002eh_x002f_x0028kg_x002edegC_x0029
eml23__UnitOfMeasure_kW_x002eh_x002fdm3 = _fesapi.eml23__UnitOfMeasure_kW_x002eh_x002fdm3
eml23__UnitOfMeasure_kW_x002eh_x002fkg = _fesapi.eml23__UnitOfMeasure_kW_x002eh_x002fkg
eml23__UnitOfMeasure_kW_x002eh_x002fm3 = _fesapi.eml23__UnitOfMeasure_kW_x002eh_x002fm3
eml23__UnitOfMeasure_kW_x002f_x0028m2_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_kW_x002f_x0028m2_x002eK_x0029
eml23__UnitOfMeasure_kW_x002f_x0028m3_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_kW_x002f_x0028m3_x002eK_x0029
eml23__UnitOfMeasure_kW_x002fcm2 = _fesapi.eml23__UnitOfMeasure_kW_x002fcm2
eml23__UnitOfMeasure_kW_x002fm2 = _fesapi.eml23__UnitOfMeasure_kW_x002fm2
eml23__UnitOfMeasure_kW_x002fm3 = _fesapi.eml23__UnitOfMeasure_kW_x002fm3
eml23__UnitOfMeasure_kWb = _fesapi.eml23__UnitOfMeasure_kWb
eml23__UnitOfMeasure_L_x002f_x0028bar_x002emin_x0029 = _fesapi.eml23__UnitOfMeasure_L_x002f_x0028bar_x002emin_x0029
eml23__UnitOfMeasure_L_x002fh = _fesapi.eml23__UnitOfMeasure_L_x002fh
eml23__UnitOfMeasure_L_x002fkg = _fesapi.eml23__UnitOfMeasure_L_x002fkg
eml23__UnitOfMeasure_L_x002fkmol = _fesapi.eml23__UnitOfMeasure_L_x002fkmol
eml23__UnitOfMeasure_L_x002fm = _fesapi.eml23__UnitOfMeasure_L_x002fm
eml23__UnitOfMeasure_L_x002fm3 = _fesapi.eml23__UnitOfMeasure_L_x002fm3
eml23__UnitOfMeasure_L_x002fmin = _fesapi.eml23__UnitOfMeasure_L_x002fmin
eml23__UnitOfMeasure_L_x002fmol = _fesapi.eml23__UnitOfMeasure_L_x002fmol
eml23__UnitOfMeasure_L_x002fs = _fesapi.eml23__UnitOfMeasure_L_x002fs
eml23__UnitOfMeasure_L_x002fs2 = _fesapi.eml23__UnitOfMeasure_L_x002fs2
eml23__UnitOfMeasure_L_x002ft = _fesapi.eml23__UnitOfMeasure_L_x002ft
eml23__UnitOfMeasure_L_x002fton_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_L_x002fton_x005bUK_x005d
eml23__UnitOfMeasure_lbf = _fesapi.eml23__UnitOfMeasure_lbf
eml23__UnitOfMeasure_lbf_x002eft = _fesapi.eml23__UnitOfMeasure_lbf_x002eft
eml23__UnitOfMeasure_lbf_x002eft_x002fbbl = _fesapi.eml23__UnitOfMeasure_lbf_x002eft_x002fbbl
eml23__UnitOfMeasure_lbf_x002eft_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_lbf_x002eft_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure_lbf_x002eft_x002fin = _fesapi.eml23__UnitOfMeasure_lbf_x002eft_x002fin
eml23__UnitOfMeasure_lbf_x002eft_x002fin2 = _fesapi.eml23__UnitOfMeasure_lbf_x002eft_x002fin2
eml23__UnitOfMeasure_lbf_x002eft_x002flbm = _fesapi.eml23__UnitOfMeasure_lbf_x002eft_x002flbm
eml23__UnitOfMeasure_lbf_x002eft_x002fmin = _fesapi.eml23__UnitOfMeasure_lbf_x002eft_x002fmin
eml23__UnitOfMeasure_lbf_x002eft_x002fs = _fesapi.eml23__UnitOfMeasure_lbf_x002eft_x002fs
eml23__UnitOfMeasure_lbf_x002ein = _fesapi.eml23__UnitOfMeasure_lbf_x002ein
eml23__UnitOfMeasure_lbf_x002ein_x002fin = _fesapi.eml23__UnitOfMeasure_lbf_x002ein_x002fin
eml23__UnitOfMeasure_lbf_x002ein2 = _fesapi.eml23__UnitOfMeasure_lbf_x002ein2
eml23__UnitOfMeasure_lbf_x002es_x002fft2 = _fesapi.eml23__UnitOfMeasure_lbf_x002es_x002fft2
eml23__UnitOfMeasure_lbf_x002es_x002fin2 = _fesapi.eml23__UnitOfMeasure_lbf_x002es_x002fin2
eml23__UnitOfMeasure_lbf_x002fft = _fesapi.eml23__UnitOfMeasure_lbf_x002fft
eml23__UnitOfMeasure_lbf_x002fft2 = _fesapi.eml23__UnitOfMeasure_lbf_x002fft2
eml23__UnitOfMeasure_lbf_x002fft3 = _fesapi.eml23__UnitOfMeasure_lbf_x002fft3
eml23__UnitOfMeasure_lbf_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_lbf_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure_lbf_x002fin = _fesapi.eml23__UnitOfMeasure_lbf_x002fin
eml23__UnitOfMeasure_lbf_x002flbf = _fesapi.eml23__UnitOfMeasure_lbf_x002flbf
eml23__UnitOfMeasure_lbm = _fesapi.eml23__UnitOfMeasure_lbm
eml23__UnitOfMeasure_lbm_x002eft = _fesapi.eml23__UnitOfMeasure_lbm_x002eft
eml23__UnitOfMeasure_lbm_x002eft_x002fs = _fesapi.eml23__UnitOfMeasure_lbm_x002eft_x002fs
eml23__UnitOfMeasure_lbm_x002eft2 = _fesapi.eml23__UnitOfMeasure_lbm_x002eft2
eml23__UnitOfMeasure_lbm_x002eft2_x002fs2 = _fesapi.eml23__UnitOfMeasure_lbm_x002eft2_x002fs2
eml23__UnitOfMeasure_lbm_x002f_x0028ft_x002eh_x0029 = _fesapi.eml23__UnitOfMeasure_lbm_x002f_x0028ft_x002eh_x0029
eml23__UnitOfMeasure_lbm_x002f_x0028ft_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_lbm_x002f_x0028ft_x002es_x0029
eml23__UnitOfMeasure_lbm_x002f_x0028ft2_x002eh_x0029 = _fesapi.eml23__UnitOfMeasure_lbm_x002f_x0028ft2_x002eh_x0029
eml23__UnitOfMeasure_lbm_x002f_x0028ft2_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_lbm_x002f_x0028ft2_x002es_x0029
eml23__UnitOfMeasure_lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure_lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029
eml23__UnitOfMeasure_lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure_lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029
eml23__UnitOfMeasure_lbm_x002f_x0028hp_x002eh_x0029 = _fesapi.eml23__UnitOfMeasure_lbm_x002f_x0028hp_x002eh_x0029
eml23__UnitOfMeasure_lbm_x002fbbl = _fesapi.eml23__UnitOfMeasure_lbm_x002fbbl
eml23__UnitOfMeasure_lbm_x002fd = _fesapi.eml23__UnitOfMeasure_lbm_x002fd
eml23__UnitOfMeasure_lbm_x002fft = _fesapi.eml23__UnitOfMeasure_lbm_x002fft
eml23__UnitOfMeasure_lbm_x002fft2 = _fesapi.eml23__UnitOfMeasure_lbm_x002fft2
eml23__UnitOfMeasure_lbm_x002fft3 = _fesapi.eml23__UnitOfMeasure_lbm_x002fft3
eml23__UnitOfMeasure_lbm_x002fft4 = _fesapi.eml23__UnitOfMeasure_lbm_x002fft4
eml23__UnitOfMeasure_lbm_x002fgal_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_lbm_x002fgal_x005bUK_x005d
eml23__UnitOfMeasure_lbm_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_lbm_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure_lbm_x002fh = _fesapi.eml23__UnitOfMeasure_lbm_x002fh
eml23__UnitOfMeasure_lbm_x002fin3 = _fesapi.eml23__UnitOfMeasure_lbm_x002fin3
eml23__UnitOfMeasure_lbm_x002flbmol = _fesapi.eml23__UnitOfMeasure_lbm_x002flbmol
eml23__UnitOfMeasure_lbm_x002fmin = _fesapi.eml23__UnitOfMeasure_lbm_x002fmin
eml23__UnitOfMeasure_lbm_x002fs = _fesapi.eml23__UnitOfMeasure_lbm_x002fs
eml23__UnitOfMeasure_lbmol = _fesapi.eml23__UnitOfMeasure_lbmol
eml23__UnitOfMeasure_lbmol_x002f_x0028h_x002eft2_x0029 = _fesapi.eml23__UnitOfMeasure_lbmol_x002f_x0028h_x002eft2_x0029
eml23__UnitOfMeasure_lbmol_x002f_x0028s_x002eft2_x0029 = _fesapi.eml23__UnitOfMeasure_lbmol_x002f_x0028s_x002eft2_x0029
eml23__UnitOfMeasure_lbmol_x002fft3 = _fesapi.eml23__UnitOfMeasure_lbmol_x002fft3
eml23__UnitOfMeasure_lbmol_x002fgal_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_lbmol_x002fgal_x005bUK_x005d
eml23__UnitOfMeasure_lbmol_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_lbmol_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure_lbmol_x002fh = _fesapi.eml23__UnitOfMeasure_lbmol_x002fh
eml23__UnitOfMeasure_lbmol_x002fs = _fesapi.eml23__UnitOfMeasure_lbmol_x002fs
eml23__UnitOfMeasure_link = _fesapi.eml23__UnitOfMeasure_link
eml23__UnitOfMeasure_link_x005bBnA_x005d = _fesapi.eml23__UnitOfMeasure_link_x005bBnA_x005d
eml23__UnitOfMeasure_link_x005bBnB_x005d = _fesapi.eml23__UnitOfMeasure_link_x005bBnB_x005d
eml23__UnitOfMeasure_link_x005bCla_x005d = _fesapi.eml23__UnitOfMeasure_link_x005bCla_x005d
eml23__UnitOfMeasure_link_x005bSe_x005d = _fesapi.eml23__UnitOfMeasure_link_x005bSe_x005d
eml23__UnitOfMeasure_link_x005bSeT_x005d = _fesapi.eml23__UnitOfMeasure_link_x005bSeT_x005d
eml23__UnitOfMeasure_link_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_link_x005bUS_x005d
eml23__UnitOfMeasure_lm = _fesapi.eml23__UnitOfMeasure_lm
eml23__UnitOfMeasure_lm_x002es = _fesapi.eml23__UnitOfMeasure_lm_x002es
eml23__UnitOfMeasure_lm_x002fm2 = _fesapi.eml23__UnitOfMeasure_lm_x002fm2
eml23__UnitOfMeasure_lm_x002fW = _fesapi.eml23__UnitOfMeasure_lm_x002fW
eml23__UnitOfMeasure_lx = _fesapi.eml23__UnitOfMeasure_lx
eml23__UnitOfMeasure_lx_x002es = _fesapi.eml23__UnitOfMeasure_lx_x002es
eml23__UnitOfMeasure_m_x002f_x0028m_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_m_x002f_x0028m_x002eK_x0029
eml23__UnitOfMeasure_m_x002fcm = _fesapi.eml23__UnitOfMeasure_m_x002fcm
eml23__UnitOfMeasure_m_x002fd = _fesapi.eml23__UnitOfMeasure_m_x002fd
eml23__UnitOfMeasure_m_x002fdega = _fesapi.eml23__UnitOfMeasure_m_x002fdega
eml23__UnitOfMeasure_m_x002fh = _fesapi.eml23__UnitOfMeasure_m_x002fh
eml23__UnitOfMeasure_m_x002fK = _fesapi.eml23__UnitOfMeasure_m_x002fK
eml23__UnitOfMeasure_m_x002fkg = _fesapi.eml23__UnitOfMeasure_m_x002fkg
eml23__UnitOfMeasure_m_x002fkm = _fesapi.eml23__UnitOfMeasure_m_x002fkm
eml23__UnitOfMeasure_m_x002fkPa = _fesapi.eml23__UnitOfMeasure_m_x002fkPa
eml23__UnitOfMeasure_m_x002fm = _fesapi.eml23__UnitOfMeasure_m_x002fm
eml23__UnitOfMeasure_m_x002fm3 = _fesapi.eml23__UnitOfMeasure_m_x002fm3
eml23__UnitOfMeasure_m_x002fmin = _fesapi.eml23__UnitOfMeasure_m_x002fmin
eml23__UnitOfMeasure_m_x002fms = _fesapi.eml23__UnitOfMeasure_m_x002fms
eml23__UnitOfMeasure_m_x002fPa = _fesapi.eml23__UnitOfMeasure_m_x002fPa
eml23__UnitOfMeasure_m_x002frad = _fesapi.eml23__UnitOfMeasure_m_x002frad
eml23__UnitOfMeasure_m_x002frev = _fesapi.eml23__UnitOfMeasure_m_x002frev
eml23__UnitOfMeasure_m_x002fs = _fesapi.eml23__UnitOfMeasure_m_x002fs
eml23__UnitOfMeasure_m_x002fs2 = _fesapi.eml23__UnitOfMeasure_m_x002fs2
eml23__UnitOfMeasure_m_x005bGer_x005d = _fesapi.eml23__UnitOfMeasure_m_x005bGer_x005d
eml23__UnitOfMeasure_m2 = _fesapi.eml23__UnitOfMeasure_m2
eml23__UnitOfMeasure_m2_x002f_x0028kPa_x002ed_x0029 = _fesapi.eml23__UnitOfMeasure_m2_x002f_x0028kPa_x002ed_x0029
eml23__UnitOfMeasure_m2_x002f_x0028Pa_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_m2_x002f_x0028Pa_x002es_x0029
eml23__UnitOfMeasure_m2_x002fcm3 = _fesapi.eml23__UnitOfMeasure_m2_x002fcm3
eml23__UnitOfMeasure_m2_x002fd = _fesapi.eml23__UnitOfMeasure_m2_x002fd
eml23__UnitOfMeasure_m2_x002fg = _fesapi.eml23__UnitOfMeasure_m2_x002fg
eml23__UnitOfMeasure_m2_x002fh = _fesapi.eml23__UnitOfMeasure_m2_x002fh
eml23__UnitOfMeasure_m2_x002fkg = _fesapi.eml23__UnitOfMeasure_m2_x002fkg
eml23__UnitOfMeasure_m2_x002fm2 = _fesapi.eml23__UnitOfMeasure_m2_x002fm2
eml23__UnitOfMeasure_m2_x002fm3 = _fesapi.eml23__UnitOfMeasure_m2_x002fm3
eml23__UnitOfMeasure_m2_x002fmol = _fesapi.eml23__UnitOfMeasure_m2_x002fmol
eml23__UnitOfMeasure_m2_x002fs = _fesapi.eml23__UnitOfMeasure_m2_x002fs
eml23__UnitOfMeasure_m3 = _fesapi.eml23__UnitOfMeasure_m3
eml23__UnitOfMeasure_m3_x002f_x0028bar_x002ed_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028bar_x002ed_x0029
eml23__UnitOfMeasure_m3_x002f_x0028bar_x002eh_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028bar_x002eh_x0029
eml23__UnitOfMeasure_m3_x002f_x0028bar_x002emin_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028bar_x002emin_x0029
eml23__UnitOfMeasure_m3_x002f_x0028d_x002em_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028d_x002em_x0029
eml23__UnitOfMeasure_m3_x002f_x0028h_x002em_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028h_x002em_x0029
eml23__UnitOfMeasure_m3_x002f_x0028ha_x002em_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028ha_x002em_x0029
eml23__UnitOfMeasure_m3_x002f_x0028kPa_x002ed_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028kPa_x002ed_x0029
eml23__UnitOfMeasure_m3_x002f_x0028kPa_x002eh_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028kPa_x002eh_x0029
eml23__UnitOfMeasure_m3_x002f_x0028kW_x002eh_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028kW_x002eh_x0029
eml23__UnitOfMeasure_m3_x002f_x0028m3_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028m3_x002eK_x0029
eml23__UnitOfMeasure_m3_x002f_x0028Pa_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028Pa_x002es_x0029
eml23__UnitOfMeasure_m3_x002f_x0028psi_x002ed_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028psi_x002ed_x0029
eml23__UnitOfMeasure_m3_x002f_x0028s_x002eft_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028s_x002eft_x0029
eml23__UnitOfMeasure_m3_x002f_x0028s_x002em_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028s_x002em_x0029
eml23__UnitOfMeasure_m3_x002f_x0028s_x002em2_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028s_x002em2_x0029
eml23__UnitOfMeasure_m3_x002f_x0028s_x002em3_x0029 = _fesapi.eml23__UnitOfMeasure_m3_x002f_x0028s_x002em3_x0029
eml23__UnitOfMeasure_m3_x002fbbl = _fesapi.eml23__UnitOfMeasure_m3_x002fbbl
eml23__UnitOfMeasure_m3_x002fd = _fesapi.eml23__UnitOfMeasure_m3_x002fd
eml23__UnitOfMeasure_m3_x002fd2 = _fesapi.eml23__UnitOfMeasure_m3_x002fd2
eml23__UnitOfMeasure_m3_x002fg = _fesapi.eml23__UnitOfMeasure_m3_x002fg
eml23__UnitOfMeasure_m3_x002fh = _fesapi.eml23__UnitOfMeasure_m3_x002fh
eml23__UnitOfMeasure_m3_x002fJ = _fesapi.eml23__UnitOfMeasure_m3_x002fJ
eml23__UnitOfMeasure_m3_x002fkg = _fesapi.eml23__UnitOfMeasure_m3_x002fkg
eml23__UnitOfMeasure_m3_x002fkm = _fesapi.eml23__UnitOfMeasure_m3_x002fkm
eml23__UnitOfMeasure_m3_x002fkmol = _fesapi.eml23__UnitOfMeasure_m3_x002fkmol
eml23__UnitOfMeasure_m3_x002fkPa = _fesapi.eml23__UnitOfMeasure_m3_x002fkPa
eml23__UnitOfMeasure_m3_x002fm = _fesapi.eml23__UnitOfMeasure_m3_x002fm
eml23__UnitOfMeasure_m3_x002fm2 = _fesapi.eml23__UnitOfMeasure_m3_x002fm2
eml23__UnitOfMeasure_m3_x002fm3 = _fesapi.eml23__UnitOfMeasure_m3_x002fm3
eml23__UnitOfMeasure_m3_x002fmin = _fesapi.eml23__UnitOfMeasure_m3_x002fmin
eml23__UnitOfMeasure_m3_x002fmol = _fesapi.eml23__UnitOfMeasure_m3_x002fmol
eml23__UnitOfMeasure_m3_x002fPa = _fesapi.eml23__UnitOfMeasure_m3_x002fPa
eml23__UnitOfMeasure_m3_x002frad = _fesapi.eml23__UnitOfMeasure_m3_x002frad
eml23__UnitOfMeasure_m3_x002frev = _fesapi.eml23__UnitOfMeasure_m3_x002frev
eml23__UnitOfMeasure_m3_x002fs = _fesapi.eml23__UnitOfMeasure_m3_x002fs
eml23__UnitOfMeasure_m3_x002fs2 = _fesapi.eml23__UnitOfMeasure_m3_x002fs2
eml23__UnitOfMeasure_m3_x002ft = _fesapi.eml23__UnitOfMeasure_m3_x002ft
eml23__UnitOfMeasure_m3_x002fton_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_m3_x002fton_x005bUK_x005d
eml23__UnitOfMeasure_m3_x002fton_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_m3_x002fton_x005bUS_x005d
eml23__UnitOfMeasure_m4 = _fesapi.eml23__UnitOfMeasure_m4
eml23__UnitOfMeasure_m4_x002fs = _fesapi.eml23__UnitOfMeasure_m4_x002fs
eml23__UnitOfMeasure_MA = _fesapi.eml23__UnitOfMeasure_MA
eml23__UnitOfMeasure_mA = _fesapi.eml23__UnitOfMeasure_mA
eml23__UnitOfMeasure_mA_x002fcm2 = _fesapi.eml23__UnitOfMeasure_mA_x002fcm2
eml23__UnitOfMeasure_mA_x002fft2 = _fesapi.eml23__UnitOfMeasure_mA_x002fft2
eml23__UnitOfMeasure_Ma_x005bt_x005d = _fesapi.eml23__UnitOfMeasure_Ma_x005bt_x005d
eml23__UnitOfMeasure_mbar = _fesapi.eml23__UnitOfMeasure_mbar
eml23__UnitOfMeasure_MBq = _fesapi.eml23__UnitOfMeasure_MBq
eml23__UnitOfMeasure_MC = _fesapi.eml23__UnitOfMeasure_MC
eml23__UnitOfMeasure_mC = _fesapi.eml23__UnitOfMeasure_mC
eml23__UnitOfMeasure_mC_x002fm2 = _fesapi.eml23__UnitOfMeasure_mC_x002fm2
eml23__UnitOfMeasure_Mcal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_Mcal_x005bth_x005d
eml23__UnitOfMeasure_mcal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_mcal_x005bth_x005d
eml23__UnitOfMeasure_mCi = _fesapi.eml23__UnitOfMeasure_mCi
eml23__UnitOfMeasure_mD = _fesapi.eml23__UnitOfMeasure_mD
eml23__UnitOfMeasure_mD_x002eft = _fesapi.eml23__UnitOfMeasure_mD_x002eft
eml23__UnitOfMeasure_mD_x002eft2_x002f_x0028lbf_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_mD_x002eft2_x002f_x0028lbf_x002es_x0029
eml23__UnitOfMeasure_mD_x002ein2_x002f_x0028lbf_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_mD_x002ein2_x002f_x0028lbf_x002es_x0029
eml23__UnitOfMeasure_mD_x002em = _fesapi.eml23__UnitOfMeasure_mD_x002em
eml23__UnitOfMeasure_mD_x002f_x0028Pa_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_mD_x002f_x0028Pa_x002es_x0029
eml23__UnitOfMeasure_mD_x002fcP = _fesapi.eml23__UnitOfMeasure_mD_x002fcP
eml23__UnitOfMeasure_mEuc = _fesapi.eml23__UnitOfMeasure_mEuc
eml23__UnitOfMeasure_MEuc = _fesapi.eml23__UnitOfMeasure_MEuc
eml23__UnitOfMeasure_MeV = _fesapi.eml23__UnitOfMeasure_MeV
eml23__UnitOfMeasure_meV = _fesapi.eml23__UnitOfMeasure_meV
eml23__UnitOfMeasure_MF = _fesapi.eml23__UnitOfMeasure_MF
eml23__UnitOfMeasure_mF = _fesapi.eml23__UnitOfMeasure_mF
eml23__UnitOfMeasure_mg = _fesapi.eml23__UnitOfMeasure_mg
eml23__UnitOfMeasure_Mg = _fesapi.eml23__UnitOfMeasure_Mg
eml23__UnitOfMeasure_Mg_x002fa = _fesapi.eml23__UnitOfMeasure_Mg_x002fa
eml23__UnitOfMeasure_Mg_x002fd = _fesapi.eml23__UnitOfMeasure_Mg_x002fd
eml23__UnitOfMeasure_mg_x002fdm3 = _fesapi.eml23__UnitOfMeasure_mg_x002fdm3
eml23__UnitOfMeasure_mg_x002fg = _fesapi.eml23__UnitOfMeasure_mg_x002fg
eml23__UnitOfMeasure_mg_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_mg_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure_Mg_x002fh = _fesapi.eml23__UnitOfMeasure_Mg_x002fh
eml23__UnitOfMeasure_Mg_x002fin = _fesapi.eml23__UnitOfMeasure_Mg_x002fin
eml23__UnitOfMeasure_mg_x002fJ = _fesapi.eml23__UnitOfMeasure_mg_x002fJ
eml23__UnitOfMeasure_mg_x002fkg = _fesapi.eml23__UnitOfMeasure_mg_x002fkg
eml23__UnitOfMeasure_mg_x002fL = _fesapi.eml23__UnitOfMeasure_mg_x002fL
eml23__UnitOfMeasure_Mg_x002fm2 = _fesapi.eml23__UnitOfMeasure_Mg_x002fm2
eml23__UnitOfMeasure_mg_x002fm3 = _fesapi.eml23__UnitOfMeasure_mg_x002fm3
eml23__UnitOfMeasure_Mg_x002fm3 = _fesapi.eml23__UnitOfMeasure_Mg_x002fm3
eml23__UnitOfMeasure_Mg_x002fmin = _fesapi.eml23__UnitOfMeasure_Mg_x002fmin
eml23__UnitOfMeasure_mGal = _fesapi.eml23__UnitOfMeasure_mGal
eml23__UnitOfMeasure_mgauss = _fesapi.eml23__UnitOfMeasure_mgauss
eml23__UnitOfMeasure_Mgauss = _fesapi.eml23__UnitOfMeasure_Mgauss
eml23__UnitOfMeasure_Mgf = _fesapi.eml23__UnitOfMeasure_Mgf
eml23__UnitOfMeasure_mgn = _fesapi.eml23__UnitOfMeasure_mgn
eml23__UnitOfMeasure_MGy = _fesapi.eml23__UnitOfMeasure_MGy
eml23__UnitOfMeasure_mGy = _fesapi.eml23__UnitOfMeasure_mGy
eml23__UnitOfMeasure_MH = _fesapi.eml23__UnitOfMeasure_MH
eml23__UnitOfMeasure_mH = _fesapi.eml23__UnitOfMeasure_mH
eml23__UnitOfMeasure_MHz = _fesapi.eml23__UnitOfMeasure_MHz
eml23__UnitOfMeasure_mHz = _fesapi.eml23__UnitOfMeasure_mHz
eml23__UnitOfMeasure_mi = _fesapi.eml23__UnitOfMeasure_mi
eml23__UnitOfMeasure_mi_x002fgal_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_mi_x002fgal_x005bUK_x005d
eml23__UnitOfMeasure_mi_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_mi_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure_mi_x002fh = _fesapi.eml23__UnitOfMeasure_mi_x002fh
eml23__UnitOfMeasure_mi_x002fin = _fesapi.eml23__UnitOfMeasure_mi_x002fin
eml23__UnitOfMeasure_mi_x005bnaut_x005d = _fesapi.eml23__UnitOfMeasure_mi_x005bnaut_x005d
eml23__UnitOfMeasure_mi_x005bnautUK_x005d = _fesapi.eml23__UnitOfMeasure_mi_x005bnautUK_x005d
eml23__UnitOfMeasure_mi_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_mi_x005bUS_x005d
eml23__UnitOfMeasure_mi_x005bUS_x005d2 = _fesapi.eml23__UnitOfMeasure_mi_x005bUS_x005d2
eml23__UnitOfMeasure_mi2 = _fesapi.eml23__UnitOfMeasure_mi2
eml23__UnitOfMeasure_mi3 = _fesapi.eml23__UnitOfMeasure_mi3
eml23__UnitOfMeasure_Mibyte = _fesapi.eml23__UnitOfMeasure_Mibyte
eml23__UnitOfMeasure_mil = _fesapi.eml23__UnitOfMeasure_mil
eml23__UnitOfMeasure_mil_x002fa = _fesapi.eml23__UnitOfMeasure_mil_x002fa
eml23__UnitOfMeasure_mila = _fesapi.eml23__UnitOfMeasure_mila
eml23__UnitOfMeasure_min_ = _fesapi.eml23__UnitOfMeasure_min_
eml23__UnitOfMeasure_min_x002fft = _fesapi.eml23__UnitOfMeasure_min_x002fft
eml23__UnitOfMeasure_min_x002fm = _fesapi.eml23__UnitOfMeasure_min_x002fm
eml23__UnitOfMeasure_mina = _fesapi.eml23__UnitOfMeasure_mina
eml23__UnitOfMeasure_MJ = _fesapi.eml23__UnitOfMeasure_MJ
eml23__UnitOfMeasure_mJ = _fesapi.eml23__UnitOfMeasure_mJ
eml23__UnitOfMeasure_MJ_x002fa = _fesapi.eml23__UnitOfMeasure_MJ_x002fa
eml23__UnitOfMeasure_mJ_x002fcm2 = _fesapi.eml23__UnitOfMeasure_mJ_x002fcm2
eml23__UnitOfMeasure_MJ_x002fkg = _fesapi.eml23__UnitOfMeasure_MJ_x002fkg
eml23__UnitOfMeasure_MJ_x002fkmol = _fesapi.eml23__UnitOfMeasure_MJ_x002fkmol
eml23__UnitOfMeasure_MJ_x002fm = _fesapi.eml23__UnitOfMeasure_MJ_x002fm
eml23__UnitOfMeasure_mJ_x002fm2 = _fesapi.eml23__UnitOfMeasure_mJ_x002fm2
eml23__UnitOfMeasure_MJ_x002fm3 = _fesapi.eml23__UnitOfMeasure_MJ_x002fm3
eml23__UnitOfMeasure_mL = _fesapi.eml23__UnitOfMeasure_mL
eml23__UnitOfMeasure_mL_x002fgal_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_mL_x002fgal_x005bUK_x005d
eml23__UnitOfMeasure_mL_x002fgal_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_mL_x002fgal_x005bUS_x005d
eml23__UnitOfMeasure_mL_x002fmL = _fesapi.eml23__UnitOfMeasure_mL_x002fmL
eml23__UnitOfMeasure_mm = _fesapi.eml23__UnitOfMeasure_mm
eml23__UnitOfMeasure_Mm = _fesapi.eml23__UnitOfMeasure_Mm
eml23__UnitOfMeasure_mm_x002f_x0028mm_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_mm_x002f_x0028mm_x002eK_x0029
eml23__UnitOfMeasure_mm_x002fa = _fesapi.eml23__UnitOfMeasure_mm_x002fa
eml23__UnitOfMeasure_mm_x002fs = _fesapi.eml23__UnitOfMeasure_mm_x002fs
eml23__UnitOfMeasure_mm2 = _fesapi.eml23__UnitOfMeasure_mm2
eml23__UnitOfMeasure_mm2_x002fmm2 = _fesapi.eml23__UnitOfMeasure_mm2_x002fmm2
eml23__UnitOfMeasure_mm2_x002fs = _fesapi.eml23__UnitOfMeasure_mm2_x002fs
eml23__UnitOfMeasure_mm3 = _fesapi.eml23__UnitOfMeasure_mm3
eml23__UnitOfMeasure_mm3_x002fJ = _fesapi.eml23__UnitOfMeasure_mm3_x002fJ
eml23__UnitOfMeasure_mmHg_x005b0degC_x005d = _fesapi.eml23__UnitOfMeasure_mmHg_x005b0degC_x005d
eml23__UnitOfMeasure_mmol = _fesapi.eml23__UnitOfMeasure_mmol
eml23__UnitOfMeasure_MN = _fesapi.eml23__UnitOfMeasure_MN
eml23__UnitOfMeasure_mN = _fesapi.eml23__UnitOfMeasure_mN
eml23__UnitOfMeasure_mN_x002em2 = _fesapi.eml23__UnitOfMeasure_mN_x002em2
eml23__UnitOfMeasure_mN_x002fkm = _fesapi.eml23__UnitOfMeasure_mN_x002fkm
eml23__UnitOfMeasure_mN_x002fm = _fesapi.eml23__UnitOfMeasure_mN_x002fm
eml23__UnitOfMeasure_Mohm = _fesapi.eml23__UnitOfMeasure_Mohm
eml23__UnitOfMeasure_mohm = _fesapi.eml23__UnitOfMeasure_mohm
eml23__UnitOfMeasure_mol = _fesapi.eml23__UnitOfMeasure_mol
eml23__UnitOfMeasure_mol_x002em2_x002f_x0028mol_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_mol_x002em2_x002f_x0028mol_x002es_x0029
eml23__UnitOfMeasure_mol_x002f_x0028s_x002em2_x0029 = _fesapi.eml23__UnitOfMeasure_mol_x002f_x0028s_x002em2_x0029
eml23__UnitOfMeasure_mol_x002fm2 = _fesapi.eml23__UnitOfMeasure_mol_x002fm2
eml23__UnitOfMeasure_mol_x002fm3 = _fesapi.eml23__UnitOfMeasure_mol_x002fm3
eml23__UnitOfMeasure_mol_x002fmol = _fesapi.eml23__UnitOfMeasure_mol_x002fmol
eml23__UnitOfMeasure_mol_x002fs = _fesapi.eml23__UnitOfMeasure_mol_x002fs
eml23__UnitOfMeasure_MP = _fesapi.eml23__UnitOfMeasure_MP
eml23__UnitOfMeasure_mP = _fesapi.eml23__UnitOfMeasure_mP
eml23__UnitOfMeasure_MPa = _fesapi.eml23__UnitOfMeasure_MPa
eml23__UnitOfMeasure_mPa = _fesapi.eml23__UnitOfMeasure_mPa
eml23__UnitOfMeasure_mPa_x002es = _fesapi.eml23__UnitOfMeasure_mPa_x002es
eml23__UnitOfMeasure_MPa_x002es_x002fm = _fesapi.eml23__UnitOfMeasure_MPa_x002es_x002fm
eml23__UnitOfMeasure_MPa_x002fh = _fesapi.eml23__UnitOfMeasure_MPa_x002fh
eml23__UnitOfMeasure_MPa_x002fm = _fesapi.eml23__UnitOfMeasure_MPa_x002fm
eml23__UnitOfMeasure_Mpsi = _fesapi.eml23__UnitOfMeasure_Mpsi
eml23__UnitOfMeasure_mrad = _fesapi.eml23__UnitOfMeasure_mrad
eml23__UnitOfMeasure_Mrad = _fesapi.eml23__UnitOfMeasure_Mrad
eml23__UnitOfMeasure_Mrd = _fesapi.eml23__UnitOfMeasure_Mrd
eml23__UnitOfMeasure_mrd = _fesapi.eml23__UnitOfMeasure_mrd
eml23__UnitOfMeasure_mrem = _fesapi.eml23__UnitOfMeasure_mrem
eml23__UnitOfMeasure_mrem_x002fh = _fesapi.eml23__UnitOfMeasure_mrem_x002fh
eml23__UnitOfMeasure_ms = _fesapi.eml23__UnitOfMeasure_ms
eml23__UnitOfMeasure_MS = _fesapi.eml23__UnitOfMeasure_MS
eml23__UnitOfMeasure_mS = _fesapi.eml23__UnitOfMeasure_mS
eml23__UnitOfMeasure_ms_x002fcm = _fesapi.eml23__UnitOfMeasure_ms_x002fcm
eml23__UnitOfMeasure_mS_x002fcm = _fesapi.eml23__UnitOfMeasure_mS_x002fcm
eml23__UnitOfMeasure_ms_x002fft = _fesapi.eml23__UnitOfMeasure_ms_x002fft
eml23__UnitOfMeasure_ms_x002fin = _fesapi.eml23__UnitOfMeasure_ms_x002fin
eml23__UnitOfMeasure_mS_x002fm = _fesapi.eml23__UnitOfMeasure_mS_x002fm
eml23__UnitOfMeasure_ms_x002fm = _fesapi.eml23__UnitOfMeasure_ms_x002fm
eml23__UnitOfMeasure_ms_x002fs = _fesapi.eml23__UnitOfMeasure_ms_x002fs
eml23__UnitOfMeasure_mSv = _fesapi.eml23__UnitOfMeasure_mSv
eml23__UnitOfMeasure_mSv_x002fh = _fesapi.eml23__UnitOfMeasure_mSv_x002fh
eml23__UnitOfMeasure_mT = _fesapi.eml23__UnitOfMeasure_mT
eml23__UnitOfMeasure_mT_x002fdm = _fesapi.eml23__UnitOfMeasure_mT_x002fdm
eml23__UnitOfMeasure_mV = _fesapi.eml23__UnitOfMeasure_mV
eml23__UnitOfMeasure_MV = _fesapi.eml23__UnitOfMeasure_MV
eml23__UnitOfMeasure_mV_x002fft = _fesapi.eml23__UnitOfMeasure_mV_x002fft
eml23__UnitOfMeasure_mV_x002fm = _fesapi.eml23__UnitOfMeasure_mV_x002fm
eml23__UnitOfMeasure_mW = _fesapi.eml23__UnitOfMeasure_mW
eml23__UnitOfMeasure_MW = _fesapi.eml23__UnitOfMeasure_MW
eml23__UnitOfMeasure_MW_x002eh = _fesapi.eml23__UnitOfMeasure_MW_x002eh
eml23__UnitOfMeasure_MW_x002eh_x002fkg = _fesapi.eml23__UnitOfMeasure_MW_x002eh_x002fkg
eml23__UnitOfMeasure_MW_x002eh_x002fm3 = _fesapi.eml23__UnitOfMeasure_MW_x002eh_x002fm3
eml23__UnitOfMeasure_mW_x002fm2 = _fesapi.eml23__UnitOfMeasure_mW_x002fm2
eml23__UnitOfMeasure_mWb = _fesapi.eml23__UnitOfMeasure_mWb
eml23__UnitOfMeasure_MWb = _fesapi.eml23__UnitOfMeasure_MWb
eml23__UnitOfMeasure_N_x002em = _fesapi.eml23__UnitOfMeasure_N_x002em
eml23__UnitOfMeasure_N_x002em_x002fm = _fesapi.eml23__UnitOfMeasure_N_x002em_x002fm
eml23__UnitOfMeasure_N_x002em2 = _fesapi.eml23__UnitOfMeasure_N_x002em2
eml23__UnitOfMeasure_N_x002es_x002fm2 = _fesapi.eml23__UnitOfMeasure_N_x002es_x002fm2
eml23__UnitOfMeasure_N_x002fm = _fesapi.eml23__UnitOfMeasure_N_x002fm
eml23__UnitOfMeasure_N_x002fm2 = _fesapi.eml23__UnitOfMeasure_N_x002fm2
eml23__UnitOfMeasure_N_x002fm3 = _fesapi.eml23__UnitOfMeasure_N_x002fm3
eml23__UnitOfMeasure_N_x002fmm2 = _fesapi.eml23__UnitOfMeasure_N_x002fmm2
eml23__UnitOfMeasure_N_x002fN = _fesapi.eml23__UnitOfMeasure_N_x002fN
eml23__UnitOfMeasure_nA = _fesapi.eml23__UnitOfMeasure_nA
eml23__UnitOfMeasure_na = _fesapi.eml23__UnitOfMeasure_na
eml23__UnitOfMeasure_nAPI = _fesapi.eml23__UnitOfMeasure_nAPI
eml23__UnitOfMeasure_nC = _fesapi.eml23__UnitOfMeasure_nC
eml23__UnitOfMeasure_ncal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_ncal_x005bth_x005d
eml23__UnitOfMeasure_nCi = _fesapi.eml23__UnitOfMeasure_nCi
eml23__UnitOfMeasure_nEuc = _fesapi.eml23__UnitOfMeasure_nEuc
eml23__UnitOfMeasure_neV = _fesapi.eml23__UnitOfMeasure_neV
eml23__UnitOfMeasure_nF = _fesapi.eml23__UnitOfMeasure_nF
eml23__UnitOfMeasure_ng = _fesapi.eml23__UnitOfMeasure_ng
eml23__UnitOfMeasure_ng_x002fg = _fesapi.eml23__UnitOfMeasure_ng_x002fg
eml23__UnitOfMeasure_ng_x002fl = _fesapi.eml23__UnitOfMeasure_ng_x002fl
eml23__UnitOfMeasure_ng_x002fm3 = _fesapi.eml23__UnitOfMeasure_ng_x002fm3
eml23__UnitOfMeasure_ng_x002fmg = _fesapi.eml23__UnitOfMeasure_ng_x002fmg
eml23__UnitOfMeasure_ng_x002fml = _fesapi.eml23__UnitOfMeasure_ng_x002fml
eml23__UnitOfMeasure_ngauss = _fesapi.eml23__UnitOfMeasure_ngauss
eml23__UnitOfMeasure_nGy = _fesapi.eml23__UnitOfMeasure_nGy
eml23__UnitOfMeasure_nH = _fesapi.eml23__UnitOfMeasure_nH
eml23__UnitOfMeasure_nHz = _fesapi.eml23__UnitOfMeasure_nHz
eml23__UnitOfMeasure_nJ = _fesapi.eml23__UnitOfMeasure_nJ
eml23__UnitOfMeasure_nm = _fesapi.eml23__UnitOfMeasure_nm
eml23__UnitOfMeasure_nm_x002fs = _fesapi.eml23__UnitOfMeasure_nm_x002fs
eml23__UnitOfMeasure_nN = _fesapi.eml23__UnitOfMeasure_nN
eml23__UnitOfMeasure_nohm = _fesapi.eml23__UnitOfMeasure_nohm
eml23__UnitOfMeasure_nohm_x002emil2_x002fft = _fesapi.eml23__UnitOfMeasure_nohm_x002emil2_x002fft
eml23__UnitOfMeasure_nohm_x002emm2_x002fm = _fesapi.eml23__UnitOfMeasure_nohm_x002emm2_x002fm
eml23__UnitOfMeasure_nP = _fesapi.eml23__UnitOfMeasure_nP
eml23__UnitOfMeasure_nPa = _fesapi.eml23__UnitOfMeasure_nPa
eml23__UnitOfMeasure_nrd = _fesapi.eml23__UnitOfMeasure_nrd
eml23__UnitOfMeasure_nS = _fesapi.eml23__UnitOfMeasure_nS
eml23__UnitOfMeasure_ns = _fesapi.eml23__UnitOfMeasure_ns
eml23__UnitOfMeasure_ns_x002fft = _fesapi.eml23__UnitOfMeasure_ns_x002fft
eml23__UnitOfMeasure_ns_x002fm = _fesapi.eml23__UnitOfMeasure_ns_x002fm
eml23__UnitOfMeasure_nT = _fesapi.eml23__UnitOfMeasure_nT
eml23__UnitOfMeasure_nV = _fesapi.eml23__UnitOfMeasure_nV
eml23__UnitOfMeasure_nW = _fesapi.eml23__UnitOfMeasure_nW
eml23__UnitOfMeasure_nWb = _fesapi.eml23__UnitOfMeasure_nWb
eml23__UnitOfMeasure_Oe = _fesapi.eml23__UnitOfMeasure_Oe
eml23__UnitOfMeasure_ohm = _fesapi.eml23__UnitOfMeasure_ohm
eml23__UnitOfMeasure_ohm_x002ecm = _fesapi.eml23__UnitOfMeasure_ohm_x002ecm
eml23__UnitOfMeasure_ohm_x002em = _fesapi.eml23__UnitOfMeasure_ohm_x002em
eml23__UnitOfMeasure_ohm_x002em2_x002fm = _fesapi.eml23__UnitOfMeasure_ohm_x002em2_x002fm
eml23__UnitOfMeasure_ohm_x002fm = _fesapi.eml23__UnitOfMeasure_ohm_x002fm
eml23__UnitOfMeasure_ozf = _fesapi.eml23__UnitOfMeasure_ozf
eml23__UnitOfMeasure_ozm = _fesapi.eml23__UnitOfMeasure_ozm
eml23__UnitOfMeasure_ozm_x005btroy_x005d = _fesapi.eml23__UnitOfMeasure_ozm_x005btroy_x005d
eml23__UnitOfMeasure_pA = _fesapi.eml23__UnitOfMeasure_pA
eml23__UnitOfMeasure_Pa = _fesapi.eml23__UnitOfMeasure_Pa
eml23__UnitOfMeasure_Pa_x002es = _fesapi.eml23__UnitOfMeasure_Pa_x002es
eml23__UnitOfMeasure_Pa_x002es_x002em3_x002fkg = _fesapi.eml23__UnitOfMeasure_Pa_x002es_x002em3_x002fkg
eml23__UnitOfMeasure_Pa_x002es_x002fm3 = _fesapi.eml23__UnitOfMeasure_Pa_x002es_x002fm3
eml23__UnitOfMeasure_Pa_x002es2_x002fm3 = _fesapi.eml23__UnitOfMeasure_Pa_x002es2_x002fm3
eml23__UnitOfMeasure_Pa_x002f_x00281000m3_x002fday_x0029 = _fesapi.eml23__UnitOfMeasure_Pa_x002f_x00281000m3_x002fday_x0029
eml23__UnitOfMeasure_Pa_x002f_x00281000m3_x002fday_x00292 = _fesapi.eml23__UnitOfMeasure_Pa_x002f_x00281000m3_x002fday_x00292
eml23__UnitOfMeasure_Pa_x002f_x0028m3_x002fday_x0029 = _fesapi.eml23__UnitOfMeasure_Pa_x002f_x0028m3_x002fday_x0029
eml23__UnitOfMeasure_Pa_x002f_x0028m3_x002fday_x00292 = _fesapi.eml23__UnitOfMeasure_Pa_x002f_x0028m3_x002fday_x00292
eml23__UnitOfMeasure_Pa_x002fh = _fesapi.eml23__UnitOfMeasure_Pa_x002fh
eml23__UnitOfMeasure_Pa_x002fm = _fesapi.eml23__UnitOfMeasure_Pa_x002fm
eml23__UnitOfMeasure_Pa_x002fm3 = _fesapi.eml23__UnitOfMeasure_Pa_x002fm3
eml23__UnitOfMeasure_Pa_x002fs = _fesapi.eml23__UnitOfMeasure_Pa_x002fs
eml23__UnitOfMeasure_Pa2 = _fesapi.eml23__UnitOfMeasure_Pa2
eml23__UnitOfMeasure_Pa2_x002f_x0028Pa_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_Pa2_x002f_x0028Pa_x002es_x0029
eml23__UnitOfMeasure_pC = _fesapi.eml23__UnitOfMeasure_pC
eml23__UnitOfMeasure_pcal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_pcal_x005bth_x005d
eml23__UnitOfMeasure_pCi = _fesapi.eml23__UnitOfMeasure_pCi
eml23__UnitOfMeasure_pCi_x002fg = _fesapi.eml23__UnitOfMeasure_pCi_x002fg
eml23__UnitOfMeasure_pdl = _fesapi.eml23__UnitOfMeasure_pdl
eml23__UnitOfMeasure_pdl_x002ecm2 = _fesapi.eml23__UnitOfMeasure_pdl_x002ecm2
eml23__UnitOfMeasure_pdl_x002eft = _fesapi.eml23__UnitOfMeasure_pdl_x002eft
eml23__UnitOfMeasure_pdl_x002fcm = _fesapi.eml23__UnitOfMeasure_pdl_x002fcm
eml23__UnitOfMeasure_pEuc = _fesapi.eml23__UnitOfMeasure_pEuc
eml23__UnitOfMeasure_peV = _fesapi.eml23__UnitOfMeasure_peV
eml23__UnitOfMeasure_pF = _fesapi.eml23__UnitOfMeasure_pF
eml23__UnitOfMeasure_pg = _fesapi.eml23__UnitOfMeasure_pg
eml23__UnitOfMeasure_pgauss = _fesapi.eml23__UnitOfMeasure_pgauss
eml23__UnitOfMeasure_pGy = _fesapi.eml23__UnitOfMeasure_pGy
eml23__UnitOfMeasure_pHz = _fesapi.eml23__UnitOfMeasure_pHz
eml23__UnitOfMeasure_pJ = _fesapi.eml23__UnitOfMeasure_pJ
eml23__UnitOfMeasure_pm = _fesapi.eml23__UnitOfMeasure_pm
eml23__UnitOfMeasure_pN = _fesapi.eml23__UnitOfMeasure_pN
eml23__UnitOfMeasure_pohm = _fesapi.eml23__UnitOfMeasure_pohm
eml23__UnitOfMeasure_pP = _fesapi.eml23__UnitOfMeasure_pP
eml23__UnitOfMeasure_pPa = _fesapi.eml23__UnitOfMeasure_pPa
eml23__UnitOfMeasure_ppk = _fesapi.eml23__UnitOfMeasure_ppk
eml23__UnitOfMeasure_ppm = _fesapi.eml23__UnitOfMeasure_ppm
eml23__UnitOfMeasure_ppm_x005bmass_x005d = _fesapi.eml23__UnitOfMeasure_ppm_x005bmass_x005d
eml23__UnitOfMeasure_ppm_x005bvol_x005d = _fesapi.eml23__UnitOfMeasure_ppm_x005bvol_x005d
eml23__UnitOfMeasure_ppm_x005bvol_x005d_x002fdegC = _fesapi.eml23__UnitOfMeasure_ppm_x005bvol_x005d_x002fdegC
eml23__UnitOfMeasure_ppm_x005bvol_x005d_x002fdegF = _fesapi.eml23__UnitOfMeasure_ppm_x005bvol_x005d_x002fdegF
eml23__UnitOfMeasure_prd = _fesapi.eml23__UnitOfMeasure_prd
eml23__UnitOfMeasure_pS = _fesapi.eml23__UnitOfMeasure_pS
eml23__UnitOfMeasure_ps = _fesapi.eml23__UnitOfMeasure_ps
eml23__UnitOfMeasure_psi = _fesapi.eml23__UnitOfMeasure_psi
eml23__UnitOfMeasure_psi_x002ed_x002fbbl = _fesapi.eml23__UnitOfMeasure_psi_x002ed_x002fbbl
eml23__UnitOfMeasure_psi_x002es = _fesapi.eml23__UnitOfMeasure_psi_x002es
eml23__UnitOfMeasure_psi_x002f_x00281000000ft3_x002fday_x0029 = _fesapi.eml23__UnitOfMeasure_psi_x002f_x00281000000ft3_x002fday_x0029
eml23__UnitOfMeasure_psi_x002f_x00281000000ft3_x002fday_x00292 = _fesapi.eml23__UnitOfMeasure_psi_x002f_x00281000000ft3_x002fday_x00292
eml23__UnitOfMeasure_psi_x002f_x00281000ft3_x002fday_x0029 = _fesapi.eml23__UnitOfMeasure_psi_x002f_x00281000ft3_x002fday_x0029
eml23__UnitOfMeasure_psi_x002f_x00281000ft3_x002fday_x00292 = _fesapi.eml23__UnitOfMeasure_psi_x002f_x00281000ft3_x002fday_x00292
eml23__UnitOfMeasure_psi_x002f_x0028bbl_x002fday_x0029 = _fesapi.eml23__UnitOfMeasure_psi_x002f_x0028bbl_x002fday_x0029
eml23__UnitOfMeasure_psi_x002f_x0028bbl_x002fday_x00292 = _fesapi.eml23__UnitOfMeasure_psi_x002f_x0028bbl_x002fday_x00292
eml23__UnitOfMeasure_psi_x002fft = _fesapi.eml23__UnitOfMeasure_psi_x002fft
eml23__UnitOfMeasure_psi_x002fh = _fesapi.eml23__UnitOfMeasure_psi_x002fh
eml23__UnitOfMeasure_psi_x002fm = _fesapi.eml23__UnitOfMeasure_psi_x002fm
eml23__UnitOfMeasure_psi_x002fmin = _fesapi.eml23__UnitOfMeasure_psi_x002fmin
eml23__UnitOfMeasure_psi2 = _fesapi.eml23__UnitOfMeasure_psi2
eml23__UnitOfMeasure_psi2_x002ed_x002f_x0028cP_x002eft3_x0029 = _fesapi.eml23__UnitOfMeasure_psi2_x002ed_x002f_x0028cP_x002eft3_x0029
eml23__UnitOfMeasure_psi2_x002fcP = _fesapi.eml23__UnitOfMeasure_psi2_x002fcP
eml23__UnitOfMeasure_pT = _fesapi.eml23__UnitOfMeasure_pT
eml23__UnitOfMeasure_pt_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_pt_x005bUK_x005d
eml23__UnitOfMeasure_pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029 = _fesapi.eml23__UnitOfMeasure_pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029
eml23__UnitOfMeasure_pt_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_pt_x005bUS_x005d
eml23__UnitOfMeasure_pV = _fesapi.eml23__UnitOfMeasure_pV
eml23__UnitOfMeasure_pW = _fesapi.eml23__UnitOfMeasure_pW
eml23__UnitOfMeasure_pWb = _fesapi.eml23__UnitOfMeasure_pWb
eml23__UnitOfMeasure_qt_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_qt_x005bUK_x005d
eml23__UnitOfMeasure_qt_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_qt_x005bUS_x005d
eml23__UnitOfMeasure_quad = _fesapi.eml23__UnitOfMeasure_quad
eml23__UnitOfMeasure_quad_x002fa = _fesapi.eml23__UnitOfMeasure_quad_x002fa
eml23__UnitOfMeasure_rad = _fesapi.eml23__UnitOfMeasure_rad
eml23__UnitOfMeasure_rad_x002fft = _fesapi.eml23__UnitOfMeasure_rad_x002fft
eml23__UnitOfMeasure_rad_x002fft3 = _fesapi.eml23__UnitOfMeasure_rad_x002fft3
eml23__UnitOfMeasure_rad_x002fm = _fesapi.eml23__UnitOfMeasure_rad_x002fm
eml23__UnitOfMeasure_rad_x002fm3 = _fesapi.eml23__UnitOfMeasure_rad_x002fm3
eml23__UnitOfMeasure_rad_x002fs = _fesapi.eml23__UnitOfMeasure_rad_x002fs
eml23__UnitOfMeasure_rad_x002fs2 = _fesapi.eml23__UnitOfMeasure_rad_x002fs2
eml23__UnitOfMeasure_rd = _fesapi.eml23__UnitOfMeasure_rd
eml23__UnitOfMeasure_rem = _fesapi.eml23__UnitOfMeasure_rem
eml23__UnitOfMeasure_rem_x002fh = _fesapi.eml23__UnitOfMeasure_rem_x002fh
eml23__UnitOfMeasure_rev = _fesapi.eml23__UnitOfMeasure_rev
eml23__UnitOfMeasure_rev_x002fft = _fesapi.eml23__UnitOfMeasure_rev_x002fft
eml23__UnitOfMeasure_rev_x002fm = _fesapi.eml23__UnitOfMeasure_rev_x002fm
eml23__UnitOfMeasure_rev_x002fs = _fesapi.eml23__UnitOfMeasure_rev_x002fs
eml23__UnitOfMeasure_rod_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_rod_x005bUS_x005d
eml23__UnitOfMeasure_rpm = _fesapi.eml23__UnitOfMeasure_rpm
eml23__UnitOfMeasure_rpm_x002fs = _fesapi.eml23__UnitOfMeasure_rpm_x002fs
eml23__UnitOfMeasure_s_x002fcm = _fesapi.eml23__UnitOfMeasure_s_x002fcm
eml23__UnitOfMeasure_s_x002fft = _fesapi.eml23__UnitOfMeasure_s_x002fft
eml23__UnitOfMeasure_s_x002fft3 = _fesapi.eml23__UnitOfMeasure_s_x002fft3
eml23__UnitOfMeasure_s_x002fin = _fesapi.eml23__UnitOfMeasure_s_x002fin
eml23__UnitOfMeasure_s_x002fkg = _fesapi.eml23__UnitOfMeasure_s_x002fkg
eml23__UnitOfMeasure_s_x002fL = _fesapi.eml23__UnitOfMeasure_s_x002fL
eml23__UnitOfMeasure_S_x002fm = _fesapi.eml23__UnitOfMeasure_S_x002fm
eml23__UnitOfMeasure_s_x002fm = _fesapi.eml23__UnitOfMeasure_s_x002fm
eml23__UnitOfMeasure_s_x002fm3 = _fesapi.eml23__UnitOfMeasure_s_x002fm3
eml23__UnitOfMeasure_s_x002fqt_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_s_x002fqt_x005bUK_x005d
eml23__UnitOfMeasure_s_x002fqt_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_s_x002fqt_x005bUS_x005d
eml23__UnitOfMeasure_s_x002fs = _fesapi.eml23__UnitOfMeasure_s_x002fs
eml23__UnitOfMeasure_sack_x005b94lbm_x005d = _fesapi.eml23__UnitOfMeasure_sack_x005b94lbm_x005d
eml23__UnitOfMeasure_seca = _fesapi.eml23__UnitOfMeasure_seca
eml23__UnitOfMeasure_section = _fesapi.eml23__UnitOfMeasure_section
eml23__UnitOfMeasure_sr = _fesapi.eml23__UnitOfMeasure_sr
eml23__UnitOfMeasure_St = _fesapi.eml23__UnitOfMeasure_St
eml23__UnitOfMeasure_Sv = _fesapi.eml23__UnitOfMeasure_Sv
eml23__UnitOfMeasure_Sv_x002fh = _fesapi.eml23__UnitOfMeasure_Sv_x002fh
eml23__UnitOfMeasure_Sv_x002fs = _fesapi.eml23__UnitOfMeasure_Sv_x002fs
eml23__UnitOfMeasure_t_x002fa = _fesapi.eml23__UnitOfMeasure_t_x002fa
eml23__UnitOfMeasure_t_x002fd = _fesapi.eml23__UnitOfMeasure_t_x002fd
eml23__UnitOfMeasure_t_x002fh = _fesapi.eml23__UnitOfMeasure_t_x002fh
eml23__UnitOfMeasure_T_x002fm = _fesapi.eml23__UnitOfMeasure_T_x002fm
eml23__UnitOfMeasure_t_x002fm3 = _fesapi.eml23__UnitOfMeasure_t_x002fm3
eml23__UnitOfMeasure_t_x002fmin = _fesapi.eml23__UnitOfMeasure_t_x002fmin
eml23__UnitOfMeasure_TA = _fesapi.eml23__UnitOfMeasure_TA
eml23__UnitOfMeasure_Ta_x005bt_x005d = _fesapi.eml23__UnitOfMeasure_Ta_x005bt_x005d
eml23__UnitOfMeasure_TBq = _fesapi.eml23__UnitOfMeasure_TBq
eml23__UnitOfMeasure_TC = _fesapi.eml23__UnitOfMeasure_TC
eml23__UnitOfMeasure_Tcal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_Tcal_x005bth_x005d
eml23__UnitOfMeasure_TD_x005bAPI_x005d = _fesapi.eml23__UnitOfMeasure_TD_x005bAPI_x005d
eml23__UnitOfMeasure_TD_x005bAPI_x005d_x002em = _fesapi.eml23__UnitOfMeasure_TD_x005bAPI_x005d_x002em
eml23__UnitOfMeasure_TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029 = _fesapi.eml23__UnitOfMeasure_TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029
eml23__UnitOfMeasure_TEuc = _fesapi.eml23__UnitOfMeasure_TEuc
eml23__UnitOfMeasure_TeV = _fesapi.eml23__UnitOfMeasure_TeV
eml23__UnitOfMeasure_TF = _fesapi.eml23__UnitOfMeasure_TF
eml23__UnitOfMeasure_Tg = _fesapi.eml23__UnitOfMeasure_Tg
eml23__UnitOfMeasure_Tgauss = _fesapi.eml23__UnitOfMeasure_Tgauss
eml23__UnitOfMeasure_TGy = _fesapi.eml23__UnitOfMeasure_TGy
eml23__UnitOfMeasure_TH = _fesapi.eml23__UnitOfMeasure_TH
eml23__UnitOfMeasure_therm_x005bEC_x005d = _fesapi.eml23__UnitOfMeasure_therm_x005bEC_x005d
eml23__UnitOfMeasure_therm_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_therm_x005bUK_x005d
eml23__UnitOfMeasure_therm_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_therm_x005bUS_x005d
eml23__UnitOfMeasure_THz = _fesapi.eml23__UnitOfMeasure_THz
eml23__UnitOfMeasure_TJ = _fesapi.eml23__UnitOfMeasure_TJ
eml23__UnitOfMeasure_TJ_x002fa = _fesapi.eml23__UnitOfMeasure_TJ_x002fa
eml23__UnitOfMeasure_Tm = _fesapi.eml23__UnitOfMeasure_Tm
eml23__UnitOfMeasure_TN = _fesapi.eml23__UnitOfMeasure_TN
eml23__UnitOfMeasure_Tohm = _fesapi.eml23__UnitOfMeasure_Tohm
eml23__UnitOfMeasure_ton_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_ton_x005bUK_x005d
eml23__UnitOfMeasure_ton_x005bUK_x005d_x002fa = _fesapi.eml23__UnitOfMeasure_ton_x005bUK_x005d_x002fa
eml23__UnitOfMeasure_ton_x005bUK_x005d_x002fd = _fesapi.eml23__UnitOfMeasure_ton_x005bUK_x005d_x002fd
eml23__UnitOfMeasure_ton_x005bUK_x005d_x002fh = _fesapi.eml23__UnitOfMeasure_ton_x005bUK_x005d_x002fh
eml23__UnitOfMeasure_ton_x005bUK_x005d_x002fmin = _fesapi.eml23__UnitOfMeasure_ton_x005bUK_x005d_x002fmin
eml23__UnitOfMeasure_ton_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_ton_x005bUS_x005d
eml23__UnitOfMeasure_ton_x005bUS_x005d_x002fa = _fesapi.eml23__UnitOfMeasure_ton_x005bUS_x005d_x002fa
eml23__UnitOfMeasure_ton_x005bUS_x005d_x002fd = _fesapi.eml23__UnitOfMeasure_ton_x005bUS_x005d_x002fd
eml23__UnitOfMeasure_ton_x005bUS_x005d_x002fft2 = _fesapi.eml23__UnitOfMeasure_ton_x005bUS_x005d_x002fft2
eml23__UnitOfMeasure_ton_x005bUS_x005d_x002fh = _fesapi.eml23__UnitOfMeasure_ton_x005bUS_x005d_x002fh
eml23__UnitOfMeasure_ton_x005bUS_x005d_x002fmin = _fesapi.eml23__UnitOfMeasure_ton_x005bUS_x005d_x002fmin
eml23__UnitOfMeasure_tonf_x005bUK_x005d = _fesapi.eml23__UnitOfMeasure_tonf_x005bUK_x005d
eml23__UnitOfMeasure_tonf_x005bUK_x005d_x002eft2 = _fesapi.eml23__UnitOfMeasure_tonf_x005bUK_x005d_x002eft2
eml23__UnitOfMeasure_tonf_x005bUK_x005d_x002fft = _fesapi.eml23__UnitOfMeasure_tonf_x005bUK_x005d_x002fft
eml23__UnitOfMeasure_tonf_x005bUK_x005d_x002fft2 = _fesapi.eml23__UnitOfMeasure_tonf_x005bUK_x005d_x002fft2
eml23__UnitOfMeasure_tonf_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_tonf_x005bUS_x005d
eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002eft = _fesapi.eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002eft
eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002eft2 = _fesapi.eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002eft2
eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002emi = _fesapi.eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002emi
eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002emi_x002fbbl = _fesapi.eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002emi_x002fbbl
eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002emi_x002fft = _fesapi.eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002emi_x002fft
eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002fft = _fesapi.eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002fft
eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002fft2 = _fesapi.eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002fft2
eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002fin2 = _fesapi.eml23__UnitOfMeasure_tonf_x005bUS_x005d_x002fin2
eml23__UnitOfMeasure_tonRefrig = _fesapi.eml23__UnitOfMeasure_tonRefrig
eml23__UnitOfMeasure_torr = _fesapi.eml23__UnitOfMeasure_torr
eml23__UnitOfMeasure_TP = _fesapi.eml23__UnitOfMeasure_TP
eml23__UnitOfMeasure_TPa = _fesapi.eml23__UnitOfMeasure_TPa
eml23__UnitOfMeasure_Trd = _fesapi.eml23__UnitOfMeasure_Trd
eml23__UnitOfMeasure_TS = _fesapi.eml23__UnitOfMeasure_TS
eml23__UnitOfMeasure_TT = _fesapi.eml23__UnitOfMeasure_TT
eml23__UnitOfMeasure_TV = _fesapi.eml23__UnitOfMeasure_TV
eml23__UnitOfMeasure_TW = _fesapi.eml23__UnitOfMeasure_TW
eml23__UnitOfMeasure_TW_x002eh = _fesapi.eml23__UnitOfMeasure_TW_x002eh
eml23__UnitOfMeasure_TWb = _fesapi.eml23__UnitOfMeasure_TWb
eml23__UnitOfMeasure_uA = _fesapi.eml23__UnitOfMeasure_uA
eml23__UnitOfMeasure_uA_x002fcm2 = _fesapi.eml23__UnitOfMeasure_uA_x002fcm2
eml23__UnitOfMeasure_uA_x002fin2 = _fesapi.eml23__UnitOfMeasure_uA_x002fin2
eml23__UnitOfMeasure_ubar = _fesapi.eml23__UnitOfMeasure_ubar
eml23__UnitOfMeasure_uC = _fesapi.eml23__UnitOfMeasure_uC
eml23__UnitOfMeasure_ucal_x005bth_x005d = _fesapi.eml23__UnitOfMeasure_ucal_x005bth_x005d
eml23__UnitOfMeasure_ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029 = _fesapi.eml23__UnitOfMeasure_ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029
eml23__UnitOfMeasure_ucal_x005bth_x005d_x002fs = _fesapi.eml23__UnitOfMeasure_ucal_x005bth_x005d_x002fs
eml23__UnitOfMeasure_uCi = _fesapi.eml23__UnitOfMeasure_uCi
eml23__UnitOfMeasure_uEuc = _fesapi.eml23__UnitOfMeasure_uEuc
eml23__UnitOfMeasure_ueV = _fesapi.eml23__UnitOfMeasure_ueV
eml23__UnitOfMeasure_uF = _fesapi.eml23__UnitOfMeasure_uF
eml23__UnitOfMeasure_uF_x002fm = _fesapi.eml23__UnitOfMeasure_uF_x002fm
eml23__UnitOfMeasure_ug = _fesapi.eml23__UnitOfMeasure_ug
eml23__UnitOfMeasure_ug_x002fcm3 = _fesapi.eml23__UnitOfMeasure_ug_x002fcm3
eml23__UnitOfMeasure_ug_x002fg = _fesapi.eml23__UnitOfMeasure_ug_x002fg
eml23__UnitOfMeasure_ug_x002fmg = _fesapi.eml23__UnitOfMeasure_ug_x002fmg
eml23__UnitOfMeasure_ugauss = _fesapi.eml23__UnitOfMeasure_ugauss
eml23__UnitOfMeasure_uGy = _fesapi.eml23__UnitOfMeasure_uGy
eml23__UnitOfMeasure_uH = _fesapi.eml23__UnitOfMeasure_uH
eml23__UnitOfMeasure_uH_x002fm = _fesapi.eml23__UnitOfMeasure_uH_x002fm
eml23__UnitOfMeasure_uHz = _fesapi.eml23__UnitOfMeasure_uHz
eml23__UnitOfMeasure_uJ = _fesapi.eml23__UnitOfMeasure_uJ
eml23__UnitOfMeasure_um = _fesapi.eml23__UnitOfMeasure_um
eml23__UnitOfMeasure_um_x002fs = _fesapi.eml23__UnitOfMeasure_um_x002fs
eml23__UnitOfMeasure_um2 = _fesapi.eml23__UnitOfMeasure_um2
eml23__UnitOfMeasure_um2_x002em = _fesapi.eml23__UnitOfMeasure_um2_x002em
eml23__UnitOfMeasure_umHg_x005b0degC_x005d = _fesapi.eml23__UnitOfMeasure_umHg_x005b0degC_x005d
eml23__UnitOfMeasure_umol = _fesapi.eml23__UnitOfMeasure_umol
eml23__UnitOfMeasure_uN = _fesapi.eml23__UnitOfMeasure_uN
eml23__UnitOfMeasure_unitless = _fesapi.eml23__UnitOfMeasure_unitless
eml23__UnitOfMeasure_uohm = _fesapi.eml23__UnitOfMeasure_uohm
eml23__UnitOfMeasure_uohm_x002fft = _fesapi.eml23__UnitOfMeasure_uohm_x002fft
eml23__UnitOfMeasure_uohm_x002fm = _fesapi.eml23__UnitOfMeasure_uohm_x002fm
eml23__UnitOfMeasure_uP = _fesapi.eml23__UnitOfMeasure_uP
eml23__UnitOfMeasure_uPa = _fesapi.eml23__UnitOfMeasure_uPa
eml23__UnitOfMeasure_upsi = _fesapi.eml23__UnitOfMeasure_upsi
eml23__UnitOfMeasure_urad = _fesapi.eml23__UnitOfMeasure_urad
eml23__UnitOfMeasure_urd = _fesapi.eml23__UnitOfMeasure_urd
eml23__UnitOfMeasure_us = _fesapi.eml23__UnitOfMeasure_us
eml23__UnitOfMeasure_uS = _fesapi.eml23__UnitOfMeasure_uS
eml23__UnitOfMeasure_us_x002fft = _fesapi.eml23__UnitOfMeasure_us_x002fft
eml23__UnitOfMeasure_us_x002fin = _fesapi.eml23__UnitOfMeasure_us_x002fin
eml23__UnitOfMeasure_us_x002fm = _fesapi.eml23__UnitOfMeasure_us_x002fm
eml23__UnitOfMeasure_uT = _fesapi.eml23__UnitOfMeasure_uT
eml23__UnitOfMeasure_uV = _fesapi.eml23__UnitOfMeasure_uV
eml23__UnitOfMeasure_uV_x002fft = _fesapi.eml23__UnitOfMeasure_uV_x002fft
eml23__UnitOfMeasure_uV_x002fm = _fesapi.eml23__UnitOfMeasure_uV_x002fm
eml23__UnitOfMeasure_uW = _fesapi.eml23__UnitOfMeasure_uW
eml23__UnitOfMeasure_uW_x002fm3 = _fesapi.eml23__UnitOfMeasure_uW_x002fm3
eml23__UnitOfMeasure_uWb = _fesapi.eml23__UnitOfMeasure_uWb
eml23__UnitOfMeasure_V_x002fB = _fesapi.eml23__UnitOfMeasure_V_x002fB
eml23__UnitOfMeasure_V_x002fdB = _fesapi.eml23__UnitOfMeasure_V_x002fdB
eml23__UnitOfMeasure_V_x002fm = _fesapi.eml23__UnitOfMeasure_V_x002fm
eml23__UnitOfMeasure_W_x002em2_x002eK_x002f_x0028J_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_W_x002em2_x002eK_x002f_x0028J_x002eK_x0029
eml23__UnitOfMeasure_W_x002f_x0028m_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_W_x002f_x0028m_x002eK_x0029
eml23__UnitOfMeasure_W_x002f_x0028m2_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_W_x002f_x0028m2_x002eK_x0029
eml23__UnitOfMeasure_W_x002f_x0028m2_x002esr_x0029 = _fesapi.eml23__UnitOfMeasure_W_x002f_x0028m2_x002esr_x0029
eml23__UnitOfMeasure_W_x002f_x0028m3_x002eK_x0029 = _fesapi.eml23__UnitOfMeasure_W_x002f_x0028m3_x002eK_x0029
eml23__UnitOfMeasure_W_x002fcm2 = _fesapi.eml23__UnitOfMeasure_W_x002fcm2
eml23__UnitOfMeasure_W_x002fK = _fesapi.eml23__UnitOfMeasure_W_x002fK
eml23__UnitOfMeasure_W_x002fkW = _fesapi.eml23__UnitOfMeasure_W_x002fkW
eml23__UnitOfMeasure_W_x002fm2 = _fesapi.eml23__UnitOfMeasure_W_x002fm2
eml23__UnitOfMeasure_W_x002fm3 = _fesapi.eml23__UnitOfMeasure_W_x002fm3
eml23__UnitOfMeasure_W_x002fmm2 = _fesapi.eml23__UnitOfMeasure_W_x002fmm2
eml23__UnitOfMeasure_W_x002fsr = _fesapi.eml23__UnitOfMeasure_W_x002fsr
eml23__UnitOfMeasure_W_x002fW = _fesapi.eml23__UnitOfMeasure_W_x002fW
eml23__UnitOfMeasure_Wb = _fesapi.eml23__UnitOfMeasure_Wb
eml23__UnitOfMeasure_Wb_x002em = _fesapi.eml23__UnitOfMeasure_Wb_x002em
eml23__UnitOfMeasure_Wb_x002fm = _fesapi.eml23__UnitOfMeasure_Wb_x002fm
eml23__UnitOfMeasure_Wb_x002fmm = _fesapi.eml23__UnitOfMeasure_Wb_x002fmm
eml23__UnitOfMeasure_wk = _fesapi.eml23__UnitOfMeasure_wk
eml23__UnitOfMeasure_yd = _fesapi.eml23__UnitOfMeasure_yd
eml23__UnitOfMeasure_yd_x005bBnA_x005d = _fesapi.eml23__UnitOfMeasure_yd_x005bBnA_x005d
eml23__UnitOfMeasure_yd_x005bBnB_x005d = _fesapi.eml23__UnitOfMeasure_yd_x005bBnB_x005d
eml23__UnitOfMeasure_yd_x005bCla_x005d = _fesapi.eml23__UnitOfMeasure_yd_x005bCla_x005d
eml23__UnitOfMeasure_yd_x005bInd_x005d = _fesapi.eml23__UnitOfMeasure_yd_x005bInd_x005d
eml23__UnitOfMeasure_yd_x005bInd37_x005d = _fesapi.eml23__UnitOfMeasure_yd_x005bInd37_x005d
eml23__UnitOfMeasure_yd_x005bInd62_x005d = _fesapi.eml23__UnitOfMeasure_yd_x005bInd62_x005d
eml23__UnitOfMeasure_yd_x005bInd75_x005d = _fesapi.eml23__UnitOfMeasure_yd_x005bInd75_x005d
eml23__UnitOfMeasure_yd_x005bSe_x005d = _fesapi.eml23__UnitOfMeasure_yd_x005bSe_x005d
eml23__UnitOfMeasure_yd_x005bSeT_x005d = _fesapi.eml23__UnitOfMeasure_yd_x005bSeT_x005d
eml23__UnitOfMeasure_yd_x005bUS_x005d = _fesapi.eml23__UnitOfMeasure_yd_x005bUS_x005d
eml23__UnitOfMeasure_yd2 = _fesapi.eml23__UnitOfMeasure_yd2
eml23__UnitOfMeasure_yd3 = _fesapi.eml23__UnitOfMeasure_yd3
eml23__VerticalCoordinateUom_m = _fesapi.eml23__VerticalCoordinateUom_m
eml23__VerticalCoordinateUom_ft = _fesapi.eml23__VerticalCoordinateUom_ft
eml23__VerticalCoordinateUom_ftUS = _fesapi.eml23__VerticalCoordinateUom_ftUS
eml23__VerticalCoordinateUom_ftBr_x002865_x0029 = _fesapi.eml23__VerticalCoordinateUom_ftBr_x002865_x0029
class Eml23_Activity(Activity):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Eml23_Activity

# Register Eml23_Activity in _fesapi:
_fesapi.Eml23_Activity_swigregister(Eml23_Activity)
class Eml23_ActivityTemplate(ActivityTemplate):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Eml23_ActivityTemplate

# Register Eml23_ActivityTemplate in _fesapi:
_fesapi.Eml23_ActivityTemplate_swigregister(Eml23_ActivityTemplate)
class Eml23_GraphicalInformationSet(Eml2_GraphicalInformationSet):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Eml23_GraphicalInformationSet

# Register Eml23_GraphicalInformationSet in _fesapi:
_fesapi.Eml23_GraphicalInformationSet_swigregister(Eml23_GraphicalInformationSet)
class Eml23_LocalEngineering2dCrs(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Eml23_LocalEngineering2dCrs

# Register Eml23_LocalEngineering2dCrs in _fesapi:
_fesapi.Eml23_LocalEngineering2dCrs_swigregister(Eml23_LocalEngineering2dCrs)
class Eml23_VerticalCrs(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Eml23_VerticalCrs

# Register Eml23_VerticalCrs in _fesapi:
_fesapi.Eml23_VerticalCrs_swigregister(Eml23_VerticalCrs)
class Eml23_LocalEngineeringCompoundCrs(Eml2_AbstractLocal3dCrs):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getLocalEngineering2dCrs(self) -> "eml2_3::LocalEngineering2dCrs *":
        return _fesapi.Eml23_LocalEngineeringCompoundCrs_getLocalEngineering2dCrs(self)

    def getVerticalCrs(self) -> "eml2_3::VerticalCrs *":
        return _fesapi.Eml23_LocalEngineeringCompoundCrs_getVerticalCrs(self)
    __swig_destroy__ = _fesapi.delete_Eml23_LocalEngineeringCompoundCrs

# Register Eml23_LocalEngineeringCompoundCrs in _fesapi:
_fesapi.Eml23_LocalEngineeringCompoundCrs_swigregister(Eml23_LocalEngineeringCompoundCrs)
class Eml23_PropertyKind(PropertyKind):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getDeprecationDate(self) -> "time_t":
        r"""
        Gets the date and time at which this property dictionary entry must no longer be used.
        Files generated before this date would have used this entry so it is left here for reference.

        :raises: std::invalid_argument	If this instance is actually a partial object.

        :rtype: int
        :return: deprecationDate	The deprecation date and time of this data object.
        """
        return _fesapi.Eml23_PropertyKind_getDeprecationDate(self)

    def setDeprecationDate(self, deprecationDate: "time_t") -> "void":
        r"""
        Sets the date and time at which this property dictionary entry must no longer be used.
        Files generated before this date would have used this entry so it is left here for reference.

        :raises: std::invalid_argument	If this instance is actually a partial object.

        :type deprecationDate: int
        :param deprecationDate:	The deprecation date and time to set to this data object.
        """
        return _fesapi.Eml23_PropertyKind_setDeprecationDate(self, deprecationDate)
    __swig_destroy__ = _fesapi.delete_Eml23_PropertyKind

# Register Eml23_PropertyKind in _fesapi:
_fesapi.Eml23_PropertyKind_swigregister(Eml23_PropertyKind)
class Eml23_TimeSeries(TimeSeries):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Eml23_TimeSeries

# Register Eml23_TimeSeries in _fesapi:
_fesapi.Eml23_TimeSeries_swigregister(Eml23_TimeSeries)
resqml20__ResqmlUom_A = _fesapi.resqml20__ResqmlUom_A
resqml20__ResqmlUom_a = _fesapi.resqml20__ResqmlUom_a
resqml20__ResqmlUom_b = _fesapi.resqml20__ResqmlUom_b
resqml20__ResqmlUom_B = _fesapi.resqml20__ResqmlUom_B
resqml20__ResqmlUom_C = _fesapi.resqml20__ResqmlUom_C
resqml20__ResqmlUom_d = _fesapi.resqml20__ResqmlUom_d
resqml20__ResqmlUom_D = _fesapi.resqml20__ResqmlUom_D
resqml20__ResqmlUom_F = _fesapi.resqml20__ResqmlUom_F
resqml20__ResqmlUom_g = _fesapi.resqml20__ResqmlUom_g
resqml20__ResqmlUom_H = _fesapi.resqml20__ResqmlUom_H
resqml20__ResqmlUom_h = _fesapi.resqml20__ResqmlUom_h
resqml20__ResqmlUom_J = _fesapi.resqml20__ResqmlUom_J
resqml20__ResqmlUom_K = _fesapi.resqml20__ResqmlUom_K
resqml20__ResqmlUom_L = _fesapi.resqml20__ResqmlUom_L
resqml20__ResqmlUom_m = _fesapi.resqml20__ResqmlUom_m
resqml20__ResqmlUom_N = _fesapi.resqml20__ResqmlUom_N
resqml20__ResqmlUom_O = _fesapi.resqml20__ResqmlUom_O
resqml20__ResqmlUom_P = _fesapi.resqml20__ResqmlUom_P
resqml20__ResqmlUom_S = _fesapi.resqml20__ResqmlUom_S
resqml20__ResqmlUom_s = _fesapi.resqml20__ResqmlUom_s
resqml20__ResqmlUom_t = _fesapi.resqml20__ResqmlUom_t
resqml20__ResqmlUom_T = _fesapi.resqml20__ResqmlUom_T
resqml20__ResqmlUom_V = _fesapi.resqml20__ResqmlUom_V
resqml20__ResqmlUom_W = _fesapi.resqml20__ResqmlUom_W
resqml20__ResqmlUom__x0025 = _fesapi.resqml20__ResqmlUom__x0025
resqml20__ResqmlUom__x0025_x005barea_x005d = _fesapi.resqml20__ResqmlUom__x0025_x005barea_x005d
resqml20__ResqmlUom__x0025_x005bmass_x005d = _fesapi.resqml20__ResqmlUom__x0025_x005bmass_x005d
resqml20__ResqmlUom__x0025_x005bmolar_x005d = _fesapi.resqml20__ResqmlUom__x0025_x005bmolar_x005d
resqml20__ResqmlUom__x0025_x005bvol_x005d = _fesapi.resqml20__ResqmlUom__x0025_x005bvol_x005d
resqml20__ResqmlUom__x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = _fesapi.resqml20__ResqmlUom__x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029
resqml20__ResqmlUom__x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029 = _fesapi.resqml20__ResqmlUom__x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029
resqml20__ResqmlUom__x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029 = _fesapi.resqml20__ResqmlUom__x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029
resqml20__ResqmlUom__0_x002e001_x0020bbl_x002fft3 = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020bbl_x002fft3
resqml20__ResqmlUom__0_x002e001_x0020bbl_x002fm3 = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020bbl_x002fm3
resqml20__ResqmlUom__0_x002e001_x0020d_x002fft3 = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020d_x002fft3
resqml20__ResqmlUom__0_x002e001_x0020gal_x005bUK_x005d_x002fbbl = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020gal_x005bUK_x005d_x002fbbl
resqml20__ResqmlUom__0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d
resqml20__ResqmlUom__0_x002e001_x0020gal_x005bUS_x005d_x002fbbl = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020gal_x005bUS_x005d_x002fbbl
resqml20__ResqmlUom__0_x002e001_x0020gal_x005bUS_x005d_x002fft3 = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020gal_x005bUS_x005d_x002fft3
resqml20__ResqmlUom__0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d
resqml20__ResqmlUom__0_x002e001_x0020h_x002fft = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020h_x002fft
resqml20__ResqmlUom__0_x002e001_x0020kPa2_x002fcP = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020kPa2_x002fcP
resqml20__ResqmlUom__0_x002e001_x0020lbm_x002fbbl = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020lbm_x002fbbl
resqml20__ResqmlUom__0_x002e001_x0020lbm_x002fgal_x005bUK_x005d = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020lbm_x002fgal_x005bUK_x005d
resqml20__ResqmlUom__0_x002e001_x0020lbm_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020lbm_x002fgal_x005bUS_x005d
resqml20__ResqmlUom__0_x002e001_x0020psi_x002fft = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020psi_x002fft
resqml20__ResqmlUom__0_x002e001_x0020pt_x005bUK_x005d_x002fbbl = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020pt_x005bUK_x005d_x002fbbl
resqml20__ResqmlUom__0_x002e001_x0020seca = _fesapi.resqml20__ResqmlUom__0_x002e001_x0020seca
resqml20__ResqmlUom__0_x002e01_x0020bbl_x002fbbl = _fesapi.resqml20__ResqmlUom__0_x002e01_x0020bbl_x002fbbl
resqml20__ResqmlUom__0_x002e01_x0020dega_x002fft = _fesapi.resqml20__ResqmlUom__0_x002e01_x0020dega_x002fft
resqml20__ResqmlUom__0_x002e01_x0020degF_x002fft = _fesapi.resqml20__ResqmlUom__0_x002e01_x0020degF_x002fft
resqml20__ResqmlUom__0_x002e01_x0020dm3_x002fkm = _fesapi.resqml20__ResqmlUom__0_x002e01_x0020dm3_x002fkm
resqml20__ResqmlUom__0_x002e01_x0020ft_x002fft = _fesapi.resqml20__ResqmlUom__0_x002e01_x0020ft_x002fft
resqml20__ResqmlUom__0_x002e01_x0020grain_x002fft3 = _fesapi.resqml20__ResqmlUom__0_x002e01_x0020grain_x002fft3
resqml20__ResqmlUom__0_x002e01_x0020L_x002fkg = _fesapi.resqml20__ResqmlUom__0_x002e01_x0020L_x002fkg
resqml20__ResqmlUom__0_x002e01_x0020L_x002fkm = _fesapi.resqml20__ResqmlUom__0_x002e01_x0020L_x002fkm
resqml20__ResqmlUom__0_x002e01_x0020lbf_x002fft = _fesapi.resqml20__ResqmlUom__0_x002e01_x0020lbf_x002fft
resqml20__ResqmlUom__0_x002e01_x0020lbf_x002fft2 = _fesapi.resqml20__ResqmlUom__0_x002e01_x0020lbf_x002fft2
resqml20__ResqmlUom__0_x002e01_x0020lbm_x002fft2 = _fesapi.resqml20__ResqmlUom__0_x002e01_x0020lbm_x002fft2
resqml20__ResqmlUom__0_x002e01_x0020psi_x002fft = _fesapi.resqml20__ResqmlUom__0_x002e01_x0020psi_x002fft
resqml20__ResqmlUom__0_x002e1_x0020ft = _fesapi.resqml20__ResqmlUom__0_x002e1_x0020ft
resqml20__ResqmlUom__0_x002e1_x0020ft_x005bUS_x005d = _fesapi.resqml20__ResqmlUom__0_x002e1_x0020ft_x005bUS_x005d
resqml20__ResqmlUom__0_x002e1_x0020gal_x005bUS_x005d_x002fbbl = _fesapi.resqml20__ResqmlUom__0_x002e1_x0020gal_x005bUS_x005d_x002fbbl
resqml20__ResqmlUom__0_x002e1_x0020in = _fesapi.resqml20__ResqmlUom__0_x002e1_x0020in
resqml20__ResqmlUom__0_x002e1_x0020L_x002fbbl = _fesapi.resqml20__ResqmlUom__0_x002e1_x0020L_x002fbbl
resqml20__ResqmlUom__0_x002e1_x0020lbm_x002fbbl = _fesapi.resqml20__ResqmlUom__0_x002e1_x0020lbm_x002fbbl
resqml20__ResqmlUom__0_x002e1_x0020pt_x005bUS_x005d_x002fbbl = _fesapi.resqml20__ResqmlUom__0_x002e1_x0020pt_x005bUS_x005d_x002fbbl
resqml20__ResqmlUom__0_x002e1_x0020yd = _fesapi.resqml20__ResqmlUom__0_x002e1_x0020yd
resqml20__ResqmlUom__1_x002f_x0028kg_x002es_x0029 = _fesapi.resqml20__ResqmlUom__1_x002f_x0028kg_x002es_x0029
resqml20__ResqmlUom__1_x002f16_x0020in = _fesapi.resqml20__ResqmlUom__1_x002f16_x0020in
resqml20__ResqmlUom__1_x002f2_x0020ft = _fesapi.resqml20__ResqmlUom__1_x002f2_x0020ft
resqml20__ResqmlUom__1_x002f2_x0020ms = _fesapi.resqml20__ResqmlUom__1_x002f2_x0020ms
resqml20__ResqmlUom__1_x002f30_x0020cm3_x002fmin = _fesapi.resqml20__ResqmlUom__1_x002f30_x0020cm3_x002fmin
resqml20__ResqmlUom__1_x002f30_x0020dega_x002fft = _fesapi.resqml20__ResqmlUom__1_x002f30_x0020dega_x002fft
resqml20__ResqmlUom__1_x002f30_x0020dega_x002fm = _fesapi.resqml20__ResqmlUom__1_x002f30_x0020dega_x002fm
resqml20__ResqmlUom__1_x002f30_x0020lbf_x002fm = _fesapi.resqml20__ResqmlUom__1_x002f30_x0020lbf_x002fm
resqml20__ResqmlUom__1_x002f30_x0020m_x002fm = _fesapi.resqml20__ResqmlUom__1_x002f30_x0020m_x002fm
resqml20__ResqmlUom__1_x002f30_x0020N_x002fm = _fesapi.resqml20__ResqmlUom__1_x002f30_x0020N_x002fm
resqml20__ResqmlUom__1_x002f32_x0020in = _fesapi.resqml20__ResqmlUom__1_x002f32_x0020in
resqml20__ResqmlUom__1_x002f64_x0020in = _fesapi.resqml20__ResqmlUom__1_x002f64_x0020in
resqml20__ResqmlUom__1_x002fa = _fesapi.resqml20__ResqmlUom__1_x002fa
resqml20__ResqmlUom__1_x002fangstrom = _fesapi.resqml20__ResqmlUom__1_x002fangstrom
resqml20__ResqmlUom__1_x002fbar = _fesapi.resqml20__ResqmlUom__1_x002fbar
resqml20__ResqmlUom__1_x002fbbl = _fesapi.resqml20__ResqmlUom__1_x002fbbl
resqml20__ResqmlUom__1_x002fcm = _fesapi.resqml20__ResqmlUom__1_x002fcm
resqml20__ResqmlUom__1_x002fd = _fesapi.resqml20__ResqmlUom__1_x002fd
resqml20__ResqmlUom__1_x002fdegC = _fesapi.resqml20__ResqmlUom__1_x002fdegC
resqml20__ResqmlUom__1_x002fdegF = _fesapi.resqml20__ResqmlUom__1_x002fdegF
resqml20__ResqmlUom__1_x002fdegR = _fesapi.resqml20__ResqmlUom__1_x002fdegR
resqml20__ResqmlUom__1_x002fft = _fesapi.resqml20__ResqmlUom__1_x002fft
resqml20__ResqmlUom__1_x002fft2 = _fesapi.resqml20__ResqmlUom__1_x002fft2
resqml20__ResqmlUom__1_x002fft3 = _fesapi.resqml20__ResqmlUom__1_x002fft3
resqml20__ResqmlUom__1_x002fg = _fesapi.resqml20__ResqmlUom__1_x002fg
resqml20__ResqmlUom__1_x002fgal_x005bUK_x005d = _fesapi.resqml20__ResqmlUom__1_x002fgal_x005bUK_x005d
resqml20__ResqmlUom__1_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom__1_x002fgal_x005bUS_x005d
resqml20__ResqmlUom__1_x002fH = _fesapi.resqml20__ResqmlUom__1_x002fH
resqml20__ResqmlUom__1_x002fh = _fesapi.resqml20__ResqmlUom__1_x002fh
resqml20__ResqmlUom__1_x002fin = _fesapi.resqml20__ResqmlUom__1_x002fin
resqml20__ResqmlUom__1_x002fK = _fesapi.resqml20__ResqmlUom__1_x002fK
resqml20__ResqmlUom__1_x002fkg = _fesapi.resqml20__ResqmlUom__1_x002fkg
resqml20__ResqmlUom__1_x002fkm2 = _fesapi.resqml20__ResqmlUom__1_x002fkm2
resqml20__ResqmlUom__1_x002fkPa = _fesapi.resqml20__ResqmlUom__1_x002fkPa
resqml20__ResqmlUom__1_x002fL = _fesapi.resqml20__ResqmlUom__1_x002fL
resqml20__ResqmlUom__1_x002flbf = _fesapi.resqml20__ResqmlUom__1_x002flbf
resqml20__ResqmlUom__1_x002flbm = _fesapi.resqml20__ResqmlUom__1_x002flbm
resqml20__ResqmlUom__1_x002fm = _fesapi.resqml20__ResqmlUom__1_x002fm
resqml20__ResqmlUom__1_x002fm2 = _fesapi.resqml20__ResqmlUom__1_x002fm2
resqml20__ResqmlUom__1_x002fm3 = _fesapi.resqml20__ResqmlUom__1_x002fm3
resqml20__ResqmlUom__1_x002fmi = _fesapi.resqml20__ResqmlUom__1_x002fmi
resqml20__ResqmlUom__1_x002fmi2 = _fesapi.resqml20__ResqmlUom__1_x002fmi2
resqml20__ResqmlUom__1_x002fmin = _fesapi.resqml20__ResqmlUom__1_x002fmin
resqml20__ResqmlUom__1_x002fmm = _fesapi.resqml20__ResqmlUom__1_x002fmm
resqml20__ResqmlUom__1_x002fms = _fesapi.resqml20__ResqmlUom__1_x002fms
resqml20__ResqmlUom__1_x002fN = _fesapi.resqml20__ResqmlUom__1_x002fN
resqml20__ResqmlUom__1_x002fnm = _fesapi.resqml20__ResqmlUom__1_x002fnm
resqml20__ResqmlUom__1_x002fPa = _fesapi.resqml20__ResqmlUom__1_x002fPa
resqml20__ResqmlUom__1_x002fpPa = _fesapi.resqml20__ResqmlUom__1_x002fpPa
resqml20__ResqmlUom__1_x002fpsi = _fesapi.resqml20__ResqmlUom__1_x002fpsi
resqml20__ResqmlUom__1_x002fs = _fesapi.resqml20__ResqmlUom__1_x002fs
resqml20__ResqmlUom__1_x002fupsi = _fesapi.resqml20__ResqmlUom__1_x002fupsi
resqml20__ResqmlUom__1_x002fus = _fesapi.resqml20__ResqmlUom__1_x002fus
resqml20__ResqmlUom__1_x002fuV = _fesapi.resqml20__ResqmlUom__1_x002fuV
resqml20__ResqmlUom__1_x002fV = _fesapi.resqml20__ResqmlUom__1_x002fV
resqml20__ResqmlUom__1_x002fwk = _fesapi.resqml20__ResqmlUom__1_x002fwk
resqml20__ResqmlUom__1_x002fyd = _fesapi.resqml20__ResqmlUom__1_x002fyd
resqml20__ResqmlUom__10_x0020ft = _fesapi.resqml20__ResqmlUom__10_x0020ft
resqml20__ResqmlUom__10_x0020in = _fesapi.resqml20__ResqmlUom__10_x0020in
resqml20__ResqmlUom__10_x0020km = _fesapi.resqml20__ResqmlUom__10_x0020km
resqml20__ResqmlUom__10_x0020kN = _fesapi.resqml20__ResqmlUom__10_x0020kN
resqml20__ResqmlUom__10_x0020Mg_x002fm3 = _fesapi.resqml20__ResqmlUom__10_x0020Mg_x002fm3
resqml20__ResqmlUom__100_x0020ft = _fesapi.resqml20__ResqmlUom__100_x0020ft
resqml20__ResqmlUom__100_x0020ka_x005bt_x005d = _fesapi.resqml20__ResqmlUom__100_x0020ka_x005bt_x005d
resqml20__ResqmlUom__100_x0020km = _fesapi.resqml20__ResqmlUom__100_x0020km
resqml20__ResqmlUom__1000_x0020bbl = _fesapi.resqml20__ResqmlUom__1000_x0020bbl
resqml20__ResqmlUom__1000_x0020bbl_x002eft_x002fd = _fesapi.resqml20__ResqmlUom__1000_x0020bbl_x002eft_x002fd
resqml20__ResqmlUom__1000_x0020bbl_x002fd = _fesapi.resqml20__ResqmlUom__1000_x0020bbl_x002fd
resqml20__ResqmlUom__1000_x0020ft = _fesapi.resqml20__ResqmlUom__1000_x0020ft
resqml20__ResqmlUom__1000_x0020ft_x002fh = _fesapi.resqml20__ResqmlUom__1000_x0020ft_x002fh
resqml20__ResqmlUom__1000_x0020ft_x002fs = _fesapi.resqml20__ResqmlUom__1000_x0020ft_x002fs
resqml20__ResqmlUom__1000_x0020ft3 = _fesapi.resqml20__ResqmlUom__1000_x0020ft3
resqml20__ResqmlUom__1000_x0020ft3_x002f_x0028d_x002eft_x0029 = _fesapi.resqml20__ResqmlUom__1000_x0020ft3_x002f_x0028d_x002eft_x0029
resqml20__ResqmlUom__1000_x0020ft3_x002f_x0028psi_x002ed_x0029 = _fesapi.resqml20__ResqmlUom__1000_x0020ft3_x002f_x0028psi_x002ed_x0029
resqml20__ResqmlUom__1000_x0020ft3_x002fbbl = _fesapi.resqml20__ResqmlUom__1000_x0020ft3_x002fbbl
resqml20__ResqmlUom__1000_x0020ft3_x002fd = _fesapi.resqml20__ResqmlUom__1000_x0020ft3_x002fd
resqml20__ResqmlUom__1000_x0020gal_x005bUK_x005d = _fesapi.resqml20__ResqmlUom__1000_x0020gal_x005bUK_x005d
resqml20__ResqmlUom__1000_x0020gal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom__1000_x0020gal_x005bUS_x005d
resqml20__ResqmlUom__1000_x0020lbf_x002eft = _fesapi.resqml20__ResqmlUom__1000_x0020lbf_x002eft
resqml20__ResqmlUom__1000_x0020m3 = _fesapi.resqml20__ResqmlUom__1000_x0020m3
resqml20__ResqmlUom__1000_x0020m3_x002f_x0028d_x002em_x0029 = _fesapi.resqml20__ResqmlUom__1000_x0020m3_x002f_x0028d_x002em_x0029
resqml20__ResqmlUom__1000_x0020m3_x002f_x0028h_x002em_x0029 = _fesapi.resqml20__ResqmlUom__1000_x0020m3_x002f_x0028h_x002em_x0029
resqml20__ResqmlUom__1000_x0020m3_x002fd = _fesapi.resqml20__ResqmlUom__1000_x0020m3_x002fd
resqml20__ResqmlUom__1000_x0020m3_x002fh = _fesapi.resqml20__ResqmlUom__1000_x0020m3_x002fh
resqml20__ResqmlUom__1000_x0020m3_x002fm3 = _fesapi.resqml20__ResqmlUom__1000_x0020m3_x002fm3
resqml20__ResqmlUom__1000_x0020m4_x002fd = _fesapi.resqml20__ResqmlUom__1000_x0020m4_x002fd
resqml20__ResqmlUom__1E_6_x0020acre_x002eft_x002fbbl = _fesapi.resqml20__ResqmlUom__1E_6_x0020acre_x002eft_x002fbbl
resqml20__ResqmlUom__1E_6_x0020bbl_x002fft3 = _fesapi.resqml20__ResqmlUom__1E_6_x0020bbl_x002fft3
resqml20__ResqmlUom__1E_6_x0020bbl_x002fm3 = _fesapi.resqml20__ResqmlUom__1E_6_x0020bbl_x002fm3
resqml20__ResqmlUom__1E_6_x0020gal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom__1E_6_x0020gal_x005bUS_x005d
resqml20__ResqmlUom__1E_6_x0020m3_x002f_x0028m3_x002edegC_x0029 = _fesapi.resqml20__ResqmlUom__1E_6_x0020m3_x002f_x0028m3_x002edegC_x0029
resqml20__ResqmlUom__1E_6_x0020m3_x002f_x0028m3_x002edegF_x0029 = _fesapi.resqml20__ResqmlUom__1E_6_x0020m3_x002f_x0028m3_x002edegF_x0029
resqml20__ResqmlUom__1E_9_x00201_x002fft = _fesapi.resqml20__ResqmlUom__1E_9_x00201_x002fft
resqml20__ResqmlUom__1E12_x0020ft3 = _fesapi.resqml20__ResqmlUom__1E12_x0020ft3
resqml20__ResqmlUom__1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = _fesapi.resqml20__ResqmlUom__1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029
resqml20__ResqmlUom__1E6_x0020bbl = _fesapi.resqml20__ResqmlUom__1E6_x0020bbl
resqml20__ResqmlUom__1E6_x0020bbl_x002f_x0028acre_x002eft_x0029 = _fesapi.resqml20__ResqmlUom__1E6_x0020bbl_x002f_x0028acre_x002eft_x0029
resqml20__ResqmlUom__1E6_x0020bbl_x002facre = _fesapi.resqml20__ResqmlUom__1E6_x0020bbl_x002facre
resqml20__ResqmlUom__1E6_x0020bbl_x002fd = _fesapi.resqml20__ResqmlUom__1E6_x0020bbl_x002fd
resqml20__ResqmlUom__1E6_x0020Btu_x005bIT_x005d = _fesapi.resqml20__ResqmlUom__1E6_x0020Btu_x005bIT_x005d
resqml20__ResqmlUom__1E6_x0020Btu_x005bIT_x005d_x002fh = _fesapi.resqml20__ResqmlUom__1E6_x0020Btu_x005bIT_x005d_x002fh
resqml20__ResqmlUom__1E6_x0020ft3 = _fesapi.resqml20__ResqmlUom__1E6_x0020ft3
resqml20__ResqmlUom__1E6_x0020ft3_x002f_x0028acre_x002eft_x0029 = _fesapi.resqml20__ResqmlUom__1E6_x0020ft3_x002f_x0028acre_x002eft_x0029
resqml20__ResqmlUom__1E6_x0020ft3_x002fbbl = _fesapi.resqml20__ResqmlUom__1E6_x0020ft3_x002fbbl
resqml20__ResqmlUom__1E6_x0020ft3_x002fd = _fesapi.resqml20__ResqmlUom__1E6_x0020ft3_x002fd
resqml20__ResqmlUom__1E6_x0020lbm_x002fa = _fesapi.resqml20__ResqmlUom__1E6_x0020lbm_x002fa
resqml20__ResqmlUom__1E6_x0020m3 = _fesapi.resqml20__ResqmlUom__1E6_x0020m3
resqml20__ResqmlUom__1E6_x0020m3_x002fd = _fesapi.resqml20__ResqmlUom__1E6_x0020m3_x002fd
resqml20__ResqmlUom__1E9_x0020bbl = _fesapi.resqml20__ResqmlUom__1E9_x0020bbl
resqml20__ResqmlUom__1E9_x0020ft3 = _fesapi.resqml20__ResqmlUom__1E9_x0020ft3
resqml20__ResqmlUom__30_x0020ft = _fesapi.resqml20__ResqmlUom__30_x0020ft
resqml20__ResqmlUom__30_x0020m = _fesapi.resqml20__ResqmlUom__30_x0020m
resqml20__ResqmlUom_A_x002eh = _fesapi.resqml20__ResqmlUom_A_x002eh
resqml20__ResqmlUom_A_x002em2 = _fesapi.resqml20__ResqmlUom_A_x002em2
resqml20__ResqmlUom_A_x002es = _fesapi.resqml20__ResqmlUom_A_x002es
resqml20__ResqmlUom_A_x002es_x002fkg = _fesapi.resqml20__ResqmlUom_A_x002es_x002fkg
resqml20__ResqmlUom_A_x002es_x002fm3 = _fesapi.resqml20__ResqmlUom_A_x002es_x002fm3
resqml20__ResqmlUom_A_x002fcm2 = _fesapi.resqml20__ResqmlUom_A_x002fcm2
resqml20__ResqmlUom_A_x002fft2 = _fesapi.resqml20__ResqmlUom_A_x002fft2
resqml20__ResqmlUom_A_x002fm = _fesapi.resqml20__ResqmlUom_A_x002fm
resqml20__ResqmlUom_A_x002fm2 = _fesapi.resqml20__ResqmlUom_A_x002fm2
resqml20__ResqmlUom_A_x002fmm = _fesapi.resqml20__ResqmlUom_A_x002fmm
resqml20__ResqmlUom_A_x002fmm2 = _fesapi.resqml20__ResqmlUom_A_x002fmm2
resqml20__ResqmlUom_a_x005bt_x005d = _fesapi.resqml20__ResqmlUom_a_x005bt_x005d
resqml20__ResqmlUom_acre = _fesapi.resqml20__ResqmlUom_acre
resqml20__ResqmlUom_acre_x002eft = _fesapi.resqml20__ResqmlUom_acre_x002eft
resqml20__ResqmlUom_ag = _fesapi.resqml20__ResqmlUom_ag
resqml20__ResqmlUom_aJ = _fesapi.resqml20__ResqmlUom_aJ
resqml20__ResqmlUom_angstrom = _fesapi.resqml20__ResqmlUom_angstrom
resqml20__ResqmlUom_at = _fesapi.resqml20__ResqmlUom_at
resqml20__ResqmlUom_atm = _fesapi.resqml20__ResqmlUom_atm
resqml20__ResqmlUom_atm_x002fft = _fesapi.resqml20__ResqmlUom_atm_x002fft
resqml20__ResqmlUom_atm_x002fh = _fesapi.resqml20__ResqmlUom_atm_x002fh
resqml20__ResqmlUom_atm_x002fhm = _fesapi.resqml20__ResqmlUom_atm_x002fhm
resqml20__ResqmlUom_atm_x002fm = _fesapi.resqml20__ResqmlUom_atm_x002fm
resqml20__ResqmlUom_B_x002eW = _fesapi.resqml20__ResqmlUom_B_x002eW
resqml20__ResqmlUom_b_x002fcm3 = _fesapi.resqml20__ResqmlUom_b_x002fcm3
resqml20__ResqmlUom_B_x002fm = _fesapi.resqml20__ResqmlUom_B_x002fm
resqml20__ResqmlUom_B_x002fO = _fesapi.resqml20__ResqmlUom_B_x002fO
resqml20__ResqmlUom_bar = _fesapi.resqml20__ResqmlUom_bar
resqml20__ResqmlUom_bar_x002fh = _fesapi.resqml20__ResqmlUom_bar_x002fh
resqml20__ResqmlUom_bar_x002fkm = _fesapi.resqml20__ResqmlUom_bar_x002fkm
resqml20__ResqmlUom_bar_x002fm = _fesapi.resqml20__ResqmlUom_bar_x002fm
resqml20__ResqmlUom_bar2 = _fesapi.resqml20__ResqmlUom_bar2
resqml20__ResqmlUom_bar2_x002fcP = _fesapi.resqml20__ResqmlUom_bar2_x002fcP
resqml20__ResqmlUom_bbl = _fesapi.resqml20__ResqmlUom_bbl
resqml20__ResqmlUom_bbl_x002f_x0028acre_x002eft_x0029 = _fesapi.resqml20__ResqmlUom_bbl_x002f_x0028acre_x002eft_x0029
resqml20__ResqmlUom_bbl_x002f_x0028d_x002eacre_x002eft_x0029 = _fesapi.resqml20__ResqmlUom_bbl_x002f_x0028d_x002eacre_x002eft_x0029
resqml20__ResqmlUom_bbl_x002f_x0028d_x002eft_x0029 = _fesapi.resqml20__ResqmlUom_bbl_x002f_x0028d_x002eft_x0029
resqml20__ResqmlUom_bbl_x002f_x0028ft_x002epsi_x002ed_x0029 = _fesapi.resqml20__ResqmlUom_bbl_x002f_x0028ft_x002epsi_x002ed_x0029
resqml20__ResqmlUom_bbl_x002f_x0028kPa_x002ed_x0029 = _fesapi.resqml20__ResqmlUom_bbl_x002f_x0028kPa_x002ed_x0029
resqml20__ResqmlUom_bbl_x002f_x0028psi_x002ed_x0029 = _fesapi.resqml20__ResqmlUom_bbl_x002f_x0028psi_x002ed_x0029
resqml20__ResqmlUom_bbl_x002facre = _fesapi.resqml20__ResqmlUom_bbl_x002facre
resqml20__ResqmlUom_bbl_x002fbbl = _fesapi.resqml20__ResqmlUom_bbl_x002fbbl
resqml20__ResqmlUom_bbl_x002fd = _fesapi.resqml20__ResqmlUom_bbl_x002fd
resqml20__ResqmlUom_bbl_x002fd2 = _fesapi.resqml20__ResqmlUom_bbl_x002fd2
resqml20__ResqmlUom_bbl_x002fft = _fesapi.resqml20__ResqmlUom_bbl_x002fft
resqml20__ResqmlUom_bbl_x002fft3 = _fesapi.resqml20__ResqmlUom_bbl_x002fft3
resqml20__ResqmlUom_bbl_x002fh = _fesapi.resqml20__ResqmlUom_bbl_x002fh
resqml20__ResqmlUom_bbl_x002fh2 = _fesapi.resqml20__ResqmlUom_bbl_x002fh2
resqml20__ResqmlUom_bbl_x002fin = _fesapi.resqml20__ResqmlUom_bbl_x002fin
resqml20__ResqmlUom_bbl_x002fm3 = _fesapi.resqml20__ResqmlUom_bbl_x002fm3
resqml20__ResqmlUom_bbl_x002fmi = _fesapi.resqml20__ResqmlUom_bbl_x002fmi
resqml20__ResqmlUom_bbl_x002fmin = _fesapi.resqml20__ResqmlUom_bbl_x002fmin
resqml20__ResqmlUom_bbl_x002fpsi = _fesapi.resqml20__ResqmlUom_bbl_x002fpsi
resqml20__ResqmlUom_bbl_x002fton_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_bbl_x002fton_x005bUK_x005d
resqml20__ResqmlUom_bbl_x002fton_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_bbl_x002fton_x005bUS_x005d
resqml20__ResqmlUom_Bd = _fesapi.resqml20__ResqmlUom_Bd
resqml20__ResqmlUom_bit = _fesapi.resqml20__ResqmlUom_bit
resqml20__ResqmlUom_bit_x002fs = _fesapi.resqml20__ResqmlUom_bit_x002fs
resqml20__ResqmlUom_Bq = _fesapi.resqml20__ResqmlUom_Bq
resqml20__ResqmlUom_Bq_x002fkg = _fesapi.resqml20__ResqmlUom_Bq_x002fkg
resqml20__ResqmlUom_Btu_x005bIT_x005d = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edegF_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edegF_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edegF_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edegF_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegF_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegF_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegR_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegR_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edegF_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edegF_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edegC_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028lbm_x002edegF_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028lbm_x002edegF_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028lbm_x002edegR_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028lbm_x002edegR_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028lbmol_x002edegF_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028lbmol_x002edegF_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edegF_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edegF_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edegF_x0029 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edegF_x0029
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fbbl = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fbbl
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fft3 = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fft3
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fgal_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fgal_x005bUK_x005d
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fgal_x005bUS_x005d
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fh = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fh
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002flbm = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002flbm
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002flbmol = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002flbmol
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fmin = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fmin
resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fs = _fesapi.resqml20__ResqmlUom_Btu_x005bIT_x005d_x002fs
resqml20__ResqmlUom_Btu_x005bth_x005d = _fesapi.resqml20__ResqmlUom_Btu_x005bth_x005d
resqml20__ResqmlUom_Btu_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_Btu_x005bUK_x005d
resqml20__ResqmlUom_byte = _fesapi.resqml20__ResqmlUom_byte
resqml20__ResqmlUom_byte_x002fs = _fesapi.resqml20__ResqmlUom_byte_x002fs
resqml20__ResqmlUom_C_x002em = _fesapi.resqml20__ResqmlUom_C_x002em
resqml20__ResqmlUom_C_x002fcm2 = _fesapi.resqml20__ResqmlUom_C_x002fcm2
resqml20__ResqmlUom_C_x002fcm3 = _fesapi.resqml20__ResqmlUom_C_x002fcm3
resqml20__ResqmlUom_C_x002fg = _fesapi.resqml20__ResqmlUom_C_x002fg
resqml20__ResqmlUom_C_x002fkg = _fesapi.resqml20__ResqmlUom_C_x002fkg
resqml20__ResqmlUom_C_x002fm2 = _fesapi.resqml20__ResqmlUom_C_x002fm2
resqml20__ResqmlUom_C_x002fm3 = _fesapi.resqml20__ResqmlUom_C_x002fm3
resqml20__ResqmlUom_C_x002fmm2 = _fesapi.resqml20__ResqmlUom_C_x002fmm2
resqml20__ResqmlUom_C_x002fmm3 = _fesapi.resqml20__ResqmlUom_C_x002fmm3
resqml20__ResqmlUom_ca = _fesapi.resqml20__ResqmlUom_ca
resqml20__ResqmlUom_cA = _fesapi.resqml20__ResqmlUom_cA
resqml20__ResqmlUom_cal_x005bIT_x005d = _fesapi.resqml20__ResqmlUom_cal_x005bIT_x005d
resqml20__ResqmlUom_cal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d
resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028g_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028g_x002eK_x0029
resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edegC_x0029 = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edegC_x0029
resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029 = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029
resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edegC_x0029 = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edegC_x0029
resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029 = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029
resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028mol_x002edegC_x0029 = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028mol_x002edegC_x0029
resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edegC_x0029 = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edegC_x0029
resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edegC_x0029 = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edegC_x0029
resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029 = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029
resqml20__ResqmlUom_cal_x005bth_x005d_x002fcm3 = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002fcm3
resqml20__ResqmlUom_cal_x005bth_x005d_x002fg = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002fg
resqml20__ResqmlUom_cal_x005bth_x005d_x002fh = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002fh
resqml20__ResqmlUom_cal_x005bth_x005d_x002fkg = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002fkg
resqml20__ResqmlUom_cal_x005bth_x005d_x002flbm = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002flbm
resqml20__ResqmlUom_cal_x005bth_x005d_x002fmL = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002fmL
resqml20__ResqmlUom_cal_x005bth_x005d_x002fmm3 = _fesapi.resqml20__ResqmlUom_cal_x005bth_x005d_x002fmm3
resqml20__ResqmlUom_cC = _fesapi.resqml20__ResqmlUom_cC
resqml20__ResqmlUom_ccal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_ccal_x005bth_x005d
resqml20__ResqmlUom_ccgr = _fesapi.resqml20__ResqmlUom_ccgr
resqml20__ResqmlUom_cd = _fesapi.resqml20__ResqmlUom_cd
resqml20__ResqmlUom_cd_x002fm2 = _fesapi.resqml20__ResqmlUom_cd_x002fm2
resqml20__ResqmlUom_cEuc = _fesapi.resqml20__ResqmlUom_cEuc
resqml20__ResqmlUom_ceV = _fesapi.resqml20__ResqmlUom_ceV
resqml20__ResqmlUom_cF = _fesapi.resqml20__ResqmlUom_cF
resqml20__ResqmlUom_cg = _fesapi.resqml20__ResqmlUom_cg
resqml20__ResqmlUom_cgauss = _fesapi.resqml20__ResqmlUom_cgauss
resqml20__ResqmlUom_cgr = _fesapi.resqml20__ResqmlUom_cgr
resqml20__ResqmlUom_cGy = _fesapi.resqml20__ResqmlUom_cGy
resqml20__ResqmlUom_cH = _fesapi.resqml20__ResqmlUom_cH
resqml20__ResqmlUom_chain = _fesapi.resqml20__ResqmlUom_chain
resqml20__ResqmlUom_chain_x005bBnA_x005d = _fesapi.resqml20__ResqmlUom_chain_x005bBnA_x005d
resqml20__ResqmlUom_chain_x005bBnB_x005d = _fesapi.resqml20__ResqmlUom_chain_x005bBnB_x005d
resqml20__ResqmlUom_chain_x005bCla_x005d = _fesapi.resqml20__ResqmlUom_chain_x005bCla_x005d
resqml20__ResqmlUom_chain_x005bInd37_x005d = _fesapi.resqml20__ResqmlUom_chain_x005bInd37_x005d
resqml20__ResqmlUom_chain_x005bSe_x005d = _fesapi.resqml20__ResqmlUom_chain_x005bSe_x005d
resqml20__ResqmlUom_chain_x005bSeT_x005d = _fesapi.resqml20__ResqmlUom_chain_x005bSeT_x005d
resqml20__ResqmlUom_chain_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_chain_x005bUS_x005d
resqml20__ResqmlUom_cHz = _fesapi.resqml20__ResqmlUom_cHz
resqml20__ResqmlUom_Ci = _fesapi.resqml20__ResqmlUom_Ci
resqml20__ResqmlUom_cJ = _fesapi.resqml20__ResqmlUom_cJ
resqml20__ResqmlUom_cm = _fesapi.resqml20__ResqmlUom_cm
resqml20__ResqmlUom_cm_x002fa = _fesapi.resqml20__ResqmlUom_cm_x002fa
resqml20__ResqmlUom_cm_x002fs = _fesapi.resqml20__ResqmlUom_cm_x002fs
resqml20__ResqmlUom_cm_x002fs2 = _fesapi.resqml20__ResqmlUom_cm_x002fs2
resqml20__ResqmlUom_cm2 = _fesapi.resqml20__ResqmlUom_cm2
resqml20__ResqmlUom_cm2_x002fg = _fesapi.resqml20__ResqmlUom_cm2_x002fg
resqml20__ResqmlUom_cm2_x002fs = _fesapi.resqml20__ResqmlUom_cm2_x002fs
resqml20__ResqmlUom_cm3 = _fesapi.resqml20__ResqmlUom_cm3
resqml20__ResqmlUom_cm3_x002fcm3 = _fesapi.resqml20__ResqmlUom_cm3_x002fcm3
resqml20__ResqmlUom_cm3_x002fg = _fesapi.resqml20__ResqmlUom_cm3_x002fg
resqml20__ResqmlUom_cm3_x002fh = _fesapi.resqml20__ResqmlUom_cm3_x002fh
resqml20__ResqmlUom_cm3_x002fL = _fesapi.resqml20__ResqmlUom_cm3_x002fL
resqml20__ResqmlUom_cm3_x002fm3 = _fesapi.resqml20__ResqmlUom_cm3_x002fm3
resqml20__ResqmlUom_cm3_x002fmin = _fesapi.resqml20__ResqmlUom_cm3_x002fmin
resqml20__ResqmlUom_cm3_x002fs = _fesapi.resqml20__ResqmlUom_cm3_x002fs
resqml20__ResqmlUom_cm4 = _fesapi.resqml20__ResqmlUom_cm4
resqml20__ResqmlUom_cmH2O_x005b4degC_x005d = _fesapi.resqml20__ResqmlUom_cmH2O_x005b4degC_x005d
resqml20__ResqmlUom_cN = _fesapi.resqml20__ResqmlUom_cN
resqml20__ResqmlUom_cohm = _fesapi.resqml20__ResqmlUom_cohm
resqml20__ResqmlUom_cP = _fesapi.resqml20__ResqmlUom_cP
resqml20__ResqmlUom_cPa = _fesapi.resqml20__ResqmlUom_cPa
resqml20__ResqmlUom_crd = _fesapi.resqml20__ResqmlUom_crd
resqml20__ResqmlUom_cS = _fesapi.resqml20__ResqmlUom_cS
resqml20__ResqmlUom_cs = _fesapi.resqml20__ResqmlUom_cs
resqml20__ResqmlUom_cSt = _fesapi.resqml20__ResqmlUom_cSt
resqml20__ResqmlUom_ct = _fesapi.resqml20__ResqmlUom_ct
resqml20__ResqmlUom_cT = _fesapi.resqml20__ResqmlUom_cT
resqml20__ResqmlUom_cu = _fesapi.resqml20__ResqmlUom_cu
resqml20__ResqmlUom_cV = _fesapi.resqml20__ResqmlUom_cV
resqml20__ResqmlUom_cW = _fesapi.resqml20__ResqmlUom_cW
resqml20__ResqmlUom_cWb = _fesapi.resqml20__ResqmlUom_cWb
resqml20__ResqmlUom_cwt_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_cwt_x005bUK_x005d
resqml20__ResqmlUom_cwt_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_cwt_x005bUS_x005d
resqml20__ResqmlUom_D_x002eft = _fesapi.resqml20__ResqmlUom_D_x002eft
resqml20__ResqmlUom_D_x002em = _fesapi.resqml20__ResqmlUom_D_x002em
resqml20__ResqmlUom_D_x002f_x0028Pa_x002es_x0029 = _fesapi.resqml20__ResqmlUom_D_x002f_x0028Pa_x002es_x0029
resqml20__ResqmlUom_d_x002fbbl = _fesapi.resqml20__ResqmlUom_d_x002fbbl
resqml20__ResqmlUom_D_x002fcP = _fesapi.resqml20__ResqmlUom_D_x002fcP
resqml20__ResqmlUom_d_x002fft3 = _fesapi.resqml20__ResqmlUom_d_x002fft3
resqml20__ResqmlUom_d_x002fm3 = _fesapi.resqml20__ResqmlUom_d_x002fm3
resqml20__ResqmlUom_D_x005bAPI_x005d = _fesapi.resqml20__ResqmlUom_D_x005bAPI_x005d
resqml20__ResqmlUom_dA = _fesapi.resqml20__ResqmlUom_dA
resqml20__ResqmlUom_dam = _fesapi.resqml20__ResqmlUom_dam
resqml20__ResqmlUom_daN = _fesapi.resqml20__ResqmlUom_daN
resqml20__ResqmlUom_daN_x002em = _fesapi.resqml20__ResqmlUom_daN_x002em
resqml20__ResqmlUom_dAPI = _fesapi.resqml20__ResqmlUom_dAPI
resqml20__ResqmlUom_dB = _fesapi.resqml20__ResqmlUom_dB
resqml20__ResqmlUom_dB_x002eMW = _fesapi.resqml20__ResqmlUom_dB_x002eMW
resqml20__ResqmlUom_dB_x002emW = _fesapi.resqml20__ResqmlUom_dB_x002emW
resqml20__ResqmlUom_dB_x002eW = _fesapi.resqml20__ResqmlUom_dB_x002eW
resqml20__ResqmlUom_dB_x002fft = _fesapi.resqml20__ResqmlUom_dB_x002fft
resqml20__ResqmlUom_dB_x002fkm = _fesapi.resqml20__ResqmlUom_dB_x002fkm
resqml20__ResqmlUom_dB_x002fm = _fesapi.resqml20__ResqmlUom_dB_x002fm
resqml20__ResqmlUom_dB_x002fO = _fesapi.resqml20__ResqmlUom_dB_x002fO
resqml20__ResqmlUom_dC = _fesapi.resqml20__ResqmlUom_dC
resqml20__ResqmlUom_dcal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_dcal_x005bth_x005d
resqml20__ResqmlUom_dega = _fesapi.resqml20__ResqmlUom_dega
resqml20__ResqmlUom_dega_x002fft = _fesapi.resqml20__ResqmlUom_dega_x002fft
resqml20__ResqmlUom_dega_x002fh = _fesapi.resqml20__ResqmlUom_dega_x002fh
resqml20__ResqmlUom_dega_x002fm = _fesapi.resqml20__ResqmlUom_dega_x002fm
resqml20__ResqmlUom_dega_x002fmin = _fesapi.resqml20__ResqmlUom_dega_x002fmin
resqml20__ResqmlUom_dega_x002fs = _fesapi.resqml20__ResqmlUom_dega_x002fs
resqml20__ResqmlUom_degC = _fesapi.resqml20__ResqmlUom_degC
resqml20__ResqmlUom_degC_x002em2_x002eh_x002fkcal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_degC_x002em2_x002eh_x002fkcal_x005bth_x005d
resqml20__ResqmlUom_degC_x002fft = _fesapi.resqml20__ResqmlUom_degC_x002fft
resqml20__ResqmlUom_degC_x002fh = _fesapi.resqml20__ResqmlUom_degC_x002fh
resqml20__ResqmlUom_degC_x002fhm = _fesapi.resqml20__ResqmlUom_degC_x002fhm
resqml20__ResqmlUom_degC_x002fkm = _fesapi.resqml20__ResqmlUom_degC_x002fkm
resqml20__ResqmlUom_degC_x002fkPa = _fesapi.resqml20__ResqmlUom_degC_x002fkPa
resqml20__ResqmlUom_degC_x002fm = _fesapi.resqml20__ResqmlUom_degC_x002fm
resqml20__ResqmlUom_degC_x002fmin = _fesapi.resqml20__ResqmlUom_degC_x002fmin
resqml20__ResqmlUom_degC_x002fs = _fesapi.resqml20__ResqmlUom_degC_x002fs
resqml20__ResqmlUom_degF = _fesapi.resqml20__ResqmlUom_degF
resqml20__ResqmlUom_degF_x002eft2_x002eh_x002fBtu_x005bIT_x005d = _fesapi.resqml20__ResqmlUom_degF_x002eft2_x002eh_x002fBtu_x005bIT_x005d
resqml20__ResqmlUom_degF_x002fft = _fesapi.resqml20__ResqmlUom_degF_x002fft
resqml20__ResqmlUom_degF_x002fh = _fesapi.resqml20__ResqmlUom_degF_x002fh
resqml20__ResqmlUom_degF_x002fm = _fesapi.resqml20__ResqmlUom_degF_x002fm
resqml20__ResqmlUom_degF_x002fmin = _fesapi.resqml20__ResqmlUom_degF_x002fmin
resqml20__ResqmlUom_degF_x002fpsi = _fesapi.resqml20__ResqmlUom_degF_x002fpsi
resqml20__ResqmlUom_degF_x002fs = _fesapi.resqml20__ResqmlUom_degF_x002fs
resqml20__ResqmlUom_degR = _fesapi.resqml20__ResqmlUom_degR
resqml20__ResqmlUom_dEuc = _fesapi.resqml20__ResqmlUom_dEuc
resqml20__ResqmlUom_deV = _fesapi.resqml20__ResqmlUom_deV
resqml20__ResqmlUom_dF = _fesapi.resqml20__ResqmlUom_dF
resqml20__ResqmlUom_dgauss = _fesapi.resqml20__ResqmlUom_dgauss
resqml20__ResqmlUom_dGy = _fesapi.resqml20__ResqmlUom_dGy
resqml20__ResqmlUom_dH = _fesapi.resqml20__ResqmlUom_dH
resqml20__ResqmlUom_dHz = _fesapi.resqml20__ResqmlUom_dHz
resqml20__ResqmlUom_dJ = _fesapi.resqml20__ResqmlUom_dJ
resqml20__ResqmlUom_dm = _fesapi.resqml20__ResqmlUom_dm
resqml20__ResqmlUom_dm_x002fs = _fesapi.resqml20__ResqmlUom_dm_x002fs
resqml20__ResqmlUom_dm3 = _fesapi.resqml20__ResqmlUom_dm3
resqml20__ResqmlUom_dm3_x002f_x0028kW_x002eh_x0029 = _fesapi.resqml20__ResqmlUom_dm3_x002f_x0028kW_x002eh_x0029
resqml20__ResqmlUom_dm3_x002fkg = _fesapi.resqml20__ResqmlUom_dm3_x002fkg
resqml20__ResqmlUom_dm3_x002fkmol = _fesapi.resqml20__ResqmlUom_dm3_x002fkmol
resqml20__ResqmlUom_dm3_x002fm = _fesapi.resqml20__ResqmlUom_dm3_x002fm
resqml20__ResqmlUom_dm3_x002fm3 = _fesapi.resqml20__ResqmlUom_dm3_x002fm3
resqml20__ResqmlUom_dm3_x002fMJ = _fesapi.resqml20__ResqmlUom_dm3_x002fMJ
resqml20__ResqmlUom_dm3_x002fs = _fesapi.resqml20__ResqmlUom_dm3_x002fs
resqml20__ResqmlUom_dm3_x002fs2 = _fesapi.resqml20__ResqmlUom_dm3_x002fs2
resqml20__ResqmlUom_dm3_x002ft = _fesapi.resqml20__ResqmlUom_dm3_x002ft
resqml20__ResqmlUom_dN = _fesapi.resqml20__ResqmlUom_dN
resqml20__ResqmlUom_dN_x002em = _fesapi.resqml20__ResqmlUom_dN_x002em
resqml20__ResqmlUom_dohm = _fesapi.resqml20__ResqmlUom_dohm
resqml20__ResqmlUom_dP = _fesapi.resqml20__ResqmlUom_dP
resqml20__ResqmlUom_dPa = _fesapi.resqml20__ResqmlUom_dPa
resqml20__ResqmlUom_drd = _fesapi.resqml20__ResqmlUom_drd
resqml20__ResqmlUom_ds = _fesapi.resqml20__ResqmlUom_ds
resqml20__ResqmlUom_dS = _fesapi.resqml20__ResqmlUom_dS
resqml20__ResqmlUom_dT = _fesapi.resqml20__ResqmlUom_dT
resqml20__ResqmlUom_dV = _fesapi.resqml20__ResqmlUom_dV
resqml20__ResqmlUom_dW = _fesapi.resqml20__ResqmlUom_dW
resqml20__ResqmlUom_dWb = _fesapi.resqml20__ResqmlUom_dWb
resqml20__ResqmlUom_dyne = _fesapi.resqml20__ResqmlUom_dyne
resqml20__ResqmlUom_dyne_x002ecm2 = _fesapi.resqml20__ResqmlUom_dyne_x002ecm2
resqml20__ResqmlUom_dyne_x002es_x002fcm2 = _fesapi.resqml20__ResqmlUom_dyne_x002es_x002fcm2
resqml20__ResqmlUom_dyne_x002fcm = _fesapi.resqml20__ResqmlUom_dyne_x002fcm
resqml20__ResqmlUom_dyne_x002fcm2 = _fesapi.resqml20__ResqmlUom_dyne_x002fcm2
resqml20__ResqmlUom_EA = _fesapi.resqml20__ResqmlUom_EA
resqml20__ResqmlUom_Ea_x005bt_x005d = _fesapi.resqml20__ResqmlUom_Ea_x005bt_x005d
resqml20__ResqmlUom_EC = _fesapi.resqml20__ResqmlUom_EC
resqml20__ResqmlUom_Ecal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_Ecal_x005bth_x005d
resqml20__ResqmlUom_EEuc = _fesapi.resqml20__ResqmlUom_EEuc
resqml20__ResqmlUom_EeV = _fesapi.resqml20__ResqmlUom_EeV
resqml20__ResqmlUom_EF = _fesapi.resqml20__ResqmlUom_EF
resqml20__ResqmlUom_Eg = _fesapi.resqml20__ResqmlUom_Eg
resqml20__ResqmlUom_Egauss = _fesapi.resqml20__ResqmlUom_Egauss
resqml20__ResqmlUom_EGy = _fesapi.resqml20__ResqmlUom_EGy
resqml20__ResqmlUom_EH = _fesapi.resqml20__ResqmlUom_EH
resqml20__ResqmlUom_EHz = _fesapi.resqml20__ResqmlUom_EHz
resqml20__ResqmlUom_EJ = _fesapi.resqml20__ResqmlUom_EJ
resqml20__ResqmlUom_EJ_x002fa = _fesapi.resqml20__ResqmlUom_EJ_x002fa
resqml20__ResqmlUom_Em = _fesapi.resqml20__ResqmlUom_Em
resqml20__ResqmlUom_EN = _fesapi.resqml20__ResqmlUom_EN
resqml20__ResqmlUom_Eohm = _fesapi.resqml20__ResqmlUom_Eohm
resqml20__ResqmlUom_EP = _fesapi.resqml20__ResqmlUom_EP
resqml20__ResqmlUom_EPa = _fesapi.resqml20__ResqmlUom_EPa
resqml20__ResqmlUom_Erd = _fesapi.resqml20__ResqmlUom_Erd
resqml20__ResqmlUom_erg = _fesapi.resqml20__ResqmlUom_erg
resqml20__ResqmlUom_erg_x002fa = _fesapi.resqml20__ResqmlUom_erg_x002fa
resqml20__ResqmlUom_erg_x002fcm2 = _fesapi.resqml20__ResqmlUom_erg_x002fcm2
resqml20__ResqmlUom_erg_x002fcm3 = _fesapi.resqml20__ResqmlUom_erg_x002fcm3
resqml20__ResqmlUom_erg_x002fg = _fesapi.resqml20__ResqmlUom_erg_x002fg
resqml20__ResqmlUom_erg_x002fkg = _fesapi.resqml20__ResqmlUom_erg_x002fkg
resqml20__ResqmlUom_erg_x002fm3 = _fesapi.resqml20__ResqmlUom_erg_x002fm3
resqml20__ResqmlUom_ES = _fesapi.resqml20__ResqmlUom_ES
resqml20__ResqmlUom_ET = _fesapi.resqml20__ResqmlUom_ET
resqml20__ResqmlUom_Euc = _fesapi.resqml20__ResqmlUom_Euc
resqml20__ResqmlUom_eV = _fesapi.resqml20__ResqmlUom_eV
resqml20__ResqmlUom_EW = _fesapi.resqml20__ResqmlUom_EW
resqml20__ResqmlUom_EWb = _fesapi.resqml20__ResqmlUom_EWb
resqml20__ResqmlUom_F_x002fm = _fesapi.resqml20__ResqmlUom_F_x002fm
resqml20__ResqmlUom_fa = _fesapi.resqml20__ResqmlUom_fa
resqml20__ResqmlUom_fA = _fesapi.resqml20__ResqmlUom_fA
resqml20__ResqmlUom_fathom = _fesapi.resqml20__ResqmlUom_fathom
resqml20__ResqmlUom_fC = _fesapi.resqml20__ResqmlUom_fC
resqml20__ResqmlUom_fcal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_fcal_x005bth_x005d
resqml20__ResqmlUom_fEuc = _fesapi.resqml20__ResqmlUom_fEuc
resqml20__ResqmlUom_feV = _fesapi.resqml20__ResqmlUom_feV
resqml20__ResqmlUom_fF = _fesapi.resqml20__ResqmlUom_fF
resqml20__ResqmlUom_fg = _fesapi.resqml20__ResqmlUom_fg
resqml20__ResqmlUom_fgauss = _fesapi.resqml20__ResqmlUom_fgauss
resqml20__ResqmlUom_fGy = _fesapi.resqml20__ResqmlUom_fGy
resqml20__ResqmlUom_fH = _fesapi.resqml20__ResqmlUom_fH
resqml20__ResqmlUom_fHz = _fesapi.resqml20__ResqmlUom_fHz
resqml20__ResqmlUom_fJ = _fesapi.resqml20__ResqmlUom_fJ
resqml20__ResqmlUom_floz_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_floz_x005bUK_x005d
resqml20__ResqmlUom_floz_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_floz_x005bUS_x005d
resqml20__ResqmlUom_fm = _fesapi.resqml20__ResqmlUom_fm
resqml20__ResqmlUom_fN = _fesapi.resqml20__ResqmlUom_fN
resqml20__ResqmlUom_fohm = _fesapi.resqml20__ResqmlUom_fohm
resqml20__ResqmlUom_footcandle = _fesapi.resqml20__ResqmlUom_footcandle
resqml20__ResqmlUom_footcandle_x002es = _fesapi.resqml20__ResqmlUom_footcandle_x002es
resqml20__ResqmlUom_fP = _fesapi.resqml20__ResqmlUom_fP
resqml20__ResqmlUom_fPa = _fesapi.resqml20__ResqmlUom_fPa
resqml20__ResqmlUom_frd = _fesapi.resqml20__ResqmlUom_frd
resqml20__ResqmlUom_fS = _fesapi.resqml20__ResqmlUom_fS
resqml20__ResqmlUom_ft = _fesapi.resqml20__ResqmlUom_ft
resqml20__ResqmlUom_fT = _fesapi.resqml20__ResqmlUom_fT
resqml20__ResqmlUom_ft_x002fbbl = _fesapi.resqml20__ResqmlUom_ft_x002fbbl
resqml20__ResqmlUom_ft_x002fd = _fesapi.resqml20__ResqmlUom_ft_x002fd
resqml20__ResqmlUom_ft_x002fdegF = _fesapi.resqml20__ResqmlUom_ft_x002fdegF
resqml20__ResqmlUom_ft_x002fft = _fesapi.resqml20__ResqmlUom_ft_x002fft
resqml20__ResqmlUom_ft_x002fft3 = _fesapi.resqml20__ResqmlUom_ft_x002fft3
resqml20__ResqmlUom_ft_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_ft_x002fgal_x005bUS_x005d
resqml20__ResqmlUom_ft_x002fh = _fesapi.resqml20__ResqmlUom_ft_x002fh
resqml20__ResqmlUom_ft_x002fin = _fesapi.resqml20__ResqmlUom_ft_x002fin
resqml20__ResqmlUom_ft_x002flbm = _fesapi.resqml20__ResqmlUom_ft_x002flbm
resqml20__ResqmlUom_ft_x002fm = _fesapi.resqml20__ResqmlUom_ft_x002fm
resqml20__ResqmlUom_ft_x002fmi = _fesapi.resqml20__ResqmlUom_ft_x002fmi
resqml20__ResqmlUom_ft_x002fmin = _fesapi.resqml20__ResqmlUom_ft_x002fmin
resqml20__ResqmlUom_ft_x002fms = _fesapi.resqml20__ResqmlUom_ft_x002fms
resqml20__ResqmlUom_ft_x002fpsi = _fesapi.resqml20__ResqmlUom_ft_x002fpsi
resqml20__ResqmlUom_ft_x002fs = _fesapi.resqml20__ResqmlUom_ft_x002fs
resqml20__ResqmlUom_ft_x002fs2 = _fesapi.resqml20__ResqmlUom_ft_x002fs2
resqml20__ResqmlUom_ft_x002fus = _fesapi.resqml20__ResqmlUom_ft_x002fus
resqml20__ResqmlUom_ft_x005bBnA_x005d = _fesapi.resqml20__ResqmlUom_ft_x005bBnA_x005d
resqml20__ResqmlUom_ft_x005bBnB_x005d = _fesapi.resqml20__ResqmlUom_ft_x005bBnB_x005d
resqml20__ResqmlUom_ft_x005bBr36_x005d = _fesapi.resqml20__ResqmlUom_ft_x005bBr36_x005d
resqml20__ResqmlUom_ft_x005bBr65_x005d = _fesapi.resqml20__ResqmlUom_ft_x005bBr65_x005d
resqml20__ResqmlUom_ft_x005bCla_x005d = _fesapi.resqml20__ResqmlUom_ft_x005bCla_x005d
resqml20__ResqmlUom_ft_x005bGC_x005d = _fesapi.resqml20__ResqmlUom_ft_x005bGC_x005d
resqml20__ResqmlUom_ft_x005bInd_x005d = _fesapi.resqml20__ResqmlUom_ft_x005bInd_x005d
resqml20__ResqmlUom_ft_x005bInd37_x005d = _fesapi.resqml20__ResqmlUom_ft_x005bInd37_x005d
resqml20__ResqmlUom_ft_x005bInd62_x005d = _fesapi.resqml20__ResqmlUom_ft_x005bInd62_x005d
resqml20__ResqmlUom_ft_x005bInd75_x005d = _fesapi.resqml20__ResqmlUom_ft_x005bInd75_x005d
resqml20__ResqmlUom_ft_x005bSe_x005d = _fesapi.resqml20__ResqmlUom_ft_x005bSe_x005d
resqml20__ResqmlUom_ft_x005bSeT_x005d = _fesapi.resqml20__ResqmlUom_ft_x005bSeT_x005d
resqml20__ResqmlUom_ft_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_ft_x005bUS_x005d
resqml20__ResqmlUom_ft2 = _fesapi.resqml20__ResqmlUom_ft2
resqml20__ResqmlUom_ft2_x002fh = _fesapi.resqml20__ResqmlUom_ft2_x002fh
resqml20__ResqmlUom_ft2_x002fin3 = _fesapi.resqml20__ResqmlUom_ft2_x002fin3
resqml20__ResqmlUom_ft2_x002flbm = _fesapi.resqml20__ResqmlUom_ft2_x002flbm
resqml20__ResqmlUom_ft2_x002fs = _fesapi.resqml20__ResqmlUom_ft2_x002fs
resqml20__ResqmlUom_ft3 = _fesapi.resqml20__ResqmlUom_ft3
resqml20__ResqmlUom_ft3_x002f_x0028d_x002eft_x0029 = _fesapi.resqml20__ResqmlUom_ft3_x002f_x0028d_x002eft_x0029
resqml20__ResqmlUom_ft3_x002f_x0028ft_x002epsi_x002ed_x0029 = _fesapi.resqml20__ResqmlUom_ft3_x002f_x0028ft_x002epsi_x002ed_x0029
resqml20__ResqmlUom_ft3_x002f_x0028min_x002eft2_x0029 = _fesapi.resqml20__ResqmlUom_ft3_x002f_x0028min_x002eft2_x0029
resqml20__ResqmlUom_ft3_x002f_x0028s_x002eft2_x0029 = _fesapi.resqml20__ResqmlUom_ft3_x002f_x0028s_x002eft2_x0029
resqml20__ResqmlUom_ft3_x002fbbl = _fesapi.resqml20__ResqmlUom_ft3_x002fbbl
resqml20__ResqmlUom_ft3_x002fd = _fesapi.resqml20__ResqmlUom_ft3_x002fd
resqml20__ResqmlUom_ft3_x002fd2 = _fesapi.resqml20__ResqmlUom_ft3_x002fd2
resqml20__ResqmlUom_ft3_x002fft = _fesapi.resqml20__ResqmlUom_ft3_x002fft
resqml20__ResqmlUom_ft3_x002fft2 = _fesapi.resqml20__ResqmlUom_ft3_x002fft2
resqml20__ResqmlUom_ft3_x002fft3 = _fesapi.resqml20__ResqmlUom_ft3_x002fft3
resqml20__ResqmlUom_ft3_x002fh = _fesapi.resqml20__ResqmlUom_ft3_x002fh
resqml20__ResqmlUom_ft3_x002fh2 = _fesapi.resqml20__ResqmlUom_ft3_x002fh2
resqml20__ResqmlUom_ft3_x002fkg = _fesapi.resqml20__ResqmlUom_ft3_x002fkg
resqml20__ResqmlUom_ft3_x002flbm = _fesapi.resqml20__ResqmlUom_ft3_x002flbm
resqml20__ResqmlUom_ft3_x002flbmol = _fesapi.resqml20__ResqmlUom_ft3_x002flbmol
resqml20__ResqmlUom_ft3_x002fmin = _fesapi.resqml20__ResqmlUom_ft3_x002fmin
resqml20__ResqmlUom_ft3_x002fmin2 = _fesapi.resqml20__ResqmlUom_ft3_x002fmin2
resqml20__ResqmlUom_ft3_x002frad = _fesapi.resqml20__ResqmlUom_ft3_x002frad
resqml20__ResqmlUom_ft3_x002fs = _fesapi.resqml20__ResqmlUom_ft3_x002fs
resqml20__ResqmlUom_ft3_x002fs2 = _fesapi.resqml20__ResqmlUom_ft3_x002fs2
resqml20__ResqmlUom_ft3_x002fsack_x005b94lbm_x005d = _fesapi.resqml20__ResqmlUom_ft3_x002fsack_x005b94lbm_x005d
resqml20__ResqmlUom_fur_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_fur_x005bUS_x005d
resqml20__ResqmlUom_fV = _fesapi.resqml20__ResqmlUom_fV
resqml20__ResqmlUom_fW = _fesapi.resqml20__ResqmlUom_fW
resqml20__ResqmlUom_fWb = _fesapi.resqml20__ResqmlUom_fWb
resqml20__ResqmlUom_g_x002eft_x002f_x0028cm3_x002es_x0029 = _fesapi.resqml20__ResqmlUom_g_x002eft_x002f_x0028cm3_x002es_x0029
resqml20__ResqmlUom_g_x002em_x002f_x0028cm3_x002es_x0029 = _fesapi.resqml20__ResqmlUom_g_x002em_x002f_x0028cm3_x002es_x0029
resqml20__ResqmlUom_g_x002fcm3 = _fesapi.resqml20__ResqmlUom_g_x002fcm3
resqml20__ResqmlUom_g_x002fcm4 = _fesapi.resqml20__ResqmlUom_g_x002fcm4
resqml20__ResqmlUom_g_x002fdm3 = _fesapi.resqml20__ResqmlUom_g_x002fdm3
resqml20__ResqmlUom_g_x002fgal_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_g_x002fgal_x005bUK_x005d
resqml20__ResqmlUom_g_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_g_x002fgal_x005bUS_x005d
resqml20__ResqmlUom_g_x002fkg = _fesapi.resqml20__ResqmlUom_g_x002fkg
resqml20__ResqmlUom_g_x002fL = _fesapi.resqml20__ResqmlUom_g_x002fL
resqml20__ResqmlUom_g_x002fm3 = _fesapi.resqml20__ResqmlUom_g_x002fm3
resqml20__ResqmlUom_g_x002fmol = _fesapi.resqml20__ResqmlUom_g_x002fmol
resqml20__ResqmlUom_g_x002fs = _fesapi.resqml20__ResqmlUom_g_x002fs
resqml20__ResqmlUom_g_x002ft = _fesapi.resqml20__ResqmlUom_g_x002ft
resqml20__ResqmlUom_GA = _fesapi.resqml20__ResqmlUom_GA
resqml20__ResqmlUom_Ga_x005bt_x005d = _fesapi.resqml20__ResqmlUom_Ga_x005bt_x005d
resqml20__ResqmlUom_Gal = _fesapi.resqml20__ResqmlUom_Gal
resqml20__ResqmlUom_gal_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d
resqml20__ResqmlUom_gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029 = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029
resqml20__ResqmlUom_gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029 = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029
resqml20__ResqmlUom_gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029 = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029
resqml20__ResqmlUom_gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029 = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029
resqml20__ResqmlUom_gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029 = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029
resqml20__ResqmlUom_gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029 = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029
resqml20__ResqmlUom_gal_x005bUK_x005d_x002fd = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002fd
resqml20__ResqmlUom_gal_x005bUK_x005d_x002fft3 = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002fft3
resqml20__ResqmlUom_gal_x005bUK_x005d_x002fh = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002fh
resqml20__ResqmlUom_gal_x005bUK_x005d_x002fh2 = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002fh2
resqml20__ResqmlUom_gal_x005bUK_x005d_x002flbm = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002flbm
resqml20__ResqmlUom_gal_x005bUK_x005d_x002fmi = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002fmi
resqml20__ResqmlUom_gal_x005bUK_x005d_x002fmin = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002fmin
resqml20__ResqmlUom_gal_x005bUK_x005d_x002fmin2 = _fesapi.resqml20__ResqmlUom_gal_x005bUK_x005d_x002fmin2
resqml20__ResqmlUom_gal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d
resqml20__ResqmlUom_gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029 = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029
resqml20__ResqmlUom_gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029 = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029
resqml20__ResqmlUom_gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029 = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029
resqml20__ResqmlUom_gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029 = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029
resqml20__ResqmlUom_gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029 = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029
resqml20__ResqmlUom_gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029 = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029
resqml20__ResqmlUom_gal_x005bUS_x005d_x002fbbl = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002fbbl
resqml20__ResqmlUom_gal_x005bUS_x005d_x002fd = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002fd
resqml20__ResqmlUom_gal_x005bUS_x005d_x002fft = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002fft
resqml20__ResqmlUom_gal_x005bUS_x005d_x002fft3 = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002fft3
resqml20__ResqmlUom_gal_x005bUS_x005d_x002fh = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002fh
resqml20__ResqmlUom_gal_x005bUS_x005d_x002fh2 = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002fh2
resqml20__ResqmlUom_gal_x005bUS_x005d_x002flbm = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002flbm
resqml20__ResqmlUom_gal_x005bUS_x005d_x002fmi = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002fmi
resqml20__ResqmlUom_gal_x005bUS_x005d_x002fmin = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002fmin
resqml20__ResqmlUom_gal_x005bUS_x005d_x002fmin2 = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002fmin2
resqml20__ResqmlUom_gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d
resqml20__ResqmlUom_gal_x005bUS_x005d_x002fton_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002fton_x005bUK_x005d
resqml20__ResqmlUom_gal_x005bUS_x005d_x002fton_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_gal_x005bUS_x005d_x002fton_x005bUS_x005d
resqml20__ResqmlUom_gAPI = _fesapi.resqml20__ResqmlUom_gAPI
resqml20__ResqmlUom_gauss = _fesapi.resqml20__ResqmlUom_gauss
resqml20__ResqmlUom_gauss_x002fcm = _fesapi.resqml20__ResqmlUom_gauss_x002fcm
resqml20__ResqmlUom_GBq = _fesapi.resqml20__ResqmlUom_GBq
resqml20__ResqmlUom_GC = _fesapi.resqml20__ResqmlUom_GC
resqml20__ResqmlUom_Gcal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_Gcal_x005bth_x005d
resqml20__ResqmlUom_GEuc = _fesapi.resqml20__ResqmlUom_GEuc
resqml20__ResqmlUom_GeV = _fesapi.resqml20__ResqmlUom_GeV
resqml20__ResqmlUom_gf = _fesapi.resqml20__ResqmlUom_gf
resqml20__ResqmlUom_GF = _fesapi.resqml20__ResqmlUom_GF
resqml20__ResqmlUom_Gg = _fesapi.resqml20__ResqmlUom_Gg
resqml20__ResqmlUom_Ggauss = _fesapi.resqml20__ResqmlUom_Ggauss
resqml20__ResqmlUom_GGy = _fesapi.resqml20__ResqmlUom_GGy
resqml20__ResqmlUom_GH = _fesapi.resqml20__ResqmlUom_GH
resqml20__ResqmlUom_GHz = _fesapi.resqml20__ResqmlUom_GHz
resqml20__ResqmlUom_GJ = _fesapi.resqml20__ResqmlUom_GJ
resqml20__ResqmlUom_Gm = _fesapi.resqml20__ResqmlUom_Gm
resqml20__ResqmlUom_gn = _fesapi.resqml20__ResqmlUom_gn
resqml20__ResqmlUom_GN = _fesapi.resqml20__ResqmlUom_GN
resqml20__ResqmlUom_Gohm = _fesapi.resqml20__ResqmlUom_Gohm
resqml20__ResqmlUom_gon = _fesapi.resqml20__ResqmlUom_gon
resqml20__ResqmlUom_GP = _fesapi.resqml20__ResqmlUom_GP
resqml20__ResqmlUom_GPa = _fesapi.resqml20__ResqmlUom_GPa
resqml20__ResqmlUom_GPa_x002fcm = _fesapi.resqml20__ResqmlUom_GPa_x002fcm
resqml20__ResqmlUom_GPa2 = _fesapi.resqml20__ResqmlUom_GPa2
resqml20__ResqmlUom_grain = _fesapi.resqml20__ResqmlUom_grain
resqml20__ResqmlUom_grain_x002fft3 = _fesapi.resqml20__ResqmlUom_grain_x002fft3
resqml20__ResqmlUom_grain_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_grain_x002fgal_x005bUS_x005d
resqml20__ResqmlUom_Grd = _fesapi.resqml20__ResqmlUom_Grd
resqml20__ResqmlUom_GS = _fesapi.resqml20__ResqmlUom_GS
resqml20__ResqmlUom_GT = _fesapi.resqml20__ResqmlUom_GT
resqml20__ResqmlUom_GV = _fesapi.resqml20__ResqmlUom_GV
resqml20__ResqmlUom_GW = _fesapi.resqml20__ResqmlUom_GW
resqml20__ResqmlUom_GW_x002eh = _fesapi.resqml20__ResqmlUom_GW_x002eh
resqml20__ResqmlUom_GWb = _fesapi.resqml20__ResqmlUom_GWb
resqml20__ResqmlUom_Gy = _fesapi.resqml20__ResqmlUom_Gy
resqml20__ResqmlUom_h_x002fft3 = _fesapi.resqml20__ResqmlUom_h_x002fft3
resqml20__ResqmlUom_h_x002fkm = _fesapi.resqml20__ResqmlUom_h_x002fkm
resqml20__ResqmlUom_H_x002fm = _fesapi.resqml20__ResqmlUom_H_x002fm
resqml20__ResqmlUom_h_x002fm3 = _fesapi.resqml20__ResqmlUom_h_x002fm3
resqml20__ResqmlUom_ha = _fesapi.resqml20__ResqmlUom_ha
resqml20__ResqmlUom_ha_x002em = _fesapi.resqml20__ResqmlUom_ha_x002em
resqml20__ResqmlUom_hbar = _fesapi.resqml20__ResqmlUom_hbar
resqml20__ResqmlUom_hg = _fesapi.resqml20__ResqmlUom_hg
resqml20__ResqmlUom_hL = _fesapi.resqml20__ResqmlUom_hL
resqml20__ResqmlUom_hm = _fesapi.resqml20__ResqmlUom_hm
resqml20__ResqmlUom_hN = _fesapi.resqml20__ResqmlUom_hN
resqml20__ResqmlUom_hp = _fesapi.resqml20__ResqmlUom_hp
resqml20__ResqmlUom_hp_x002eh = _fesapi.resqml20__ResqmlUom_hp_x002eh
resqml20__ResqmlUom_hp_x002eh_x002fbbl = _fesapi.resqml20__ResqmlUom_hp_x002eh_x002fbbl
resqml20__ResqmlUom_hp_x002eh_x002flbm = _fesapi.resqml20__ResqmlUom_hp_x002eh_x002flbm
resqml20__ResqmlUom_hp_x002fft3 = _fesapi.resqml20__ResqmlUom_hp_x002fft3
resqml20__ResqmlUom_hp_x002fin2 = _fesapi.resqml20__ResqmlUom_hp_x002fin2
resqml20__ResqmlUom_hp_x005belec_x005d = _fesapi.resqml20__ResqmlUom_hp_x005belec_x005d
resqml20__ResqmlUom_hp_x005bhyd_x005d = _fesapi.resqml20__ResqmlUom_hp_x005bhyd_x005d
resqml20__ResqmlUom_hp_x005bhyd_x005d_x002fin2 = _fesapi.resqml20__ResqmlUom_hp_x005bhyd_x005d_x002fin2
resqml20__ResqmlUom_hp_x005bmetric_x005d = _fesapi.resqml20__ResqmlUom_hp_x005bmetric_x005d
resqml20__ResqmlUom_hp_x005bmetric_x005d_x002eh = _fesapi.resqml20__ResqmlUom_hp_x005bmetric_x005d_x002eh
resqml20__ResqmlUom_hs = _fesapi.resqml20__ResqmlUom_hs
resqml20__ResqmlUom_Hz = _fesapi.resqml20__ResqmlUom_Hz
resqml20__ResqmlUom__in = _fesapi.resqml20__ResqmlUom__in
resqml20__ResqmlUom_in_x002f_x0028in_x002edegF_x0029 = _fesapi.resqml20__ResqmlUom_in_x002f_x0028in_x002edegF_x0029
resqml20__ResqmlUom_in_x002fa = _fesapi.resqml20__ResqmlUom_in_x002fa
resqml20__ResqmlUom_in_x002fmin = _fesapi.resqml20__ResqmlUom_in_x002fmin
resqml20__ResqmlUom_in_x002fs = _fesapi.resqml20__ResqmlUom_in_x002fs
resqml20__ResqmlUom_in_x002fs2 = _fesapi.resqml20__ResqmlUom_in_x002fs2
resqml20__ResqmlUom_in_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_in_x005bUS_x005d
resqml20__ResqmlUom_in2 = _fesapi.resqml20__ResqmlUom_in2
resqml20__ResqmlUom_in2_x002fft2 = _fesapi.resqml20__ResqmlUom_in2_x002fft2
resqml20__ResqmlUom_in2_x002fin2 = _fesapi.resqml20__ResqmlUom_in2_x002fin2
resqml20__ResqmlUom_in2_x002fs = _fesapi.resqml20__ResqmlUom_in2_x002fs
resqml20__ResqmlUom_in3 = _fesapi.resqml20__ResqmlUom_in3
resqml20__ResqmlUom_in3_x002fft = _fesapi.resqml20__ResqmlUom_in3_x002fft
resqml20__ResqmlUom_in4 = _fesapi.resqml20__ResqmlUom_in4
resqml20__ResqmlUom_inH2O_x005b39degF_x005d = _fesapi.resqml20__ResqmlUom_inH2O_x005b39degF_x005d
resqml20__ResqmlUom_inH2O_x005b60degF_x005d = _fesapi.resqml20__ResqmlUom_inH2O_x005b60degF_x005d
resqml20__ResqmlUom_inHg_x005b32degF_x005d = _fesapi.resqml20__ResqmlUom_inHg_x005b32degF_x005d
resqml20__ResqmlUom_inHg_x005b60degF_x005d = _fesapi.resqml20__ResqmlUom_inHg_x005b60degF_x005d
resqml20__ResqmlUom_J_x002em_x002f_x0028s_x002em2_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_J_x002em_x002f_x0028s_x002em2_x002eK_x0029
resqml20__ResqmlUom_J_x002em_x002fm2 = _fesapi.resqml20__ResqmlUom_J_x002em_x002fm2
resqml20__ResqmlUom_J_x002f_x0028g_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_J_x002f_x0028g_x002eK_x0029
resqml20__ResqmlUom_J_x002f_x0028kg_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_J_x002f_x0028kg_x002eK_x0029
resqml20__ResqmlUom_J_x002f_x0028mol_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_J_x002f_x0028mol_x002eK_x0029
resqml20__ResqmlUom_J_x002f_x0028s_x002em2_x002edegC_x0029 = _fesapi.resqml20__ResqmlUom_J_x002f_x0028s_x002em2_x002edegC_x0029
resqml20__ResqmlUom_J_x002fcm2 = _fesapi.resqml20__ResqmlUom_J_x002fcm2
resqml20__ResqmlUom_J_x002fdm3 = _fesapi.resqml20__ResqmlUom_J_x002fdm3
resqml20__ResqmlUom_J_x002fg = _fesapi.resqml20__ResqmlUom_J_x002fg
resqml20__ResqmlUom_J_x002fK = _fesapi.resqml20__ResqmlUom_J_x002fK
resqml20__ResqmlUom_J_x002fkg = _fesapi.resqml20__ResqmlUom_J_x002fkg
resqml20__ResqmlUom_J_x002fm = _fesapi.resqml20__ResqmlUom_J_x002fm
resqml20__ResqmlUom_J_x002fm2 = _fesapi.resqml20__ResqmlUom_J_x002fm2
resqml20__ResqmlUom_J_x002fm3 = _fesapi.resqml20__ResqmlUom_J_x002fm3
resqml20__ResqmlUom_J_x002fmol = _fesapi.resqml20__ResqmlUom_J_x002fmol
resqml20__ResqmlUom_J_x002fs = _fesapi.resqml20__ResqmlUom_J_x002fs
resqml20__ResqmlUom_K_x002em2_x002fkW = _fesapi.resqml20__ResqmlUom_K_x002em2_x002fkW
resqml20__ResqmlUom_K_x002em2_x002fW = _fesapi.resqml20__ResqmlUom_K_x002em2_x002fW
resqml20__ResqmlUom_K_x002fkm = _fesapi.resqml20__ResqmlUom_K_x002fkm
resqml20__ResqmlUom_K_x002fm = _fesapi.resqml20__ResqmlUom_K_x002fm
resqml20__ResqmlUom_K_x002fPa = _fesapi.resqml20__ResqmlUom_K_x002fPa
resqml20__ResqmlUom_K_x002fs = _fesapi.resqml20__ResqmlUom_K_x002fs
resqml20__ResqmlUom_K_x002fW = _fesapi.resqml20__ResqmlUom_K_x002fW
resqml20__ResqmlUom_kA = _fesapi.resqml20__ResqmlUom_kA
resqml20__ResqmlUom_ka_x005bt_x005d = _fesapi.resqml20__ResqmlUom_ka_x005bt_x005d
resqml20__ResqmlUom_kC = _fesapi.resqml20__ResqmlUom_kC
resqml20__ResqmlUom_kcal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_kcal_x005bth_x005d
resqml20__ResqmlUom_kcal_x005bth_x005d_x002em_x002fcm2 = _fesapi.resqml20__ResqmlUom_kcal_x005bth_x005d_x002em_x002fcm2
resqml20__ResqmlUom_kcal_x005bth_x005d_x002f_x0028h_x002em_x002edegC_x0029 = _fesapi.resqml20__ResqmlUom_kcal_x005bth_x005d_x002f_x0028h_x002em_x002edegC_x0029
resqml20__ResqmlUom_kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = _fesapi.resqml20__ResqmlUom_kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edegC_x0029
resqml20__ResqmlUom_kcal_x005bth_x005d_x002f_x0028kg_x002edegC_x0029 = _fesapi.resqml20__ResqmlUom_kcal_x005bth_x005d_x002f_x0028kg_x002edegC_x0029
resqml20__ResqmlUom_kcal_x005bth_x005d_x002fcm3 = _fesapi.resqml20__ResqmlUom_kcal_x005bth_x005d_x002fcm3
resqml20__ResqmlUom_kcal_x005bth_x005d_x002fg = _fesapi.resqml20__ResqmlUom_kcal_x005bth_x005d_x002fg
resqml20__ResqmlUom_kcal_x005bth_x005d_x002fh = _fesapi.resqml20__ResqmlUom_kcal_x005bth_x005d_x002fh
resqml20__ResqmlUom_kcal_x005bth_x005d_x002fkg = _fesapi.resqml20__ResqmlUom_kcal_x005bth_x005d_x002fkg
resqml20__ResqmlUom_kcal_x005bth_x005d_x002fm3 = _fesapi.resqml20__ResqmlUom_kcal_x005bth_x005d_x002fm3
resqml20__ResqmlUom_kcal_x005bth_x005d_x002fmol = _fesapi.resqml20__ResqmlUom_kcal_x005bth_x005d_x002fmol
resqml20__ResqmlUom_kcd = _fesapi.resqml20__ResqmlUom_kcd
resqml20__ResqmlUom_kdyne = _fesapi.resqml20__ResqmlUom_kdyne
resqml20__ResqmlUom_kEuc = _fesapi.resqml20__ResqmlUom_kEuc
resqml20__ResqmlUom_keV = _fesapi.resqml20__ResqmlUom_keV
resqml20__ResqmlUom_kF = _fesapi.resqml20__ResqmlUom_kF
resqml20__ResqmlUom_kg = _fesapi.resqml20__ResqmlUom_kg
resqml20__ResqmlUom_kg_x002em = _fesapi.resqml20__ResqmlUom_kg_x002em
resqml20__ResqmlUom_kg_x002em_x002fcm2 = _fesapi.resqml20__ResqmlUom_kg_x002em_x002fcm2
resqml20__ResqmlUom_kg_x002em_x002fs = _fesapi.resqml20__ResqmlUom_kg_x002em_x002fs
resqml20__ResqmlUom_kg_x002em2 = _fesapi.resqml20__ResqmlUom_kg_x002em2
resqml20__ResqmlUom_kg_x002f_x0028kW_x002eh_x0029 = _fesapi.resqml20__ResqmlUom_kg_x002f_x0028kW_x002eh_x0029
resqml20__ResqmlUom_kg_x002f_x0028m_x002es_x0029 = _fesapi.resqml20__ResqmlUom_kg_x002f_x0028m_x002es_x0029
resqml20__ResqmlUom_kg_x002f_x0028m2_x002es_x0029 = _fesapi.resqml20__ResqmlUom_kg_x002f_x0028m2_x002es_x0029
resqml20__ResqmlUom_kg_x002fd = _fesapi.resqml20__ResqmlUom_kg_x002fd
resqml20__ResqmlUom_kg_x002fdm3 = _fesapi.resqml20__ResqmlUom_kg_x002fdm3
resqml20__ResqmlUom_kg_x002fdm4 = _fesapi.resqml20__ResqmlUom_kg_x002fdm4
resqml20__ResqmlUom_kg_x002fh = _fesapi.resqml20__ResqmlUom_kg_x002fh
resqml20__ResqmlUom_kg_x002fJ = _fesapi.resqml20__ResqmlUom_kg_x002fJ
resqml20__ResqmlUom_kg_x002fkg = _fesapi.resqml20__ResqmlUom_kg_x002fkg
resqml20__ResqmlUom_kg_x002fL = _fesapi.resqml20__ResqmlUom_kg_x002fL
resqml20__ResqmlUom_kg_x002fm = _fesapi.resqml20__ResqmlUom_kg_x002fm
resqml20__ResqmlUom_kg_x002fm2 = _fesapi.resqml20__ResqmlUom_kg_x002fm2
resqml20__ResqmlUom_kg_x002fm3 = _fesapi.resqml20__ResqmlUom_kg_x002fm3
resqml20__ResqmlUom_kg_x002fm4 = _fesapi.resqml20__ResqmlUom_kg_x002fm4
resqml20__ResqmlUom_kg_x002fmin = _fesapi.resqml20__ResqmlUom_kg_x002fmin
resqml20__ResqmlUom_kg_x002fMJ = _fesapi.resqml20__ResqmlUom_kg_x002fMJ
resqml20__ResqmlUom_kg_x002fmol = _fesapi.resqml20__ResqmlUom_kg_x002fmol
resqml20__ResqmlUom_kg_x002fs = _fesapi.resqml20__ResqmlUom_kg_x002fs
resqml20__ResqmlUom_kg_x002fsack_x005b94lbm_x005d = _fesapi.resqml20__ResqmlUom_kg_x002fsack_x005b94lbm_x005d
resqml20__ResqmlUom_kg_x002ft = _fesapi.resqml20__ResqmlUom_kg_x002ft
resqml20__ResqmlUom_kgauss = _fesapi.resqml20__ResqmlUom_kgauss
resqml20__ResqmlUom_kgf = _fesapi.resqml20__ResqmlUom_kgf
resqml20__ResqmlUom_kgf_x002em = _fesapi.resqml20__ResqmlUom_kgf_x002em
resqml20__ResqmlUom_kgf_x002em_x002fcm2 = _fesapi.resqml20__ResqmlUom_kgf_x002em_x002fcm2
resqml20__ResqmlUom_kgf_x002em_x002fm = _fesapi.resqml20__ResqmlUom_kgf_x002em_x002fm
resqml20__ResqmlUom_kgf_x002em2 = _fesapi.resqml20__ResqmlUom_kgf_x002em2
resqml20__ResqmlUom_kgf_x002es_x002fm2 = _fesapi.resqml20__ResqmlUom_kgf_x002es_x002fm2
resqml20__ResqmlUom_kgf_x002fcm = _fesapi.resqml20__ResqmlUom_kgf_x002fcm
resqml20__ResqmlUom_kgf_x002fcm2 = _fesapi.resqml20__ResqmlUom_kgf_x002fcm2
resqml20__ResqmlUom_kgf_x002fkgf = _fesapi.resqml20__ResqmlUom_kgf_x002fkgf
resqml20__ResqmlUom_kgf_x002fm2 = _fesapi.resqml20__ResqmlUom_kgf_x002fm2
resqml20__ResqmlUom_kgf_x002fmm2 = _fesapi.resqml20__ResqmlUom_kgf_x002fmm2
resqml20__ResqmlUom_kGy = _fesapi.resqml20__ResqmlUom_kGy
resqml20__ResqmlUom_kH = _fesapi.resqml20__ResqmlUom_kH
resqml20__ResqmlUom_kHz = _fesapi.resqml20__ResqmlUom_kHz
resqml20__ResqmlUom_Kibyte = _fesapi.resqml20__ResqmlUom_Kibyte
resqml20__ResqmlUom_kJ = _fesapi.resqml20__ResqmlUom_kJ
resqml20__ResqmlUom_kJ_x002em_x002f_x0028h_x002em2_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_kJ_x002em_x002f_x0028h_x002em2_x002eK_x0029
resqml20__ResqmlUom_kJ_x002f_x0028h_x002em2_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_kJ_x002f_x0028h_x002em2_x002eK_x0029
resqml20__ResqmlUom_kJ_x002f_x0028kg_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_kJ_x002f_x0028kg_x002eK_x0029
resqml20__ResqmlUom_kJ_x002f_x0028kmol_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_kJ_x002f_x0028kmol_x002eK_x0029
resqml20__ResqmlUom_kJ_x002fdm3 = _fesapi.resqml20__ResqmlUom_kJ_x002fdm3
resqml20__ResqmlUom_kJ_x002fkg = _fesapi.resqml20__ResqmlUom_kJ_x002fkg
resqml20__ResqmlUom_kJ_x002fkmol = _fesapi.resqml20__ResqmlUom_kJ_x002fkmol
resqml20__ResqmlUom_kJ_x002fm3 = _fesapi.resqml20__ResqmlUom_kJ_x002fm3
resqml20__ResqmlUom_klbf = _fesapi.resqml20__ResqmlUom_klbf
resqml20__ResqmlUom_klbm = _fesapi.resqml20__ResqmlUom_klbm
resqml20__ResqmlUom_klbm_x002fin = _fesapi.resqml20__ResqmlUom_klbm_x002fin
resqml20__ResqmlUom_klx = _fesapi.resqml20__ResqmlUom_klx
resqml20__ResqmlUom_km = _fesapi.resqml20__ResqmlUom_km
resqml20__ResqmlUom_km_x002fcm = _fesapi.resqml20__ResqmlUom_km_x002fcm
resqml20__ResqmlUom_km_x002fdm3 = _fesapi.resqml20__ResqmlUom_km_x002fdm3
resqml20__ResqmlUom_km_x002fh = _fesapi.resqml20__ResqmlUom_km_x002fh
resqml20__ResqmlUom_km_x002fL = _fesapi.resqml20__ResqmlUom_km_x002fL
resqml20__ResqmlUom_km_x002fs = _fesapi.resqml20__ResqmlUom_km_x002fs
resqml20__ResqmlUom_km2 = _fesapi.resqml20__ResqmlUom_km2
resqml20__ResqmlUom_km3 = _fesapi.resqml20__ResqmlUom_km3
resqml20__ResqmlUom_kmol = _fesapi.resqml20__ResqmlUom_kmol
resqml20__ResqmlUom_kmol_x002fh = _fesapi.resqml20__ResqmlUom_kmol_x002fh
resqml20__ResqmlUom_kmol_x002fm3 = _fesapi.resqml20__ResqmlUom_kmol_x002fm3
resqml20__ResqmlUom_kmol_x002fs = _fesapi.resqml20__ResqmlUom_kmol_x002fs
resqml20__ResqmlUom_kN = _fesapi.resqml20__ResqmlUom_kN
resqml20__ResqmlUom_kN_x002em = _fesapi.resqml20__ResqmlUom_kN_x002em
resqml20__ResqmlUom_kN_x002em2 = _fesapi.resqml20__ResqmlUom_kN_x002em2
resqml20__ResqmlUom_kN_x002fm = _fesapi.resqml20__ResqmlUom_kN_x002fm
resqml20__ResqmlUom_kN_x002fm2 = _fesapi.resqml20__ResqmlUom_kN_x002fm2
resqml20__ResqmlUom_knot = _fesapi.resqml20__ResqmlUom_knot
resqml20__ResqmlUom_kohm = _fesapi.resqml20__ResqmlUom_kohm
resqml20__ResqmlUom_kohm_x002em = _fesapi.resqml20__ResqmlUom_kohm_x002em
resqml20__ResqmlUom_kP = _fesapi.resqml20__ResqmlUom_kP
resqml20__ResqmlUom_kPa = _fesapi.resqml20__ResqmlUom_kPa
resqml20__ResqmlUom_kPa_x002es_x002fm = _fesapi.resqml20__ResqmlUom_kPa_x002es_x002fm
resqml20__ResqmlUom_kPa_x002fh = _fesapi.resqml20__ResqmlUom_kPa_x002fh
resqml20__ResqmlUom_kPa_x002fhm = _fesapi.resqml20__ResqmlUom_kPa_x002fhm
resqml20__ResqmlUom_kPa_x002fm = _fesapi.resqml20__ResqmlUom_kPa_x002fm
resqml20__ResqmlUom_kPa_x002fmin = _fesapi.resqml20__ResqmlUom_kPa_x002fmin
resqml20__ResqmlUom_kPa2 = _fesapi.resqml20__ResqmlUom_kPa2
resqml20__ResqmlUom_kPa2_x002fcP = _fesapi.resqml20__ResqmlUom_kPa2_x002fcP
resqml20__ResqmlUom_kpsi = _fesapi.resqml20__ResqmlUom_kpsi
resqml20__ResqmlUom_kpsi2 = _fesapi.resqml20__ResqmlUom_kpsi2
resqml20__ResqmlUom_krad = _fesapi.resqml20__ResqmlUom_krad
resqml20__ResqmlUom_krd = _fesapi.resqml20__ResqmlUom_krd
resqml20__ResqmlUom_kS = _fesapi.resqml20__ResqmlUom_kS
resqml20__ResqmlUom_kS_x002fm = _fesapi.resqml20__ResqmlUom_kS_x002fm
resqml20__ResqmlUom_kT = _fesapi.resqml20__ResqmlUom_kT
resqml20__ResqmlUom_kV = _fesapi.resqml20__ResqmlUom_kV
resqml20__ResqmlUom_kW = _fesapi.resqml20__ResqmlUom_kW
resqml20__ResqmlUom_kW_x002eh = _fesapi.resqml20__ResqmlUom_kW_x002eh
resqml20__ResqmlUom_kW_x002eh_x002f_x0028kg_x002edegC_x0029 = _fesapi.resqml20__ResqmlUom_kW_x002eh_x002f_x0028kg_x002edegC_x0029
resqml20__ResqmlUom_kW_x002eh_x002fdm3 = _fesapi.resqml20__ResqmlUom_kW_x002eh_x002fdm3
resqml20__ResqmlUom_kW_x002eh_x002fkg = _fesapi.resqml20__ResqmlUom_kW_x002eh_x002fkg
resqml20__ResqmlUom_kW_x002eh_x002fm3 = _fesapi.resqml20__ResqmlUom_kW_x002eh_x002fm3
resqml20__ResqmlUom_kW_x002f_x0028m2_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_kW_x002f_x0028m2_x002eK_x0029
resqml20__ResqmlUom_kW_x002f_x0028m3_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_kW_x002f_x0028m3_x002eK_x0029
resqml20__ResqmlUom_kW_x002fcm2 = _fesapi.resqml20__ResqmlUom_kW_x002fcm2
resqml20__ResqmlUom_kW_x002fm2 = _fesapi.resqml20__ResqmlUom_kW_x002fm2
resqml20__ResqmlUom_kW_x002fm3 = _fesapi.resqml20__ResqmlUom_kW_x002fm3
resqml20__ResqmlUom_kWb = _fesapi.resqml20__ResqmlUom_kWb
resqml20__ResqmlUom_L_x002f_x0028bar_x002emin_x0029 = _fesapi.resqml20__ResqmlUom_L_x002f_x0028bar_x002emin_x0029
resqml20__ResqmlUom_L_x002fh = _fesapi.resqml20__ResqmlUom_L_x002fh
resqml20__ResqmlUom_L_x002fkg = _fesapi.resqml20__ResqmlUom_L_x002fkg
resqml20__ResqmlUom_L_x002fkmol = _fesapi.resqml20__ResqmlUom_L_x002fkmol
resqml20__ResqmlUom_L_x002fm = _fesapi.resqml20__ResqmlUom_L_x002fm
resqml20__ResqmlUom_L_x002fm3 = _fesapi.resqml20__ResqmlUom_L_x002fm3
resqml20__ResqmlUom_L_x002fmin = _fesapi.resqml20__ResqmlUom_L_x002fmin
resqml20__ResqmlUom_L_x002fmol = _fesapi.resqml20__ResqmlUom_L_x002fmol
resqml20__ResqmlUom_L_x002fs = _fesapi.resqml20__ResqmlUom_L_x002fs
resqml20__ResqmlUom_L_x002fs2 = _fesapi.resqml20__ResqmlUom_L_x002fs2
resqml20__ResqmlUom_L_x002ft = _fesapi.resqml20__ResqmlUom_L_x002ft
resqml20__ResqmlUom_L_x002fton_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_L_x002fton_x005bUK_x005d
resqml20__ResqmlUom_lbf = _fesapi.resqml20__ResqmlUom_lbf
resqml20__ResqmlUom_lbf_x002eft = _fesapi.resqml20__ResqmlUom_lbf_x002eft
resqml20__ResqmlUom_lbf_x002eft_x002fbbl = _fesapi.resqml20__ResqmlUom_lbf_x002eft_x002fbbl
resqml20__ResqmlUom_lbf_x002eft_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_lbf_x002eft_x002fgal_x005bUS_x005d
resqml20__ResqmlUom_lbf_x002eft_x002fin = _fesapi.resqml20__ResqmlUom_lbf_x002eft_x002fin
resqml20__ResqmlUom_lbf_x002eft_x002fin2 = _fesapi.resqml20__ResqmlUom_lbf_x002eft_x002fin2
resqml20__ResqmlUom_lbf_x002eft_x002flbm = _fesapi.resqml20__ResqmlUom_lbf_x002eft_x002flbm
resqml20__ResqmlUom_lbf_x002eft_x002fmin = _fesapi.resqml20__ResqmlUom_lbf_x002eft_x002fmin
resqml20__ResqmlUom_lbf_x002eft_x002fs = _fesapi.resqml20__ResqmlUom_lbf_x002eft_x002fs
resqml20__ResqmlUom_lbf_x002ein = _fesapi.resqml20__ResqmlUom_lbf_x002ein
resqml20__ResqmlUom_lbf_x002ein_x002fin = _fesapi.resqml20__ResqmlUom_lbf_x002ein_x002fin
resqml20__ResqmlUom_lbf_x002ein2 = _fesapi.resqml20__ResqmlUom_lbf_x002ein2
resqml20__ResqmlUom_lbf_x002es_x002fft2 = _fesapi.resqml20__ResqmlUom_lbf_x002es_x002fft2
resqml20__ResqmlUom_lbf_x002es_x002fin2 = _fesapi.resqml20__ResqmlUom_lbf_x002es_x002fin2
resqml20__ResqmlUom_lbf_x002fft = _fesapi.resqml20__ResqmlUom_lbf_x002fft
resqml20__ResqmlUom_lbf_x002fft2 = _fesapi.resqml20__ResqmlUom_lbf_x002fft2
resqml20__ResqmlUom_lbf_x002fft3 = _fesapi.resqml20__ResqmlUom_lbf_x002fft3
resqml20__ResqmlUom_lbf_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_lbf_x002fgal_x005bUS_x005d
resqml20__ResqmlUom_lbf_x002fin = _fesapi.resqml20__ResqmlUom_lbf_x002fin
resqml20__ResqmlUom_lbf_x002flbf = _fesapi.resqml20__ResqmlUom_lbf_x002flbf
resqml20__ResqmlUom_lbm = _fesapi.resqml20__ResqmlUom_lbm
resqml20__ResqmlUom_lbm_x002eft = _fesapi.resqml20__ResqmlUom_lbm_x002eft
resqml20__ResqmlUom_lbm_x002eft_x002fs = _fesapi.resqml20__ResqmlUom_lbm_x002eft_x002fs
resqml20__ResqmlUom_lbm_x002eft2 = _fesapi.resqml20__ResqmlUom_lbm_x002eft2
resqml20__ResqmlUom_lbm_x002eft2_x002fs2 = _fesapi.resqml20__ResqmlUom_lbm_x002eft2_x002fs2
resqml20__ResqmlUom_lbm_x002f_x0028ft_x002eh_x0029 = _fesapi.resqml20__ResqmlUom_lbm_x002f_x0028ft_x002eh_x0029
resqml20__ResqmlUom_lbm_x002f_x0028ft_x002es_x0029 = _fesapi.resqml20__ResqmlUom_lbm_x002f_x0028ft_x002es_x0029
resqml20__ResqmlUom_lbm_x002f_x0028ft2_x002eh_x0029 = _fesapi.resqml20__ResqmlUom_lbm_x002f_x0028ft2_x002eh_x0029
resqml20__ResqmlUom_lbm_x002f_x0028ft2_x002es_x0029 = _fesapi.resqml20__ResqmlUom_lbm_x002f_x0028ft2_x002es_x0029
resqml20__ResqmlUom_lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029 = _fesapi.resqml20__ResqmlUom_lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029
resqml20__ResqmlUom_lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029 = _fesapi.resqml20__ResqmlUom_lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029
resqml20__ResqmlUom_lbm_x002f_x0028hp_x002eh_x0029 = _fesapi.resqml20__ResqmlUom_lbm_x002f_x0028hp_x002eh_x0029
resqml20__ResqmlUom_lbm_x002fbbl = _fesapi.resqml20__ResqmlUom_lbm_x002fbbl
resqml20__ResqmlUom_lbm_x002fd = _fesapi.resqml20__ResqmlUom_lbm_x002fd
resqml20__ResqmlUom_lbm_x002fft = _fesapi.resqml20__ResqmlUom_lbm_x002fft
resqml20__ResqmlUom_lbm_x002fft2 = _fesapi.resqml20__ResqmlUom_lbm_x002fft2
resqml20__ResqmlUom_lbm_x002fft3 = _fesapi.resqml20__ResqmlUom_lbm_x002fft3
resqml20__ResqmlUom_lbm_x002fft4 = _fesapi.resqml20__ResqmlUom_lbm_x002fft4
resqml20__ResqmlUom_lbm_x002fgal_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_lbm_x002fgal_x005bUK_x005d
resqml20__ResqmlUom_lbm_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_lbm_x002fgal_x005bUS_x005d
resqml20__ResqmlUom_lbm_x002fh = _fesapi.resqml20__ResqmlUom_lbm_x002fh
resqml20__ResqmlUom_lbm_x002fin3 = _fesapi.resqml20__ResqmlUom_lbm_x002fin3
resqml20__ResqmlUom_lbm_x002flbmol = _fesapi.resqml20__ResqmlUom_lbm_x002flbmol
resqml20__ResqmlUom_lbm_x002fmin = _fesapi.resqml20__ResqmlUom_lbm_x002fmin
resqml20__ResqmlUom_lbm_x002fs = _fesapi.resqml20__ResqmlUom_lbm_x002fs
resqml20__ResqmlUom_lbmol = _fesapi.resqml20__ResqmlUom_lbmol
resqml20__ResqmlUom_lbmol_x002f_x0028h_x002eft2_x0029 = _fesapi.resqml20__ResqmlUom_lbmol_x002f_x0028h_x002eft2_x0029
resqml20__ResqmlUom_lbmol_x002f_x0028s_x002eft2_x0029 = _fesapi.resqml20__ResqmlUom_lbmol_x002f_x0028s_x002eft2_x0029
resqml20__ResqmlUom_lbmol_x002fft3 = _fesapi.resqml20__ResqmlUom_lbmol_x002fft3
resqml20__ResqmlUom_lbmol_x002fgal_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_lbmol_x002fgal_x005bUK_x005d
resqml20__ResqmlUom_lbmol_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_lbmol_x002fgal_x005bUS_x005d
resqml20__ResqmlUom_lbmol_x002fh = _fesapi.resqml20__ResqmlUom_lbmol_x002fh
resqml20__ResqmlUom_lbmol_x002fs = _fesapi.resqml20__ResqmlUom_lbmol_x002fs
resqml20__ResqmlUom_link = _fesapi.resqml20__ResqmlUom_link
resqml20__ResqmlUom_link_x005bBnA_x005d = _fesapi.resqml20__ResqmlUom_link_x005bBnA_x005d
resqml20__ResqmlUom_link_x005bBnB_x005d = _fesapi.resqml20__ResqmlUom_link_x005bBnB_x005d
resqml20__ResqmlUom_link_x005bCla_x005d = _fesapi.resqml20__ResqmlUom_link_x005bCla_x005d
resqml20__ResqmlUom_link_x005bSe_x005d = _fesapi.resqml20__ResqmlUom_link_x005bSe_x005d
resqml20__ResqmlUom_link_x005bSeT_x005d = _fesapi.resqml20__ResqmlUom_link_x005bSeT_x005d
resqml20__ResqmlUom_link_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_link_x005bUS_x005d
resqml20__ResqmlUom_lm = _fesapi.resqml20__ResqmlUom_lm
resqml20__ResqmlUom_lm_x002es = _fesapi.resqml20__ResqmlUom_lm_x002es
resqml20__ResqmlUom_lm_x002fm2 = _fesapi.resqml20__ResqmlUom_lm_x002fm2
resqml20__ResqmlUom_lm_x002fW = _fesapi.resqml20__ResqmlUom_lm_x002fW
resqml20__ResqmlUom_lx = _fesapi.resqml20__ResqmlUom_lx
resqml20__ResqmlUom_lx_x002es = _fesapi.resqml20__ResqmlUom_lx_x002es
resqml20__ResqmlUom_m_x002f_x0028m_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_m_x002f_x0028m_x002eK_x0029
resqml20__ResqmlUom_m_x002fcm = _fesapi.resqml20__ResqmlUom_m_x002fcm
resqml20__ResqmlUom_m_x002fd = _fesapi.resqml20__ResqmlUom_m_x002fd
resqml20__ResqmlUom_m_x002fh = _fesapi.resqml20__ResqmlUom_m_x002fh
resqml20__ResqmlUom_m_x002fK = _fesapi.resqml20__ResqmlUom_m_x002fK
resqml20__ResqmlUom_m_x002fkg = _fesapi.resqml20__ResqmlUom_m_x002fkg
resqml20__ResqmlUom_m_x002fkm = _fesapi.resqml20__ResqmlUom_m_x002fkm
resqml20__ResqmlUom_m_x002fkPa = _fesapi.resqml20__ResqmlUom_m_x002fkPa
resqml20__ResqmlUom_m_x002fm = _fesapi.resqml20__ResqmlUom_m_x002fm
resqml20__ResqmlUom_m_x002fm3 = _fesapi.resqml20__ResqmlUom_m_x002fm3
resqml20__ResqmlUom_m_x002fmin = _fesapi.resqml20__ResqmlUom_m_x002fmin
resqml20__ResqmlUom_m_x002fms = _fesapi.resqml20__ResqmlUom_m_x002fms
resqml20__ResqmlUom_m_x002fPa = _fesapi.resqml20__ResqmlUom_m_x002fPa
resqml20__ResqmlUom_m_x002fs = _fesapi.resqml20__ResqmlUom_m_x002fs
resqml20__ResqmlUom_m_x002fs2 = _fesapi.resqml20__ResqmlUom_m_x002fs2
resqml20__ResqmlUom_m_x005bGer_x005d = _fesapi.resqml20__ResqmlUom_m_x005bGer_x005d
resqml20__ResqmlUom_m2 = _fesapi.resqml20__ResqmlUom_m2
resqml20__ResqmlUom_m2_x002f_x0028kPa_x002ed_x0029 = _fesapi.resqml20__ResqmlUom_m2_x002f_x0028kPa_x002ed_x0029
resqml20__ResqmlUom_m2_x002f_x0028Pa_x002es_x0029 = _fesapi.resqml20__ResqmlUom_m2_x002f_x0028Pa_x002es_x0029
resqml20__ResqmlUom_m2_x002fcm3 = _fesapi.resqml20__ResqmlUom_m2_x002fcm3
resqml20__ResqmlUom_m2_x002fd = _fesapi.resqml20__ResqmlUom_m2_x002fd
resqml20__ResqmlUom_m2_x002fg = _fesapi.resqml20__ResqmlUom_m2_x002fg
resqml20__ResqmlUom_m2_x002fh = _fesapi.resqml20__ResqmlUom_m2_x002fh
resqml20__ResqmlUom_m2_x002fkg = _fesapi.resqml20__ResqmlUom_m2_x002fkg
resqml20__ResqmlUom_m2_x002fm2 = _fesapi.resqml20__ResqmlUom_m2_x002fm2
resqml20__ResqmlUom_m2_x002fm3 = _fesapi.resqml20__ResqmlUom_m2_x002fm3
resqml20__ResqmlUom_m2_x002fmol = _fesapi.resqml20__ResqmlUom_m2_x002fmol
resqml20__ResqmlUom_m2_x002fs = _fesapi.resqml20__ResqmlUom_m2_x002fs
resqml20__ResqmlUom_m3 = _fesapi.resqml20__ResqmlUom_m3
resqml20__ResqmlUom_m3_x002f_x0028bar_x002ed_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028bar_x002ed_x0029
resqml20__ResqmlUom_m3_x002f_x0028bar_x002eh_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028bar_x002eh_x0029
resqml20__ResqmlUom_m3_x002f_x0028bar_x002emin_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028bar_x002emin_x0029
resqml20__ResqmlUom_m3_x002f_x0028d_x002em_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028d_x002em_x0029
resqml20__ResqmlUom_m3_x002f_x0028h_x002em_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028h_x002em_x0029
resqml20__ResqmlUom_m3_x002f_x0028ha_x002em_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028ha_x002em_x0029
resqml20__ResqmlUom_m3_x002f_x0028kPa_x002ed_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028kPa_x002ed_x0029
resqml20__ResqmlUom_m3_x002f_x0028kPa_x002eh_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028kPa_x002eh_x0029
resqml20__ResqmlUom_m3_x002f_x0028kW_x002eh_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028kW_x002eh_x0029
resqml20__ResqmlUom_m3_x002f_x0028m3_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028m3_x002eK_x0029
resqml20__ResqmlUom_m3_x002f_x0028Pa_x002es_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028Pa_x002es_x0029
resqml20__ResqmlUom_m3_x002f_x0028psi_x002ed_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028psi_x002ed_x0029
resqml20__ResqmlUom_m3_x002f_x0028s_x002eft_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028s_x002eft_x0029
resqml20__ResqmlUom_m3_x002f_x0028s_x002em_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028s_x002em_x0029
resqml20__ResqmlUom_m3_x002f_x0028s_x002em2_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028s_x002em2_x0029
resqml20__ResqmlUom_m3_x002f_x0028s_x002em3_x0029 = _fesapi.resqml20__ResqmlUom_m3_x002f_x0028s_x002em3_x0029
resqml20__ResqmlUom_m3_x002fbbl = _fesapi.resqml20__ResqmlUom_m3_x002fbbl
resqml20__ResqmlUom_m3_x002fd = _fesapi.resqml20__ResqmlUom_m3_x002fd
resqml20__ResqmlUom_m3_x002fd2 = _fesapi.resqml20__ResqmlUom_m3_x002fd2
resqml20__ResqmlUom_m3_x002fg = _fesapi.resqml20__ResqmlUom_m3_x002fg
resqml20__ResqmlUom_m3_x002fh = _fesapi.resqml20__ResqmlUom_m3_x002fh
resqml20__ResqmlUom_m3_x002fJ = _fesapi.resqml20__ResqmlUom_m3_x002fJ
resqml20__ResqmlUom_m3_x002fkg = _fesapi.resqml20__ResqmlUom_m3_x002fkg
resqml20__ResqmlUom_m3_x002fkm = _fesapi.resqml20__ResqmlUom_m3_x002fkm
resqml20__ResqmlUom_m3_x002fkmol = _fesapi.resqml20__ResqmlUom_m3_x002fkmol
resqml20__ResqmlUom_m3_x002fkPa = _fesapi.resqml20__ResqmlUom_m3_x002fkPa
resqml20__ResqmlUom_m3_x002fm = _fesapi.resqml20__ResqmlUom_m3_x002fm
resqml20__ResqmlUom_m3_x002fm2 = _fesapi.resqml20__ResqmlUom_m3_x002fm2
resqml20__ResqmlUom_m3_x002fm3 = _fesapi.resqml20__ResqmlUom_m3_x002fm3
resqml20__ResqmlUom_m3_x002fmin = _fesapi.resqml20__ResqmlUom_m3_x002fmin
resqml20__ResqmlUom_m3_x002fmol = _fesapi.resqml20__ResqmlUom_m3_x002fmol
resqml20__ResqmlUom_m3_x002fPa = _fesapi.resqml20__ResqmlUom_m3_x002fPa
resqml20__ResqmlUom_m3_x002frad = _fesapi.resqml20__ResqmlUom_m3_x002frad
resqml20__ResqmlUom_m3_x002frev = _fesapi.resqml20__ResqmlUom_m3_x002frev
resqml20__ResqmlUom_m3_x002fs = _fesapi.resqml20__ResqmlUom_m3_x002fs
resqml20__ResqmlUom_m3_x002fs2 = _fesapi.resqml20__ResqmlUom_m3_x002fs2
resqml20__ResqmlUom_m3_x002ft = _fesapi.resqml20__ResqmlUom_m3_x002ft
resqml20__ResqmlUom_m3_x002fton_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_m3_x002fton_x005bUK_x005d
resqml20__ResqmlUom_m3_x002fton_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_m3_x002fton_x005bUS_x005d
resqml20__ResqmlUom_m4 = _fesapi.resqml20__ResqmlUom_m4
resqml20__ResqmlUom_m4_x002fs = _fesapi.resqml20__ResqmlUom_m4_x002fs
resqml20__ResqmlUom_mA = _fesapi.resqml20__ResqmlUom_mA
resqml20__ResqmlUom_MA = _fesapi.resqml20__ResqmlUom_MA
resqml20__ResqmlUom_mA_x002fcm2 = _fesapi.resqml20__ResqmlUom_mA_x002fcm2
resqml20__ResqmlUom_mA_x002fft2 = _fesapi.resqml20__ResqmlUom_mA_x002fft2
resqml20__ResqmlUom_Ma_x005bt_x005d = _fesapi.resqml20__ResqmlUom_Ma_x005bt_x005d
resqml20__ResqmlUom_mbar = _fesapi.resqml20__ResqmlUom_mbar
resqml20__ResqmlUom_MBq = _fesapi.resqml20__ResqmlUom_MBq
resqml20__ResqmlUom_mC = _fesapi.resqml20__ResqmlUom_mC
resqml20__ResqmlUom_MC = _fesapi.resqml20__ResqmlUom_MC
resqml20__ResqmlUom_mC_x002fm2 = _fesapi.resqml20__ResqmlUom_mC_x002fm2
resqml20__ResqmlUom_Mcal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_Mcal_x005bth_x005d
resqml20__ResqmlUom_mcal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_mcal_x005bth_x005d
resqml20__ResqmlUom_mCi = _fesapi.resqml20__ResqmlUom_mCi
resqml20__ResqmlUom_mD = _fesapi.resqml20__ResqmlUom_mD
resqml20__ResqmlUom_mD_x002eft = _fesapi.resqml20__ResqmlUom_mD_x002eft
resqml20__ResqmlUom_mD_x002eft2_x002f_x0028lbf_x002es_x0029 = _fesapi.resqml20__ResqmlUom_mD_x002eft2_x002f_x0028lbf_x002es_x0029
resqml20__ResqmlUom_mD_x002ein2_x002f_x0028lbf_x002es_x0029 = _fesapi.resqml20__ResqmlUom_mD_x002ein2_x002f_x0028lbf_x002es_x0029
resqml20__ResqmlUom_mD_x002em = _fesapi.resqml20__ResqmlUom_mD_x002em
resqml20__ResqmlUom_mD_x002f_x0028Pa_x002es_x0029 = _fesapi.resqml20__ResqmlUom_mD_x002f_x0028Pa_x002es_x0029
resqml20__ResqmlUom_mD_x002fcP = _fesapi.resqml20__ResqmlUom_mD_x002fcP
resqml20__ResqmlUom_MEuc = _fesapi.resqml20__ResqmlUom_MEuc
resqml20__ResqmlUom_mEuc = _fesapi.resqml20__ResqmlUom_mEuc
resqml20__ResqmlUom_meV = _fesapi.resqml20__ResqmlUom_meV
resqml20__ResqmlUom_MeV = _fesapi.resqml20__ResqmlUom_MeV
resqml20__ResqmlUom_mF = _fesapi.resqml20__ResqmlUom_mF
resqml20__ResqmlUom_MF = _fesapi.resqml20__ResqmlUom_MF
resqml20__ResqmlUom_Mg = _fesapi.resqml20__ResqmlUom_Mg
resqml20__ResqmlUom_mg = _fesapi.resqml20__ResqmlUom_mg
resqml20__ResqmlUom_Mg_x002fa = _fesapi.resqml20__ResqmlUom_Mg_x002fa
resqml20__ResqmlUom_Mg_x002fd = _fesapi.resqml20__ResqmlUom_Mg_x002fd
resqml20__ResqmlUom_mg_x002fdm3 = _fesapi.resqml20__ResqmlUom_mg_x002fdm3
resqml20__ResqmlUom_mg_x002fg = _fesapi.resqml20__ResqmlUom_mg_x002fg
resqml20__ResqmlUom_mg_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_mg_x002fgal_x005bUS_x005d
resqml20__ResqmlUom_Mg_x002fh = _fesapi.resqml20__ResqmlUom_Mg_x002fh
resqml20__ResqmlUom_Mg_x002fin = _fesapi.resqml20__ResqmlUom_Mg_x002fin
resqml20__ResqmlUom_mg_x002fJ = _fesapi.resqml20__ResqmlUom_mg_x002fJ
resqml20__ResqmlUom_mg_x002fkg = _fesapi.resqml20__ResqmlUom_mg_x002fkg
resqml20__ResqmlUom_mg_x002fL = _fesapi.resqml20__ResqmlUom_mg_x002fL
resqml20__ResqmlUom_Mg_x002fm2 = _fesapi.resqml20__ResqmlUom_Mg_x002fm2
resqml20__ResqmlUom_Mg_x002fm3 = _fesapi.resqml20__ResqmlUom_Mg_x002fm3
resqml20__ResqmlUom_mg_x002fm3 = _fesapi.resqml20__ResqmlUom_mg_x002fm3
resqml20__ResqmlUom_Mg_x002fmin = _fesapi.resqml20__ResqmlUom_Mg_x002fmin
resqml20__ResqmlUom_mGal = _fesapi.resqml20__ResqmlUom_mGal
resqml20__ResqmlUom_Mgauss = _fesapi.resqml20__ResqmlUom_Mgauss
resqml20__ResqmlUom_mgauss = _fesapi.resqml20__ResqmlUom_mgauss
resqml20__ResqmlUom_Mgf = _fesapi.resqml20__ResqmlUom_Mgf
resqml20__ResqmlUom_mgn = _fesapi.resqml20__ResqmlUom_mgn
resqml20__ResqmlUom_MGy = _fesapi.resqml20__ResqmlUom_MGy
resqml20__ResqmlUom_mGy = _fesapi.resqml20__ResqmlUom_mGy
resqml20__ResqmlUom_MH = _fesapi.resqml20__ResqmlUom_MH
resqml20__ResqmlUom_mH = _fesapi.resqml20__ResqmlUom_mH
resqml20__ResqmlUom_mHz = _fesapi.resqml20__ResqmlUom_mHz
resqml20__ResqmlUom_MHz = _fesapi.resqml20__ResqmlUom_MHz
resqml20__ResqmlUom_mi = _fesapi.resqml20__ResqmlUom_mi
resqml20__ResqmlUom_mi_x002fgal_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_mi_x002fgal_x005bUK_x005d
resqml20__ResqmlUom_mi_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_mi_x002fgal_x005bUS_x005d
resqml20__ResqmlUom_mi_x002fh = _fesapi.resqml20__ResqmlUom_mi_x002fh
resqml20__ResqmlUom_mi_x002fin = _fesapi.resqml20__ResqmlUom_mi_x002fin
resqml20__ResqmlUom_mi_x005bnaut_x005d = _fesapi.resqml20__ResqmlUom_mi_x005bnaut_x005d
resqml20__ResqmlUom_mi_x005bnautUK_x005d = _fesapi.resqml20__ResqmlUom_mi_x005bnautUK_x005d
resqml20__ResqmlUom_mi_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_mi_x005bUS_x005d
resqml20__ResqmlUom_mi_x005bUS_x005d2 = _fesapi.resqml20__ResqmlUom_mi_x005bUS_x005d2
resqml20__ResqmlUom_mi2 = _fesapi.resqml20__ResqmlUom_mi2
resqml20__ResqmlUom_mi3 = _fesapi.resqml20__ResqmlUom_mi3
resqml20__ResqmlUom_Mibyte = _fesapi.resqml20__ResqmlUom_Mibyte
resqml20__ResqmlUom_mil = _fesapi.resqml20__ResqmlUom_mil
resqml20__ResqmlUom_mil_x002fa = _fesapi.resqml20__ResqmlUom_mil_x002fa
resqml20__ResqmlUom_mila = _fesapi.resqml20__ResqmlUom_mila
resqml20__ResqmlUom_min_ = _fesapi.resqml20__ResqmlUom_min_
resqml20__ResqmlUom_min_x002fft = _fesapi.resqml20__ResqmlUom_min_x002fft
resqml20__ResqmlUom_min_x002fm = _fesapi.resqml20__ResqmlUom_min_x002fm
resqml20__ResqmlUom_mina = _fesapi.resqml20__ResqmlUom_mina
resqml20__ResqmlUom_mJ = _fesapi.resqml20__ResqmlUom_mJ
resqml20__ResqmlUom_MJ = _fesapi.resqml20__ResqmlUom_MJ
resqml20__ResqmlUom_MJ_x002fa = _fesapi.resqml20__ResqmlUom_MJ_x002fa
resqml20__ResqmlUom_mJ_x002fcm2 = _fesapi.resqml20__ResqmlUom_mJ_x002fcm2
resqml20__ResqmlUom_MJ_x002fkg = _fesapi.resqml20__ResqmlUom_MJ_x002fkg
resqml20__ResqmlUom_MJ_x002fkmol = _fesapi.resqml20__ResqmlUom_MJ_x002fkmol
resqml20__ResqmlUom_MJ_x002fm = _fesapi.resqml20__ResqmlUom_MJ_x002fm
resqml20__ResqmlUom_mJ_x002fm2 = _fesapi.resqml20__ResqmlUom_mJ_x002fm2
resqml20__ResqmlUom_MJ_x002fm3 = _fesapi.resqml20__ResqmlUom_MJ_x002fm3
resqml20__ResqmlUom_mL = _fesapi.resqml20__ResqmlUom_mL
resqml20__ResqmlUom_mL_x002fgal_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_mL_x002fgal_x005bUK_x005d
resqml20__ResqmlUom_mL_x002fgal_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_mL_x002fgal_x005bUS_x005d
resqml20__ResqmlUom_mL_x002fmL = _fesapi.resqml20__ResqmlUom_mL_x002fmL
resqml20__ResqmlUom_Mm = _fesapi.resqml20__ResqmlUom_Mm
resqml20__ResqmlUom_mm = _fesapi.resqml20__ResqmlUom_mm
resqml20__ResqmlUom_mm_x002f_x0028mm_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_mm_x002f_x0028mm_x002eK_x0029
resqml20__ResqmlUom_mm_x002fa = _fesapi.resqml20__ResqmlUom_mm_x002fa
resqml20__ResqmlUom_mm_x002fs = _fesapi.resqml20__ResqmlUom_mm_x002fs
resqml20__ResqmlUom_mm2 = _fesapi.resqml20__ResqmlUom_mm2
resqml20__ResqmlUom_mm2_x002fmm2 = _fesapi.resqml20__ResqmlUom_mm2_x002fmm2
resqml20__ResqmlUom_mm2_x002fs = _fesapi.resqml20__ResqmlUom_mm2_x002fs
resqml20__ResqmlUom_mm3 = _fesapi.resqml20__ResqmlUom_mm3
resqml20__ResqmlUom_mm3_x002fJ = _fesapi.resqml20__ResqmlUom_mm3_x002fJ
resqml20__ResqmlUom_mmHg_x005b0degC_x005d = _fesapi.resqml20__ResqmlUom_mmHg_x005b0degC_x005d
resqml20__ResqmlUom_mmol = _fesapi.resqml20__ResqmlUom_mmol
resqml20__ResqmlUom_mN = _fesapi.resqml20__ResqmlUom_mN
resqml20__ResqmlUom_MN = _fesapi.resqml20__ResqmlUom_MN
resqml20__ResqmlUom_mN_x002em2 = _fesapi.resqml20__ResqmlUom_mN_x002em2
resqml20__ResqmlUom_mN_x002fkm = _fesapi.resqml20__ResqmlUom_mN_x002fkm
resqml20__ResqmlUom_mN_x002fm = _fesapi.resqml20__ResqmlUom_mN_x002fm
resqml20__ResqmlUom_mohm = _fesapi.resqml20__ResqmlUom_mohm
resqml20__ResqmlUom_Mohm = _fesapi.resqml20__ResqmlUom_Mohm
resqml20__ResqmlUom_mol = _fesapi.resqml20__ResqmlUom_mol
resqml20__ResqmlUom_mol_x002em2_x002f_x0028mol_x002es_x0029 = _fesapi.resqml20__ResqmlUom_mol_x002em2_x002f_x0028mol_x002es_x0029
resqml20__ResqmlUom_mol_x002f_x0028s_x002em2_x0029 = _fesapi.resqml20__ResqmlUom_mol_x002f_x0028s_x002em2_x0029
resqml20__ResqmlUom_mol_x002fm2 = _fesapi.resqml20__ResqmlUom_mol_x002fm2
resqml20__ResqmlUom_mol_x002fm3 = _fesapi.resqml20__ResqmlUom_mol_x002fm3
resqml20__ResqmlUom_mol_x002fmol = _fesapi.resqml20__ResqmlUom_mol_x002fmol
resqml20__ResqmlUom_mol_x002fs = _fesapi.resqml20__ResqmlUom_mol_x002fs
resqml20__ResqmlUom_mP = _fesapi.resqml20__ResqmlUom_mP
resqml20__ResqmlUom_MP = _fesapi.resqml20__ResqmlUom_MP
resqml20__ResqmlUom_MPa = _fesapi.resqml20__ResqmlUom_MPa
resqml20__ResqmlUom_mPa = _fesapi.resqml20__ResqmlUom_mPa
resqml20__ResqmlUom_mPa_x002es = _fesapi.resqml20__ResqmlUom_mPa_x002es
resqml20__ResqmlUom_MPa_x002es_x002fm = _fesapi.resqml20__ResqmlUom_MPa_x002es_x002fm
resqml20__ResqmlUom_MPa_x002fh = _fesapi.resqml20__ResqmlUom_MPa_x002fh
resqml20__ResqmlUom_MPa_x002fm = _fesapi.resqml20__ResqmlUom_MPa_x002fm
resqml20__ResqmlUom_Mpsi = _fesapi.resqml20__ResqmlUom_Mpsi
resqml20__ResqmlUom_mrad = _fesapi.resqml20__ResqmlUom_mrad
resqml20__ResqmlUom_Mrad = _fesapi.resqml20__ResqmlUom_Mrad
resqml20__ResqmlUom_Mrd = _fesapi.resqml20__ResqmlUom_Mrd
resqml20__ResqmlUom_mrd = _fesapi.resqml20__ResqmlUom_mrd
resqml20__ResqmlUom_mrem = _fesapi.resqml20__ResqmlUom_mrem
resqml20__ResqmlUom_mrem_x002fh = _fesapi.resqml20__ResqmlUom_mrem_x002fh
resqml20__ResqmlUom_MS = _fesapi.resqml20__ResqmlUom_MS
resqml20__ResqmlUom_mS = _fesapi.resqml20__ResqmlUom_mS
resqml20__ResqmlUom_ms = _fesapi.resqml20__ResqmlUom_ms
resqml20__ResqmlUom_ms_x002fcm = _fesapi.resqml20__ResqmlUom_ms_x002fcm
resqml20__ResqmlUom_mS_x002fcm = _fesapi.resqml20__ResqmlUom_mS_x002fcm
resqml20__ResqmlUom_ms_x002fft = _fesapi.resqml20__ResqmlUom_ms_x002fft
resqml20__ResqmlUom_ms_x002fin = _fesapi.resqml20__ResqmlUom_ms_x002fin
resqml20__ResqmlUom_mS_x002fm = _fesapi.resqml20__ResqmlUom_mS_x002fm
resqml20__ResqmlUom_ms_x002fm = _fesapi.resqml20__ResqmlUom_ms_x002fm
resqml20__ResqmlUom_ms_x002fs = _fesapi.resqml20__ResqmlUom_ms_x002fs
resqml20__ResqmlUom_mSv = _fesapi.resqml20__ResqmlUom_mSv
resqml20__ResqmlUom_mSv_x002fh = _fesapi.resqml20__ResqmlUom_mSv_x002fh
resqml20__ResqmlUom_mT = _fesapi.resqml20__ResqmlUom_mT
resqml20__ResqmlUom_mT_x002fdm = _fesapi.resqml20__ResqmlUom_mT_x002fdm
resqml20__ResqmlUom_MV = _fesapi.resqml20__ResqmlUom_MV
resqml20__ResqmlUom_mV = _fesapi.resqml20__ResqmlUom_mV
resqml20__ResqmlUom_mV_x002fft = _fesapi.resqml20__ResqmlUom_mV_x002fft
resqml20__ResqmlUom_mV_x002fm = _fesapi.resqml20__ResqmlUom_mV_x002fm
resqml20__ResqmlUom_MW = _fesapi.resqml20__ResqmlUom_MW
resqml20__ResqmlUom_mW = _fesapi.resqml20__ResqmlUom_mW
resqml20__ResqmlUom_MW_x002eh = _fesapi.resqml20__ResqmlUom_MW_x002eh
resqml20__ResqmlUom_MW_x002eh_x002fkg = _fesapi.resqml20__ResqmlUom_MW_x002eh_x002fkg
resqml20__ResqmlUom_MW_x002eh_x002fm3 = _fesapi.resqml20__ResqmlUom_MW_x002eh_x002fm3
resqml20__ResqmlUom_mW_x002fm2 = _fesapi.resqml20__ResqmlUom_mW_x002fm2
resqml20__ResqmlUom_mWb = _fesapi.resqml20__ResqmlUom_mWb
resqml20__ResqmlUom_MWb = _fesapi.resqml20__ResqmlUom_MWb
resqml20__ResqmlUom_N_x002em = _fesapi.resqml20__ResqmlUom_N_x002em
resqml20__ResqmlUom_N_x002em_x002fm = _fesapi.resqml20__ResqmlUom_N_x002em_x002fm
resqml20__ResqmlUom_N_x002em2 = _fesapi.resqml20__ResqmlUom_N_x002em2
resqml20__ResqmlUom_N_x002es_x002fm2 = _fesapi.resqml20__ResqmlUom_N_x002es_x002fm2
resqml20__ResqmlUom_N_x002fm = _fesapi.resqml20__ResqmlUom_N_x002fm
resqml20__ResqmlUom_N_x002fm2 = _fesapi.resqml20__ResqmlUom_N_x002fm2
resqml20__ResqmlUom_N_x002fm3 = _fesapi.resqml20__ResqmlUom_N_x002fm3
resqml20__ResqmlUom_N_x002fmm2 = _fesapi.resqml20__ResqmlUom_N_x002fmm2
resqml20__ResqmlUom_N_x002fN = _fesapi.resqml20__ResqmlUom_N_x002fN
resqml20__ResqmlUom_nA = _fesapi.resqml20__ResqmlUom_nA
resqml20__ResqmlUom_na = _fesapi.resqml20__ResqmlUom_na
resqml20__ResqmlUom_nAPI = _fesapi.resqml20__ResqmlUom_nAPI
resqml20__ResqmlUom_nC = _fesapi.resqml20__ResqmlUom_nC
resqml20__ResqmlUom_ncal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_ncal_x005bth_x005d
resqml20__ResqmlUom_nCi = _fesapi.resqml20__ResqmlUom_nCi
resqml20__ResqmlUom_nEuc = _fesapi.resqml20__ResqmlUom_nEuc
resqml20__ResqmlUom_neV = _fesapi.resqml20__ResqmlUom_neV
resqml20__ResqmlUom_nF = _fesapi.resqml20__ResqmlUom_nF
resqml20__ResqmlUom_ng = _fesapi.resqml20__ResqmlUom_ng
resqml20__ResqmlUom_ng_x002fg = _fesapi.resqml20__ResqmlUom_ng_x002fg
resqml20__ResqmlUom_ng_x002fmg = _fesapi.resqml20__ResqmlUom_ng_x002fmg
resqml20__ResqmlUom_ngauss = _fesapi.resqml20__ResqmlUom_ngauss
resqml20__ResqmlUom_nGy = _fesapi.resqml20__ResqmlUom_nGy
resqml20__ResqmlUom_nH = _fesapi.resqml20__ResqmlUom_nH
resqml20__ResqmlUom_nHz = _fesapi.resqml20__ResqmlUom_nHz
resqml20__ResqmlUom_nJ = _fesapi.resqml20__ResqmlUom_nJ
resqml20__ResqmlUom_nm = _fesapi.resqml20__ResqmlUom_nm
resqml20__ResqmlUom_nm_x002fs = _fesapi.resqml20__ResqmlUom_nm_x002fs
resqml20__ResqmlUom_nN = _fesapi.resqml20__ResqmlUom_nN
resqml20__ResqmlUom_nohm = _fesapi.resqml20__ResqmlUom_nohm
resqml20__ResqmlUom_nohm_x002emil2_x002fft = _fesapi.resqml20__ResqmlUom_nohm_x002emil2_x002fft
resqml20__ResqmlUom_nohm_x002emm2_x002fm = _fesapi.resqml20__ResqmlUom_nohm_x002emm2_x002fm
resqml20__ResqmlUom_nP = _fesapi.resqml20__ResqmlUom_nP
resqml20__ResqmlUom_nPa = _fesapi.resqml20__ResqmlUom_nPa
resqml20__ResqmlUom_nrd = _fesapi.resqml20__ResqmlUom_nrd
resqml20__ResqmlUom_nS = _fesapi.resqml20__ResqmlUom_nS
resqml20__ResqmlUom_ns = _fesapi.resqml20__ResqmlUom_ns
resqml20__ResqmlUom_ns_x002fft = _fesapi.resqml20__ResqmlUom_ns_x002fft
resqml20__ResqmlUom_ns_x002fm = _fesapi.resqml20__ResqmlUom_ns_x002fm
resqml20__ResqmlUom_nT = _fesapi.resqml20__ResqmlUom_nT
resqml20__ResqmlUom_nV = _fesapi.resqml20__ResqmlUom_nV
resqml20__ResqmlUom_nW = _fesapi.resqml20__ResqmlUom_nW
resqml20__ResqmlUom_nWb = _fesapi.resqml20__ResqmlUom_nWb
resqml20__ResqmlUom_Oe = _fesapi.resqml20__ResqmlUom_Oe
resqml20__ResqmlUom_ohm = _fesapi.resqml20__ResqmlUom_ohm
resqml20__ResqmlUom_ohm_x002ecm = _fesapi.resqml20__ResqmlUom_ohm_x002ecm
resqml20__ResqmlUom_ohm_x002em = _fesapi.resqml20__ResqmlUom_ohm_x002em
resqml20__ResqmlUom_ohm_x002em2_x002fm = _fesapi.resqml20__ResqmlUom_ohm_x002em2_x002fm
resqml20__ResqmlUom_ohm_x002fm = _fesapi.resqml20__ResqmlUom_ohm_x002fm
resqml20__ResqmlUom_ozf = _fesapi.resqml20__ResqmlUom_ozf
resqml20__ResqmlUom_ozm = _fesapi.resqml20__ResqmlUom_ozm
resqml20__ResqmlUom_ozm_x005btroy_x005d = _fesapi.resqml20__ResqmlUom_ozm_x005btroy_x005d
resqml20__ResqmlUom_pA = _fesapi.resqml20__ResqmlUom_pA
resqml20__ResqmlUom_Pa = _fesapi.resqml20__ResqmlUom_Pa
resqml20__ResqmlUom_Pa_x002es = _fesapi.resqml20__ResqmlUom_Pa_x002es
resqml20__ResqmlUom_Pa_x002es_x002em3_x002fkg = _fesapi.resqml20__ResqmlUom_Pa_x002es_x002em3_x002fkg
resqml20__ResqmlUom_Pa_x002es_x002fm3 = _fesapi.resqml20__ResqmlUom_Pa_x002es_x002fm3
resqml20__ResqmlUom_Pa_x002es2_x002fm3 = _fesapi.resqml20__ResqmlUom_Pa_x002es2_x002fm3
resqml20__ResqmlUom_Pa_x002fh = _fesapi.resqml20__ResqmlUom_Pa_x002fh
resqml20__ResqmlUom_Pa_x002fm = _fesapi.resqml20__ResqmlUom_Pa_x002fm
resqml20__ResqmlUom_Pa_x002fm3 = _fesapi.resqml20__ResqmlUom_Pa_x002fm3
resqml20__ResqmlUom_Pa_x002fs = _fesapi.resqml20__ResqmlUom_Pa_x002fs
resqml20__ResqmlUom_Pa2 = _fesapi.resqml20__ResqmlUom_Pa2
resqml20__ResqmlUom_Pa2_x002f_x0028Pa_x002es_x0029 = _fesapi.resqml20__ResqmlUom_Pa2_x002f_x0028Pa_x002es_x0029
resqml20__ResqmlUom_pC = _fesapi.resqml20__ResqmlUom_pC
resqml20__ResqmlUom_pcal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_pcal_x005bth_x005d
resqml20__ResqmlUom_pCi = _fesapi.resqml20__ResqmlUom_pCi
resqml20__ResqmlUom_pCi_x002fg = _fesapi.resqml20__ResqmlUom_pCi_x002fg
resqml20__ResqmlUom_pdl = _fesapi.resqml20__ResqmlUom_pdl
resqml20__ResqmlUom_pdl_x002ecm2 = _fesapi.resqml20__ResqmlUom_pdl_x002ecm2
resqml20__ResqmlUom_pdl_x002eft = _fesapi.resqml20__ResqmlUom_pdl_x002eft
resqml20__ResqmlUom_pdl_x002fcm = _fesapi.resqml20__ResqmlUom_pdl_x002fcm
resqml20__ResqmlUom_pEuc = _fesapi.resqml20__ResqmlUom_pEuc
resqml20__ResqmlUom_peV = _fesapi.resqml20__ResqmlUom_peV
resqml20__ResqmlUom_pF = _fesapi.resqml20__ResqmlUom_pF
resqml20__ResqmlUom_pg = _fesapi.resqml20__ResqmlUom_pg
resqml20__ResqmlUom_pgauss = _fesapi.resqml20__ResqmlUom_pgauss
resqml20__ResqmlUom_pGy = _fesapi.resqml20__ResqmlUom_pGy
resqml20__ResqmlUom_pHz = _fesapi.resqml20__ResqmlUom_pHz
resqml20__ResqmlUom_pJ = _fesapi.resqml20__ResqmlUom_pJ
resqml20__ResqmlUom_pm = _fesapi.resqml20__ResqmlUom_pm
resqml20__ResqmlUom_pN = _fesapi.resqml20__ResqmlUom_pN
resqml20__ResqmlUom_pohm = _fesapi.resqml20__ResqmlUom_pohm
resqml20__ResqmlUom_pP = _fesapi.resqml20__ResqmlUom_pP
resqml20__ResqmlUom_pPa = _fesapi.resqml20__ResqmlUom_pPa
resqml20__ResqmlUom_ppk = _fesapi.resqml20__ResqmlUom_ppk
resqml20__ResqmlUom_ppm = _fesapi.resqml20__ResqmlUom_ppm
resqml20__ResqmlUom_ppm_x005bmass_x005d = _fesapi.resqml20__ResqmlUom_ppm_x005bmass_x005d
resqml20__ResqmlUom_ppm_x005bvol_x005d = _fesapi.resqml20__ResqmlUom_ppm_x005bvol_x005d
resqml20__ResqmlUom_ppm_x005bvol_x005d_x002fdegC = _fesapi.resqml20__ResqmlUom_ppm_x005bvol_x005d_x002fdegC
resqml20__ResqmlUom_ppm_x005bvol_x005d_x002fdegF = _fesapi.resqml20__ResqmlUom_ppm_x005bvol_x005d_x002fdegF
resqml20__ResqmlUom_prd = _fesapi.resqml20__ResqmlUom_prd
resqml20__ResqmlUom_ps = _fesapi.resqml20__ResqmlUom_ps
resqml20__ResqmlUom_pS = _fesapi.resqml20__ResqmlUom_pS
resqml20__ResqmlUom_psi = _fesapi.resqml20__ResqmlUom_psi
resqml20__ResqmlUom_psi_x002ed_x002fbbl = _fesapi.resqml20__ResqmlUom_psi_x002ed_x002fbbl
resqml20__ResqmlUom_psi_x002es = _fesapi.resqml20__ResqmlUom_psi_x002es
resqml20__ResqmlUom_psi_x002fft = _fesapi.resqml20__ResqmlUom_psi_x002fft
resqml20__ResqmlUom_psi_x002fh = _fesapi.resqml20__ResqmlUom_psi_x002fh
resqml20__ResqmlUom_psi_x002fm = _fesapi.resqml20__ResqmlUom_psi_x002fm
resqml20__ResqmlUom_psi_x002fmin = _fesapi.resqml20__ResqmlUom_psi_x002fmin
resqml20__ResqmlUom_psi2 = _fesapi.resqml20__ResqmlUom_psi2
resqml20__ResqmlUom_psi2_x002ed_x002f_x0028cP_x002eft3_x0029 = _fesapi.resqml20__ResqmlUom_psi2_x002ed_x002f_x0028cP_x002eft3_x0029
resqml20__ResqmlUom_psi2_x002fcP = _fesapi.resqml20__ResqmlUom_psi2_x002fcP
resqml20__ResqmlUom_pT = _fesapi.resqml20__ResqmlUom_pT
resqml20__ResqmlUom_pt_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_pt_x005bUK_x005d
resqml20__ResqmlUom_pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029 = _fesapi.resqml20__ResqmlUom_pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029
resqml20__ResqmlUom_pt_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_pt_x005bUS_x005d
resqml20__ResqmlUom_pV = _fesapi.resqml20__ResqmlUom_pV
resqml20__ResqmlUom_pW = _fesapi.resqml20__ResqmlUom_pW
resqml20__ResqmlUom_pWb = _fesapi.resqml20__ResqmlUom_pWb
resqml20__ResqmlUom_qt_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_qt_x005bUK_x005d
resqml20__ResqmlUom_qt_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_qt_x005bUS_x005d
resqml20__ResqmlUom_quad = _fesapi.resqml20__ResqmlUom_quad
resqml20__ResqmlUom_quad_x002fa = _fesapi.resqml20__ResqmlUom_quad_x002fa
resqml20__ResqmlUom_rad = _fesapi.resqml20__ResqmlUom_rad
resqml20__ResqmlUom_rad_x002fft = _fesapi.resqml20__ResqmlUom_rad_x002fft
resqml20__ResqmlUom_rad_x002fft3 = _fesapi.resqml20__ResqmlUom_rad_x002fft3
resqml20__ResqmlUom_rad_x002fm = _fesapi.resqml20__ResqmlUom_rad_x002fm
resqml20__ResqmlUom_rad_x002fm3 = _fesapi.resqml20__ResqmlUom_rad_x002fm3
resqml20__ResqmlUom_rad_x002fs = _fesapi.resqml20__ResqmlUom_rad_x002fs
resqml20__ResqmlUom_rad_x002fs2 = _fesapi.resqml20__ResqmlUom_rad_x002fs2
resqml20__ResqmlUom_rd = _fesapi.resqml20__ResqmlUom_rd
resqml20__ResqmlUom_rem = _fesapi.resqml20__ResqmlUom_rem
resqml20__ResqmlUom_rem_x002fh = _fesapi.resqml20__ResqmlUom_rem_x002fh
resqml20__ResqmlUom_rev = _fesapi.resqml20__ResqmlUom_rev
resqml20__ResqmlUom_rev_x002fft = _fesapi.resqml20__ResqmlUom_rev_x002fft
resqml20__ResqmlUom_rev_x002fm = _fesapi.resqml20__ResqmlUom_rev_x002fm
resqml20__ResqmlUom_rev_x002fs = _fesapi.resqml20__ResqmlUom_rev_x002fs
resqml20__ResqmlUom_rod_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_rod_x005bUS_x005d
resqml20__ResqmlUom_rpm = _fesapi.resqml20__ResqmlUom_rpm
resqml20__ResqmlUom_rpm_x002fs = _fesapi.resqml20__ResqmlUom_rpm_x002fs
resqml20__ResqmlUom_s_x002fcm = _fesapi.resqml20__ResqmlUom_s_x002fcm
resqml20__ResqmlUom_s_x002fft = _fesapi.resqml20__ResqmlUom_s_x002fft
resqml20__ResqmlUom_s_x002fft3 = _fesapi.resqml20__ResqmlUom_s_x002fft3
resqml20__ResqmlUom_s_x002fin = _fesapi.resqml20__ResqmlUom_s_x002fin
resqml20__ResqmlUom_s_x002fkg = _fesapi.resqml20__ResqmlUom_s_x002fkg
resqml20__ResqmlUom_s_x002fL = _fesapi.resqml20__ResqmlUom_s_x002fL
resqml20__ResqmlUom_S_x002fm = _fesapi.resqml20__ResqmlUom_S_x002fm
resqml20__ResqmlUom_s_x002fm = _fesapi.resqml20__ResqmlUom_s_x002fm
resqml20__ResqmlUom_s_x002fm3 = _fesapi.resqml20__ResqmlUom_s_x002fm3
resqml20__ResqmlUom_s_x002fqt_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_s_x002fqt_x005bUK_x005d
resqml20__ResqmlUom_s_x002fqt_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_s_x002fqt_x005bUS_x005d
resqml20__ResqmlUom_s_x002fs = _fesapi.resqml20__ResqmlUom_s_x002fs
resqml20__ResqmlUom_sack_x005b94lbm_x005d = _fesapi.resqml20__ResqmlUom_sack_x005b94lbm_x005d
resqml20__ResqmlUom_seca = _fesapi.resqml20__ResqmlUom_seca
resqml20__ResqmlUom_section = _fesapi.resqml20__ResqmlUom_section
resqml20__ResqmlUom_sr = _fesapi.resqml20__ResqmlUom_sr
resqml20__ResqmlUom_St = _fesapi.resqml20__ResqmlUom_St
resqml20__ResqmlUom_Sv = _fesapi.resqml20__ResqmlUom_Sv
resqml20__ResqmlUom_Sv_x002fh = _fesapi.resqml20__ResqmlUom_Sv_x002fh
resqml20__ResqmlUom_Sv_x002fs = _fesapi.resqml20__ResqmlUom_Sv_x002fs
resqml20__ResqmlUom_t_x002fa = _fesapi.resqml20__ResqmlUom_t_x002fa
resqml20__ResqmlUom_t_x002fd = _fesapi.resqml20__ResqmlUom_t_x002fd
resqml20__ResqmlUom_t_x002fh = _fesapi.resqml20__ResqmlUom_t_x002fh
resqml20__ResqmlUom_T_x002fm = _fesapi.resqml20__ResqmlUom_T_x002fm
resqml20__ResqmlUom_t_x002fm3 = _fesapi.resqml20__ResqmlUom_t_x002fm3
resqml20__ResqmlUom_t_x002fmin = _fesapi.resqml20__ResqmlUom_t_x002fmin
resqml20__ResqmlUom_TA = _fesapi.resqml20__ResqmlUom_TA
resqml20__ResqmlUom_Ta_x005bt_x005d = _fesapi.resqml20__ResqmlUom_Ta_x005bt_x005d
resqml20__ResqmlUom_TBq = _fesapi.resqml20__ResqmlUom_TBq
resqml20__ResqmlUom_TC = _fesapi.resqml20__ResqmlUom_TC
resqml20__ResqmlUom_Tcal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_Tcal_x005bth_x005d
resqml20__ResqmlUom_TD_x005bAPI_x005d = _fesapi.resqml20__ResqmlUom_TD_x005bAPI_x005d
resqml20__ResqmlUom_TD_x005bAPI_x005d_x002em = _fesapi.resqml20__ResqmlUom_TD_x005bAPI_x005d_x002em
resqml20__ResqmlUom_TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029 = _fesapi.resqml20__ResqmlUom_TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029
resqml20__ResqmlUom_TEuc = _fesapi.resqml20__ResqmlUom_TEuc
resqml20__ResqmlUom_TeV = _fesapi.resqml20__ResqmlUom_TeV
resqml20__ResqmlUom_TF = _fesapi.resqml20__ResqmlUom_TF
resqml20__ResqmlUom_Tg = _fesapi.resqml20__ResqmlUom_Tg
resqml20__ResqmlUom_Tgauss = _fesapi.resqml20__ResqmlUom_Tgauss
resqml20__ResqmlUom_TGy = _fesapi.resqml20__ResqmlUom_TGy
resqml20__ResqmlUom_TH = _fesapi.resqml20__ResqmlUom_TH
resqml20__ResqmlUom_therm_x005bEC_x005d = _fesapi.resqml20__ResqmlUom_therm_x005bEC_x005d
resqml20__ResqmlUom_therm_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_therm_x005bUK_x005d
resqml20__ResqmlUom_therm_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_therm_x005bUS_x005d
resqml20__ResqmlUom_THz = _fesapi.resqml20__ResqmlUom_THz
resqml20__ResqmlUom_TJ = _fesapi.resqml20__ResqmlUom_TJ
resqml20__ResqmlUom_TJ_x002fa = _fesapi.resqml20__ResqmlUom_TJ_x002fa
resqml20__ResqmlUom_Tm = _fesapi.resqml20__ResqmlUom_Tm
resqml20__ResqmlUom_TN = _fesapi.resqml20__ResqmlUom_TN
resqml20__ResqmlUom_Tohm = _fesapi.resqml20__ResqmlUom_Tohm
resqml20__ResqmlUom_ton_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_ton_x005bUK_x005d
resqml20__ResqmlUom_ton_x005bUK_x005d_x002fa = _fesapi.resqml20__ResqmlUom_ton_x005bUK_x005d_x002fa
resqml20__ResqmlUom_ton_x005bUK_x005d_x002fd = _fesapi.resqml20__ResqmlUom_ton_x005bUK_x005d_x002fd
resqml20__ResqmlUom_ton_x005bUK_x005d_x002fh = _fesapi.resqml20__ResqmlUom_ton_x005bUK_x005d_x002fh
resqml20__ResqmlUom_ton_x005bUK_x005d_x002fmin = _fesapi.resqml20__ResqmlUom_ton_x005bUK_x005d_x002fmin
resqml20__ResqmlUom_ton_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_ton_x005bUS_x005d
resqml20__ResqmlUom_ton_x005bUS_x005d_x002fa = _fesapi.resqml20__ResqmlUom_ton_x005bUS_x005d_x002fa
resqml20__ResqmlUom_ton_x005bUS_x005d_x002fd = _fesapi.resqml20__ResqmlUom_ton_x005bUS_x005d_x002fd
resqml20__ResqmlUom_ton_x005bUS_x005d_x002fft2 = _fesapi.resqml20__ResqmlUom_ton_x005bUS_x005d_x002fft2
resqml20__ResqmlUom_ton_x005bUS_x005d_x002fh = _fesapi.resqml20__ResqmlUom_ton_x005bUS_x005d_x002fh
resqml20__ResqmlUom_ton_x005bUS_x005d_x002fmin = _fesapi.resqml20__ResqmlUom_ton_x005bUS_x005d_x002fmin
resqml20__ResqmlUom_tonf_x005bUK_x005d = _fesapi.resqml20__ResqmlUom_tonf_x005bUK_x005d
resqml20__ResqmlUom_tonf_x005bUK_x005d_x002eft2 = _fesapi.resqml20__ResqmlUom_tonf_x005bUK_x005d_x002eft2
resqml20__ResqmlUom_tonf_x005bUK_x005d_x002fft = _fesapi.resqml20__ResqmlUom_tonf_x005bUK_x005d_x002fft
resqml20__ResqmlUom_tonf_x005bUK_x005d_x002fft2 = _fesapi.resqml20__ResqmlUom_tonf_x005bUK_x005d_x002fft2
resqml20__ResqmlUom_tonf_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_tonf_x005bUS_x005d
resqml20__ResqmlUom_tonf_x005bUS_x005d_x002eft = _fesapi.resqml20__ResqmlUom_tonf_x005bUS_x005d_x002eft
resqml20__ResqmlUom_tonf_x005bUS_x005d_x002eft2 = _fesapi.resqml20__ResqmlUom_tonf_x005bUS_x005d_x002eft2
resqml20__ResqmlUom_tonf_x005bUS_x005d_x002emi = _fesapi.resqml20__ResqmlUom_tonf_x005bUS_x005d_x002emi
resqml20__ResqmlUom_tonf_x005bUS_x005d_x002emi_x002fbbl = _fesapi.resqml20__ResqmlUom_tonf_x005bUS_x005d_x002emi_x002fbbl
resqml20__ResqmlUom_tonf_x005bUS_x005d_x002emi_x002fft = _fesapi.resqml20__ResqmlUom_tonf_x005bUS_x005d_x002emi_x002fft
resqml20__ResqmlUom_tonf_x005bUS_x005d_x002fft = _fesapi.resqml20__ResqmlUom_tonf_x005bUS_x005d_x002fft
resqml20__ResqmlUom_tonf_x005bUS_x005d_x002fft2 = _fesapi.resqml20__ResqmlUom_tonf_x005bUS_x005d_x002fft2
resqml20__ResqmlUom_tonf_x005bUS_x005d_x002fin2 = _fesapi.resqml20__ResqmlUom_tonf_x005bUS_x005d_x002fin2
resqml20__ResqmlUom_tonRefrig = _fesapi.resqml20__ResqmlUom_tonRefrig
resqml20__ResqmlUom_torr = _fesapi.resqml20__ResqmlUom_torr
resqml20__ResqmlUom_TP = _fesapi.resqml20__ResqmlUom_TP
resqml20__ResqmlUom_TPa = _fesapi.resqml20__ResqmlUom_TPa
resqml20__ResqmlUom_Trd = _fesapi.resqml20__ResqmlUom_Trd
resqml20__ResqmlUom_TS = _fesapi.resqml20__ResqmlUom_TS
resqml20__ResqmlUom_TT = _fesapi.resqml20__ResqmlUom_TT
resqml20__ResqmlUom_TV = _fesapi.resqml20__ResqmlUom_TV
resqml20__ResqmlUom_TW = _fesapi.resqml20__ResqmlUom_TW
resqml20__ResqmlUom_TW_x002eh = _fesapi.resqml20__ResqmlUom_TW_x002eh
resqml20__ResqmlUom_TWb = _fesapi.resqml20__ResqmlUom_TWb
resqml20__ResqmlUom_uA = _fesapi.resqml20__ResqmlUom_uA
resqml20__ResqmlUom_uA_x002fcm2 = _fesapi.resqml20__ResqmlUom_uA_x002fcm2
resqml20__ResqmlUom_uA_x002fin2 = _fesapi.resqml20__ResqmlUom_uA_x002fin2
resqml20__ResqmlUom_ubar = _fesapi.resqml20__ResqmlUom_ubar
resqml20__ResqmlUom_uC = _fesapi.resqml20__ResqmlUom_uC
resqml20__ResqmlUom_ucal_x005bth_x005d = _fesapi.resqml20__ResqmlUom_ucal_x005bth_x005d
resqml20__ResqmlUom_ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029 = _fesapi.resqml20__ResqmlUom_ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029
resqml20__ResqmlUom_ucal_x005bth_x005d_x002fs = _fesapi.resqml20__ResqmlUom_ucal_x005bth_x005d_x002fs
resqml20__ResqmlUom_uCi = _fesapi.resqml20__ResqmlUom_uCi
resqml20__ResqmlUom_uEuc = _fesapi.resqml20__ResqmlUom_uEuc
resqml20__ResqmlUom_ueV = _fesapi.resqml20__ResqmlUom_ueV
resqml20__ResqmlUom_uF = _fesapi.resqml20__ResqmlUom_uF
resqml20__ResqmlUom_uF_x002fm = _fesapi.resqml20__ResqmlUom_uF_x002fm
resqml20__ResqmlUom_ug = _fesapi.resqml20__ResqmlUom_ug
resqml20__ResqmlUom_ug_x002fcm3 = _fesapi.resqml20__ResqmlUom_ug_x002fcm3
resqml20__ResqmlUom_ug_x002fg = _fesapi.resqml20__ResqmlUom_ug_x002fg
resqml20__ResqmlUom_ug_x002fmg = _fesapi.resqml20__ResqmlUom_ug_x002fmg
resqml20__ResqmlUom_ugauss = _fesapi.resqml20__ResqmlUom_ugauss
resqml20__ResqmlUom_uGy = _fesapi.resqml20__ResqmlUom_uGy
resqml20__ResqmlUom_uH = _fesapi.resqml20__ResqmlUom_uH
resqml20__ResqmlUom_uH_x002fm = _fesapi.resqml20__ResqmlUom_uH_x002fm
resqml20__ResqmlUom_uHz = _fesapi.resqml20__ResqmlUom_uHz
resqml20__ResqmlUom_uJ = _fesapi.resqml20__ResqmlUom_uJ
resqml20__ResqmlUom_um = _fesapi.resqml20__ResqmlUom_um
resqml20__ResqmlUom_um_x002fs = _fesapi.resqml20__ResqmlUom_um_x002fs
resqml20__ResqmlUom_um2 = _fesapi.resqml20__ResqmlUom_um2
resqml20__ResqmlUom_um2_x002em = _fesapi.resqml20__ResqmlUom_um2_x002em
resqml20__ResqmlUom_umHg_x005b0degC_x005d = _fesapi.resqml20__ResqmlUom_umHg_x005b0degC_x005d
resqml20__ResqmlUom_umol = _fesapi.resqml20__ResqmlUom_umol
resqml20__ResqmlUom_uN = _fesapi.resqml20__ResqmlUom_uN
resqml20__ResqmlUom_uohm = _fesapi.resqml20__ResqmlUom_uohm
resqml20__ResqmlUom_uohm_x002fft = _fesapi.resqml20__ResqmlUom_uohm_x002fft
resqml20__ResqmlUom_uohm_x002fm = _fesapi.resqml20__ResqmlUom_uohm_x002fm
resqml20__ResqmlUom_uP = _fesapi.resqml20__ResqmlUom_uP
resqml20__ResqmlUom_uPa = _fesapi.resqml20__ResqmlUom_uPa
resqml20__ResqmlUom_upsi = _fesapi.resqml20__ResqmlUom_upsi
resqml20__ResqmlUom_urad = _fesapi.resqml20__ResqmlUom_urad
resqml20__ResqmlUom_urd = _fesapi.resqml20__ResqmlUom_urd
resqml20__ResqmlUom_us = _fesapi.resqml20__ResqmlUom_us
resqml20__ResqmlUom_uS = _fesapi.resqml20__ResqmlUom_uS
resqml20__ResqmlUom_us_x002fft = _fesapi.resqml20__ResqmlUom_us_x002fft
resqml20__ResqmlUom_us_x002fin = _fesapi.resqml20__ResqmlUom_us_x002fin
resqml20__ResqmlUom_us_x002fm = _fesapi.resqml20__ResqmlUom_us_x002fm
resqml20__ResqmlUom_uT = _fesapi.resqml20__ResqmlUom_uT
resqml20__ResqmlUom_uV = _fesapi.resqml20__ResqmlUom_uV
resqml20__ResqmlUom_uV_x002fft = _fesapi.resqml20__ResqmlUom_uV_x002fft
resqml20__ResqmlUom_uV_x002fm = _fesapi.resqml20__ResqmlUom_uV_x002fm
resqml20__ResqmlUom_uW = _fesapi.resqml20__ResqmlUom_uW
resqml20__ResqmlUom_uW_x002fm3 = _fesapi.resqml20__ResqmlUom_uW_x002fm3
resqml20__ResqmlUom_uWb = _fesapi.resqml20__ResqmlUom_uWb
resqml20__ResqmlUom_V_x002fB = _fesapi.resqml20__ResqmlUom_V_x002fB
resqml20__ResqmlUom_V_x002fdB = _fesapi.resqml20__ResqmlUom_V_x002fdB
resqml20__ResqmlUom_V_x002fm = _fesapi.resqml20__ResqmlUom_V_x002fm
resqml20__ResqmlUom_W_x002em2_x002eK_x002f_x0028J_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_W_x002em2_x002eK_x002f_x0028J_x002eK_x0029
resqml20__ResqmlUom_W_x002f_x0028m_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_W_x002f_x0028m_x002eK_x0029
resqml20__ResqmlUom_W_x002f_x0028m2_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_W_x002f_x0028m2_x002eK_x0029
resqml20__ResqmlUom_W_x002f_x0028m2_x002esr_x0029 = _fesapi.resqml20__ResqmlUom_W_x002f_x0028m2_x002esr_x0029
resqml20__ResqmlUom_W_x002f_x0028m3_x002eK_x0029 = _fesapi.resqml20__ResqmlUom_W_x002f_x0028m3_x002eK_x0029
resqml20__ResqmlUom_W_x002fcm2 = _fesapi.resqml20__ResqmlUom_W_x002fcm2
resqml20__ResqmlUom_W_x002fK = _fesapi.resqml20__ResqmlUom_W_x002fK
resqml20__ResqmlUom_W_x002fkW = _fesapi.resqml20__ResqmlUom_W_x002fkW
resqml20__ResqmlUom_W_x002fm2 = _fesapi.resqml20__ResqmlUom_W_x002fm2
resqml20__ResqmlUom_W_x002fm3 = _fesapi.resqml20__ResqmlUom_W_x002fm3
resqml20__ResqmlUom_W_x002fmm2 = _fesapi.resqml20__ResqmlUom_W_x002fmm2
resqml20__ResqmlUom_W_x002fsr = _fesapi.resqml20__ResqmlUom_W_x002fsr
resqml20__ResqmlUom_W_x002fW = _fesapi.resqml20__ResqmlUom_W_x002fW
resqml20__ResqmlUom_Wb = _fesapi.resqml20__ResqmlUom_Wb
resqml20__ResqmlUom_Wb_x002em = _fesapi.resqml20__ResqmlUom_Wb_x002em
resqml20__ResqmlUom_Wb_x002fm = _fesapi.resqml20__ResqmlUom_Wb_x002fm
resqml20__ResqmlUom_Wb_x002fmm = _fesapi.resqml20__ResqmlUom_Wb_x002fmm
resqml20__ResqmlUom_wk = _fesapi.resqml20__ResqmlUom_wk
resqml20__ResqmlUom_yd = _fesapi.resqml20__ResqmlUom_yd
resqml20__ResqmlUom_yd_x005bBnA_x005d = _fesapi.resqml20__ResqmlUom_yd_x005bBnA_x005d
resqml20__ResqmlUom_yd_x005bBnB_x005d = _fesapi.resqml20__ResqmlUom_yd_x005bBnB_x005d
resqml20__ResqmlUom_yd_x005bCla_x005d = _fesapi.resqml20__ResqmlUom_yd_x005bCla_x005d
resqml20__ResqmlUom_yd_x005bInd_x005d = _fesapi.resqml20__ResqmlUom_yd_x005bInd_x005d
resqml20__ResqmlUom_yd_x005bInd37_x005d = _fesapi.resqml20__ResqmlUom_yd_x005bInd37_x005d
resqml20__ResqmlUom_yd_x005bInd62_x005d = _fesapi.resqml20__ResqmlUom_yd_x005bInd62_x005d
resqml20__ResqmlUom_yd_x005bInd75_x005d = _fesapi.resqml20__ResqmlUom_yd_x005bInd75_x005d
resqml20__ResqmlUom_yd_x005bSe_x005d = _fesapi.resqml20__ResqmlUom_yd_x005bSe_x005d
resqml20__ResqmlUom_yd_x005bSeT_x005d = _fesapi.resqml20__ResqmlUom_yd_x005bSeT_x005d
resqml20__ResqmlUom_yd_x005bUS_x005d = _fesapi.resqml20__ResqmlUom_yd_x005bUS_x005d
resqml20__ResqmlUom_yd2 = _fesapi.resqml20__ResqmlUom_yd2
resqml20__ResqmlUom_yd3 = _fesapi.resqml20__ResqmlUom_yd3
eml20__PlaneAngleUom__0_x002e001_x0020seca = _fesapi.eml20__PlaneAngleUom__0_x002e001_x0020seca
eml20__PlaneAngleUom_ccgr = _fesapi.eml20__PlaneAngleUom_ccgr
eml20__PlaneAngleUom_cgr = _fesapi.eml20__PlaneAngleUom_cgr
eml20__PlaneAngleUom_dega = _fesapi.eml20__PlaneAngleUom_dega
eml20__PlaneAngleUom_gon = _fesapi.eml20__PlaneAngleUom_gon
eml20__PlaneAngleUom_krad = _fesapi.eml20__PlaneAngleUom_krad
eml20__PlaneAngleUom_mila = _fesapi.eml20__PlaneAngleUom_mila
eml20__PlaneAngleUom_mina = _fesapi.eml20__PlaneAngleUom_mina
eml20__PlaneAngleUom_Mrad = _fesapi.eml20__PlaneAngleUom_Mrad
eml20__PlaneAngleUom_mrad = _fesapi.eml20__PlaneAngleUom_mrad
eml20__PlaneAngleUom_rad = _fesapi.eml20__PlaneAngleUom_rad
eml20__PlaneAngleUom_rev = _fesapi.eml20__PlaneAngleUom_rev
eml20__PlaneAngleUom_seca = _fesapi.eml20__PlaneAngleUom_seca
eml20__PlaneAngleUom_urad = _fesapi.eml20__PlaneAngleUom_urad
eml20__LengthUom_m = _fesapi.eml20__LengthUom_m
eml20__LengthUom__0_x002e1_x0020ft = _fesapi.eml20__LengthUom__0_x002e1_x0020ft
eml20__LengthUom__0_x002e1_x0020ft_x005bUS_x005d = _fesapi.eml20__LengthUom__0_x002e1_x0020ft_x005bUS_x005d
eml20__LengthUom__0_x002e1_x0020in = _fesapi.eml20__LengthUom__0_x002e1_x0020in
eml20__LengthUom__0_x002e1_x0020yd = _fesapi.eml20__LengthUom__0_x002e1_x0020yd
eml20__LengthUom__1_x002f16_x0020in = _fesapi.eml20__LengthUom__1_x002f16_x0020in
eml20__LengthUom__1_x002f2_x0020ft = _fesapi.eml20__LengthUom__1_x002f2_x0020ft
eml20__LengthUom__1_x002f32_x0020in = _fesapi.eml20__LengthUom__1_x002f32_x0020in
eml20__LengthUom__1_x002f64_x0020in = _fesapi.eml20__LengthUom__1_x002f64_x0020in
eml20__LengthUom__10_x0020ft = _fesapi.eml20__LengthUom__10_x0020ft
eml20__LengthUom__10_x0020in = _fesapi.eml20__LengthUom__10_x0020in
eml20__LengthUom__10_x0020km = _fesapi.eml20__LengthUom__10_x0020km
eml20__LengthUom__100_x0020ft = _fesapi.eml20__LengthUom__100_x0020ft
eml20__LengthUom__100_x0020km = _fesapi.eml20__LengthUom__100_x0020km
eml20__LengthUom__1000_x0020ft = _fesapi.eml20__LengthUom__1000_x0020ft
eml20__LengthUom__30_x0020ft = _fesapi.eml20__LengthUom__30_x0020ft
eml20__LengthUom__30_x0020m = _fesapi.eml20__LengthUom__30_x0020m
eml20__LengthUom_angstrom = _fesapi.eml20__LengthUom_angstrom
eml20__LengthUom_chain = _fesapi.eml20__LengthUom_chain
eml20__LengthUom_chain_x005bBnA_x005d = _fesapi.eml20__LengthUom_chain_x005bBnA_x005d
eml20__LengthUom_chain_x005bBnB_x005d = _fesapi.eml20__LengthUom_chain_x005bBnB_x005d
eml20__LengthUom_chain_x005bCla_x005d = _fesapi.eml20__LengthUom_chain_x005bCla_x005d
eml20__LengthUom_chain_x005bInd37_x005d = _fesapi.eml20__LengthUom_chain_x005bInd37_x005d
eml20__LengthUom_chain_x005bSe_x005d = _fesapi.eml20__LengthUom_chain_x005bSe_x005d
eml20__LengthUom_chain_x005bSeT_x005d = _fesapi.eml20__LengthUom_chain_x005bSeT_x005d
eml20__LengthUom_chain_x005bUS_x005d = _fesapi.eml20__LengthUom_chain_x005bUS_x005d
eml20__LengthUom_cm = _fesapi.eml20__LengthUom_cm
eml20__LengthUom_dam = _fesapi.eml20__LengthUom_dam
eml20__LengthUom_dm = _fesapi.eml20__LengthUom_dm
eml20__LengthUom_Em = _fesapi.eml20__LengthUom_Em
eml20__LengthUom_fathom = _fesapi.eml20__LengthUom_fathom
eml20__LengthUom_fm = _fesapi.eml20__LengthUom_fm
eml20__LengthUom_ft = _fesapi.eml20__LengthUom_ft
eml20__LengthUom_ft_x005bBnA_x005d = _fesapi.eml20__LengthUom_ft_x005bBnA_x005d
eml20__LengthUom_ft_x005bBnB_x005d = _fesapi.eml20__LengthUom_ft_x005bBnB_x005d
eml20__LengthUom_ft_x005bBr36_x005d = _fesapi.eml20__LengthUom_ft_x005bBr36_x005d
eml20__LengthUom_ft_x005bBr65_x005d = _fesapi.eml20__LengthUom_ft_x005bBr65_x005d
eml20__LengthUom_ft_x005bCla_x005d = _fesapi.eml20__LengthUom_ft_x005bCla_x005d
eml20__LengthUom_ft_x005bGC_x005d = _fesapi.eml20__LengthUom_ft_x005bGC_x005d
eml20__LengthUom_ft_x005bInd_x005d = _fesapi.eml20__LengthUom_ft_x005bInd_x005d
eml20__LengthUom_ft_x005bInd37_x005d = _fesapi.eml20__LengthUom_ft_x005bInd37_x005d
eml20__LengthUom_ft_x005bInd62_x005d = _fesapi.eml20__LengthUom_ft_x005bInd62_x005d
eml20__LengthUom_ft_x005bInd75_x005d = _fesapi.eml20__LengthUom_ft_x005bInd75_x005d
eml20__LengthUom_ft_x005bSe_x005d = _fesapi.eml20__LengthUom_ft_x005bSe_x005d
eml20__LengthUom_ft_x005bSeT_x005d = _fesapi.eml20__LengthUom_ft_x005bSeT_x005d
eml20__LengthUom_ft_x005bUS_x005d = _fesapi.eml20__LengthUom_ft_x005bUS_x005d
eml20__LengthUom_fur_x005bUS_x005d = _fesapi.eml20__LengthUom_fur_x005bUS_x005d
eml20__LengthUom_Gm = _fesapi.eml20__LengthUom_Gm
eml20__LengthUom_hm = _fesapi.eml20__LengthUom_hm
eml20__LengthUom__in = _fesapi.eml20__LengthUom__in
eml20__LengthUom_in_x005bUS_x005d = _fesapi.eml20__LengthUom_in_x005bUS_x005d
eml20__LengthUom_km = _fesapi.eml20__LengthUom_km
eml20__LengthUom_link = _fesapi.eml20__LengthUom_link
eml20__LengthUom_link_x005bBnA_x005d = _fesapi.eml20__LengthUom_link_x005bBnA_x005d
eml20__LengthUom_link_x005bBnB_x005d = _fesapi.eml20__LengthUom_link_x005bBnB_x005d
eml20__LengthUom_link_x005bCla_x005d = _fesapi.eml20__LengthUom_link_x005bCla_x005d
eml20__LengthUom_link_x005bSe_x005d = _fesapi.eml20__LengthUom_link_x005bSe_x005d
eml20__LengthUom_link_x005bSeT_x005d = _fesapi.eml20__LengthUom_link_x005bSeT_x005d
eml20__LengthUom_link_x005bUS_x005d = _fesapi.eml20__LengthUom_link_x005bUS_x005d
eml20__LengthUom_m_x005bGer_x005d = _fesapi.eml20__LengthUom_m_x005bGer_x005d
eml20__LengthUom_mi = _fesapi.eml20__LengthUom_mi
eml20__LengthUom_mi_x005bnaut_x005d = _fesapi.eml20__LengthUom_mi_x005bnaut_x005d
eml20__LengthUom_mi_x005bnautUK_x005d = _fesapi.eml20__LengthUom_mi_x005bnautUK_x005d
eml20__LengthUom_mi_x005bUS_x005d = _fesapi.eml20__LengthUom_mi_x005bUS_x005d
eml20__LengthUom_mil = _fesapi.eml20__LengthUom_mil
eml20__LengthUom_Mm = _fesapi.eml20__LengthUom_Mm
eml20__LengthUom_mm = _fesapi.eml20__LengthUom_mm
eml20__LengthUom_nm = _fesapi.eml20__LengthUom_nm
eml20__LengthUom_pm = _fesapi.eml20__LengthUom_pm
eml20__LengthUom_rod_x005bUS_x005d = _fesapi.eml20__LengthUom_rod_x005bUS_x005d
eml20__LengthUom_Tm = _fesapi.eml20__LengthUom_Tm
eml20__LengthUom_um = _fesapi.eml20__LengthUom_um
eml20__LengthUom_yd = _fesapi.eml20__LengthUom_yd
eml20__LengthUom_yd_x005bBnA_x005d = _fesapi.eml20__LengthUom_yd_x005bBnA_x005d
eml20__LengthUom_yd_x005bBnB_x005d = _fesapi.eml20__LengthUom_yd_x005bBnB_x005d
eml20__LengthUom_yd_x005bCla_x005d = _fesapi.eml20__LengthUom_yd_x005bCla_x005d
eml20__LengthUom_yd_x005bInd_x005d = _fesapi.eml20__LengthUom_yd_x005bInd_x005d
eml20__LengthUom_yd_x005bInd37_x005d = _fesapi.eml20__LengthUom_yd_x005bInd37_x005d
eml20__LengthUom_yd_x005bInd62_x005d = _fesapi.eml20__LengthUom_yd_x005bInd62_x005d
eml20__LengthUom_yd_x005bInd75_x005d = _fesapi.eml20__LengthUom_yd_x005bInd75_x005d
eml20__LengthUom_yd_x005bSe_x005d = _fesapi.eml20__LengthUom_yd_x005bSe_x005d
eml20__LengthUom_yd_x005bSeT_x005d = _fesapi.eml20__LengthUom_yd_x005bSeT_x005d
eml20__LengthUom_yd_x005bUS_x005d = _fesapi.eml20__LengthUom_yd_x005bUS_x005d
eml20__TimeUom_a = _fesapi.eml20__TimeUom_a
eml20__TimeUom_d = _fesapi.eml20__TimeUom_d
eml20__TimeUom_h = _fesapi.eml20__TimeUom_h
eml20__TimeUom_s = _fesapi.eml20__TimeUom_s
eml20__TimeUom__1_x002f2_x0020ms = _fesapi.eml20__TimeUom__1_x002f2_x0020ms
eml20__TimeUom__100_x0020ka_x005bt_x005d = _fesapi.eml20__TimeUom__100_x0020ka_x005bt_x005d
eml20__TimeUom_a_x005bt_x005d = _fesapi.eml20__TimeUom_a_x005bt_x005d
eml20__TimeUom_ca = _fesapi.eml20__TimeUom_ca
eml20__TimeUom_cs = _fesapi.eml20__TimeUom_cs
eml20__TimeUom_ds = _fesapi.eml20__TimeUom_ds
eml20__TimeUom_Ea_x005bt_x005d = _fesapi.eml20__TimeUom_Ea_x005bt_x005d
eml20__TimeUom_fa = _fesapi.eml20__TimeUom_fa
eml20__TimeUom_Ga_x005bt_x005d = _fesapi.eml20__TimeUom_Ga_x005bt_x005d
eml20__TimeUom_hs = _fesapi.eml20__TimeUom_hs
eml20__TimeUom_ka_x005bt_x005d = _fesapi.eml20__TimeUom_ka_x005bt_x005d
eml20__TimeUom_Ma_x005bt_x005d = _fesapi.eml20__TimeUom_Ma_x005bt_x005d
eml20__TimeUom_min_ = _fesapi.eml20__TimeUom_min_
eml20__TimeUom_ms = _fesapi.eml20__TimeUom_ms
eml20__TimeUom_na = _fesapi.eml20__TimeUom_na
eml20__TimeUom_ns = _fesapi.eml20__TimeUom_ns
eml20__TimeUom_ps = _fesapi.eml20__TimeUom_ps
eml20__TimeUom_Ta_x005bt_x005d = _fesapi.eml20__TimeUom_Ta_x005bt_x005d
eml20__TimeUom_us = _fesapi.eml20__TimeUom_us
eml20__TimeUom_wk = _fesapi.eml20__TimeUom_wk
eml20__AxisOrder2d_easting_x0020northing = _fesapi.eml20__AxisOrder2d_easting_x0020northing
eml20__AxisOrder2d_northing_x0020easting = _fesapi.eml20__AxisOrder2d_northing_x0020easting
eml20__AxisOrder2d_westing_x0020southing = _fesapi.eml20__AxisOrder2d_westing_x0020southing
eml20__AxisOrder2d_southing_x0020westing = _fesapi.eml20__AxisOrder2d_southing_x0020westing
eml20__AxisOrder2d_northing_x0020westing = _fesapi.eml20__AxisOrder2d_northing_x0020westing
eml20__AxisOrder2d_westing_x0020northing = _fesapi.eml20__AxisOrder2d_westing_x0020northing
resqml20__GeologicBoundaryKind_fault = _fesapi.resqml20__GeologicBoundaryKind_fault
resqml20__GeologicBoundaryKind_geobody = _fesapi.resqml20__GeologicBoundaryKind_geobody
resqml20__GeologicBoundaryKind_horizon = _fesapi.resqml20__GeologicBoundaryKind_horizon
resqml20__KDirection_down = _fesapi.resqml20__KDirection_down
resqml20__KDirection_up = _fesapi.resqml20__KDirection_up
resqml20__KDirection_not_x0020monotonic = _fesapi.resqml20__KDirection_not_x0020monotonic
resqml20__CellShape_tetrahedral = _fesapi.resqml20__CellShape_tetrahedral
resqml20__CellShape_pyramidal = _fesapi.resqml20__CellShape_pyramidal
resqml20__CellShape_prism = _fesapi.resqml20__CellShape_prism
resqml20__CellShape_hexahedral = _fesapi.resqml20__CellShape_hexahedral
resqml20__CellShape_polyhedral = _fesapi.resqml20__CellShape_polyhedral
resqml20__SurfaceRole_map = _fesapi.resqml20__SurfaceRole_map
resqml20__SurfaceRole_pick = _fesapi.resqml20__SurfaceRole_pick
resqml20__ContactSide_footwall = _fesapi.resqml20__ContactSide_footwall
resqml20__ContactSide_hanging_x0020wall = _fesapi.resqml20__ContactSide_hanging_x0020wall
resqml20__ContactSide_north = _fesapi.resqml20__ContactSide_north
resqml20__ContactSide_south = _fesapi.resqml20__ContactSide_south
resqml20__ContactSide_east = _fesapi.resqml20__ContactSide_east
resqml20__ContactSide_west = _fesapi.resqml20__ContactSide_west
resqml20__ContactSide_younger = _fesapi.resqml20__ContactSide_younger
resqml20__ContactSide_older = _fesapi.resqml20__ContactSide_older
resqml20__ContactSide_both = _fesapi.resqml20__ContactSide_both
resqml20__DepositionMode_proportional_x0020between_x0020top_x0020and_x0020bottom = _fesapi.resqml20__DepositionMode_proportional_x0020between_x0020top_x0020and_x0020bottom
resqml20__DepositionMode_parallel_x0020to_x0020bottom = _fesapi.resqml20__DepositionMode_parallel_x0020to_x0020bottom
resqml20__DepositionMode_parallel_x0020to_x0020top = _fesapi.resqml20__DepositionMode_parallel_x0020to_x0020top
resqml20__DepositionMode_parallel_x0020to_x0020another_x0020boundary = _fesapi.resqml20__DepositionMode_parallel_x0020to_x0020another_x0020boundary
resqml20__Domain_depth = _fesapi.resqml20__Domain_depth
resqml20__Domain_time = _fesapi.resqml20__Domain_time
resqml20__Domain_mixed = _fesapi.resqml20__Domain_mixed
resqml20__PillarShape_vertical = _fesapi.resqml20__PillarShape_vertical
resqml20__PillarShape_straight = _fesapi.resqml20__PillarShape_straight
resqml20__PillarShape_curved = _fesapi.resqml20__PillarShape_curved
resqml20__FluidContact_free_x0020water_x0020contact = _fesapi.resqml20__FluidContact_free_x0020water_x0020contact
resqml20__FluidContact_gas_x0020oil_x0020contact = _fesapi.resqml20__FluidContact_gas_x0020oil_x0020contact
resqml20__FluidContact_gas_x0020water_x0020contact = _fesapi.resqml20__FluidContact_gas_x0020water_x0020contact
resqml20__FluidContact_seal = _fesapi.resqml20__FluidContact_seal
resqml20__FluidContact_water_x0020oil_x0020contact = _fesapi.resqml20__FluidContact_water_x0020oil_x0020contact
resqml22__Shape3d_sheet = _fesapi.resqml22__Shape3d_sheet
resqml22__Shape3d_dyke = _fesapi.resqml22__Shape3d_dyke
resqml22__Shape3d_dome = _fesapi.resqml22__Shape3d_dome
resqml22__Shape3d_mushroom = _fesapi.resqml22__Shape3d_mushroom
resqml22__Shape3d_channel = _fesapi.resqml22__Shape3d_channel
resqml22__Shape3d_delta = _fesapi.resqml22__Shape3d_delta
resqml22__Shape3d_dune = _fesapi.resqml22__Shape3d_dune
resqml22__Shape3d_fan = _fesapi.resqml22__Shape3d_fan
resqml22__Shape3d_reef = _fesapi.resqml22__Shape3d_reef
resqml22__Shape3d_wedge = _fesapi.resqml22__Shape3d_wedge
resqml22__ContactVerb_stops = _fesapi.resqml22__ContactVerb_stops
resqml22__ContactVerb_splits = _fesapi.resqml22__ContactVerb_splits
resqml22__ContactVerb_crosses = _fesapi.resqml22__ContactVerb_crosses
resqml22__ContactMode_conformable = _fesapi.resqml22__ContactMode_conformable
resqml22__ContactMode_extended = _fesapi.resqml22__ContactMode_extended
resqml22__ContactMode_unconformable = _fesapi.resqml22__ContactMode_unconformable
resqml22__Phase_aquifer = _fesapi.resqml22__Phase_aquifer
resqml22__Phase_gas_x0020cap = _fesapi.resqml22__Phase_gas_x0020cap
resqml22__Phase_oil_x0020column = _fesapi.resqml22__Phase_oil_x0020column
resqml22__Phase_seal = _fesapi.resqml22__Phase_seal
resqml22__LineRole_fault_x0020center_x0020line = _fesapi.resqml22__LineRole_fault_x0020center_x0020line
resqml22__LineRole_pick = _fesapi.resqml22__LineRole_pick
resqml22__LineRole_inner_x0020ring = _fesapi.resqml22__LineRole_inner_x0020ring
resqml22__LineRole_outer_x0020ring = _fesapi.resqml22__LineRole_outer_x0020ring
resqml22__LineRole_trajectory = _fesapi.resqml22__LineRole_trajectory
resqml22__LineRole_interpretation_x0020line = _fesapi.resqml22__LineRole_interpretation_x0020line
resqml22__LineRole_contact = _fesapi.resqml22__LineRole_contact
resqml22__LineRole_depositional_x0020line = _fesapi.resqml22__LineRole_depositional_x0020line
resqml22__LineRole_erosion_x0020line = _fesapi.resqml22__LineRole_erosion_x0020line
resqml22__LineRole_contour = _fesapi.resqml22__LineRole_contour
resqml22__LineRole_pillar = _fesapi.resqml22__LineRole_pillar
resqml22__LineRole_break_x0020line = _fesapi.resqml22__LineRole_break_x0020line
resqml22__LineRole_structural_x0020closure = _fesapi.resqml22__LineRole_structural_x0020closure
resqml22__LineRole_culture = _fesapi.resqml22__LineRole_culture
eml23__FacetKind_conditions = _fesapi.eml23__FacetKind_conditions
eml23__FacetKind_side = _fesapi.eml23__FacetKind_side
eml23__FacetKind_direction = _fesapi.eml23__FacetKind_direction
eml23__FacetKind_netgross = _fesapi.eml23__FacetKind_netgross
eml23__FacetKind_qualifier = _fesapi.eml23__FacetKind_qualifier
eml23__FacetKind_statistics = _fesapi.eml23__FacetKind_statistics
eml23__FacetKind_what = _fesapi.eml23__FacetKind_what
class Resqml2_AbstractColorMap(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setHsvColors(self, *args) -> "void":
        r"""
        https://en.wikipedia.org/wiki/HSV_color_space
        :type colorCount: int
        :param colorCount:		the size (number of colors) of the color map
        :type hsvColors: float
        :param hsvColors:		array (of size colorCount * 3) of HSV colors with hsvColors[3*i] is the hue, hsvColors[3*i + 1] is the saturation and hsvColors[3*i + 2] is the value of the ith color (hue is in range [0, 360] while saturation and value are in range [0, 1])
        :type alphas: float, optional
        :param alphas:			array (of size colorCount) of numeric values in the range [0, 1] for alpha transparency channel (0 means transparent and 1 means opaque). If alphas == nullptr (default value), default alpha value is 1.
        :type indices: float, optional
        :param indices:		array (of size colorCount) of color indices. These indices are cast to unsigned int in the case of a discrete color map. If indices
        :type colorTitles: std::vector< std::string,std::allocator< std::string > >, optional
        :param colorTitles:	vector (of size colorCount) of color titles. Titles are not set if colorTitles is empty (default value)= nullptr (default value), indices are set from 0 to colorCount - 1
        """
        return _fesapi.Resqml2_AbstractColorMap_setHsvColors(self, *args)

    def setRgbColors(self, *args) -> "void":
        r"""
        *Overload 1:*

        https://en.wikipedia.org/wiki/HSV_color_space
        :type colorCount: int
        :param colorCount:		the size (number of colors) of the color map
        :type rgbColors: float
        :param rgbColors:		array (of size colorCount * 3) of RGB colors with rgbColors[3*i] is red component, rgbColors[3*i + 1] is green component and rgbColors[3*i + 2] is blue component of the ith color (red, green and blue are in range [0, 1])
        :type alphas: float, optional
        :param alphas:			array (of size colorCount) of numeric values in the range [0, 1] for alpha transparency channel (0 means transparent and 1 means opaque). If alphas == nullptr (default value), default alpha value is 1.
        :type indices: float, optional
        :param indices:		array (of size colorCount) of color indices. These indices are cast to unsigned int in the case of a discrete color map. If indices == nullptr (default value), indices are set from 0 to colorCount - 1
        :type colorTitles: std::vector< std::string,std::allocator< std::string > >, optional
        :param colorTitles:	vector (of size colorCount) of color titles. Titles are not set if colorTitles is empty (default value)


        |

        *Overload 2:*

        https://en.wikipedia.org/wiki/HSV_color_space
        :type colorCount: int
        :param colorCount:		the size (number of colors) of the color map
        :type rgbColors: uint8_t
        :param rgbColors:		array (of size colorCount * 3) of RGB colors with hsvColors[3*i] is red componant, hsvColors[3*i + 1] is green component and hsvColors[3*i + 2] is blue component of the ith color (red, green and blue are in range [0, 255])
        :type alphas: float, optional
        :param alphas:			array (of size colorCount) of numeric values in the range [0, 1] for alpha transparency channel (0 means transparent and 1 means opaque). If alphas == nullptr (default value), default alpha value is 1.
        :type indices: float, optional
        :param indices:		array (of size colorCount) of color indices. These indices are cast to unsigned int in the case of a discrete color map. If indices == nullptr (default value), indices are set from 0 to colorCount - 1
        :type colorTitles: std::vector< std::string,std::allocator< std::string > >, optional
        :param colorTitles:	vector (of size colorCount) of color titles. Titles are not set if colorTitles is empty (default value)


        |

        *Overload 3:*

        https://en.wikipedia.org/wiki/HSV_color_space
        :type colorCount: int
        :param colorCount:		the size (number of colors) of the color map
        :type rgbColors: uint8_t
        :param rgbColors:		array (of size colorCount * 3) of RGB colors with hsvColors[3*i] is red componant, hsvColors[3*i + 1] is green component and hsvColors[3*i + 2] is blue component of the ith color (red, green and blue are in range [0, 255])
        :type alphas: float, optional
        :param alphas:			array (of size colorCount) of numeric values in the range [0, 1] for alpha transparency channel (0 means transparent and 1 means opaque). If alphas == nullptr (default value), default alpha value is 1.
        :type indices: float, optional
        :param indices:		array (of size colorCount) of color indices. These indices are cast to unsigned int in the case of a discrete color map. If indices == nullptr (default value), indices are set from 0 to colorCount - 1
        :param colorTitles:	vector (of size colorCount) of color titles. Titles are not set if colorTitles is empty (default value)


        |

        *Overload 4:*

        https://en.wikipedia.org/wiki/HSV_color_space
        :type colorCount: int
        :param colorCount:		the size (number of colors) of the color map
        :type rgbColors: uint8_t
        :param rgbColors:		array (of size colorCount * 3) of RGB colors with hsvColors[3*i] is red componant, hsvColors[3*i + 1] is green component and hsvColors[3*i + 2] is blue component of the ith color (red, green and blue are in range [0, 255])
        :type alphas: float, optional
        :param alphas:			array (of size colorCount) of numeric values in the range [0, 1] for alpha transparency channel (0 means transparent and 1 means opaque). If alphas == nullptr (default value), default alpha value is 1.
        :param indices:		array (of size colorCount) of color indices. These indices are cast to unsigned int in the case of a discrete color map. If indices == nullptr (default value), indices are set from 0 to colorCount - 1
        :param colorTitles:	vector (of size colorCount) of color titles. Titles are not set if colorTitles is empty (default value)


        |

        *Overload 5:*

        https://en.wikipedia.org/wiki/HSV_color_space
        :type colorCount: int
        :param colorCount:		the size (number of colors) of the color map
        :type rgbColors: uint8_t
        :param rgbColors:		array (of size colorCount * 3) of RGB colors with hsvColors[3*i] is red componant, hsvColors[3*i + 1] is green component and hsvColors[3*i + 2] is blue component of the ith color (red, green and blue are in range [0, 255])
        :param alphas:			array (of size colorCount) of numeric values in the range [0, 1] for alpha transparency channel (0 means transparent and 1 means opaque). If alphas == nullptr (default value), default alpha value is 1.
        :param indices:		array (of size colorCount) of color indices. These indices are cast to unsigned int in the case of a discrete color map. If indices == nullptr (default value), indices are set from 0 to colorCount - 1
        :param colorTitles:	vector (of size colorCount) of color titles. Titles are not set if colorTitles is empty (default value)
        """
        return _fesapi.Resqml2_AbstractColorMap_setRgbColors(self, *args)

    def getColorCount(self) -> "uint64_t":
        r"""
        Gets color count

        :rtype: int
        :return: The color count.
        """
        return _fesapi.Resqml2_AbstractColorMap_getColorCount(self)

    def getHue(self, colorIndex: "uint64_t") -> "double":
        r"""
        :type colorIndex: int
        :param colorIndex:	index of a color in the color map.
        :rtype: float
        :return: hue in the range [0, 360]
        """
        return _fesapi.Resqml2_AbstractColorMap_getHue(self, colorIndex)

    def getSaturation(self, colorIndex: "uint64_t") -> "double":
        r"""
        :type colorIndex: int
        :param colorIndex:	index of a color in the color map.
        :rtype: float
        :return: saturation in the range [0, 1]
        """
        return _fesapi.Resqml2_AbstractColorMap_getSaturation(self, colorIndex)

    def getValue(self, colorIndex: "uint64_t") -> "double":
        r"""
        :type colorIndex: int
        :param colorIndex:	index of a color in the color map.
        :rtype: float
        :return: value in the range [0, 1]
        """
        return _fesapi.Resqml2_AbstractColorMap_getValue(self, colorIndex)

    def getAlpha(self, colorIndex: "uint64_t") -> "double":
        r"""
        :type colorIndex: int
        :param colorIndex:	index of a color in the color map.
        :rtype: float
        :return: alpha in the range [0, 1] (0 means transparent and 1 means opaque)
        """
        return _fesapi.Resqml2_AbstractColorMap_getAlpha(self, colorIndex)

    def getRgbColor(self, *args) -> "void":
        r"""
        *Overload 1:*

        :type colorIndex: int
        :param colorIndex:	index of a color in the color map.
        :type red: float
        :param red:			(output parameter) red value in the range [0, 1]
        :type green: float
        :param green:			(output parameter) green value in the range [0, 1]
        :type blue: float
        :param blue:			(output parameter) blue value in the range [0, 1]

        |

        *Overload 2:*

        :type colorIndex: int
        :param colorIndex:	index of a color in the color map.
        :type red: uint8_t
        :param red:			(output parameter) red value in the range [0, 255]
        :type green: uint8_t
        :param green:			(output parameter) green value in the range [0, 255]
        :type blue: uint8_t
        :param blue:			(output parameter) blue value in the range [0, 255]
        """
        return _fesapi.Resqml2_AbstractColorMap_getRgbColor(self, *args)

    def hasColorTitle(self, colorIndex: "uint64_t") -> "bool":
        r"""
        Queries if 'colorIndex' has color title

        :type colorIndex: int
        :param colorIndex:	Zero-based index of the color.

        :rtype: boolean
        :return: True if color title, false if not.
        """
        return _fesapi.Resqml2_AbstractColorMap_hasColorTitle(self, colorIndex)

    def getColorTitle(self, colorIndex: "uint64_t") -> "std::string":
        r"""
        Gets color title

        :type colorIndex: int
        :param colorIndex:	Zero-based index of the color.

        :rtype: string
        :return: The color title.
        """
        return _fesapi.Resqml2_AbstractColorMap_getColorTitle(self, colorIndex)

    def setNullHsvColor(self, *args) -> "void":
        r"""
        Sets the NullColor value of a continuous color map

        :type hue: float
        :param hue:		  	hue in the range [0, 360].
        :type saturation: float
        :param saturation:	saturation in the range [0, 1].
        :type value: float
        :param value:	  	value in the range [0, 1].
        :type alpha: float, optional
        :param alpha:	  	(Optional) alpha in the range [0, 1] (0 means transparent and 1 means
            						opaque). Default alpha value is 1.
        :type colorTitle: string, optional
        :param colorTitle:	(Optional) color title. It is not set if empty string (default value)
        """
        return _fesapi.Resqml2_AbstractColorMap_setNullHsvColor(self, *args)

    def setNullRgbColor(self, *args) -> "void":
        r"""
        *Overload 1:*

        Sets the NullColor value of a continuous color map

        :type red: float
        :param red:		  	red value in the range [0, 1].
        :type green: float
        :param green:	  	green value in the range [0, 1].
        :type blue: float
        :param blue:	  	blue value in the range [0, 1].
        :type alpha: float, optional
        :param alpha:	  	(Optional) alpha in the range [0, 1] (0 means transparent and 1 means
            						opaque). Default alpha value is 1.
        :type colorTitle: string, optional
        :param colorTitle:	(Optional) color title. It is not set if empty string (default value)

        |

        *Overload 2:*

        Sets the NullColor value of a continuous color map

        :type red: uint8_t
        :param red:		  	red value in the range [0, 255].
        :type green: uint8_t
        :param green:	  	green value in the range [0, 255].
        :type blue: uint8_t
        :param blue:	  	blue value in the range [0, 255].
        :type alpha: float, optional
        :param alpha:	  	(Optional) alpha in the range [0, 1] (0 means transparent and 1 means
            						opaque). Default alpha value is 1.
        :type colorTitle: string, optional
        :param colorTitle:	(Optional) color title. It is not set if empty string (default value)

        |

        *Overload 3:*

        Sets the NullColor value of a continuous color map

        :type red: uint8_t
        :param red:		  	red value in the range [0, 255].
        :type green: uint8_t
        :param green:	  	green value in the range [0, 255].
        :type blue: uint8_t
        :param blue:	  	blue value in the range [0, 255].
        :type alpha: float, optional
        :param alpha:	  	(Optional) alpha in the range [0, 1] (0 means transparent and 1 means
            						opaque). Default alpha value is 1.
        :param colorTitle:	(Optional) color title. It is not set if empty string (default value)

        |

        *Overload 4:*

        Sets the NullColor value of a continuous color map

        :type red: uint8_t
        :param red:		  	red value in the range [0, 255].
        :type green: uint8_t
        :param green:	  	green value in the range [0, 255].
        :type blue: uint8_t
        :param blue:	  	blue value in the range [0, 255].
        :param alpha:	  	(Optional) alpha in the range [0, 1] (0 means transparent and 1 means
            						opaque). Default alpha value is 1.
        :param colorTitle:	(Optional) color title. It is not set if empty string (default value)
        """
        return _fesapi.Resqml2_AbstractColorMap_setNullRgbColor(self, *args)

    def hasNullColor(self) -> "bool":
        r"""checks if the color map has a definition for the color of Null values."""
        return _fesapi.Resqml2_AbstractColorMap_hasNullColor(self)

    def getNullHue(self) -> "double":
        r"""
        :rtype: float
        :return: hue in the range [0, 360]
        """
        return _fesapi.Resqml2_AbstractColorMap_getNullHue(self)

    def getNullSaturation(self) -> "double":
        r"""
        :rtype: float
        :return: saturation in the range [0, 1]
        """
        return _fesapi.Resqml2_AbstractColorMap_getNullSaturation(self)

    def getNullValue(self) -> "double":
        r"""
        :rtype: float
        :return: value in the range [0, 1]
        """
        return _fesapi.Resqml2_AbstractColorMap_getNullValue(self)

    def getNullAlpha(self) -> "double":
        r"""
        :rtype: float
        :return: alpha in the range [0, 1] (0 means transparent and 1 means opaque)
        """
        return _fesapi.Resqml2_AbstractColorMap_getNullAlpha(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractColorMap

# Register Resqml2_AbstractColorMap in _fesapi:
_fesapi.Resqml2_AbstractColorMap_swigregister(Resqml2_AbstractColorMap)
class Resqml2_DiscreteColorMap(Resqml2_AbstractColorMap):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getColorLocationInColorMap(self, colorIndex: "uint64_t") -> "int64_t":
        r"""
        Gets the location of a color of the color map

        :type colorIndex: int
        :param colorIndex:	Zero-based index of the color.

        :rtype: int
        :return: The color location in the color map.
        """
        return _fesapi.Resqml2_DiscreteColorMap_getColorLocationInColorMap(self, colorIndex)
    __swig_destroy__ = _fesapi.delete_Resqml2_DiscreteColorMap

# Register Resqml2_DiscreteColorMap in _fesapi:
_fesapi.Resqml2_DiscreteColorMap_swigregister(Resqml2_DiscreteColorMap)
class Resqml2_ContinuousColorMap(Resqml2_AbstractColorMap):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getInterpolationDomain(self) -> "gsoap_eml2_3::resqml22__InterpolationDomain":
        return _fesapi.Resqml2_ContinuousColorMap_getInterpolationDomain(self)

    def getInterpolationDomainAsString(self) -> "std::string":
        return _fesapi.Resqml2_ContinuousColorMap_getInterpolationDomainAsString(self)

    def getInterpolationMethod(self) -> "gsoap_eml2_3::resqml22__InterpolationMethod":
        return _fesapi.Resqml2_ContinuousColorMap_getInterpolationMethod(self)

    def getInterpolationMethodAsString(self) -> "std::string":
        return _fesapi.Resqml2_ContinuousColorMap_getInterpolationMethodAsString(self)

    def getColorLocationInColorMap(self, colorIndex: "uint64_t") -> "double":
        r"""
        Gets the location of a color of the color map

        :type colorIndex: int
        :param colorIndex:	Zero-based index of the color.

        :rtype: float
        :return: The color location in the color map.
        """
        return _fesapi.Resqml2_ContinuousColorMap_getColorLocationInColorMap(self, colorIndex)
    __swig_destroy__ = _fesapi.delete_Resqml2_ContinuousColorMap

# Register Resqml2_ContinuousColorMap in _fesapi:
_fesapi.Resqml2_ContinuousColorMap_swigregister(Resqml2_ContinuousColorMap)
class Resqml2_MdDatum(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getLocalCrs(self) -> "eml2::AbstractLocal3dCrs *":
        return _fesapi.Resqml2_MdDatum_getLocalCrs(self)

    def getX(self) -> "double":
        return _fesapi.Resqml2_MdDatum_getX(self)

    def getXInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_MdDatum_getXInGlobalCrs(self)

    def getY(self) -> "double":
        return _fesapi.Resqml2_MdDatum_getY(self)

    def getYInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_MdDatum_getYInGlobalCrs(self)

    def getZ(self) -> "double":
        return _fesapi.Resqml2_MdDatum_getZ(self)

    def getZInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_MdDatum_getZInGlobalCrs(self)

    def getKind(self) -> "gsoap_eml2_3::eml23__ReferencePointKind":
        return _fesapi.Resqml2_MdDatum_getKind(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_MdDatum

# Register Resqml2_MdDatum in _fesapi:
_fesapi.Resqml2_MdDatum_swigregister(Resqml2_MdDatum)
class Resqml2_AbstractFeature(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getInterpretationCount(self) -> "uint64_t":
        return _fesapi.Resqml2_AbstractFeature_getInterpretationCount(self)

    def getInterpretation(self, index: "uint64_t") -> "resqml2::AbstractFeatureInterpretation *":
        return _fesapi.Resqml2_AbstractFeature_getInterpretation(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractFeature

# Register Resqml2_AbstractFeature in _fesapi:
_fesapi.Resqml2_AbstractFeature_swigregister(Resqml2_AbstractFeature)
class Resqml2_AbstractTechnicalFeature(Resqml2_AbstractFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractTechnicalFeature

# Register Resqml2_AbstractTechnicalFeature in _fesapi:
_fesapi.Resqml2_AbstractTechnicalFeature_swigregister(Resqml2_AbstractTechnicalFeature)
class Resqml2_BoundaryFeature(Resqml2_AbstractFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_BoundaryFeature

# Register Resqml2_BoundaryFeature in _fesapi:
_fesapi.Resqml2_BoundaryFeature_swigregister(Resqml2_BoundaryFeature)
class Resqml2_CulturalFeature(Resqml2_AbstractTechnicalFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_CulturalFeature

# Register Resqml2_CulturalFeature in _fesapi:
_fesapi.Resqml2_CulturalFeature_swigregister(Resqml2_CulturalFeature)
class Resqml2_Model(Resqml2_AbstractFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_Model

# Register Resqml2_Model in _fesapi:
_fesapi.Resqml2_Model_swigregister(Resqml2_Model)
class Resqml2_RockVolumeFeature(Resqml2_AbstractFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_RockVolumeFeature

# Register Resqml2_RockVolumeFeature in _fesapi:
_fesapi.Resqml2_RockVolumeFeature_swigregister(Resqml2_RockVolumeFeature)
class Resqml2_SeismicLatticeFeature(Resqml2_AbstractTechnicalFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getCrosslineIncrement(self) -> "int64_t":
        r"""
        Gets the crossline annotated index increment between two consecutive crosslines.

        :rtype: int
        :return: The crossline increment.
        """
        return _fesapi.Resqml2_SeismicLatticeFeature_getCrosslineIncrement(self)

    def getInlineIncrement(self) -> "int64_t":
        r"""
        Gets the inline annotated index increment between two consecutive inlines.

        :rtype: int
        :return: The inline increment.
        """
        return _fesapi.Resqml2_SeismicLatticeFeature_getInlineIncrement(self)

    def getCrosslineOrigin(self) -> "int64_t":
        r"""
        Gets the annotated index of the first crossline.

        :rtype: int
        :return: The origin crossline.
        """
        return _fesapi.Resqml2_SeismicLatticeFeature_getCrosslineOrigin(self)

    def getInlineOrigin(self) -> "int64_t":
        r"""
        Gets the annotated index of the first inline.

        :rtype: int
        :return: The origin inline.
        """
        return _fesapi.Resqml2_SeismicLatticeFeature_getInlineOrigin(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_SeismicLatticeFeature

# Register Resqml2_SeismicLatticeFeature in _fesapi:
_fesapi.Resqml2_SeismicLatticeFeature_swigregister(Resqml2_SeismicLatticeFeature)
class Resqml2_SeismicLineSetFeature(Resqml2_AbstractTechnicalFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_SeismicLineSetFeature

# Register Resqml2_SeismicLineSetFeature in _fesapi:
_fesapi.Resqml2_SeismicLineSetFeature_swigregister(Resqml2_SeismicLineSetFeature)
class Resqml2_AbstractSeismicLineFeature(Resqml2_AbstractTechnicalFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setSeismicLineSet(self, seisLineSet: "Resqml2_SeismicLineSetFeature") -> "void":
        return _fesapi.Resqml2_AbstractSeismicLineFeature_setSeismicLineSet(self, seisLineSet)

    def getSeismicLineSet(self) -> "resqml2::SeismicLineSetFeature *":
        return _fesapi.Resqml2_AbstractSeismicLineFeature_getSeismicLineSet(self)

    def getTraceCount(self) -> "uint64_t":
        return _fesapi.Resqml2_AbstractSeismicLineFeature_getTraceCount(self)

    def setTraceLabels(self, values: "StringVector", proxy: "Eml2_AbstractHdfProxy") -> "void":
        return _fesapi.Resqml2_AbstractSeismicLineFeature_setTraceLabels(self, values, proxy)

    def getTraceLabels(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _fesapi.Resqml2_AbstractSeismicLineFeature_getTraceLabels(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractSeismicLineFeature

# Register Resqml2_AbstractSeismicLineFeature in _fesapi:
_fesapi.Resqml2_AbstractSeismicLineFeature_swigregister(Resqml2_AbstractSeismicLineFeature)
class ShotPointLineFeature_resqml2(Resqml2_AbstractSeismicLineFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_ShotPointLineFeature_resqml2

# Register ShotPointLineFeature_resqml2 in _fesapi:
_fesapi.ShotPointLineFeature_resqml2_swigregister(ShotPointLineFeature_resqml2)
class CmpLineFeature_resqml2(Resqml2_AbstractSeismicLineFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setShotPointLine(self, shotPointLine: "ShotPointLineFeature_resqml2") -> "void":
        return _fesapi.CmpLineFeature_resqml2_setShotPointLine(self, shotPointLine)

    def getShotPointLine(self) -> "resqml2::ShotPointLineFeature *":
        return _fesapi.CmpLineFeature_resqml2_getShotPointLine(self)
    __swig_destroy__ = _fesapi.delete_CmpLineFeature_resqml2

# Register CmpLineFeature_resqml2 in _fesapi:
_fesapi.CmpLineFeature_resqml2_swigregister(CmpLineFeature_resqml2)
class Resqml2_WellboreFeature(Resqml2_AbstractTechnicalFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getWitsmlWellbore(self) -> "witsml2::Wellbore *":
        return _fesapi.Resqml2_WellboreFeature_getWitsmlWellbore(self)

    def setWitsmlWellbore(self, wellbore: "Witsml2_Wellbore") -> "void":
        return _fesapi.Resqml2_WellboreFeature_setWitsmlWellbore(self, wellbore)
    __swig_destroy__ = _fesapi.delete_Resqml2_WellboreFeature

# Register Resqml2_WellboreFeature in _fesapi:
_fesapi.Resqml2_WellboreFeature_swigregister(Resqml2_WellboreFeature)
class AbstractFeatureInterpretation(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getRepresentationCount(self) -> "uint64_t":
        r"""
        Get the representation count of this interpretation.

        :raises: std::range_error	If the representation count is strictly greater than unsigned
            									int max.

        :rtype: int
        :return: The representation count.
        """
        return _fesapi.AbstractFeatureInterpretation_getRepresentationCount(self)

    def getInterpretedFeature(self) -> "resqml2::AbstractFeature *":
        r"""
        Gets the feature this instance interprets

        :rtype: :py:class:`AbstractFeature`
        :return: A pointer to the interpreted feature.
        """
        return _fesapi.AbstractFeatureInterpretation_getInterpretedFeature(self)

    def getRepresentation(self, index: "uint64_t") -> "resqml2::AbstractRepresentation *":
        r"""
        Gets a particular representation of this interpretation according to its position in the
        representations ordering.

        :raises: std::out_of_range	If ``index`` is out of the range of the representation set.

        :type index: int
        :param index:	Zero-based index of the representation we look for.

        :rtype: :py:class:`AbstractRepresentation`
        :return: A pointer to the representation at ``index``.
        """
        return _fesapi.AbstractFeatureInterpretation_getRepresentation(self, index)

    def initDomain(self, defaultDomain: "gsoap_resqml2_0_1::resqml20__Domain") -> "gsoap_resqml2_0_1::resqml20__Domain":
        r"""
        Initializes the domain of the interpretation by looking at the local CRS domain of its
        representations.

        :type defaultDomain: int
        :param defaultDomain:	The default domain to set when no representation is associated to
            							this interpretation.

        :rtype: int
        :return: The domain that have been set to this interpretation (either deduced from its
            			representation or ``defaultDomain)``.
        """
        return _fesapi.AbstractFeatureInterpretation_initDomain(self, defaultDomain)

    def getDomain(self) -> "gsoap_resqml2_0_1::resqml20__Domain":
        r"""
        Gets the domain of this interpretation.

        :rtype: int
        :return: The domain of this interpretation.
        """
        return _fesapi.AbstractFeatureInterpretation_getDomain(self)
    __swig_destroy__ = _fesapi.delete_AbstractFeatureInterpretation

# Register AbstractFeatureInterpretation in _fesapi:
_fesapi.AbstractFeatureInterpretation_swigregister(AbstractFeatureInterpretation)
class Resqml2_GenericFeatureInterpretation(AbstractFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_GenericFeatureInterpretation

# Register Resqml2_GenericFeatureInterpretation in _fesapi:
_fesapi.Resqml2_GenericFeatureInterpretation_swigregister(Resqml2_GenericFeatureInterpretation)
class Resqml2_BoundaryFeatureInterpretation(AbstractFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_BoundaryFeatureInterpretation

# Register Resqml2_BoundaryFeatureInterpretation in _fesapi:
_fesapi.Resqml2_BoundaryFeatureInterpretation_swigregister(Resqml2_BoundaryFeatureInterpretation)
class Resqml2_GeobodyBoundaryInterpretation(Resqml2_BoundaryFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_GeobodyBoundaryInterpretation

# Register Resqml2_GeobodyBoundaryInterpretation in _fesapi:
_fesapi.Resqml2_GeobodyBoundaryInterpretation_swigregister(Resqml2_GeobodyBoundaryInterpretation)
class Resqml2_HorizonInterpretation(Resqml2_BoundaryFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_HorizonInterpretation

# Register Resqml2_HorizonInterpretation in _fesapi:
_fesapi.Resqml2_HorizonInterpretation_swigregister(Resqml2_HorizonInterpretation)
class Resqml2_FaultInterpretation(Resqml2_BoundaryFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackThrowInterpretation(self, throwKind: "gsoap_resqml2_0_1::resqml20__ThrowKind") -> "void":
        r"""
        Pushes back a new throw interpretation for this fault interpretation. More than one throw
        kind is necessary if for example the throw is reverse at a time period and then normal at
        another time period.

        :type throwKind: int
        :param throwKind:	The throw kind to push back.
        """
        return _fesapi.Resqml2_FaultInterpretation_pushBackThrowInterpretation(self, throwKind)
    __swig_destroy__ = _fesapi.delete_Resqml2_FaultInterpretation

# Register Resqml2_FaultInterpretation in _fesapi:
_fesapi.Resqml2_FaultInterpretation_swigregister(Resqml2_FaultInterpretation)
class Resqml2_FluidBoundaryInterpretation(Resqml2_BoundaryFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_FluidBoundaryInterpretation

# Register Resqml2_FluidBoundaryInterpretation in _fesapi:
_fesapi.Resqml2_FluidBoundaryInterpretation_swigregister(Resqml2_FluidBoundaryInterpretation)
class Resqml2_GeobodyInterpretation(AbstractFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set3dShape(self, geobody3dShape: "gsoap_eml2_3::resqml22__Shape3d") -> "void":
        return _fesapi.Resqml2_GeobodyInterpretation_set3dShape(self, geobody3dShape)

    def has3dShape(self) -> "bool":
        return _fesapi.Resqml2_GeobodyInterpretation_has3dShape(self)

    def get3dShape(self) -> "gsoap_eml2_3::resqml22__Shape3d":
        return _fesapi.Resqml2_GeobodyInterpretation_get3dShape(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_GeobodyInterpretation

# Register Resqml2_GeobodyInterpretation in _fesapi:
_fesapi.Resqml2_GeobodyInterpretation_swigregister(Resqml2_GeobodyInterpretation)
class Resqml2_StratigraphicUnitInterpretation(AbstractFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def hasDepositionMode(self) -> "bool":
        return _fesapi.Resqml2_StratigraphicUnitInterpretation_hasDepositionMode(self)

    def getDepositionMode(self) -> "gsoap_resqml2_0_1::resqml20__DepositionMode":
        return _fesapi.Resqml2_StratigraphicUnitInterpretation_getDepositionMode(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_StratigraphicUnitInterpretation

# Register Resqml2_StratigraphicUnitInterpretation in _fesapi:
_fesapi.Resqml2_StratigraphicUnitInterpretation_swigregister(Resqml2_StratigraphicUnitInterpretation)
class Resqml2_AbstractOrganizationInterpretation(AbstractFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def isStructural(self) -> "bool":
        r"""Indicates if this instance is a structural one."""
        return _fesapi.Resqml2_AbstractOrganizationInterpretation_isStructural(self)

    def isStratigraphic(self) -> "bool":
        r"""Indicates if this instance is a structural one."""
        return _fesapi.Resqml2_AbstractOrganizationInterpretation_isStratigraphic(self)

    def isRockFluid(self) -> "bool":
        r"""Indicates if this instance is a structural one."""
        return _fesapi.Resqml2_AbstractOrganizationInterpretation_isRockFluid(self)

    def pushBackBinaryContact(self, *args) -> "void":
        r"""
        *Overload 1:*

        Adds a binary contact to this organization interpretation by means of a simple sentence.

        :raises: std::invalid_argument	If ``subject`` or ``directObject`` is ``nullptr``.

        :param [in]:	subject			The subject of the sentence that defines how the contact was
            								constructed.
        :type verb: int
        :param verb:			The verb of the sentence that defines how the contact was
            								constructed.
        :param [in]:	directObject	The direct object of the sentence that defines how the contact
            								was constructed.

        |

        *Overload 2:*

        Adds a binary contact to this organization interpretation by means of a simple sentence.

        :raises: std::invalid_argument	If ``subject`` or ``directObject`` is ``nullptr``.

        :param [in]:	subject			The subject of the sentence that defines how the contact was
            								constructed.
        :type verb: int
        :param verb:			The verb of the sentence that defines how the contact was
            								constructed.
        :param [in]:	directObject	The direct object of the sentence that defines how the contact
            								was constructed.
        :param [in]:	partOf			indicates the interpertation this contact is part of

        |

        *Overload 3:*

        Adds a binary contact to the organization interpretation by means of a sentence where the
        direct object can be qualified.

        :raises: std::invalid_argument	If ``subject`` or ``directObject`` is ``nullptr``.

        :param [in]:	subject				 	The subject of the sentence that defines how the contact
            										was constructed.
        :type verb: int
        :param verb:				 	The verb of the sentence that defines how the contact was
            										constructed.
        :param [in]:	directObject		 	The direct object of the sentence that defines how the
            										contact was constructed.
        :type directObjectQualifier: int
        :param directObjectQualifier:	The direct object qualifier defining its contact side
            										(footwall, hanging wall, north, south, etc.).

        |

        *Overload 4:*

        Adds a binary contact to the organization interpretation by means of a sentence where both
        the subject and the direct object can be qualified.

        :raises: std::invalid_argument	If ``subject`` or ``directObject`` is ``nullptr``.

        :param [in]:	subject				 	The subject of the sentence that defines how the contact
            										was constructed.
        :type subjectQualifier: int
        :param subjectQualifier:	 	The subject qualifier defining its contact side (footwall,
            										hanging wall, north, south, etc.).
        :type verb: int
        :param verb:				 	The verb of the sentence that defines how the contact was
            										constructed.
        :param [in]:	directObject		 	The direct object of the sentence that defines how the
            										contact was constructed.
        :type directObjectQualifier: int
        :param directObjectQualifier:	The direct object qualifier defining its contact side
            										(footwall, hanging wall, north, south, etc.).
        """
        return _fesapi.Resqml2_AbstractOrganizationInterpretation_pushBackBinaryContact(self, *args)
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractOrganizationInterpretation

# Register Resqml2_AbstractOrganizationInterpretation in _fesapi:
_fesapi.Resqml2_AbstractOrganizationInterpretation_swigregister(Resqml2_AbstractOrganizationInterpretation)
class Resqml2_AbstractStratigraphicOrganizationInterpretation(Resqml2_AbstractOrganizationInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getGridRepresentationCount(self) -> "unsigned int":
        return _fesapi.Resqml2_AbstractStratigraphicOrganizationInterpretation_getGridRepresentationCount(self)

    def getGridRepresentation(self, index: "unsigned int") -> "resqml2::AbstractGridRepresentation *":
        return _fesapi.Resqml2_AbstractStratigraphicOrganizationInterpretation_getGridRepresentation(self, index)

    def isAssociatedToGridRepresentation(self, gridRep: "Resqml2_AbstractGridRepresentation") -> "bool":
        return _fesapi.Resqml2_AbstractStratigraphicOrganizationInterpretation_isAssociatedToGridRepresentation(self, gridRep)
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractStratigraphicOrganizationInterpretation

# Register Resqml2_AbstractStratigraphicOrganizationInterpretation in _fesapi:
_fesapi.Resqml2_AbstractStratigraphicOrganizationInterpretation_swigregister(Resqml2_AbstractStratigraphicOrganizationInterpretation)
class Resqml2_StratigraphicColumnRankInterpretation(Resqml2_AbstractStratigraphicOrganizationInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackStratiUnitInterpretation(self, stratiUnitInterpretation: "Resqml2_StratigraphicUnitInterpretation") -> "void":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_pushBackStratiUnitInterpretation(self, stratiUnitInterpretation)

    def pushBackStratigraphicBinaryContact(self, subject: "Resqml2_StratigraphicUnitInterpretation", subjectContactMode: "gsoap_eml2_3::resqml22__ContactMode", directObject: "Resqml2_StratigraphicUnitInterpretation", directObjectMode: "gsoap_eml2_3::resqml22__ContactMode", partOf: "Resqml2_HorizonInterpretation"=None) -> "void":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_pushBackStratigraphicBinaryContact(self, subject, subjectContactMode, directObject, directObjectMode, partOf)

    def getContactCount(self) -> "unsigned int":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getContactCount(self)

    def getSubjectContactModeOfContact(self, contactIndex: "unsigned int") -> "gsoap_eml2_3::resqml22__ContactMode":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getSubjectContactModeOfContact(self, contactIndex)

    def getDirectObjectContactModeOfContact(self, contactIndex: "unsigned int") -> "gsoap_eml2_3::resqml22__ContactMode":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getDirectObjectContactModeOfContact(self, contactIndex)

    def getHorizonInterpretationOfContact(self, contactIndex: "unsigned int") -> "resqml2::HorizonInterpretation *":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getHorizonInterpretationOfContact(self, contactIndex)

    def isAChronoStratiRank(self) -> "bool":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_isAChronoStratiRank(self)

    def getSubjectOfContact(self, contactIndex: "unsigned int") -> "resqml2::StratigraphicUnitInterpretation *":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getSubjectOfContact(self, contactIndex)

    def getDirectObjectOfContact(self, contactIndex: "unsigned int") -> "resqml2::StratigraphicUnitInterpretation *":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getDirectObjectOfContact(self, contactIndex)

    def getStratigraphicUnitInterpretationCount(self) -> "unsigned int":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getStratigraphicUnitInterpretationCount(self)

    def getStratigraphicUnitInterpretation(self, index: "unsigned int") -> "resqml2::StratigraphicUnitInterpretation *":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getStratigraphicUnitInterpretation(self, index)

    def getStratigraphicOccurrenceInterpretationCount(self) -> "unsigned int":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getStratigraphicOccurrenceInterpretationCount(self)

    def getStratigraphicOccurrenceInterpretation(self, index: "unsigned int") -> "resqml2::StratigraphicOccurrenceInterpretation *":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getStratigraphicOccurrenceInterpretation(self, index)

    def getHorizonInterpretationCount(self) -> "unsigned int":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getHorizonInterpretationCount(self)

    def getHorizonInterpretation(self, index: "unsigned int") -> "resqml2::HorizonInterpretation *":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getHorizonInterpretation(self, index)

    def getStratigraphicColumnCount(self) -> "unsigned int":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getStratigraphicColumnCount(self)

    def getStratigraphicColumn(self, index: "unsigned int") -> "resqml2::StratigraphicColumn *":
        return _fesapi.Resqml2_StratigraphicColumnRankInterpretation_getStratigraphicColumn(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_StratigraphicColumnRankInterpretation

# Register Resqml2_StratigraphicColumnRankInterpretation in _fesapi:
_fesapi.Resqml2_StratigraphicColumnRankInterpretation_swigregister(Resqml2_StratigraphicColumnRankInterpretation)
class Resqml2_StratigraphicOccurrenceInterpretation(Resqml2_AbstractStratigraphicOrganizationInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStratigraphicColumnRankInterpretation(self, stratiColumnRankInterp: "Resqml2_StratigraphicColumnRankInterpretation") -> "void":
        return _fesapi.Resqml2_StratigraphicOccurrenceInterpretation_setStratigraphicColumnRankInterpretation(self, stratiColumnRankInterp)

    def getStratigraphicColumnRankInterpretation(self) -> "resqml2::StratigraphicColumnRankInterpretation *":
        return _fesapi.Resqml2_StratigraphicOccurrenceInterpretation_getStratigraphicColumnRankInterpretation(self)

    def getWellboreMarkerFrameRepresentationCount(self) -> "unsigned int":
        return _fesapi.Resqml2_StratigraphicOccurrenceInterpretation_getWellboreMarkerFrameRepresentationCount(self)

    def getWellboreMarkerFrameRepresentation(self, index: "unsigned int") -> "resqml2::WellboreMarkerFrameRepresentation *":
        return _fesapi.Resqml2_StratigraphicOccurrenceInterpretation_getWellboreMarkerFrameRepresentation(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_StratigraphicOccurrenceInterpretation

# Register Resqml2_StratigraphicOccurrenceInterpretation in _fesapi:
_fesapi.Resqml2_StratigraphicOccurrenceInterpretation_swigregister(Resqml2_StratigraphicOccurrenceInterpretation)
class Resqml2_StratigraphicColumn(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackStratiColumnRank(self, stratiColumnRank: "Resqml2_StratigraphicColumnRankInterpretation") -> "void":
        return _fesapi.Resqml2_StratigraphicColumn_pushBackStratiColumnRank(self, stratiColumnRank)

    def getStratigraphicColumnRankInterpretationCount(self) -> "unsigned int":
        return _fesapi.Resqml2_StratigraphicColumn_getStratigraphicColumnRankInterpretationCount(self)

    def getStratigraphicColumnRankInterpretation(self, index: "unsigned int") -> "resqml2::StratigraphicColumnRankInterpretation *":
        return _fesapi.Resqml2_StratigraphicColumn_getStratigraphicColumnRankInterpretation(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_StratigraphicColumn

# Register Resqml2_StratigraphicColumn in _fesapi:
_fesapi.Resqml2_StratigraphicColumn_swigregister(Resqml2_StratigraphicColumn)
class Resqml2_RockFluidUnitInterpretation(AbstractFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def hasPhase(self) -> "bool":
        r"""
        Indicates if this instance has a phase information.

        :rtype: boolean
        :return: True if there exists a phase information, false if not.
        """
        return _fesapi.Resqml2_RockFluidUnitInterpretation_hasPhase(self)

    def getPhase(self) -> "gsoap_eml2_3::resqml22__Phase":
        r"""
        Gets the phase information of this rock fluid unit interpretation.

        :raises: std::logic_error	If no phase information exists in this rock fluid unit
            									interpretation (please use hasPhase() before calling this
            									method).

        :rtype: int
        :return: The phase of this rock fluid unit interpretation.
        """
        return _fesapi.Resqml2_RockFluidUnitInterpretation_getPhase(self)

    def setPhase(self, phase: "gsoap_eml2_3::resqml22__Phase") -> "void":
        r"""
        Sets the phase information of this rock fluid unit interpretation.

        :type phase: int
        :param phase:	The phase of this rock fluid unit interpretation.
        """
        return _fesapi.Resqml2_RockFluidUnitInterpretation_setPhase(self, phase)
    __swig_destroy__ = _fesapi.delete_Resqml2_RockFluidUnitInterpretation

# Register Resqml2_RockFluidUnitInterpretation in _fesapi:
_fesapi.Resqml2_RockFluidUnitInterpretation_swigregister(Resqml2_RockFluidUnitInterpretation)
class Resqml2_RockFluidOrganizationInterpretation(Resqml2_AbstractOrganizationInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getGridRepresentationCount(self) -> "uint64_t":
        r"""
        Gets the count of grid representations associated to this rock fluid organization.

        :raises: std::range_error	If the count of associated grid representations is strictly
            									greater than unsigned int max.

        :rtype: int
        :return: The count of grid representations associated to this rock fluid organization.
        """
        return _fesapi.Resqml2_RockFluidOrganizationInterpretation_getGridRepresentationCount(self)

    def getGridRepresentation(self, index: "uint64_t") -> "resqml2::AbstractGridRepresentation *":
        r"""
        Gets a grid representation associated to this rock fluid organization by means of its index.

        :raises: std::out_of_range	If index >= getGridRepresentationCount().

        :type index: int
        :param index:	Zero-based index of the grid representation to get in the array of grid
            					representations of this rock fluid organization.

        :rtype: :py:class:`AbstractGridRepresentation`
        :return: The associated grid representation at position ``index``.
        """
        return _fesapi.Resqml2_RockFluidOrganizationInterpretation_getGridRepresentation(self, index)

    def isAssociatedToGridRepresentation(self, gridRep: "Resqml2_AbstractGridRepresentation") -> "bool":
        r"""
        Checks whether a given grid representation is associated to this rock fluid organization.

        :param [in]:	gridRep	The grid representation for which we want to know if it is associated to
            						this rock fluid organization.

        :rtype: boolean
        :return: True if ``gridRep`` is associated to this rock fluid organization, false if not.
        """
        return _fesapi.Resqml2_RockFluidOrganizationInterpretation_isAssociatedToGridRepresentation(self, gridRep)

    def pushBackRockFluidUnitInterpretation(self, rockFluidUnitInterpretation: "Resqml2_RockFluidUnitInterpretation") -> "void":
        r"""
        Pushes back a rock fluid unit interpretation in this rock fluid organization.

        :raises: std::invalid_argument	If rockFluidUnitInterpretation == nullptr.

        :param [in]:	rockFluidUnitInterpretation	The rock fluid unit interpretation to push back.
        """
        return _fesapi.Resqml2_RockFluidOrganizationInterpretation_pushBackRockFluidUnitInterpretation(self, rockFluidUnitInterpretation)

    def getRockFluidUnitInterpCount(self) -> "uint64_t":
        r"""
        Gets the count of rock fluid unit interpretations of this rock fluid organization.

        :rtype: int
        :return: The count of rock fluid unit interpretations of this rock fluid organization.
        """
        return _fesapi.Resqml2_RockFluidOrganizationInterpretation_getRockFluidUnitInterpCount(self)

    def getRockFluidUnitInterpretation(self, index: "uint64_t") -> "resqml2::RockFluidUnitInterpretation *":
        r"""
        Gets a rock fluid unit interpretation of this rock fluid organization by means of
        its index.

        :raises: std::out_of_range	If index >= getRockFluidUnitInterpCount().

        :type index: int
        :param index:	Zero-based index of the rock fluid unit interpretation we look for.

        :rtype: :py:class:`RockFluidUnitInterpretation`
        :return: The rock fluid unit interpretation at position ``index``.
        """
        return _fesapi.Resqml2_RockFluidOrganizationInterpretation_getRockFluidUnitInterpretation(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_RockFluidOrganizationInterpretation

# Register Resqml2_RockFluidOrganizationInterpretation in _fesapi:
_fesapi.Resqml2_RockFluidOrganizationInterpretation_swigregister(Resqml2_RockFluidOrganizationInterpretation)
class Resqml2_StructuralOrganizationInterpretation(Resqml2_AbstractOrganizationInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackFaultInterpretation(self, faultInterpretation: "Resqml2_FaultInterpretation") -> "void":
        return _fesapi.Resqml2_StructuralOrganizationInterpretation_pushBackFaultInterpretation(self, faultInterpretation)

    def pushBackHorizonInterpretation(self, horizonInterpretation: "Resqml2_HorizonInterpretation", stratigraphicRank: "int const &") -> "void":
        return _fesapi.Resqml2_StructuralOrganizationInterpretation_pushBackHorizonInterpretation(self, horizonInterpretation, stratigraphicRank)

    def pushBackTopFrontierInterpretation(self, topFrontierInterpretation: "AbstractFeatureInterpretation") -> "void":
        return _fesapi.Resqml2_StructuralOrganizationInterpretation_pushBackTopFrontierInterpretation(self, topFrontierInterpretation)

    def pushBackBottomFrontierInterpretation(self, bottomFrontierInterpretation: "AbstractFeatureInterpretation") -> "void":
        return _fesapi.Resqml2_StructuralOrganizationInterpretation_pushBackBottomFrontierInterpretation(self, bottomFrontierInterpretation)

    def pushBackSideFrontierInterpretation(self, sideFrontierInterpretation: "AbstractFeatureInterpretation") -> "void":
        return _fesapi.Resqml2_StructuralOrganizationInterpretation_pushBackSideFrontierInterpretation(self, sideFrontierInterpretation)

    def getFaultInterpretationCount(self) -> "unsigned int":
        return _fesapi.Resqml2_StructuralOrganizationInterpretation_getFaultInterpretationCount(self)

    def getFaultInterpretation(self, index: "unsigned int") -> "resqml2::FaultInterpretation *":
        return _fesapi.Resqml2_StructuralOrganizationInterpretation_getFaultInterpretation(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_StructuralOrganizationInterpretation

# Register Resqml2_StructuralOrganizationInterpretation in _fesapi:
_fesapi.Resqml2_StructuralOrganizationInterpretation_swigregister(Resqml2_StructuralOrganizationInterpretation)
class Resqml2_EarthModelInterpretation(AbstractFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getStructuralOrganizationInterpretationCount(self) -> "unsigned int":
        return _fesapi.Resqml2_EarthModelInterpretation_getStructuralOrganizationInterpretationCount(self)

    def getStructuralOrganizationInterpertation(self, index: "unsigned int") -> "resqml2::StructuralOrganizationInterpretation *":
        return _fesapi.Resqml2_EarthModelInterpretation_getStructuralOrganizationInterpertation(self, index)

    def pushBackStructuralOrganizationInterpretation(self, structOrganization: "Resqml2_StructuralOrganizationInterpretation") -> "void":
        return _fesapi.Resqml2_EarthModelInterpretation_pushBackStructuralOrganizationInterpretation(self, structOrganization)

    def hasStratiColumn(self) -> "bool":
        return _fesapi.Resqml2_EarthModelInterpretation_hasStratiColumn(self)

    def setStratiColumn(self, stratiColumn: "Resqml2_StratigraphicColumn") -> "void":
        return _fesapi.Resqml2_EarthModelInterpretation_setStratiColumn(self, stratiColumn)

    def getStratiColumn(self) -> "resqml2::StratigraphicColumn *":
        return _fesapi.Resqml2_EarthModelInterpretation_getStratiColumn(self)

    def getStratiOccurrenceCount(self) -> "unsigned int":
        return _fesapi.Resqml2_EarthModelInterpretation_getStratiOccurrenceCount(self)

    def getStratiOccurrence(self, index: "unsigned int") -> "resqml2::StratigraphicOccurrenceInterpretation *":
        return _fesapi.Resqml2_EarthModelInterpretation_getStratiOccurrence(self, index)

    def pushBackStratiOccurrence(self, stratiOccurence: "Resqml2_StratigraphicOccurrenceInterpretation") -> "void":
        return _fesapi.Resqml2_EarthModelInterpretation_pushBackStratiOccurrence(self, stratiOccurence)

    def getRockFluidOrganizationInterpretationCount(self) -> "unsigned int":
        return _fesapi.Resqml2_EarthModelInterpretation_getRockFluidOrganizationInterpretationCount(self)

    def pushBackRockFluidOrganizationInterpretation(self, rockFluid: "Resqml2_RockFluidOrganizationInterpretation") -> "void":
        return _fesapi.Resqml2_EarthModelInterpretation_pushBackRockFluidOrganizationInterpretation(self, rockFluid)

    def getRockFluidOrganizationInterpretation(self, index: "unsigned int") -> "resqml2::RockFluidOrganizationInterpretation *":
        return _fesapi.Resqml2_EarthModelInterpretation_getRockFluidOrganizationInterpretation(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_EarthModelInterpretation

# Register Resqml2_EarthModelInterpretation in _fesapi:
_fesapi.Resqml2_EarthModelInterpretation_swigregister(Resqml2_EarthModelInterpretation)
class Resqml2_WellboreInterpretation(AbstractFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def isDrilled(self) -> "bool":
        return _fesapi.Resqml2_WellboreInterpretation_isDrilled(self)

    def getWellboreTrajectoryRepresentationCount(self) -> "unsigned int":
        return _fesapi.Resqml2_WellboreInterpretation_getWellboreTrajectoryRepresentationCount(self)

    def getWellboreTrajectoryRepresentation(self, index: "unsigned int") -> "resqml2::WellboreTrajectoryRepresentation *":
        return _fesapi.Resqml2_WellboreInterpretation_getWellboreTrajectoryRepresentation(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_WellboreInterpretation

# Register Resqml2_WellboreInterpretation in _fesapi:
_fesapi.Resqml2_WellboreInterpretation_swigregister(Resqml2_WellboreInterpretation)
class Resqml2_AbstractRepresentation(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getInterpretation(self) -> "resqml2::AbstractFeatureInterpretation *":
        r"""
        Gets the interpretation associated to this representation.

        :rtype: :py:class:`AbstractFeatureInterpretation`
        :return: Null pointer if no interpretation is associated to this representation. Otherwise
            			the associated interpretation.
        """
        return _fesapi.Resqml2_AbstractRepresentation_getInterpretation(self)

    def getLocalCrs(self, patchIndex: "uint64_t") -> "eml2::AbstractLocal3dCrs *":
        r"""
        Gets the local 3d CRS associated to a given patch of this representation in read and write
        access.

        :raises: std::out_of_range	If ``patchIndex`` is out of range.

        :type patchIndex: int
        :param patchIndex:	Zero-based index of the patch for which we look for the local CRS.

        :rtype: :py:class:`AbstractLocal3dCrs`
        :return: Null if it fails, else the local CRS associated to the ``patchIndex`` patch.
        """
        return _fesapi.Resqml2_AbstractRepresentation_getLocalCrs(self, patchIndex)

    def setTimeIndex(self, timeIndex: "uint64_t", timeSeries: "TimeSeries") -> "void":
        r"""
        Set a time index in a time series for all point geometries of all existing patches of this representation.

        :type timeIndex: int
        :param timeIndex:	The time index of the time to associate to this representation.
        :type timeSeries: :py:class:`TimeSeries`
        :param timeSeries:	The time series containing the time of the representation at ``timeIndex``.
        """
        return _fesapi.Resqml2_AbstractRepresentation_setTimeIndex(self, timeIndex, timeSeries)

    def getTimeIndex(self) -> "uint64_t":
        r"""
        Gets the time index of this representation in the associated TimeSeries.
        		Be sure to first check that a TimeSeries is associated this representation by calling getTimeSeriesDor or getTimeSeries;

        :raises: std::logic_error	If this representation is partial. Or if the representation is not associated to any TimeSeries.

        :rtype: int
        :return: The time index of this representation in the associated TimeSeries.
        """
        return _fesapi.Resqml2_AbstractRepresentation_getTimeIndex(self)

    def getTimeSeries(self) -> "eml2::TimeSeries *":
        r"""
        Gets the TimeSeries associated to this representation.

        :rtype: :py:class:`TimeSeries`
        :return: Null if it fails, else the TimeSeries associated to this representation.
        """
        return _fesapi.Resqml2_AbstractRepresentation_getTimeSeries(self)

    def getValuesPropertyCount(self) -> "unsigned int":
        return _fesapi.Resqml2_AbstractRepresentation_getValuesPropertyCount(self)

    def getValuesProperty(self, index: "unsigned int") -> "resqml2::AbstractValuesProperty *":
        return _fesapi.Resqml2_AbstractRepresentation_getValuesProperty(self, index)

    def getPointsPropertyCount(self) -> "unsigned int":
        return _fesapi.Resqml2_AbstractRepresentation_getPointsPropertyCount(self)

    def getPointsProperty(self, index: "unsigned int") -> "resqml2::PointsProperty *":
        return _fesapi.Resqml2_AbstractRepresentation_getPointsProperty(self, index)

    def getSubRepresentationCount(self) -> "unsigned int":
        return _fesapi.Resqml2_AbstractRepresentation_getSubRepresentationCount(self)

    def getSubRepresentation(self, index: "unsigned int") -> "resqml2::SubRepresentation *":
        return _fesapi.Resqml2_AbstractRepresentation_getSubRepresentation(self, index)

    def getFaultSubRepresentationCount(self) -> "unsigned int":
        return _fesapi.Resqml2_AbstractRepresentation_getFaultSubRepresentationCount(self)

    def getFaultSubRepresentation(self, index: "unsigned int") -> "resqml2::SubRepresentation *":
        return _fesapi.Resqml2_AbstractRepresentation_getFaultSubRepresentation(self, index)

    def getRepresentationSetRepresentationCount(self) -> "unsigned int":
        return _fesapi.Resqml2_AbstractRepresentation_getRepresentationSetRepresentationCount(self)

    def getRepresentationSetRepresentation(self, index: "unsigned int") -> "resqml2::RepresentationSetRepresentation *":
        return _fesapi.Resqml2_AbstractRepresentation_getRepresentationSetRepresentation(self, index)

    def getXyzPointCountOfPatch(self, patchIndex: "unsigned int") -> "uint64_t":
        r"""
        Get the xyz point count in a given patch of this representation.

        :raises: std::out_of_range	If ``patchIndex`` is out of range.
        :raises: std::logic_error 	If this representation is partial.

        :type patchIndex: int
        :param patchIndex:	Zero-based index of the patch from which we look for the xyz points.

        :rtype: int
        :return: The xyz point count of the patch at position ``patchIndex``.
        """
        return _fesapi.Resqml2_AbstractRepresentation_getXyzPointCountOfPatch(self, patchIndex)

    def getXyzPointCountOfAllPatches(self) -> "uint64_t":
        r"""
        Get the xyz point count of all patches of this representation.

        :rtype: int
        :return: The xyz point count of all patches.
        """
        return _fesapi.Resqml2_AbstractRepresentation_getXyzPointCountOfAllPatches(self)

    def getXyzPointsOfPatch(self, patchIndex: "unsigned int", xyzPoints: "double *") -> "void":
        r"""
        Gets all the xyz points of a particular patch of this representation. xyz points are
        			given in the local CRS.

        :raises: std::out_of_range	If ``patchIndex`` is out of range.
        :raises: std::logic_error 	If this representation is partial.

        :type patchIndex: int
        :param patchIndex:	Zero-based index of the patch from which we look for the xyz points.
        :param [out]:	xyzPoints 	A linearized 2d array where the first (quickest) dimension is the
            							coordinate dimension (x, y or z) and second dimension is vertex
            							dimension. It must be preallocated with a size of 3 *
            							getXyzPointCountOfPatch(patchIndex).
        """
        return _fesapi.Resqml2_AbstractRepresentation_getXyzPointsOfPatch(self, patchIndex, xyzPoints)

    def getXyzPointsOfPatchInGlobalCrs(self, patchIndex: "unsigned int", xyzPoints: "double *") -> "void":
        r"""
        Gets all the xyz points of a particular patch of this representation. xyz points are given in
        the global CRS.

        :raises: std::out_of_range	If ``patchIndex`` is out of range.

        :type patchIndex: int
        :param patchIndex:	Zero-based index of the patch from which we look for the xyz points.
        :param [out]:	xyzPoints 	A linearized 2d array where the first (quickest) dimension is the
            							coordinate dimension (x, y or z) and second dimension is vertex
            							dimension. It must be preallocated with a size of 3 *
            							getXyzPointCountOfPatch(patchIndex).
        """
        return _fesapi.Resqml2_AbstractRepresentation_getXyzPointsOfPatchInGlobalCrs(self, patchIndex, xyzPoints)

    def getXyzPointsOfAllPatches(self, xyzPoints: "double *") -> "void":
        r"""
        Gets all the xyz points of all patches of this representation. xyz points are given in the
        local CRS.

        :param [out]:	xyzPoints	A linearized 2d array where the first (quickest) dimension is the
            							coordinate dimension (x, y or z) and second dimension is vertex
            							dimension. It must be preallocated with a size of 3 *
            							getXyzPointCountOfAllPatches().
        """
        return _fesapi.Resqml2_AbstractRepresentation_getXyzPointsOfAllPatches(self, xyzPoints)

    def isInSingleLocalCrs(self) -> "bool":
        r"""
        Checks if all of the patches (geometries) of this representation are defined in a same local
        CRS.

        :rtype: boolean
        :return: True if this representation is defined in a single local CRS, false if not.
        """
        return _fesapi.Resqml2_AbstractRepresentation_isInSingleLocalCrs(self)

    def isInSingleGlobalCrs(self) -> "bool":
        r"""
        Checks if all of the patches (geometries) of this representation are defined in a same global
        CRS.

        :rtype: boolean
        :return: True if this representation is defined in a single global CRS, false if not.
        """
        return _fesapi.Resqml2_AbstractRepresentation_isInSingleGlobalCrs(self)

    def getXyzPointsOfAllPatchesInGlobalCrs(self, xyzPoints: "double *") -> "void":
        r"""
        Gets all the xyz points of all patches of this individual representation. xyz points are
        given in the global CRS.

        :param [out]:	xyzPoints	A linearized 2d array where the first (quickest) dimension is the
            							coordinate dimension (x, y or Z) and second dimension is vertex
            							dimension. Thus, its size is 3*(3*[count of all xyz points]). It must
            							be preallocated.
        """
        return _fesapi.Resqml2_AbstractRepresentation_getXyzPointsOfAllPatchesInGlobalCrs(self, xyzPoints)

    def getPatchCount(self) -> "uint64_t":
        r"""
        Gets the patch count.

        :rtype: int
        :return: The patch count.
        """
        return _fesapi.Resqml2_AbstractRepresentation_getPatchCount(self)

    def getSeismicSupportOfPatch(self, patchIndex: "unsigned int") -> "resqml2::AbstractRepresentation *":
        r"""
        Gets the seismic support of a specific patch of this representation.

        :raises: std::out_of_range	If ``patchIndex`` is out of the patch count range.

        :type patchIndex: int
        :param patchIndex:	Zero-based index of the patch from which we look for the seismic support.

        :rtype: :py:class:`AbstractRepresentation`
        :return: Null if no seismic information have been provided for the patch at position
            ``patchIndex``. Else, its seismic support.
        """
        return _fesapi.Resqml2_AbstractRepresentation_getSeismicSupportOfPatch(self, patchIndex)

    def getSeismicLineAbscissaOfPointsOfPatch(self, patchIndex: "unsigned int", values: "double *") -> "void":
        r"""
        Gets all the abscissa of the points of a specific patch related to 2d seismic line.

        :raises: std::out_of_range	 	If ``patchIndex`` is out of range.
        :raises: std::invalid_argument	If the patch at position ``patchIndex`` has no seismic
            										information.

        :type patchIndex: int
        :param patchIndex:	The index of the geometry patch which stores the seismic coordinates.
        :param [out]:	values	  	The array where the abscissa are going to be stored. The count of
            							this array must be equal to getXyzPointCountOfPatch(patchIndex).
        """
        return _fesapi.Resqml2_AbstractRepresentation_getSeismicLineAbscissaOfPointsOfPatch(self, patchIndex, values)

    def addSeismic2dCoordinatesToPatch(self, patchIndex: "unsigned int", lineAbscissa: "double *", seismicSupport: "Resqml2_AbstractRepresentation", proxy: "Eml2_AbstractHdfProxy") -> "void":
        r"""
        Adds seismic 2d coordinates to an existing point geometry patch.

        :raises: std::out_of_range	 	If ``patchIndex`` is out of range.
        :raises: std::invalid_argument	If ``patchIndex`` does not identify a point geometry patch.
        :raises: std::invalid_argument	If there already exists some seismic 3d coordinates for
            										the geometry patch at position ``patchIndex``.

        :type patchIndex: int
        :param patchIndex:	  	The index of the geometry patch which receives the seismic
            									coordinates.
        :param [in,out]:	lineAbscissa  	The abscissa of each points of the patch on the seismic line.
            									The count of this array must be equal to
            									getXyzPointCountOfPatch(patchIndex).
        :param [in,out]:	seismicSupport	The representation of the seismic line.
        :param [in,out]:	proxy		  	The HDF proxy where to write the ``lineAbscissa`` values. It
            									must be already opened for writing and won't be closed in
            									this method.
        """
        return _fesapi.Resqml2_AbstractRepresentation_addSeismic2dCoordinatesToPatch(self, patchIndex, lineAbscissa, seismicSupport, proxy)

    def getInlinesOfPointsOfPatch(self, patchIndex: "unsigned int", values: "double *") -> "void":
        r"""
        Gets all the inline coordinates of the points of a specific patch related to seismic lattice.

        :raises: std::out_of_range	 	If ``patchIndex`` is out of range.
        :raises: std::invalid_argument	If the patch at position ``patchIndex`` has no seismic
            										information.

        :type patchIndex: int
        :param patchIndex:	The index of the geometry patch which stores the seismic coordinates.
        :param [out]:	values	  	The array where the inlines coordinates are going to be stored. The
            							count of this array must be equal to
            							getXyzPointCountOfPatch(patchIndex).
        """
        return _fesapi.Resqml2_AbstractRepresentation_getInlinesOfPointsOfPatch(self, patchIndex, values)

    def getCrosslinesOfPointsOfPatch(self, patchIndex: "unsigned int", values: "double *") -> "void":
        r"""
        Gets all the crossline coordinates of the points of a specific patch related to seismic
        lattice.

        :raises: std::out_of_range	 	If ``patchIndex`` is out of range.
        :raises: std::invalid_argument	If the patch at position ``patchIndex`` has no seismic
            										information.

        :type patchIndex: int
        :param patchIndex:	The index of the geometry patch which stores the seismic coordinates.
        :param [out]:	values	  	The array where the crossline coordinates are going to be stored. The
            							count of this array must be equal to
            							getXyzPointCountOfPatch(patchIndex).
        """
        return _fesapi.Resqml2_AbstractRepresentation_getCrosslinesOfPointsOfPatch(self, patchIndex, values)

    def addSeismic3dCoordinatesToPatch(self, *args) -> "void":
        r"""
        *Overload 1:*

        Adds seismic 3d coordinates to an existing point geometry patch.

        :raises: std::out_of_range	 	If ``patchIndex`` is out of range.
        :raises: std::invalid_argument	If ``patchIndex`` does not identify a point geometry patch.
        :raises: std::invalid_argument	If there already exists some seismic 2d coordinates for
            										the geometry patch at position ``patchIndex``.

        :type patchIndex: int
        :param patchIndex:	  	The index of the geometry patch which receives the seismic
            									coordinates.
        :param [in]:	   	inlines		  	The sequence of trace or inter-trace inline positions that
            									correspond to the geometry coordinates. It must be in the
            									same order than ``crosslines``.
        :param [in]:	   	crosslines	  	The sequence of trace or inter-trace crossline positions that
            									correspond to the geometry coordinates. It must be in the
            									same order than ``inlines``.
        :type pointCount: int
        :param pointCount:	  	Number of points. It is the size of both ``inlines`` and
            ``crosslines``.
        :param [in]:	   	seismicSupport	The representation of the seismic line.
        :param [in:, out]	proxy		  	The HDF proxy where to write the ``inlines`` and ``crosslines``
            									values. It must be already opened for writing and won't be
            									closed in this method.

        |

        *Overload 2:*

        Adds seismic 3d coordinates to an existing point geometry patch.

        :raises: std::out_of_range	 	If ``patchIndex`` is out of range.
        :raises: std::invalid_argument	If ``patchIndex`` does not identify a point geometry patch.
        :raises: std::invalid_argument	If there already exists some seismic 2d coordinates for
            										the geometry patch at position ``patchIndex``.

        :type patchIndex: int
        :param patchIndex:	  	The index of the geometry patch which receives the seismic
            								coordinates.
        :type startInline: float
        :param startInline:   	The first inline.
        :type incrInline: float
        :param incrInline:	  	The inline increment.
        :type countInline: int
        :param countInline:   	The inline count.
        :type startCrossline: float
        :param startCrossline:	The first crossline.
        :type incrCrossline: float
        :param incrCrossline: 	The crossline increment.
        :type countCrossline: int
        :param countCrossline:	The crossline count.
        :param [in]:	seismicSupport	The representation of the seismic line.
        """
        return _fesapi.Resqml2_AbstractRepresentation_addSeismic3dCoordinatesToPatch(self, *args)

    def pushBackIntoRepresentationSet(self, repSet: "Resqml2_RepresentationSetRepresentation") -> "void":
        r"""
        Pushes back this representation into a representation set representation.

        :raises: std::invalid_argument	If ``repSet`` is null.

        :param [in]:	repSet	The representation set representation which will contain this
            							representation.
        """
        return _fesapi.Resqml2_AbstractRepresentation_pushBackIntoRepresentationSet(self, repSet)
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractRepresentation

# Register Resqml2_AbstractRepresentation in _fesapi:
_fesapi.Resqml2_AbstractRepresentation_swigregister(Resqml2_AbstractRepresentation)
class Resqml2_AbstractSurfaceRepresentation(Resqml2_AbstractRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setSurfaceRole(self, surfaceRole: "gsoap_resqml2_0_1::resqml20__SurfaceRole") -> "void":
        return _fesapi.Resqml2_AbstractSurfaceRepresentation_setSurfaceRole(self, surfaceRole)

    def getSurfaceRole(self) -> "gsoap_resqml2_0_1::resqml20__SurfaceRole":
        return _fesapi.Resqml2_AbstractSurfaceRepresentation_getSurfaceRole(self)

    def pushBackOuterRing(self, outerRing: "Resqml2_PolylineRepresentation") -> "void":
        return _fesapi.Resqml2_AbstractSurfaceRepresentation_pushBackOuterRing(self, outerRing)
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractSurfaceRepresentation

# Register Resqml2_AbstractSurfaceRepresentation in _fesapi:
_fesapi.Resqml2_AbstractSurfaceRepresentation_swigregister(Resqml2_AbstractSurfaceRepresentation)
class Resqml2_Grid2dRepresentation(Resqml2_AbstractSurfaceRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNodeCountAlongIAxis(self) -> "uint64_t":
        return _fesapi.Resqml2_Grid2dRepresentation_getNodeCountAlongIAxis(self)

    def getNodeCountAlongJAxis(self) -> "uint64_t":
        return _fesapi.Resqml2_Grid2dRepresentation_getNodeCountAlongJAxis(self)

    def getXOrigin(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getXOrigin(self)

    def getYOrigin(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getYOrigin(self)

    def getZOrigin(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getZOrigin(self)

    def getXOriginInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getXOriginInGlobalCrs(self)

    def getYOriginInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getYOriginInGlobalCrs(self)

    def getZOriginInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getZOriginInGlobalCrs(self)

    def getXJOffset(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getXJOffset(self)

    def getYJOffset(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getYJOffset(self)

    def getZJOffset(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getZJOffset(self)

    def getXJOffsetInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getXJOffsetInGlobalCrs(self)

    def getYJOffsetInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getYJOffsetInGlobalCrs(self)

    def getZJOffsetInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getZJOffsetInGlobalCrs(self)

    def getXIOffset(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getXIOffset(self)

    def getYIOffset(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getYIOffset(self)

    def getZIOffset(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getZIOffset(self)

    def getXIOffsetInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getXIOffsetInGlobalCrs(self)

    def getYIOffsetInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getYIOffsetInGlobalCrs(self)

    def getZIOffsetInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getZIOffsetInGlobalCrs(self)

    def isJSpacingConstant(self) -> "bool":
        return _fesapi.Resqml2_Grid2dRepresentation_isJSpacingConstant(self)

    def isISpacingConstant(self) -> "bool":
        return _fesapi.Resqml2_Grid2dRepresentation_isISpacingConstant(self)

    def getJSpacing(self, *args) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getJSpacing(self, *args)

    def getISpacing(self, *args) -> "double":
        return _fesapi.Resqml2_Grid2dRepresentation_getISpacing(self, *args)

    def getZValues(self, values: "double *") -> "void":
        return _fesapi.Resqml2_Grid2dRepresentation_getZValues(self, values)

    def getZValuesInGlobalCrs(self, values: "double *") -> "void":
        return _fesapi.Resqml2_Grid2dRepresentation_getZValuesInGlobalCrs(self, values)

    def getIndexOriginOnSupportingRepresentation(self, *args) -> "int":
        r"""
        *Overload 1:*

        Gets the index of the origin of the current geometry on the supporting representation. The
        index is given by means of the formula iOrigin + jOrigin *
        iNodeCountOnSupportingRepresentation

        :raises: std::logic_error	If no supporting representation is associated to this 2d grid
            									representation.

        :rtype: int
        :return: The index of the origin on the supporting representation.

        |

        *Overload 2:*

        Gets the index of the origin of the current geometry on a particular dimension of the
        supporting representation.

        :raises: std::logic_error	 	If no supporting representation is associated to this 2d
            										grid representation.
        :raises: std::invalid_argument	If ``dimension`` differs from ``0`` or ``1``.

        :type dimension: int
        :param dimension:	The dimension for which we look for the index of the origin. It can be
            ``0`` for J (slowest) dimension or ``1`` for I (fastest) dimension.

        :rtype: int
        :return: The index of the origin on the supporting representation on the dimension ``dimension``.
        """
        return _fesapi.Resqml2_Grid2dRepresentation_getIndexOriginOnSupportingRepresentation(self, *args)

    def getNodeCountOnSupportingRepresentation(self, dimension: "unsigned int") -> "uint64_t":
        r"""
        Gets the number of nodes of the current geometry which is extracted from a particular
        dimension of the supporting representation.

        :raises: std::logic_error 	If no supporting representation is associated to this 2d grid
            									representation.
        :raises: std::out_of_range	If ``dimension`` is out of range.

        :type dimension: int
        :param dimension:	The dimension for which we look for the number of nodes.

        :rtype: int
        :return: The number of nodes on the dimension ``dimension``.
        """
        return _fesapi.Resqml2_Grid2dRepresentation_getNodeCountOnSupportingRepresentation(self, dimension)

    def getIndexOffsetOnSupportingRepresentation(self, dimension: "unsigned int") -> "int64_t":
        r"""
        Gets the index offset of the nodes of the current geometry on a particular dimension
        			of the supporting representation.

        :raises: std::logic_error 	If no supporting representation is associated to this 2d grid
            									representation.
        :raises: std::out_of_range	If ``dimension`` is out of range.

        :type dimension: int
        :param dimension:	The dimension for which we look for the index offset.

        :rtype: int
        :return: The index offset on the dimension ``dimension``.
        """
        return _fesapi.Resqml2_Grid2dRepresentation_getIndexOffsetOnSupportingRepresentation(self, dimension)

    def setGeometryAsArray2dOfLatticePoints3d(self, numPointsInFastestDirection: "unsigned int", numPointsInSlowestDirection: "unsigned int", xOrigin: "double", yOrigin: "double", zOrigin: "double", xOffsetInFastestDirection: "double", yOffsetInFastestDirection: "double", zOffsetInFastestDirection: "double", xOffsetInSlowestDirection: "double", yOffsetInSlowestDirection: "double", zOffsetInSlowestDirection: "double", spacingInFastestDirection: "double", spacingInSlowestDirection: "double", localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_Grid2dRepresentation_setGeometryAsArray2dOfLatticePoints3d(self, numPointsInFastestDirection, numPointsInSlowestDirection, xOrigin, yOrigin, zOrigin, xOffsetInFastestDirection, yOffsetInFastestDirection, zOffsetInFastestDirection, xOffsetInSlowestDirection, yOffsetInSlowestDirection, zOffsetInSlowestDirection, spacingInFastestDirection, spacingInSlowestDirection, localCrs)

    def setGeometryAsArray2dOfExplicitZ(self, *args) -> "void":
        return _fesapi.Resqml2_Grid2dRepresentation_setGeometryAsArray2dOfExplicitZ(self, *args)

    def getSupportingRepresentation(self) -> "resqml2::Grid2dRepresentation *":
        return _fesapi.Resqml2_Grid2dRepresentation_getSupportingRepresentation(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_Grid2dRepresentation

# Register Resqml2_Grid2dRepresentation in _fesapi:
_fesapi.Resqml2_Grid2dRepresentation_swigregister(Resqml2_Grid2dRepresentation)
class Resqml2_PolylineSetRepresentation(Resqml2_AbstractRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getPolylineCountOfPatch(self, patchIndex: "uint64_t") -> "uint64_t":
        return _fesapi.Resqml2_PolylineSetRepresentation_getPolylineCountOfPatch(self, patchIndex)

    def getPolylineCountOfAllPatches(self) -> "uint64_t":
        return _fesapi.Resqml2_PolylineSetRepresentation_getPolylineCountOfAllPatches(self)

    def getNodeCountPerPolylineInPatch(self, patchIndex: "unsigned int", nodeCountPerPolyline: "unsigned int *") -> "void":
        return _fesapi.Resqml2_PolylineSetRepresentation_getNodeCountPerPolylineInPatch(self, patchIndex, nodeCountPerPolyline)

    def getNodeCountPerPolylineOfAllPatches(self, nodeCountPerPolyline: "unsigned int *") -> "void":
        return _fesapi.Resqml2_PolylineSetRepresentation_getNodeCountPerPolylineOfAllPatches(self, nodeCountPerPolyline)

    def pushBackGeometryPatch(self, *args) -> "void":
        return _fesapi.Resqml2_PolylineSetRepresentation_pushBackGeometryPatch(self, *args)

    def areAllPolylinesClosedOfPatch(self, patchIndex: "unsigned int") -> "bool":
        return _fesapi.Resqml2_PolylineSetRepresentation_areAllPolylinesClosedOfPatch(self, patchIndex)

    def areAllPolylinesClosedOfAllPatches(self) -> "bool":
        return _fesapi.Resqml2_PolylineSetRepresentation_areAllPolylinesClosedOfAllPatches(self)

    def areAllPolylinesNonClosedOfPatch(self, patchIndex: "unsigned int") -> "bool":
        return _fesapi.Resqml2_PolylineSetRepresentation_areAllPolylinesNonClosedOfPatch(self, patchIndex)

    def areAllPolylinesNonClosedOfAllPatches(self) -> "bool":
        return _fesapi.Resqml2_PolylineSetRepresentation_areAllPolylinesNonClosedOfAllPatches(self)

    def getClosedFlagPerPolylineOfPatch(self, patchIndex: "unsigned int", closedFlagPerPolyline: "bool *") -> "void":
        return _fesapi.Resqml2_PolylineSetRepresentation_getClosedFlagPerPolylineOfPatch(self, patchIndex, closedFlagPerPolyline)

    def getClosedFlagPerPolylineOfAllPatches(self, closedFlagPerPolyline: "bool *") -> "void":
        return _fesapi.Resqml2_PolylineSetRepresentation_getClosedFlagPerPolylineOfAllPatches(self, closedFlagPerPolyline)

    def hasALineRole(self) -> "bool":
        return _fesapi.Resqml2_PolylineSetRepresentation_hasALineRole(self)

    def getLineRole(self) -> "gsoap_eml2_3::resqml22__LineRole":
        return _fesapi.Resqml2_PolylineSetRepresentation_getLineRole(self)

    def setLineRole(self, lineRole: "gsoap_eml2_3::resqml22__LineRole") -> "void":
        return _fesapi.Resqml2_PolylineSetRepresentation_setLineRole(self, lineRole)
    __swig_destroy__ = _fesapi.delete_Resqml2_PolylineSetRepresentation

# Register Resqml2_PolylineSetRepresentation in _fesapi:
_fesapi.Resqml2_PolylineSetRepresentation_swigregister(Resqml2_PolylineSetRepresentation)
class Resqml2_PointSetRepresentation(Resqml2_AbstractRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackXyzGeometryPatch(self, xyzPointCount: "uint64_t", xyzPoints: "double const *", proxy: "Eml2_AbstractHdfProxy"=None, localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        r"""
        Pushes back a new patch of XYZ points.

        :raises: std::invalid_argument	If proxy == nullptr and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If localCrs == nullptr and no default local CRS
            										is defined in the repository.

        :type xyzPointCount: int
        :param xyzPointCount:	The xyz points count in this patch.
        :param [in]:	  	xyzPoints	 	The xyz values of the points of the patch. Ordered by xyz and
            									then by ``xyzPointCount``. Size is 3 * xyzPointCount.
        :param [in,out]:	proxy		 	(Optional) The HDF proxy which defines where the xyz points
            									will be stored. If ``nullptr`` (default), then the repository
            									default HDF proxy will be used.
        :param [in]:	  	localCrs	 	(Optional) The local CRS where the points are given. If
            ``nullptr`` (default), then the repository default local CRS will
            									be used.
        """
        return _fesapi.Resqml2_PointSetRepresentation_pushBackXyzGeometryPatch(self, xyzPointCount, xyzPoints, proxy, localCrs)

    def pushBackXyGeometryPatch(self, xyPointCount: "uint64_t", xyPoints: "double const *", proxy: "Eml2_AbstractHdfProxy"=None, localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        r"""
        Pushes back a new patch of XY points.

        :raises: std::invalid_argument	If proxy == nullptr and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If localCrs == nullptr and no default local CRS
            										is defined in the repository.

        :type xyPointCount: int
        :param xyPointCount:	The xy points count in this patch.
        :param [in]:	  	xyPoints	 	The xy values of the points of the patch. Ordered by xy and
            									then by ``xyPointCount``. Size is 2 * xyPointCount.
        :param [in,out]:	proxy		 	(Optional) The HDF proxy which defines where the xy points
            									will be stored. If ``nullptr`` (default), then the repository
            									default HDF proxy will be used.
        :param [in]:	  	localCrs	 	(Optional) The local CRS where the points are given. If
            ``nullptr`` (default), then the repository default local CRS will
            									be used.
        """
        return _fesapi.Resqml2_PointSetRepresentation_pushBackXyGeometryPatch(self, xyPointCount, xyPoints, proxy, localCrs)

    def isIn2D(self, patchIndex: "uint64_t") -> "bool":
        r"""
        Check if a point set representation patch is in 2 dimensions (i.e XY) instead of 3 dimensions (i.e XYZ)

        :param [in]:	  	patchIndex	 	The index of the patch
        """
        return _fesapi.Resqml2_PointSetRepresentation_isIn2D(self, patchIndex)

    def getXyPointsOfPatch(self, patchIndex: "uint64_t", xyPoints: "double *") -> "void":
        r"""
        Get all the XY points of a particular patch of this representation. XY points are given in
        the local CRS. You probably want to check first if the patch in in 2D using method bool isIn2D(uint64_t patchIndex).

        :type patchIndex: int
        :param patchIndex:	Zero-based index of the patch.
        :param [in,out]:	xyPoints 	A linearized 2d array where the first (quickest) dimension is
            								coordinate dimension (XY) and second dimension is vertex
            								dimension. It must be pre allocated.
        """
        return _fesapi.Resqml2_PointSetRepresentation_getXyPointsOfPatch(self, patchIndex, xyPoints)
    __swig_destroy__ = _fesapi.delete_Resqml2_PointSetRepresentation

# Register Resqml2_PointSetRepresentation in _fesapi:
_fesapi.Resqml2_PointSetRepresentation_swigregister(Resqml2_PointSetRepresentation)
class Resqml2_PlaneSetRepresentation(Resqml2_AbstractRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackHorizontalPlaneGeometryPatch(self, zCoordinate: "double", localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_PlaneSetRepresentation_pushBackHorizontalPlaneGeometryPatch(self, zCoordinate, localCrs)

    def pushBackTiltedPlaneGeometryPatch(self, x1: "double", y1: "double", z1: "double", x2: "double", y2: "double", z2: "double", x3: "double", y3: "double", z3: "double", localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_PlaneSetRepresentation_pushBackTiltedPlaneGeometryPatch(self, x1, y1, z1, x2, y2, z2, x3, y3, z3, localCrs)
    __swig_destroy__ = _fesapi.delete_Resqml2_PlaneSetRepresentation

# Register Resqml2_PlaneSetRepresentation in _fesapi:
_fesapi.Resqml2_PlaneSetRepresentation_swigregister(Resqml2_PlaneSetRepresentation)
class Resqml2_PolylineRepresentation(Resqml2_AbstractRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setGeometry(self, points: "double *", pointCount: "unsigned int", proxy: "Eml2_AbstractHdfProxy"=None, localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_PolylineRepresentation_setGeometry(self, points, pointCount, proxy, localCrs)

    def isClosed(self) -> "bool":
        return _fesapi.Resqml2_PolylineRepresentation_isClosed(self)

    def hasALineRole(self) -> "bool":
        return _fesapi.Resqml2_PolylineRepresentation_hasALineRole(self)

    def getLineRole(self) -> "gsoap_eml2_3::resqml22__LineRole":
        return _fesapi.Resqml2_PolylineRepresentation_getLineRole(self)

    def setLineRole(self, lineRole: "gsoap_eml2_3::resqml22__LineRole") -> "void":
        return _fesapi.Resqml2_PolylineRepresentation_setLineRole(self, lineRole)
    __swig_destroy__ = _fesapi.delete_Resqml2_PolylineRepresentation

# Register Resqml2_PolylineRepresentation in _fesapi:
_fesapi.Resqml2_PolylineRepresentation_swigregister(Resqml2_PolylineRepresentation)
class Resqml2_TriangulatedSetRepresentation(Resqml2_AbstractSurfaceRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getTriangleCountOfPatch(self, patchIndex: "unsigned int") -> "uint64_t":
        return _fesapi.Resqml2_TriangulatedSetRepresentation_getTriangleCountOfPatch(self, patchIndex)

    def getTriangleCountOfAllPatches(self) -> "uint64_t":
        return _fesapi.Resqml2_TriangulatedSetRepresentation_getTriangleCountOfAllPatches(self)

    def getTriangleNodeIndicesOfPatch(self, patchIndex: "unsigned int", triangleNodeIndices: "unsigned int *") -> "void":
        return _fesapi.Resqml2_TriangulatedSetRepresentation_getTriangleNodeIndicesOfPatch(self, patchIndex, triangleNodeIndices)

    def getTriangleNodeIndicesOfAllPatches(self, triangleNodeIndices: "unsigned int *") -> "void":
        return _fesapi.Resqml2_TriangulatedSetRepresentation_getTriangleNodeIndicesOfAllPatches(self, triangleNodeIndices)

    def pushBackTrianglePatch(self, nodeCount: "unsigned int", nodes: "double *", triangleCount: "unsigned int", triangleNodeIndices: "unsigned int *", proxy: "Eml2_AbstractHdfProxy"=None, localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_TriangulatedSetRepresentation_pushBackTrianglePatch(self, nodeCount, nodes, triangleCount, triangleNodeIndices, proxy, localCrs)
    __swig_destroy__ = _fesapi.delete_Resqml2_TriangulatedSetRepresentation

# Register Resqml2_TriangulatedSetRepresentation in _fesapi:
_fesapi.Resqml2_TriangulatedSetRepresentation_swigregister(Resqml2_TriangulatedSetRepresentation)
class Resqml2_RepresentationSetRepresentation(Resqml2_AbstractRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def isHomogeneous(self) -> "bool":
        return _fesapi.Resqml2_RepresentationSetRepresentation_isHomogeneous(self)

    def getRepresentationCount(self) -> "uint64_t":
        return _fesapi.Resqml2_RepresentationSetRepresentation_getRepresentationCount(self)

    def getRepresentation(self, index: "uint64_t") -> "resqml2::AbstractRepresentation *":
        return _fesapi.Resqml2_RepresentationSetRepresentation_getRepresentation(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_RepresentationSetRepresentation

# Register Resqml2_RepresentationSetRepresentation in _fesapi:
_fesapi.Resqml2_RepresentationSetRepresentation_swigregister(Resqml2_RepresentationSetRepresentation)
class Resqml2_AbstractSurfaceFrameworkRepresentation(Resqml2_RepresentationSetRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractSurfaceFrameworkRepresentation

# Register Resqml2_AbstractSurfaceFrameworkRepresentation in _fesapi:
_fesapi.Resqml2_AbstractSurfaceFrameworkRepresentation_swigregister(Resqml2_AbstractSurfaceFrameworkRepresentation)
class Resqml2_NonSealedSurfaceFrameworkRepresentation(Resqml2_AbstractSurfaceFrameworkRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackNonSealedContactRepresentation(self, pointCount: "unsigned int", points: "double *", proxy: "Eml2_AbstractHdfProxy"=None, localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_NonSealedSurfaceFrameworkRepresentation_pushBackNonSealedContactRepresentation(self, pointCount, points, proxy, localCrs)
    __swig_destroy__ = _fesapi.delete_Resqml2_NonSealedSurfaceFrameworkRepresentation

# Register Resqml2_NonSealedSurfaceFrameworkRepresentation in _fesapi:
_fesapi.Resqml2_NonSealedSurfaceFrameworkRepresentation_swigregister(Resqml2_NonSealedSurfaceFrameworkRepresentation)
class Resqml2_SubRepresentation(Resqml2_AbstractRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackSubRepresentationPatch(self, *args) -> "void":
        r"""
        *Overload 1:*

        Pushes back a new patch (without pairwise elements) in this sub-representation.
        The pushed patch is uninitialized and values must be set to this new patch afterwards.

        :type elementKind: int
        :param elementKind:				The kind of (indexable) elements which constitutes the
            										sub-representation patch.
        :param [in]:	elementIndices			The indices of the elements in the supporting
            										representation.
        :param [in]:	proxy					The HDF proxy where the numerical values (indices)
            										are stored.

        |

        *Overload 2:*

        Pushes back a new patch (without pairwise elements) in this sub-representation.
        The pushed patch is uninitialized and values must be set to this new patch afterwards.

        :type elementKind: int
        :param elementKind:				The kind of (indexable) elements which constitutes the
            										sub-representation patch.
        :param [in]:	elementIndices			The indices of the elements in the supporting
            										representation.
        :param [in]:	proxy					The HDF proxy where the numerical values (indices)
            										are stored.
        """
        return _fesapi.Resqml2_SubRepresentation_pushBackSubRepresentationPatch(self, *args)

    def setElementIndices(self, *args) -> "void":
        r"""
        Set the element indices of an already created SubRepresentationPatch

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.
        :raises: std::out_of_range	 	If ``patchIndex`` is strictly greater than patch count and
            										different from unsigned int maximum value.

        :param [in]:	  	elementIndices		  	All the element indices to set in the already created SubRepresentationPatch.
        :type elementCount: int
        :param elementCount:			The number of elements to write.
        :type offset: int
        :param offset:	  				The offset value.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the element
            											indices. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default value), a default HDF proxy must be defined
            											into the data object repository.
        :type patchIndex: int, optional
        :param patchIndex:			  	(Optional) Zero-based index of the patch where to
            											write the element indices. If not provided, its
            											default value is by convention set to unsigned int
            											maximum value and the element indices will be written
            											in the last subrepresentation patch (the one with the
            											greatest index).
        """
        return _fesapi.Resqml2_SubRepresentation_setElementIndices(self, *args)

    def areElementIndicesPairwise(self, patchIndex: "unsigned int") -> "bool":
        return _fesapi.Resqml2_SubRepresentation_areElementIndicesPairwise(self, patchIndex)

    def areElementIndicesBasedOnLattice(self, patchIndex: "unsigned int", elementIndicesIndex: "unsigned int"=0) -> "bool":
        return _fesapi.Resqml2_SubRepresentation_areElementIndicesBasedOnLattice(self, patchIndex, elementIndicesIndex)

    def getLatticeElementIndicesStartValue(self, patchIndex: "unsigned int", elementIndicesIndex: "unsigned int"=0) -> "int64_t":
        return _fesapi.Resqml2_SubRepresentation_getLatticeElementIndicesStartValue(self, patchIndex, elementIndicesIndex)

    def getLatticeElementIndicesDimensionCount(self, patchIndex: "unsigned int", elementIndicesIndex: "unsigned int"=0) -> "uint64_t":
        return _fesapi.Resqml2_SubRepresentation_getLatticeElementIndicesDimensionCount(self, patchIndex, elementIndicesIndex)

    def getLatticeElementIndicesOffsetValue(self, latticeDimensionIndex: "unsigned int", patchIndex: "unsigned int", elementIndicesIndex: "unsigned int"=0) -> "int64_t":
        return _fesapi.Resqml2_SubRepresentation_getLatticeElementIndicesOffsetValue(self, latticeDimensionIndex, patchIndex, elementIndicesIndex)

    def getLatticeElementIndicesOffsetCount(self, latticeDimensionIndex: "unsigned int", patchIndex: "unsigned int", elementIndicesIndex: "unsigned int"=0) -> "uint64_t":
        return _fesapi.Resqml2_SubRepresentation_getLatticeElementIndicesOffsetCount(self, latticeDimensionIndex, patchIndex, elementIndicesIndex)

    def getElementKindOfPatch(self, patchIndex: "unsigned int", elementIndicesIndex: "unsigned int") -> "gsoap_eml2_3::eml23__IndexableElement":
        return _fesapi.Resqml2_SubRepresentation_getElementKindOfPatch(self, patchIndex, elementIndicesIndex)

    def getElementCountOfPatch(self, patchIndex: "unsigned int") -> "uint64_t":
        return _fesapi.Resqml2_SubRepresentation_getElementCountOfPatch(self, patchIndex)

    def getElementIndicesOfPatch(self, patchIndex: "unsigned int", elementIndicesIndex: "unsigned int", elementIndices: "uint64_t *") -> "void":
        return _fesapi.Resqml2_SubRepresentation_getElementIndicesOfPatch(self, patchIndex, elementIndicesIndex, elementIndices)

    def pushBackSupportingRepresentation(self, supportingRep: "Resqml2_AbstractRepresentation") -> "void":
        return _fesapi.Resqml2_SubRepresentation_pushBackSupportingRepresentation(self, supportingRep)

    def getSupportingRepresentationCount(self) -> "uint64_t":
        return _fesapi.Resqml2_SubRepresentation_getSupportingRepresentationCount(self)

    def getSupportingRepresentation(self, index: "uint64_t") -> "resqml2::AbstractRepresentation *":
        return _fesapi.Resqml2_SubRepresentation_getSupportingRepresentation(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_SubRepresentation

# Register Resqml2_SubRepresentation in _fesapi:
_fesapi.Resqml2_SubRepresentation_swigregister(Resqml2_SubRepresentation)
class Resqml2_SealedSurfaceFrameworkRepresentation(Resqml2_AbstractSurfaceFrameworkRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_SealedSurfaceFrameworkRepresentation

# Register Resqml2_SealedSurfaceFrameworkRepresentation in _fesapi:
_fesapi.Resqml2_SealedSurfaceFrameworkRepresentation_swigregister(Resqml2_SealedSurfaceFrameworkRepresentation)
class Resqml2_SealedVolumeFrameworkRepresentation(Resqml2_RepresentationSetRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getSealedStructuralFramework(self) -> "resqml2::SealedSurfaceFrameworkRepresentation *":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_getSealedStructuralFramework(self)

    def setSealedSurfaceFramework(self, ssf: "Resqml2_SealedSurfaceFrameworkRepresentation") -> "void":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_setSealedSurfaceFramework(self, ssf)

    def setInterpretationOfVolumeRegion(self, regionindex: "uint64_t", stratiUnitInterp: "Resqml2_StratigraphicUnitInterpretation") -> "void":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_setInterpretationOfVolumeRegion(self, regionindex, stratiUnitInterp)

    def pushBackVolumeRegion(self, stratiUnitInterp: "Resqml2_StratigraphicUnitInterpretation", externalShellFaceCount: "unsigned int", faceRepresentationIndices: "unsigned int const *", faceRepPatchIndices: "unsigned int const *", faceSide: "bool const *") -> "void":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_pushBackVolumeRegion(self, stratiUnitInterp, externalShellFaceCount, faceRepresentationIndices, faceRepPatchIndices, faceSide)

    def getStratiUnitInterp(self, regionIndex: "uint64_t") -> "resqml2::StratigraphicUnitInterpretation *":
        r"""
        Gets the stratigraphic unit interpretation a particular region of this framework represents.

        :raises: std::out_of_range	 	If regionIndex >= getRegionCount().

        :type regionIndex: int
        :param regionIndex:	Zero-based index of the region.

        :rtype: :py:class:`StratigraphicUnitInterpretation`
        :return: The stratigraphic unit interpretation represented by the region at position ``regionIndex``.
        """
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_getStratiUnitInterp(self, regionIndex)

    def getRegionCount(self) -> "uint64_t":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_getRegionCount(self)

    def getInternalShellCount(self, regionindex: "uint64_t") -> "uint64_t":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_getInternalShellCount(self, regionindex)

    def getFaceCountOfExternalShell(self, regionindex: "uint64_t") -> "uint64_t":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_getFaceCountOfExternalShell(self, regionindex)

    def getFaceCountOfInternalShell(self, regionindex: "uint64_t", internalShellIndex: "unsigned int") -> "uint64_t":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_getFaceCountOfInternalShell(self, regionindex, internalShellIndex)

    def getRepOfExternalShellFace(self, regionindex: "uint64_t", faceIndex: "unsigned int") -> "resqml2::AbstractRepresentation *":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_getRepOfExternalShellFace(self, regionindex, faceIndex)

    def getRepOfInternalShellFace(self, regionindex: "uint64_t", internalShellIndex: "unsigned int", faceIndex: "unsigned int") -> "resqml2::AbstractRepresentation *":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_getRepOfInternalShellFace(self, regionindex, internalShellIndex, faceIndex)

    def getRepPatchIndexOfExternalShellFace(self, regionindex: "uint64_t", faceIndex: "unsigned int") -> "uint64_t":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_getRepPatchIndexOfExternalShellFace(self, regionindex, faceIndex)

    def getRepPatchIndexOfInternalShellFace(self, regionindex: "uint64_t", internalShellIndex: "unsigned int", faceIndex: "unsigned int") -> "uint64_t":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_getRepPatchIndexOfInternalShellFace(self, regionindex, internalShellIndex, faceIndex)

    def getSideFlagOfExternalShellFace(self, regionindex: "uint64_t", faceIndex: "unsigned int") -> "bool":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_getSideFlagOfExternalShellFace(self, regionindex, faceIndex)

    def getSideFlagOfInternalShellFace(self, regionindex: "uint64_t", internalShellIndex: "unsigned int", faceIndex: "unsigned int") -> "bool":
        return _fesapi.Resqml2_SealedVolumeFrameworkRepresentation_getSideFlagOfInternalShellFace(self, regionindex, internalShellIndex, faceIndex)
    __swig_destroy__ = _fesapi.delete_Resqml2_SealedVolumeFrameworkRepresentation

# Register Resqml2_SealedVolumeFrameworkRepresentation in _fesapi:
_fesapi.Resqml2_SealedVolumeFrameworkRepresentation_swigregister(Resqml2_SealedVolumeFrameworkRepresentation)
class Resqml2_AbstractGridRepresentation(Resqml2_AbstractRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getGridConnectionSetRepresentationCount(self) -> "uint64_t":
        r"""
        Gets the count of grid connection set representations associated to this grid instance.

        :raises: std::range_error	If the count of grid connection set representations is
            									strictly greater than unsigned int max.

        :rtype: int
        :return: The count of grid connection set representations associated to this grid instance.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getGridConnectionSetRepresentationCount(self)

    def getGridConnectionSetRepresentation(self, index: "uint64_t") -> "resqml2::GridConnectionSetRepresentation *":
        r"""
        Gets a particular grid connection set representation associated to this grid representation.

        :raises: std::out_of_range	If ``index`` is out of range (greater than {getGridConnectionSetRepresentationCount()}).

        :type index: int
        :param index:	Zero-based index of the grid connection set representation we look for.

        :rtype: :py:class:`GridConnectionSetRepresentation`
        :return: The grid connection set representation at position ``index``.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getGridConnectionSetRepresentation(self, index)

    def getCellCount(self) -> "uint64_t":
        r"""
        Gets the total count of cells in the grid.

        :raises: std::logic_error	If this grid is partial.
        :raises: std::range_error	If the count is strictly greater than unsigned int max.

        :rtype: int
        :return: The total count of cells in the grid.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getCellCount(self)

    def getParentGrid(self) -> "resqml2::AbstractGridRepresentation *":
        r"""
        Gets the parent grid of this grid.

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::logic_error	If the parent window of this grid is neither an IJK, column
            									layer nor cell window.

        :rtype: :py:class:`AbstractGridRepresentation`
        :return: nullptr if this grid is not a child grid (not an LGR), otherwise the parent grid.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getParentGrid(self)

    def getChildGridCount(self) -> "uint64_t":
        r"""
        Gets the count of child grids of this grid.

        :raises: std::range_error	If the count of child grids is strictly greater than unsigned
            									int max.

        :rtype: int
        :return: The count of child grids of this grid.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getChildGridCount(self)

    def getChildGrid(self, index: "uint64_t") -> "resqml2::AbstractGridRepresentation *":
        r"""
        Gets a particular child grid of this grid.

        :raises: std::out_of_range	If index >= getChildGridCount().

        :type index: int
        :param index:	Zero-based index of the the child grid we look for.

        :rtype: :py:class:`AbstractGridRepresentation`
        :return: The child grid at position ``index``.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getChildGrid(self, index)

    def setParentWindow(self, *args) -> "void":
        r"""
        *Overload 1:*

        Indicates that this grid takes place into another unstructured parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``cellIndexCount`` is 0 or ``cellIndices`` is nullptr or
            										``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If cellIndexCount > 1 and ``proxy`` is
            										nullptr and no default HDF proxy is defined in the
            										repository.

        :param [in]:	  	cellIndices   	Identifies the cells (of the parent grid) which are regridded.
        :type cellIndexCount: int
        :param cellIndexCount:	Identifies the count of cells (of the parent grid) which are
            									regridded.
        :param [in]:	  	parentGrid	  	The parent grid which is regridded.
        :param [in,out]:	proxy		  	(Optional) The HDF proxy where to store the numerical values.
            									If nullptr (default), then the proxy will be the default
            									proxy of the repository. This parameter is unused if
            ``cellIndexCount`` is 1 since no numerical value need to be store
            									in an HDF proxy (pure XML).

        |

        *Overload 2:*

        Indicates that this grid takes place into another column layer parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``columnIndices`` is nullptr or ``columnIndexCount`` is
            										0 or
            										``childCellCountPerInterval`` is nullptr or
            ``parentCellCountPerInterval`` is nullptr or ``intervalCount``
            										is 0 or ``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :param [in]:	  	columnIndices			  	Identifies the columns (of the parent grid) which
            												are regridded. The size is ``columnIndexCount``.
        :type columnIndexCount: int
        :param columnIndexCount:		  	Identifies the count of columns (of the parent
            												grid) which are regridded.
        :type kLayerIndexRegridStart: int
        :param kLayerIndexRegridStart:	  	K index of the first K layer of all above parent
            												grid columns to be regridded.
        :param [in]:	  	childCellCountPerInterval 	The count of cells per K interval in this (child)
            												grid. The size is ``intervalCount``.
        :param [in]:	  	parentCellCountPerInterval	The count of cells per K interval in the parent
            												grid. The size is ``intervalCount``.
        :type intervalCount: int
        :param intervalCount:			  	The count of intervals on K dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others. Intervals are the same
            												for all the regridded columns.
        :param [in]:	  	parentGrid				  	The parent grid which is regridded.
        :param [in,out]:	proxy					  	(Optional) The HDF proxy where to store the
            												numerical values. If nullptr (default), then the
            												proxy will be the default proxy of the
            												repository. This parameter is unused if no
            												numerical value need to be store in an HDF proxy
            												(pure XML).
        :param [in]:	  	childCellWeights		  	(Optional) The weights that are proportional to
            												the relative K sizes of child cells within each K
            												interval. This is useful to set up child cells of
            												different K sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on K dimension (sum of child cells
            												per interval). Default value is nullptr.

        |

        *Overload 3:*

        Indicates that this grid takes place into another column layer parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``columnIndices`` is nullptr or ``columnIndexCount`` is
            										0 or
            										``childCellCountPerInterval`` is nullptr or
            ``parentCellCountPerInterval`` is nullptr or ``intervalCount``
            										is 0 or ``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :param [in]:	  	columnIndices			  	Identifies the columns (of the parent grid) which
            												are regridded. The size is ``columnIndexCount``.
        :type columnIndexCount: int
        :param columnIndexCount:		  	Identifies the count of columns (of the parent
            												grid) which are regridded.
        :type kLayerIndexRegridStart: int
        :param kLayerIndexRegridStart:	  	K index of the first K layer of all above parent
            												grid columns to be regridded.
        :param [in]:	  	childCellCountPerInterval 	The count of cells per K interval in this (child)
            												grid. The size is ``intervalCount``.
        :param [in]:	  	parentCellCountPerInterval	The count of cells per K interval in the parent
            												grid. The size is ``intervalCount``.
        :type intervalCount: int
        :param intervalCount:			  	The count of intervals on K dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others. Intervals are the same
            												for all the regridded columns.
        :param [in]:	  	parentGrid				  	The parent grid which is regridded.
        :param [in,out]:	proxy					  	(Optional) The HDF proxy where to store the
            												numerical values. If nullptr (default), then the
            												proxy will be the default proxy of the
            												repository. This parameter is unused if no
            												numerical value need to be store in an HDF proxy
            												(pure XML).
        :param [in]:	  	childCellWeights		  	(Optional) The weights that are proportional to
            												the relative K sizes of child cells within each K
            												interval. This is useful to set up child cells of
            												different K sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on K dimension (sum of child cells
            												per interval). Default value is nullptr.

        |

        *Overload 4:*

        Indicates that this grid takes place into another column layer parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``columnIndices`` is nullptr or ``columnIndexCount`` is
            										0 or
            										``childCellCountPerInterval`` is nullptr or
            ``parentCellCountPerInterval`` is nullptr or ``intervalCount``
            										is 0 or ``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :param [in]:	  	columnIndices			  	Identifies the columns (of the parent grid) which
            												are regridded. The size is ``columnIndexCount``.
        :type columnIndexCount: int
        :param columnIndexCount:		  	Identifies the count of columns (of the parent
            												grid) which are regridded.
        :type kLayerIndexRegridStart: int
        :param kLayerIndexRegridStart:	  	K index of the first K layer of all above parent
            												grid columns to be regridded.
        :param [in]:	  	childCellCountPerInterval 	The count of cells per K interval in this (child)
            												grid. The size is ``intervalCount``.
        :param [in]:	  	parentCellCountPerInterval	The count of cells per K interval in the parent
            												grid. The size is ``intervalCount``.
        :type intervalCount: int
        :param intervalCount:			  	The count of intervals on K dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others. Intervals are the same
            												for all the regridded columns.
        :param [in]:	  	parentGrid				  	The parent grid which is regridded.
        :param [in,out]:	proxy					  	(Optional) The HDF proxy where to store the
            												numerical values. If nullptr (default), then the
            												proxy will be the default proxy of the
            												repository. This parameter is unused if no
            												numerical value need to be store in an HDF proxy
            												(pure XML).
        :param [in]:	  	childCellWeights		  	(Optional) The weights that are proportional to
            												the relative K sizes of child cells within each K
            												interval. This is useful to set up child cells of
            												different K sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on K dimension (sum of child cells
            												per interval). Default value is nullptr.

        |

        *Overload 5:*

        Indicates that this grid takes place into another IJK parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``childCellCountPerIInterval`` is nullptr or
            ``parentCellCountPerIInterval`` is nullptr or
            ``iIntervalCount`` is 0 or ``childCellCountPerJInterval`` is
            										nullptr or ``parentCellCountPerJInterval`` is nullptr or
            										``jIntervalCount`` is 0 or ``childCellCountPerKInterval``
            										is nullptr or ``parentCellCountPerKInterval`` is nullptr
            										or ``kIntervalCount`` is 0 or ``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:	   	I index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerIInterval 	The count of cells per I interval in this (child)
            												grid. The size is ``iIntervalCount``.
        :param [in]:	  	parentCellCountPerIInterval	The count of cells per I interval in the parent
            												grid. The size is ``iIntervalCount``.
        :type iIntervalCount: int
        :param iIntervalCount:			   	The count of intervals on I dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:	   	J index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerJInterval 	The count of cells per J interval in this (child)
            												grid. The size is ``jIntervalCount``.
        :param [in]:	  	parentCellCountPerJInterval	The count of cells per J interval in the parent
            												grid. The size is ``jIntervalCount``.
        :type jIntervalCount: int
        :param jIntervalCount:			   	The count of intervals on J dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:	   	K index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerKInterval 	The count of cells per K interval in this (child)
            												grid. The size is ``kIntervalCount``.
        :param [in]:	  	parentCellCountPerKInterval	The count of cells per K interval in the parent
            												grid. The size is ``kIntervalCount``.
        :type kIntervalCount: int
        :param kIntervalCount:			   	The count of intervals on K dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :param [in]:	  	parentGrid				   	The parent grid which is regridded.
        :param [in,out]:	proxy					   	(Optional) The HDF proxy where to store the
            												numerical values. If nullptr (default), then the
            												proxy will be the default proxy of the
            												repository. This parameter is unused if no
            												numerical value need to be store in an HDF proxy
            												(pure XML).
        :param [in]:	  	iChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative I sizes of child cells within each I
            												interval. This is useful to set up child cells of
            												different I sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on I dimension (sum of child cells
            												per interval). Default value is nullptr.
        :param [in]:	  	jChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative J sizes of child cells within each J
            												interval. This is useful to set up child cells of
            												different J sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on J dimension (sum of child cells
            												per interval). Default value is nullptr.
        :param [in]:	  	kChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative K sizes of child cells within each K
            												interval. This is useful to set up child cells of
            												different K sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on K dimension (sum of child cells
            												per interval). Default value is nullptr.

        |

        *Overload 6:*

        Indicates that this grid takes place into another IJK parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``childCellCountPerIInterval`` is nullptr or
            ``parentCellCountPerIInterval`` is nullptr or
            ``iIntervalCount`` is 0 or ``childCellCountPerJInterval`` is
            										nullptr or ``parentCellCountPerJInterval`` is nullptr or
            										``jIntervalCount`` is 0 or ``childCellCountPerKInterval``
            										is nullptr or ``parentCellCountPerKInterval`` is nullptr
            										or ``kIntervalCount`` is 0 or ``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:	   	I index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerIInterval 	The count of cells per I interval in this (child)
            												grid. The size is ``iIntervalCount``.
        :param [in]:	  	parentCellCountPerIInterval	The count of cells per I interval in the parent
            												grid. The size is ``iIntervalCount``.
        :type iIntervalCount: int
        :param iIntervalCount:			   	The count of intervals on I dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:	   	J index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerJInterval 	The count of cells per J interval in this (child)
            												grid. The size is ``jIntervalCount``.
        :param [in]:	  	parentCellCountPerJInterval	The count of cells per J interval in the parent
            												grid. The size is ``jIntervalCount``.
        :type jIntervalCount: int
        :param jIntervalCount:			   	The count of intervals on J dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:	   	K index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerKInterval 	The count of cells per K interval in this (child)
            												grid. The size is ``kIntervalCount``.
        :param [in]:	  	parentCellCountPerKInterval	The count of cells per K interval in the parent
            												grid. The size is ``kIntervalCount``.
        :type kIntervalCount: int
        :param kIntervalCount:			   	The count of intervals on K dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :param [in]:	  	parentGrid				   	The parent grid which is regridded.
        :param [in,out]:	proxy					   	(Optional) The HDF proxy where to store the
            												numerical values. If nullptr (default), then the
            												proxy will be the default proxy of the
            												repository. This parameter is unused if no
            												numerical value need to be store in an HDF proxy
            												(pure XML).
        :param [in]:	  	iChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative I sizes of child cells within each I
            												interval. This is useful to set up child cells of
            												different I sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on I dimension (sum of child cells
            												per interval). Default value is nullptr.
        :param [in]:	  	jChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative J sizes of child cells within each J
            												interval. This is useful to set up child cells of
            												different J sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on J dimension (sum of child cells
            												per interval). Default value is nullptr.
        :param [in]:	  	kChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative K sizes of child cells within each K
            												interval. This is useful to set up child cells of
            												different K sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on K dimension (sum of child cells
            												per interval). Default value is nullptr.

        |

        *Overload 7:*

        Indicates that this grid takes place into another IJK parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``childCellCountPerIInterval`` is nullptr or
            ``parentCellCountPerIInterval`` is nullptr or
            ``iIntervalCount`` is 0 or ``childCellCountPerJInterval`` is
            										nullptr or ``parentCellCountPerJInterval`` is nullptr or
            										``jIntervalCount`` is 0 or ``childCellCountPerKInterval``
            										is nullptr or ``parentCellCountPerKInterval`` is nullptr
            										or ``kIntervalCount`` is 0 or ``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:	   	I index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerIInterval 	The count of cells per I interval in this (child)
            												grid. The size is ``iIntervalCount``.
        :param [in]:	  	parentCellCountPerIInterval	The count of cells per I interval in the parent
            												grid. The size is ``iIntervalCount``.
        :type iIntervalCount: int
        :param iIntervalCount:			   	The count of intervals on I dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:	   	J index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerJInterval 	The count of cells per J interval in this (child)
            												grid. The size is ``jIntervalCount``.
        :param [in]:	  	parentCellCountPerJInterval	The count of cells per J interval in the parent
            												grid. The size is ``jIntervalCount``.
        :type jIntervalCount: int
        :param jIntervalCount:			   	The count of intervals on J dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:	   	K index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerKInterval 	The count of cells per K interval in this (child)
            												grid. The size is ``kIntervalCount``.
        :param [in]:	  	parentCellCountPerKInterval	The count of cells per K interval in the parent
            												grid. The size is ``kIntervalCount``.
        :type kIntervalCount: int
        :param kIntervalCount:			   	The count of intervals on K dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :param [in]:	  	parentGrid				   	The parent grid which is regridded.
        :param [in,out]:	proxy					   	(Optional) The HDF proxy where to store the
            												numerical values. If nullptr (default), then the
            												proxy will be the default proxy of the
            												repository. This parameter is unused if no
            												numerical value need to be store in an HDF proxy
            												(pure XML).
        :param [in]:	  	iChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative I sizes of child cells within each I
            												interval. This is useful to set up child cells of
            												different I sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on I dimension (sum of child cells
            												per interval). Default value is nullptr.
        :param [in]:	  	jChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative J sizes of child cells within each J
            												interval. This is useful to set up child cells of
            												different J sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on J dimension (sum of child cells
            												per interval). Default value is nullptr.
        :param [in]:	  	kChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative K sizes of child cells within each K
            												interval. This is useful to set up child cells of
            												different K sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on K dimension (sum of child cells
            												per interval). Default value is nullptr.

        |

        *Overload 8:*

        Indicates that this grid takes place into another IJK parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``childCellCountPerIInterval`` is nullptr or
            ``parentCellCountPerIInterval`` is nullptr or
            ``iIntervalCount`` is 0 or ``childCellCountPerJInterval`` is
            										nullptr or ``parentCellCountPerJInterval`` is nullptr or
            										``jIntervalCount`` is 0 or ``childCellCountPerKInterval``
            										is nullptr or ``parentCellCountPerKInterval`` is nullptr
            										or ``kIntervalCount`` is 0 or ``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:	   	I index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerIInterval 	The count of cells per I interval in this (child)
            												grid. The size is ``iIntervalCount``.
        :param [in]:	  	parentCellCountPerIInterval	The count of cells per I interval in the parent
            												grid. The size is ``iIntervalCount``.
        :type iIntervalCount: int
        :param iIntervalCount:			   	The count of intervals on I dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:	   	J index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerJInterval 	The count of cells per J interval in this (child)
            												grid. The size is ``jIntervalCount``.
        :param [in]:	  	parentCellCountPerJInterval	The count of cells per J interval in the parent
            												grid. The size is ``jIntervalCount``.
        :type jIntervalCount: int
        :param jIntervalCount:			   	The count of intervals on J dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:	   	K index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerKInterval 	The count of cells per K interval in this (child)
            												grid. The size is ``kIntervalCount``.
        :param [in]:	  	parentCellCountPerKInterval	The count of cells per K interval in the parent
            												grid. The size is ``kIntervalCount``.
        :type kIntervalCount: int
        :param kIntervalCount:			   	The count of intervals on K dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :param [in]:	  	parentGrid				   	The parent grid which is regridded.
        :param [in,out]:	proxy					   	(Optional) The HDF proxy where to store the
            												numerical values. If nullptr (default), then the
            												proxy will be the default proxy of the
            												repository. This parameter is unused if no
            												numerical value need to be store in an HDF proxy
            												(pure XML).
        :param [in]:	  	iChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative I sizes of child cells within each I
            												interval. This is useful to set up child cells of
            												different I sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on I dimension (sum of child cells
            												per interval). Default value is nullptr.
        :param [in]:	  	jChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative J sizes of child cells within each J
            												interval. This is useful to set up child cells of
            												different J sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on J dimension (sum of child cells
            												per interval). Default value is nullptr.
        :param [in]:	  	kChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative K sizes of child cells within each K
            												interval. This is useful to set up child cells of
            												different K sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on K dimension (sum of child cells
            												per interval). Default value is nullptr.

        |

        *Overload 9:*

        Indicates that this grid takes place into another IJK parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``childCellCountPerIInterval`` is nullptr or
            ``parentCellCountPerIInterval`` is nullptr or
            ``iIntervalCount`` is 0 or ``childCellCountPerJInterval`` is
            										nullptr or ``parentCellCountPerJInterval`` is nullptr or
            										``jIntervalCount`` is 0 or ``childCellCountPerKInterval``
            										is nullptr or ``parentCellCountPerKInterval`` is nullptr
            										or ``kIntervalCount`` is 0 or ``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:	   	I index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerIInterval 	The count of cells per I interval in this (child)
            												grid. The size is ``iIntervalCount``.
        :param [in]:	  	parentCellCountPerIInterval	The count of cells per I interval in the parent
            												grid. The size is ``iIntervalCount``.
        :type iIntervalCount: int
        :param iIntervalCount:			   	The count of intervals on I dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:	   	J index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerJInterval 	The count of cells per J interval in this (child)
            												grid. The size is ``jIntervalCount``.
        :param [in]:	  	parentCellCountPerJInterval	The count of cells per J interval in the parent
            												grid. The size is ``jIntervalCount``.
        :type jIntervalCount: int
        :param jIntervalCount:			   	The count of intervals on J dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:	   	K index of the first parent grid cell to be
            												regridded.
        :param [in]:	  	childCellCountPerKInterval 	The count of cells per K interval in this (child)
            												grid. The size is ``kIntervalCount``.
        :param [in]:	  	parentCellCountPerKInterval	The count of cells per K interval in the parent
            												grid. The size is ``kIntervalCount``.
        :type kIntervalCount: int
        :param kIntervalCount:			   	The count of intervals on K dimension. Intervals
            												are portions of cells to regrid which does not
            												overlap with each others.
        :param [in]:	  	parentGrid				   	The parent grid which is regridded.
        :param [in,out]:	proxy					   	(Optional) The HDF proxy where to store the
            												numerical values. If nullptr (default), then the
            												proxy will be the default proxy of the
            												repository. This parameter is unused if no
            												numerical value need to be store in an HDF proxy
            												(pure XML).
        :param [in]:	  	iChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative I sizes of child cells within each I
            												interval. This is useful to set up child cells of
            												different I sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on I dimension (sum of child cells
            												per interval). Default value is nullptr.
        :param [in]:	  	jChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative J sizes of child cells within each J
            												interval. This is useful to set up child cells of
            												different J sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on J dimension (sum of child cells
            												per interval). Default value is nullptr.
        :param [in]:	  	kChildCellWeights		   	(Optional) The weights that are proportional to
            												the relative K sizes of child cells within each K
            												interval. This is useful to set up child cells of
            												different K sizes inside the intervals. The
            												weights need not to be normalized. The count of
            												double values must be equal to the count of all
            												child cells on K dimension (sum of child cells
            												per interval). Default value is nullptr.

        |

        *Overload 10:*

        Indicates that this grid takes place into another IJK parent grid. This method
        			assumes that the count of cells per regrid interval is constant in both child and
        			parent grids.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``constantChildCellCountPerIInterval`` is 0 or
            ``constantParentCellCountPerIInterval`` is 0 or
            ``iIntervalCount`` is 0 or
            										``constantChildCellCountPerJInterval`` is 0 or
            ``constantParentCellCountPerJInterval`` is 0 or
            ``jIntervalCount`` is 0 or
            										``constantChildCellCountPerKInterval`` is 0 or
            ``constantParentCellCountPerKInterval`` is 0 or
            ``kIntervalCount`` is 0 or
            										``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:			   	I index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerIInterval: int
        :param constantChildCellCountPerIInterval: 	The constant count of cells per I
            														interval in this (child) grid.
        :type constantParentCellCountPerIInterval: int
        :param constantParentCellCountPerIInterval:	The constant count of cells per I
            														interval in the parent grid.
        :type iIntervalCount: int
        :param iIntervalCount:					   	The count of intervals on I dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:			   	J index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerJInterval: int
        :param constantChildCellCountPerJInterval: 	The constant count of cells per J
            														interval in this (child) grid.
        :type constantParentCellCountPerJInterval: int
        :param constantParentCellCountPerJInterval:	The constant count of cells per J
            														interval in the parent grid.
        :type jIntervalCount: int
        :param jIntervalCount:					   	The count of intervals on J dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:			   	K index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerKInterval: int
        :param constantChildCellCountPerKInterval: 	The constant count of cells per K
            														interval in this (child) grid.
        :type constantParentCellCountPerKInterval: int
        :param constantParentCellCountPerKInterval:	The constant count of cells per K
            														interval in the parent grid.
        :type kIntervalCount: int
        :param kIntervalCount:					   	The count of intervals on K dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :param [in]:	  	parentGrid						   	The parent grid which is regridded.
        :param [in,out]:	proxy							   	(Optional) The HDF proxy where to store
            														the numerical values. If nullptr
            														(default), then the proxy will be the
            														default proxy of the repository. This
            														parameter is unused if no numerical value
            														need to be store in an HDF proxy (pure
            														XML).
        :param [in]:	  	iChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative I sizes of
            														child cells within each I interval. This
            														is useful to set up child cells of
            														different I sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on I
            														dimension
            														(constantChildCellCountPerIInterval *
            														iIntervalCount). Default value is
            														nullptr.
        :param [in]:	  	jChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative J sizes of
            														child cells within each J interval. This
            														is useful to set up child cells of
            														different J sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on J
            														dimension
            														(constantChildCellCountPerJInterval
            														* jIntervalCount).
        :param [in]:	  	kChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative K sizes of
            														child cells within each K interval. This
            														is useful to set up child cells of
            														different K sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on K
            														dimension
            														(constantChildCellCountPerKInterval
            														* kIntervalCount).

        |

        *Overload 11:*

        Indicates that this grid takes place into another IJK parent grid. This method
        			assumes that the count of cells per regrid interval is constant in both child and
        			parent grids.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``constantChildCellCountPerIInterval`` is 0 or
            ``constantParentCellCountPerIInterval`` is 0 or
            ``iIntervalCount`` is 0 or
            										``constantChildCellCountPerJInterval`` is 0 or
            ``constantParentCellCountPerJInterval`` is 0 or
            ``jIntervalCount`` is 0 or
            										``constantChildCellCountPerKInterval`` is 0 or
            ``constantParentCellCountPerKInterval`` is 0 or
            ``kIntervalCount`` is 0 or
            										``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:			   	I index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerIInterval: int
        :param constantChildCellCountPerIInterval: 	The constant count of cells per I
            														interval in this (child) grid.
        :type constantParentCellCountPerIInterval: int
        :param constantParentCellCountPerIInterval:	The constant count of cells per I
            														interval in the parent grid.
        :type iIntervalCount: int
        :param iIntervalCount:					   	The count of intervals on I dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:			   	J index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerJInterval: int
        :param constantChildCellCountPerJInterval: 	The constant count of cells per J
            														interval in this (child) grid.
        :type constantParentCellCountPerJInterval: int
        :param constantParentCellCountPerJInterval:	The constant count of cells per J
            														interval in the parent grid.
        :type jIntervalCount: int
        :param jIntervalCount:					   	The count of intervals on J dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:			   	K index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerKInterval: int
        :param constantChildCellCountPerKInterval: 	The constant count of cells per K
            														interval in this (child) grid.
        :type constantParentCellCountPerKInterval: int
        :param constantParentCellCountPerKInterval:	The constant count of cells per K
            														interval in the parent grid.
        :type kIntervalCount: int
        :param kIntervalCount:					   	The count of intervals on K dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :param [in]:	  	parentGrid						   	The parent grid which is regridded.
        :param [in,out]:	proxy							   	(Optional) The HDF proxy where to store
            														the numerical values. If nullptr
            														(default), then the proxy will be the
            														default proxy of the repository. This
            														parameter is unused if no numerical value
            														need to be store in an HDF proxy (pure
            														XML).
        :param [in]:	  	iChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative I sizes of
            														child cells within each I interval. This
            														is useful to set up child cells of
            														different I sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on I
            														dimension
            														(constantChildCellCountPerIInterval *
            														iIntervalCount). Default value is
            														nullptr.
        :param [in]:	  	jChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative J sizes of
            														child cells within each J interval. This
            														is useful to set up child cells of
            														different J sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on J
            														dimension
            														(constantChildCellCountPerJInterval
            														* jIntervalCount).
        :param [in]:	  	kChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative K sizes of
            														child cells within each K interval. This
            														is useful to set up child cells of
            														different K sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on K
            														dimension
            														(constantChildCellCountPerKInterval
            														* kIntervalCount).

        |

        *Overload 12:*

        Indicates that this grid takes place into another IJK parent grid. This method
        			assumes that the count of cells per regrid interval is constant in both child and
        			parent grids.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``constantChildCellCountPerIInterval`` is 0 or
            ``constantParentCellCountPerIInterval`` is 0 or
            ``iIntervalCount`` is 0 or
            										``constantChildCellCountPerJInterval`` is 0 or
            ``constantParentCellCountPerJInterval`` is 0 or
            ``jIntervalCount`` is 0 or
            										``constantChildCellCountPerKInterval`` is 0 or
            ``constantParentCellCountPerKInterval`` is 0 or
            ``kIntervalCount`` is 0 or
            										``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:			   	I index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerIInterval: int
        :param constantChildCellCountPerIInterval: 	The constant count of cells per I
            														interval in this (child) grid.
        :type constantParentCellCountPerIInterval: int
        :param constantParentCellCountPerIInterval:	The constant count of cells per I
            														interval in the parent grid.
        :type iIntervalCount: int
        :param iIntervalCount:					   	The count of intervals on I dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:			   	J index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerJInterval: int
        :param constantChildCellCountPerJInterval: 	The constant count of cells per J
            														interval in this (child) grid.
        :type constantParentCellCountPerJInterval: int
        :param constantParentCellCountPerJInterval:	The constant count of cells per J
            														interval in the parent grid.
        :type jIntervalCount: int
        :param jIntervalCount:					   	The count of intervals on J dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:			   	K index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerKInterval: int
        :param constantChildCellCountPerKInterval: 	The constant count of cells per K
            														interval in this (child) grid.
        :type constantParentCellCountPerKInterval: int
        :param constantParentCellCountPerKInterval:	The constant count of cells per K
            														interval in the parent grid.
        :type kIntervalCount: int
        :param kIntervalCount:					   	The count of intervals on K dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :param [in]:	  	parentGrid						   	The parent grid which is regridded.
        :param [in,out]:	proxy							   	(Optional) The HDF proxy where to store
            														the numerical values. If nullptr
            														(default), then the proxy will be the
            														default proxy of the repository. This
            														parameter is unused if no numerical value
            														need to be store in an HDF proxy (pure
            														XML).
        :param [in]:	  	iChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative I sizes of
            														child cells within each I interval. This
            														is useful to set up child cells of
            														different I sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on I
            														dimension
            														(constantChildCellCountPerIInterval *
            														iIntervalCount). Default value is
            														nullptr.
        :param [in]:	  	jChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative J sizes of
            														child cells within each J interval. This
            														is useful to set up child cells of
            														different J sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on J
            														dimension
            														(constantChildCellCountPerJInterval
            														* jIntervalCount).
        :param [in]:	  	kChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative K sizes of
            														child cells within each K interval. This
            														is useful to set up child cells of
            														different K sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on K
            														dimension
            														(constantChildCellCountPerKInterval
            														* kIntervalCount).

        |

        *Overload 13:*

        Indicates that this grid takes place into another IJK parent grid. This method
        			assumes that the count of cells per regrid interval is constant in both child and
        			parent grids.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``constantChildCellCountPerIInterval`` is 0 or
            ``constantParentCellCountPerIInterval`` is 0 or
            ``iIntervalCount`` is 0 or
            										``constantChildCellCountPerJInterval`` is 0 or
            ``constantParentCellCountPerJInterval`` is 0 or
            ``jIntervalCount`` is 0 or
            										``constantChildCellCountPerKInterval`` is 0 or
            ``constantParentCellCountPerKInterval`` is 0 or
            ``kIntervalCount`` is 0 or
            										``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:			   	I index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerIInterval: int
        :param constantChildCellCountPerIInterval: 	The constant count of cells per I
            														interval in this (child) grid.
        :type constantParentCellCountPerIInterval: int
        :param constantParentCellCountPerIInterval:	The constant count of cells per I
            														interval in the parent grid.
        :type iIntervalCount: int
        :param iIntervalCount:					   	The count of intervals on I dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:			   	J index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerJInterval: int
        :param constantChildCellCountPerJInterval: 	The constant count of cells per J
            														interval in this (child) grid.
        :type constantParentCellCountPerJInterval: int
        :param constantParentCellCountPerJInterval:	The constant count of cells per J
            														interval in the parent grid.
        :type jIntervalCount: int
        :param jIntervalCount:					   	The count of intervals on J dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:			   	K index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerKInterval: int
        :param constantChildCellCountPerKInterval: 	The constant count of cells per K
            														interval in this (child) grid.
        :type constantParentCellCountPerKInterval: int
        :param constantParentCellCountPerKInterval:	The constant count of cells per K
            														interval in the parent grid.
        :type kIntervalCount: int
        :param kIntervalCount:					   	The count of intervals on K dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :param [in]:	  	parentGrid						   	The parent grid which is regridded.
        :param [in,out]:	proxy							   	(Optional) The HDF proxy where to store
            														the numerical values. If nullptr
            														(default), then the proxy will be the
            														default proxy of the repository. This
            														parameter is unused if no numerical value
            														need to be store in an HDF proxy (pure
            														XML).
        :param [in]:	  	iChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative I sizes of
            														child cells within each I interval. This
            														is useful to set up child cells of
            														different I sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on I
            														dimension
            														(constantChildCellCountPerIInterval *
            														iIntervalCount). Default value is
            														nullptr.
        :param [in]:	  	jChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative J sizes of
            														child cells within each J interval. This
            														is useful to set up child cells of
            														different J sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on J
            														dimension
            														(constantChildCellCountPerJInterval
            														* jIntervalCount).
        :param [in]:	  	kChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative K sizes of
            														child cells within each K interval. This
            														is useful to set up child cells of
            														different K sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on K
            														dimension
            														(constantChildCellCountPerKInterval
            														* kIntervalCount).

        |

        *Overload 14:*

        Indicates that this grid takes place into another IJK parent grid. This method
        			assumes that the count of cells per regrid interval is constant in both child and
        			parent grids.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``constantChildCellCountPerIInterval`` is 0 or
            ``constantParentCellCountPerIInterval`` is 0 or
            ``iIntervalCount`` is 0 or
            										``constantChildCellCountPerJInterval`` is 0 or
            ``constantParentCellCountPerJInterval`` is 0 or
            ``jIntervalCount`` is 0 or
            										``constantChildCellCountPerKInterval`` is 0 or
            ``constantParentCellCountPerKInterval`` is 0 or
            ``kIntervalCount`` is 0 or
            										``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:			   	I index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerIInterval: int
        :param constantChildCellCountPerIInterval: 	The constant count of cells per I
            														interval in this (child) grid.
        :type constantParentCellCountPerIInterval: int
        :param constantParentCellCountPerIInterval:	The constant count of cells per I
            														interval in the parent grid.
        :type iIntervalCount: int
        :param iIntervalCount:					   	The count of intervals on I dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:			   	J index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerJInterval: int
        :param constantChildCellCountPerJInterval: 	The constant count of cells per J
            														interval in this (child) grid.
        :type constantParentCellCountPerJInterval: int
        :param constantParentCellCountPerJInterval:	The constant count of cells per J
            														interval in the parent grid.
        :type jIntervalCount: int
        :param jIntervalCount:					   	The count of intervals on J dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:			   	K index of the first parent grid cell to
            														be regridded.
        :type constantChildCellCountPerKInterval: int
        :param constantChildCellCountPerKInterval: 	The constant count of cells per K
            														interval in this (child) grid.
        :type constantParentCellCountPerKInterval: int
        :param constantParentCellCountPerKInterval:	The constant count of cells per K
            														interval in the parent grid.
        :type kIntervalCount: int
        :param kIntervalCount:					   	The count of intervals on K dimension.
            														Intervals are portions of cells to regrid
            														which does not overlap with each others.
        :param [in]:	  	parentGrid						   	The parent grid which is regridded.
        :param [in,out]:	proxy							   	(Optional) The HDF proxy where to store
            														the numerical values. If nullptr
            														(default), then the proxy will be the
            														default proxy of the repository. This
            														parameter is unused if no numerical value
            														need to be store in an HDF proxy (pure
            														XML).
        :param [in]:	  	iChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative I sizes of
            														child cells within each I interval. This
            														is useful to set up child cells of
            														different I sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on I
            														dimension
            														(constantChildCellCountPerIInterval *
            														iIntervalCount). Default value is
            														nullptr.
        :param [in]:	  	jChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative J sizes of
            														child cells within each J interval. This
            														is useful to set up child cells of
            														different J sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on J
            														dimension
            														(constantChildCellCountPerJInterval
            														* jIntervalCount).
        :param [in]:	  	kChildCellWeights				   	(Optional) The weights that are
            														proportional to the relative K sizes of
            														child cells within each K interval. This
            														is useful to set up child cells of
            														different K sizes inside the intervals.
            														The weights need not to be normalized.
            														The count of double values must be equal
            														to the count of all child cells on K
            														dimension
            														(constantChildCellCountPerKInterval
            														* kIntervalCount).

        |

        *Overload 15:*

        Indicates that this grid takes place into another IJK parent grid. This method assumes that
        there is only one regrid interval per dimension.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``iChildCellCount`` is 0 or ``iParentCellCount`` is 0 or
            										``jChildCellCount`` is 0 or ``jParentCellCount`` is 0 or
            ``kChildCellCount`` is 0 or ``kParentCellCount`` is 0 or
            ``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:	I index of the first parent grid cell to
            											be regridded.
        :type iChildCellCount: int
        :param iChildCellCount:		 	The count of cells for the unique I interval in this
            											(child) grid.
        :type iParentCellCount: int
        :param iParentCellCount:	 	The count of cells for the unique I interval in the
            											parent grid.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:	J index of the first parent grid cell to
            											be regridded.
        :type jChildCellCount: int
        :param jChildCellCount:		 	The count of cells for the unique J interval in this
            											(child) grid.
        :type jParentCellCount: int
        :param jParentCellCount:	 	The count of cells for the unique J interval in the
            											parent grid.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:	K index of the first parent grid cell to
            											be regridded.
        :type kChildCellCount: int
        :param kChildCellCount:		 	The count of cells for the unique K interval in this
            											(child) grid.
        :type kParentCellCount: int
        :param kParentCellCount:	 	The count of cells for the unique K interval in the
            											parent grid.
        :param [in]:	  	parentGrid			 	The parent grid which is regridded.
        :param [in,out]:	proxy				 	(Optional) The HDF proxy where to store the numerical
            											values. If nullptr (default), then the proxy will be
            											the default proxy of the repository. This parameter
            											is unused if no numerical value need to be store in
            											an HDF proxy (pure XML).
        :param [in]:	  	iChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative I sizes of child cells. This is useful to
            											set up child cells of different I sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``iChildCellCount``. Default value is nullptr.
        :param [in]:	  	jChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative J sizes of child cells. This is useful to
            											set up child cells of different J sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``jChildCellCount``. Default value is nullptr.
        :param [in]:	  	kChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative K sizes of child cells. This is useful to
            											set up child cells of different K sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``kChildCellCount``. Default value is nullptr.

        |

        *Overload 16:*

        Indicates that this grid takes place into another IJK parent grid. This method assumes that
        there is only one regrid interval per dimension.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``iChildCellCount`` is 0 or ``iParentCellCount`` is 0 or
            										``jChildCellCount`` is 0 or ``jParentCellCount`` is 0 or
            ``kChildCellCount`` is 0 or ``kParentCellCount`` is 0 or
            ``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:	I index of the first parent grid cell to
            											be regridded.
        :type iChildCellCount: int
        :param iChildCellCount:		 	The count of cells for the unique I interval in this
            											(child) grid.
        :type iParentCellCount: int
        :param iParentCellCount:	 	The count of cells for the unique I interval in the
            											parent grid.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:	J index of the first parent grid cell to
            											be regridded.
        :type jChildCellCount: int
        :param jChildCellCount:		 	The count of cells for the unique J interval in this
            											(child) grid.
        :type jParentCellCount: int
        :param jParentCellCount:	 	The count of cells for the unique J interval in the
            											parent grid.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:	K index of the first parent grid cell to
            											be regridded.
        :type kChildCellCount: int
        :param kChildCellCount:		 	The count of cells for the unique K interval in this
            											(child) grid.
        :type kParentCellCount: int
        :param kParentCellCount:	 	The count of cells for the unique K interval in the
            											parent grid.
        :param [in]:	  	parentGrid			 	The parent grid which is regridded.
        :param [in,out]:	proxy				 	(Optional) The HDF proxy where to store the numerical
            											values. If nullptr (default), then the proxy will be
            											the default proxy of the repository. This parameter
            											is unused if no numerical value need to be store in
            											an HDF proxy (pure XML).
        :param [in]:	  	iChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative I sizes of child cells. This is useful to
            											set up child cells of different I sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``iChildCellCount``. Default value is nullptr.
        :param [in]:	  	jChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative J sizes of child cells. This is useful to
            											set up child cells of different J sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``jChildCellCount``. Default value is nullptr.
        :param [in]:	  	kChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative K sizes of child cells. This is useful to
            											set up child cells of different K sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``kChildCellCount``. Default value is nullptr.

        |

        *Overload 17:*

        Indicates that this grid takes place into another IJK parent grid. This method assumes that
        there is only one regrid interval per dimension.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``iChildCellCount`` is 0 or ``iParentCellCount`` is 0 or
            										``jChildCellCount`` is 0 or ``jParentCellCount`` is 0 or
            ``kChildCellCount`` is 0 or ``kParentCellCount`` is 0 or
            ``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:	I index of the first parent grid cell to
            											be regridded.
        :type iChildCellCount: int
        :param iChildCellCount:		 	The count of cells for the unique I interval in this
            											(child) grid.
        :type iParentCellCount: int
        :param iParentCellCount:	 	The count of cells for the unique I interval in the
            											parent grid.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:	J index of the first parent grid cell to
            											be regridded.
        :type jChildCellCount: int
        :param jChildCellCount:		 	The count of cells for the unique J interval in this
            											(child) grid.
        :type jParentCellCount: int
        :param jParentCellCount:	 	The count of cells for the unique J interval in the
            											parent grid.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:	K index of the first parent grid cell to
            											be regridded.
        :type kChildCellCount: int
        :param kChildCellCount:		 	The count of cells for the unique K interval in this
            											(child) grid.
        :type kParentCellCount: int
        :param kParentCellCount:	 	The count of cells for the unique K interval in the
            											parent grid.
        :param [in]:	  	parentGrid			 	The parent grid which is regridded.
        :param [in,out]:	proxy				 	(Optional) The HDF proxy where to store the numerical
            											values. If nullptr (default), then the proxy will be
            											the default proxy of the repository. This parameter
            											is unused if no numerical value need to be store in
            											an HDF proxy (pure XML).
        :param [in]:	  	iChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative I sizes of child cells. This is useful to
            											set up child cells of different I sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``iChildCellCount``. Default value is nullptr.
        :param [in]:	  	jChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative J sizes of child cells. This is useful to
            											set up child cells of different J sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``jChildCellCount``. Default value is nullptr.
        :param [in]:	  	kChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative K sizes of child cells. This is useful to
            											set up child cells of different K sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``kChildCellCount``. Default value is nullptr.

        |

        *Overload 18:*

        Indicates that this grid takes place into another IJK parent grid. This method assumes that
        there is only one regrid interval per dimension.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``iChildCellCount`` is 0 or ``iParentCellCount`` is 0 or
            										``jChildCellCount`` is 0 or ``jParentCellCount`` is 0 or
            ``kChildCellCount`` is 0 or ``kParentCellCount`` is 0 or
            ``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:	I index of the first parent grid cell to
            											be regridded.
        :type iChildCellCount: int
        :param iChildCellCount:		 	The count of cells for the unique I interval in this
            											(child) grid.
        :type iParentCellCount: int
        :param iParentCellCount:	 	The count of cells for the unique I interval in the
            											parent grid.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:	J index of the first parent grid cell to
            											be regridded.
        :type jChildCellCount: int
        :param jChildCellCount:		 	The count of cells for the unique J interval in this
            											(child) grid.
        :type jParentCellCount: int
        :param jParentCellCount:	 	The count of cells for the unique J interval in the
            											parent grid.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:	K index of the first parent grid cell to
            											be regridded.
        :type kChildCellCount: int
        :param kChildCellCount:		 	The count of cells for the unique K interval in this
            											(child) grid.
        :type kParentCellCount: int
        :param kParentCellCount:	 	The count of cells for the unique K interval in the
            											parent grid.
        :param [in]:	  	parentGrid			 	The parent grid which is regridded.
        :param [in,out]:	proxy				 	(Optional) The HDF proxy where to store the numerical
            											values. If nullptr (default), then the proxy will be
            											the default proxy of the repository. This parameter
            											is unused if no numerical value need to be store in
            											an HDF proxy (pure XML).
        :param [in]:	  	iChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative I sizes of child cells. This is useful to
            											set up child cells of different I sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``iChildCellCount``. Default value is nullptr.
        :param [in]:	  	jChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative J sizes of child cells. This is useful to
            											set up child cells of different J sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``jChildCellCount``. Default value is nullptr.
        :param [in]:	  	kChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative K sizes of child cells. This is useful to
            											set up child cells of different K sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``kChildCellCount``. Default value is nullptr.

        |

        *Overload 19:*

        Indicates that this grid takes place into another IJK parent grid. This method assumes that
        there is only one regrid interval per dimension.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``iChildCellCount`` is 0 or ``iParentCellCount`` is 0 or
            										``jChildCellCount`` is 0 or ``jParentCellCount`` is 0 or
            ``kChildCellCount`` is 0 or ``kParentCellCount`` is 0 or
            ``parentGrid`` is nullptr.
        :raises: std::invalid_argument	If an HDF proxy is required to store numerical values but
            										``proxy`` is nullptr and no default HDF proxy is defined
            										in the repository.

        :type iCellIndexRegridStart: int
        :param iCellIndexRegridStart:	I index of the first parent grid cell to
            											be regridded.
        :type iChildCellCount: int
        :param iChildCellCount:		 	The count of cells for the unique I interval in this
            											(child) grid.
        :type iParentCellCount: int
        :param iParentCellCount:	 	The count of cells for the unique I interval in the
            											parent grid.
        :type jCellIndexRegridStart: int
        :param jCellIndexRegridStart:	J index of the first parent grid cell to
            											be regridded.
        :type jChildCellCount: int
        :param jChildCellCount:		 	The count of cells for the unique J interval in this
            											(child) grid.
        :type jParentCellCount: int
        :param jParentCellCount:	 	The count of cells for the unique J interval in the
            											parent grid.
        :type kCellIndexRegridStart: int
        :param kCellIndexRegridStart:	K index of the first parent grid cell to
            											be regridded.
        :type kChildCellCount: int
        :param kChildCellCount:		 	The count of cells for the unique K interval in this
            											(child) grid.
        :type kParentCellCount: int
        :param kParentCellCount:	 	The count of cells for the unique K interval in the
            											parent grid.
        :param [in]:	  	parentGrid			 	The parent grid which is regridded.
        :param [in,out]:	proxy				 	(Optional) The HDF proxy where to store the numerical
            											values. If nullptr (default), then the proxy will be
            											the default proxy of the repository. This parameter
            											is unused if no numerical value need to be store in
            											an HDF proxy (pure XML).
        :param [in]:	  	iChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative I sizes of child cells. This is useful to
            											set up child cells of different I sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``iChildCellCount``. Default value is nullptr.
        :param [in]:	  	jChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative J sizes of child cells. This is useful to
            											set up child cells of different J sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``jChildCellCount``. Default value is nullptr.
        :param [in]:	  	kChildCellWeights	 	(Optional) The weights that are proportional to the
            											relative K sizes of child cells. This is useful to
            											set up child cells of different K sizes inside the
            											unique interval. The weights need not to be
            											normalized. The count of double values must be equal
            											to ``kChildCellCount``. Default value is nullptr.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_setParentWindow(self, *args)

    def setForcedNonRegridedParentCell(self, cellIndices: "uint64_t *", cellIndexCount: "uint64_t") -> "void":
        r"""
        When a parent windows has been defined, this method allows to force some parent cells to be
        noted as non regridded. It mainly allows non-rectangular local grids to be specified.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If no parent window is already defined of if the defined
            										parent window is neither an IJK nor a column layer parent
            										window.
        :raises: std::invalid_argument	If ``cellIndices`` is nullptr or ``cellIndexCount`` is 0.
        :raises: std::invalid_argument	If an HDF proxy is required and no default HDF proxy is
            										defined in the repository.

        :param [in]:	cellIndices   	The indices of the parent cells to be noted as non regridded. The
            								size is ``cellIndexCount``.
        :type cellIndexCount: int
        :param cellIndexCount:	Number of cells to be noted as non regridded.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_setForcedNonRegridedParentCell(self, cellIndices, cellIndexCount)

    def setCellOverlap(self, parentChildCellPairCount: "uint64_t", parentChildCellPair: "uint64_t *", volumeUom: "std::string const &", overlapVolumes: "double *"=None) -> "void":
        r"""
        Set optional cell overlap information between the current grid (the child) and the parent
        grid. Use this data-object when the child grid has an explicitly defined geometry, and these
        relationships cannot be inferred from the regrid descriptions. An overlap volume information
        can be associated to each overlapping (parent cell, child cell) pair.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If no parent window is already defined.
        :raises: std::invalid_argument	If ``parentChildCellPairCount`` is 0 or
            										``parentChildCellPair`` is nullptr.
        :raises: std::invalid_argument	If no default HDF proxy is defined in the repository.

        :type parentChildCellPairCount: int
        :param parentChildCellPairCount:	Number of (parent cell, child cell) pairs that
            											overlap.
        :param [in]:	parentChildCellPair			The (parent cell index, child cell index) pair for
            											each overlap. The size is 2 *
            											parentChildCellPairCount.
            											parentChildCellPair[2i] are parent cell indices
            											and parentChildCellPair[2i+1] are child cell
            											indices.
        :type volumeUom: string
        :param volumeUom:					The volume unit of measure.
        :param [in]:	overlapVolumes				(Optional) The overlapping volume for each (parent
            											cell, child cell) that overlaps. Size is
            ``parentChildCellPairCount``. Default value is nullptr.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_setCellOverlap(self, parentChildCellPairCount, parentChildCellPair, volumeUom, overlapVolumes)

    def getParentCellIndexCount(self) -> "uint64_t":
        r"""
        Gets the count of parent grid cells which are regridded. Please only run this method for an
        unstructured parent grid. Please use regrid information for IJK parent grid or (regrid information
        and columIndexCount) for strict column layer parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If no parent window is already defined of if the defined
            										parent window is not an unstructured parent window.
        :raises: std::invalid_argument		If the list of regridded cells is not stored in an HDF5 file.

        :rtype: int
        :return: The count of parent grid cells which are regridded.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getParentCellIndexCount(self)

    def getParentCellIndices(self, parentCellIndices: "uint64_t *") -> "void":
        r"""
        Gets the indices of the parent grid cells which are regridded. Please only run this method
        for an unstructured parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If no parent window is already defined of if the defined
            										parent window is not an unstructured parent window.
        :raises: std::invalid_argument	If the list of regridded cells is not stored in an HDF5
            										file.

        :param [out]:	parentCellIndices	An array for receiving the regridded cells indices. This
            									array must have been preallocated with a size of
            									getParentCellIndexCount().
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getParentCellIndices(self, parentCellIndices)

    def getParentColumnIndexCount(self) -> "uint64_t":
        r"""
        Gets the count of parent grid columns which are regridded. Please only run this method for a
        strict column layer parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If no parent window is already defined of if the defined
            										parent window is not a column layer parent window.
        :raises: std::invalid_argument	If the list of regridded cells is not stored in an HDF5
            										file.

        :rtype: int
        :return: The count of parent grid columns which are regridded.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getParentColumnIndexCount(self)

    def getParentColumnIndices(self, parentColumnIndices: "uint64_t *") -> "void":
        r"""
        Gets the indices of the parent grid columns which are regridded. Please only run this method
        for a strict column layer parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If no parent window is already defined of if the defined
            										parent window is not a column layer parent window.
        :raises: std::invalid_argument	If the list of regridded cells is not stored in an HDF5
            										file.

        :param [out]:	parentColumnIndices	An array for collecting the regridded column indices. This
            									array must have been preallocated with a size of
            										getParentColumnIndexCount().
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getParentColumnIndices(self, parentColumnIndices)

    def getRegridStartIndexOnParentGrid(self, dimension: "char") -> "uint64_t":
        r"""
        Get the I, J or K index of the first parent grid cell to be regridded. Please only run this
        method for an IJK parent grid or a strict column layer parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If no parent window is already defined of if the defined
            										parent window is neither an IJK nor a column layer parent
            										window.
        :raises: std::invalid_argument	If ``dimension`` differs from 'i', 'j' or 'k' (upper or
            										lower case) for an IJK parent window or if it differs
            										from 'k' (upper or lower case) for a column layer parent
            										window.

        :type dimension: char
        :param dimension:	The dimension of the index we look for. It must be either 'i', 'j' or 'k'
            						(upper or lower case) for an IJK parent grid or 'k' for a strict column
            						layer parent grid.

        :rtype: int
        :return: The regrid start index on the parent grid in dimension ``dimension``.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getRegridStartIndexOnParentGrid(self, dimension)

    def getRegridIntervalCount(self, dimension: "char") -> "uint64_t":
        r"""
        Gets the count of intervals which are regridded on a particular dimension. Intervals are
        portions of cells to regrid which does not overlap with each others. Please only run this
        method for an IJK parent grid or a strict column layer parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If no parent window is already defined of if the defined
            										parent window is neither an IJK nor a column layer parent
            										window.
        :raises: std::invalid_argument	If ``dimension`` differs from 'i', 'j' or 'k' (upper or
            										lower case) for an IJK parent window or if it differs
            										from 'k' (upper or lower case) for a column layer parent
            										window.

        :type dimension: char
        :param dimension:	The dimension of the interval count we look for. It must be either 'i',
            						'j' or 'k' (upper or lower case) for an IJK parent grid or 'k' for a
            						strict column layer parent grid.

        :rtype: int
        :return: The regrid interval count in dimension ``dimension``.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getRegridIntervalCount(self, dimension)

    def isRegridCellCountPerIntervalConstant(self, dimension: "char", childVsParentCellCount: "bool") -> "bool":
        r"""
        Checks if the cell count per interval (in the child grid or in the parent grid) is constant
        against a particular dimension. Intervals are portions of cells to regrid which does not
        overlap with each others. Please only run this method for an IJK parent grid or a strict
        column layer parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If no parent window is already defined of if the defined
            										parent window is neither an IJK nor a column layer parent
            										window.
        :raises: std::invalid_argument	If ``dimension`` differs from 'i', 'j' or 'k' (upper or
            										lower case) for an IJK parent window or if it differs
            										from 'k' (upper or lower case) for a column layer parent
            										window.
        :raises: std::invalid_argument	If there exists no regrid interval in dimension
            ``dimension``.

        :type dimension: char
        :param dimension:			  	The dimension of the interval we look for. It must be either
            									'i', 'j' ou 'k' (upper or lower case) for an IJK parent grid
            									or 'k' for a strict column layer parent grid.
        :type childVsParentCellCount: boolean
        :param childVsParentCellCount:	If true, checks if the child cell count per interval is
            									constant. If false, checks if the parent cell count per
            									interval is constant.

        :rtype: boolean
        :return: True if the regrid cell count per interval is constant in dimension ``dimension``,
            			false if not.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_isRegridCellCountPerIntervalConstant(self, dimension, childVsParentCellCount)

    def getRegridConstantCellCountPerInterval(self, dimension: "char", childVsParentCellCount: "bool") -> "uint64_t":
        r"""
        Gets the constant cell count per interval (in the child grid or in the parent grid) against a
        particular dimension. Intervals are portions of cells to regrid which does not overlap with
        each others. Please only run this method for an IJK parent grid or a strict column layer
        parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::logic_error	 	If the cell count per interval in dimension ``dimension``
            										is neither an integer constant array nor a HDF5 integer
            										array.
        :raises: std::invalid_argument	If no parent window is already defined of if the defined
            										parent window is neither an IJK nor a column layer parent
            										window.
        :raises: std::invalid_argument	If ``dimension`` differs from 'i', 'j' or 'k' (upper or
            										lower case) for an IJK parent window or if it differs
            										from 'k' (upper or lower case) for a column layer parent
            										window.
        :raises: std::invalid_argument	If there exists no regrid interval in dimension
            ``dimension``.

        :type dimension: char
        :param dimension:			  	The dimension of the interval we look for. It must be either
            									'i', 'j' ou 'k' (upper or lower case) for an IJK parent grid
            									or 'k' for a strict column layer parent grid.
        :type childVsParentCellCount: boolean
        :param childVsParentCellCount:	If true, gets the constant child cell count per interval. If
            									false, gets the constant parent cell count per interval.

        :rtype: int
        :return: The regrid constant cell count per interval in dimension ``dimension``.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getRegridConstantCellCountPerInterval(self, dimension, childVsParentCellCount)

    def getRegridCellCountPerInterval(self, dimension: "char", childCellCountPerInterval: "uint64_t *", childVsParentCellCount: "bool") -> "void":
        r"""
        Gets the regrid cell count per interval (in the child grid or in the parent grid) against a
        particular dimension. Intervals are portions of cells to regrid which does not overlap with
        each others. Please only run this method for an IJK parent grid or a strict column layer
        parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::logic_error	 	If the cell count per interval in dimension ``dimension``
            										is neither an integer constant array nor a HDF5 integer
            										array.
        :raises: std::invalid_argument	If no parent window is already defined of if the defined
            										parent window is neither an IJK nor a column layer parent
            										window.
        :raises: std::invalid_argument	If ``dimension`` differs from 'i', 'j' or 'k' (upper or
            										lower case) for an IJK parent window or if it differs
            										from 'k' (upper or lower case) for a column layer parent
            										window.
        :raises: std::invalid_argument	If there exists no regrid interval in dimension
            ``dimension``.

        :type dimension: char
        :param dimension:				 	The dimension of the interval we look for. It must be
            											either 'i', 'j' ou 'k' (upper or lower case) for an
            											IJK parent grid or 'k' for a strict column layer
            											parent grid.
        :param [in]:	childCellCountPerInterval	An array to receive the regrid cell count per
            											interval. It must have been preallocated with a size
            											of getRegridIntervalCount().
        :type childVsParentCellCount: boolean
        :param childVsParentCellCount:   	If true, gets the child cell count per interval. If
            											false, gets the parent cell count per interval.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getRegridCellCountPerInterval(self, dimension, childCellCountPerInterval, childVsParentCellCount)

    def hasRegridChildCellWeights(self, dimension: "char") -> "bool":
        r"""
        Checks if regrid child cell weights have been defined for a given dimension. Please only run
        this method for an IJK parent grid or a strict column layer parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If no parent window is already defined of if the defined
            										parent window is neither an IJK nor a column layer parent
            										window.
        :raises: std::invalid_argument	If ``dimension`` differs from 'i', 'j' or 'k' (upper or
            										lower case) for an IJK parent window or if it differs
            										from 'k' (upper or lower case) for a column layer parent
            										window.
        :raises: std::invalid_argument	If there exists no regrid interval in dimension
            ``dimension``.

        :type dimension: char
        :param dimension:	The dimension from which we look for regrid child cell weights. It must
            						be either 'i', 'j' ou 'k' (upper or lower case) for an IJK parent grid or
            						'k' for a strict column layer parent grid.

        :rtype: boolean
        :return: True if regrid child cell weights have been defined in dimension ``dimension``, false
            			if not.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_hasRegridChildCellWeights(self, dimension)

    def getRegridChildCellWeights(self, dimension: "char", childCellWeights: "double *") -> "void":
        r"""
        Gets the regrid child cell weights for a given dimension. Please only run this method for an
        IJK parent grid or a strict column layer parent grid.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If no parent window is already defined of if the defined
            										parent window is neither an IJK nor a column layer parent
            										window.
        :raises: std::invalid_argument	If ``dimension`` differs from 'i', 'j' or 'k' (upper or
            										lower case) for an IJK parent window or if it differs
            										from 'k' (upper or lower case) for a column layer parent
            										window.
        :raises: std::invalid_argument	If there exists no regrid interval in dimension
            ``dimension``.
        :raises: std::invalid_argument	If the regrid child cell weights in dimension
            ``dimension`` are not stored in an HDF5 file.

        :type dimension: char
        :param dimension:			The dimension from which we look for regrid child cell
            										weights. It must be either 'i', 'j' ou 'k' (upper or lower
            										case) for an IJK parent grid or 'k' for a strict column layer
            										parent grid.
        :param [in,out]:	childCellWeights	An array for receiving the regrid child cell weights. It
            										must have been preallocated with a size equal to the sum of
            										regrid child cell count per interval (using
            										getRegridCellCountPerInterval()).
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getRegridChildCellWeights(self, dimension, childCellWeights)

    def hasForcedNonRegridedParentCell(self) -> "bool":
        r"""
        When a parent windows has been defined, this method checks if some parent cells have been
        noted to be forced not to be regridded. It mainly occurs in case of non-rectangular local
        grids.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If no parent window is already defined.

        :rtype: boolean
        :return: True if some parent cells have been forced not to be regridded, false if not.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_hasForcedNonRegridedParentCell(self)

    def setCellAssociationWithStratigraphicOrganizationInterpretation(self, stratiUnitIndices: "int64_t *", nullValue: "int64_t", stratiOrgInterp: "Resqml2_AbstractStratigraphicOrganizationInterpretation") -> "void":
        r"""
        Sets the stratigraphic organization interpretation which is associated to this grid
        representation.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If no default HDF proxy is defined in the repository.

        :param [in]:	stratiUnitIndices	Index of the stratigraphic unit of a given stratigraphic
            									column for each cell. Array length is the number of cells in
            									the grid or the blocked well.
        :type nullValue: int
        :param nullValue:		 	The value which is used to tell the association between a
            									cell and a stratigraphic unit is unavailable.
        :param [in]:	stratiOrgInterp  	The stratigraphic organization interpretation which is
            									associated to this grid representation.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_setCellAssociationWithStratigraphicOrganizationInterpretation(self, stratiUnitIndices, nullValue, stratiOrgInterp)

    def getStratigraphicOrganizationInterpretation(self) -> "resqml2::AbstractStratigraphicOrganizationInterpretation *":
        r"""
        Gets the stratigraphic organization interpretation which is associated to this grid.

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0 one.

        :rtype: :py:class:`AbstractStratigraphicOrganizationInterpretation`
        :return: nullptr if no stratigraphic organization interpretation is associated to this grid
            			representation. Otherwise return the associated stratigraphic organization
            			interpretation.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getStratigraphicOrganizationInterpretation(self)

    def hasCellStratigraphicUnitIndices(self) -> "bool":
        r"""
        Queries if there exists some association between stratigraphic unit indices and the cells of
        this grid.

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0 one.

        :rtype: boolean
        :return: True if this grid representation has got some association between stratigraphic unit
            			indices and cells.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_hasCellStratigraphicUnitIndices(self)

    def getCellStratigraphicUnitIndices(self, stratiUnitIndices: "int64_t *") -> "int64_t":
        r"""
        Gets the stratigraphic unit indices (regarding the associated stratigraphic organization
        interpretation) of each cell of this grid representation.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::logic_error	 	If the associated stratigraphic unit indices are not
            										stored in a HDF5 integer array.
        :raises: std::invalid_argument	If the cells of this grid are not associated with
            										stratigraphic units indices.

        :param [out]:	stratiUnitIndices	An array to receive the stratigraphic unit indices associated
            									to the cells of this grid. It must be preallocated with a
            									count equal to getCellCount(). It will be filled in with the
            									stratigraphic unit indices ordered as grid cells are ordered.

        :rtype: int
        :return: The null value. The null value is used to tell the association between a cell and
            			stratigraphic unit is unavailable.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getCellStratigraphicUnitIndices(self, stratiUnitIndices)

    def isTruncated(self) -> "bool":
        r"""
        Indicates whether this grid instance contains truncated pillars or not.

        :rtype: boolean
        :return: True if truncated pillars exist, false if not.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_isTruncated(self)

    def getTruncatedFaceCount(self) -> "uint64_t":
        r"""
        Gets the truncated face count. It does not include face of truncated cells which are not
        truncated.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If this grid is not truncated.

        :rtype: int
        :return: The truncated face count.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getTruncatedFaceCount(self)

    def getNodeIndicesOfTruncatedFaces(self, nodeIndices: "uint64_t *") -> "void":
        r"""
        Gets all the node indices of the truncated faces.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::logic_error	 	If the node indices of the truncated faces are not stored
            										in a HDF5 integer array.
        :raises: std::invalid_argument	If this grid is not truncated.

        :param [out]:	nodeIndices	An array to receive the node indices of the truncated faces. It must
            							be preallocated with the last value returned by
            							getCumulativeNodeCountOfTruncatedFaces().
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getNodeIndicesOfTruncatedFaces(self, nodeIndices)

    def getCumulativeNodeCountPerTruncatedFace(self, nodeCountPerFace: "uint64_t *") -> "void":
        r"""
        Gets the cumulative node count per truncated face. First value is the count of nodes in the
        first face. Second value is the count of nodes in the first and in the second face. Third
        value is the count of nodes in the first and in the second and in the third face. Etc... The
        length of the output array is equal to getTruncatedFaceCount(). A single node count should be
        at least 3.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If this grid is not truncated.
        :raises: std::range_error	 	If the cumulative length of nodes count per cells is
            										constant (it is stored in a constant integer array).

        :param [in]:	nodeCountPerFace	An array to receive the cumulative node count per truncated
            									face. It must be preallocated with getTruncatedFaceCount()
            									(equals to last value of
            									getCumulativeTruncatedFaceCountPerTruncatedCell())
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getCumulativeNodeCountPerTruncatedFace(self, nodeCountPerFace)

    def getNodeCountPerTruncatedFace(self, nodeCountPerFace: "uint64_t *") -> "void":
        r"""
        Get the node count per truncated face. This method is less efficient than
        getCumulativeNodeCountPerTruncatedFace(). First value is the count of nodes in the first
        face. Second value is the count of nodes in the second face. etc...

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If this grid is not truncated.
        :raises: std::range_error	 	If the cumulative length of nodes count per cells is
            										constant (it is stored in a constant integer array).

        :param [out]:	nodeCountPerFace	An array to receive the node count per truncated face. It
            									must be preallocated with getTruncatedFaceCount() (equals to last
            									value of getCumulativeTruncatedFaceCountPerTruncatedCell()).
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getNodeCountPerTruncatedFace(self, nodeCountPerFace)

    def getTruncatedCellCount(self) -> "uint64_t":
        r"""
        Gets the truncated cell count.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If this grid is not truncated.

        :rtype: int
        :return: The truncated cell count.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getTruncatedCellCount(self)

    def getTruncatedCellIndices(self, cellIndices: "uint64_t *") -> "void":
        r"""
        Gets the parent cell index for each of the truncation cells.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::logic_error	 	If the parent cell indices are stored neither in a HDF5
            										integer array nor in a constant integer array.
        :raises: std::invalid_argument	If this grid is not truncated.

        :param [out]:	cellIndices	An array to receive the parent cell index of each truncation cell. It
            							must be preallocated with getTruncatedCellCount.
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getTruncatedCellIndices(self, cellIndices)

    def getTruncatedFaceIndicesOfTruncatedCells(self, faceIndices: "uint64_t *") -> "void":
        r"""
        Gets all the truncated face indices of all the truncated cells. It does not get the non
        truncated face indices of a truncated cell. Please use
        getNonTruncatedFaceIndicesOfTruncatedCells() in addition to this method in order to get the
        full list of face indices for a truncated cell.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::logic_error	 	If the truncated face indices are not stored in a HDF5
            										integer array.
        :raises: std::invalid_argument	If this grid is not truncated.

        :param [out]:	faceIndices	An array to receive the truncated face indices of all the truncated
            							cells. It must be preallocated with the last value returned by
            							getCumulativeTruncatedFaceCountPerTruncatedCell()
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getTruncatedFaceIndicesOfTruncatedCells(self, faceIndices)

    def getCumulativeTruncatedFaceCountPerTruncatedCell(self, cumulativeFaceCountPerCell: "uint64_t *") -> "void":
        r"""
        Gets the cumulative truncated face count per truncated cell. It does not take into account
        the non truncated face of a truncated cell. First value is the count of faces in the first
        cell. Second value is the count of faces in the first and in the second cell. Third value is
        the count of faces in the first and in the second and in the third cell. Etc... The length of
        the output array is equal to getTruncatedCellCount(). A single face count should be at least
        4.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If this grid is not truncated.
        :raises: std::range_error	 	If the cumulative length of truncated faces count per
            										cells is constant (it is stored in a constant integer
            										array) while there is more than one cell in the grid.

        :param [out]:	cumulativeFaceCountPerCell	An array to receive the cumulative truncated face
            											count per truncated cell. It must be pre allocated
            											with getTruncatedCellCount().
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getCumulativeTruncatedFaceCountPerTruncatedCell(self, cumulativeFaceCountPerCell)

    def getTruncatedFaceCountPerTruncatedCell(self, faceCountPerCell: "uint64_t *") -> "void":
        r"""
        Gets the truncated face count per truncated cell. This method is less efficient than
        getCumulativeTruncatedFaceCountPerTruncatedCell(). First value is the count of faces in the
        first cell. Second value is the count of faces in the second cell. etc...

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If this grid is not truncated.
        :raises: std::range_error	 	If the cumulative length of faces count per cells is
            										constant (it is stored in a constant integer array) while
            										there is more than one cell in the grid.

        :param [out]:	faceCountPerCell	An array to receive the truncated face count per truncated
            									cell. It must be preallocated with getTruncatedCellCount()
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getTruncatedFaceCountPerTruncatedCell(self, faceCountPerCell)

    def getNonTruncatedFaceIndicesOfTruncatedCells(self, faceIndices: "uint64_t *") -> "void":
        r"""
        Gets all the non truncated face indices of all the truncated cells. It does not get the
        truncated face indices of a truncated cell. Please use
        getTruncatedFaceIndicesOfTruncatedCells() in addition to this method in order to get the full
        list of face indices for a truncated cell.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::logic_error	 	If the non truncated face indices are not stored in a
            										HDF5 integer array.
        :raises: std::invalid_argument	If this grid is not truncated.

        :param [out]:	faceIndices	An array to receive the non truncated face indices of all the
            							truncated cells.It must be pre allocated with the last value returned
            							by getCumulativeNonTruncatedFaceCountPerTruncatedCell()
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getNonTruncatedFaceIndicesOfTruncatedCells(self, faceIndices)

    def getCumulativeNonTruncatedFaceCountPerTruncatedCell(self, cumulativeFaceCountPerCell: "uint64_t *") -> "void":
        r"""
        Get the cumulative non truncated face count per truncated cell. It does not take into account
        the truncated face indices of a truncated cell. First value is the count of faces in the
        first cell. Second value is the count of faces in the first and in the second cell. Third
        value is the count of faces in the first and in the second and in the third cell. Etc...
        Count of this array is equal to getTruncatedCellCount(). A single face count should be at
        least 4.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If this grid is not truncated.
        :raises: std::range_error	 	If the cumulative length of non truncated faces count per
            										cells is constant (it is stored in a constant integer
            										array) while there is more than one cell in the grid.

        :param [out]:	cumulativeFaceCountPerCell	An array to receive the cumulative non truncated face
            											count per truncated cell. It must be preallocated with
            												getTruncatedCellCount()
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getCumulativeNonTruncatedFaceCountPerTruncatedCell(self, cumulativeFaceCountPerCell)

    def getNonTruncatedFaceCountPerTruncatedCell(self, faceCountPerCell: "uint64_t *") -> "void":
        r"""
        Gets the non truncated face count per cell. This method is less efficient than
        getCumulativeNonTruncatedFaceCountPerTruncatedCell(). First value is the count of faces in
        the first cell. Second value is the count of faces in the second cell. etc...

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If this grid is not truncated.
        :raises: std::range_error	 	If the cumulative length of non truncated faces count per
            										cells is constant (it is stored in a constant integer
            										array) while there is more than one cell in the grid.

        :param [out]:	faceCountPerCell	An array to receive the non truncated face count per
            									truncated cell. It must be pre allocated with
            									getTruncatedCellCount()
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getNonTruncatedFaceCountPerTruncatedCell(self, faceCountPerCell)

    def getTruncatedFaceIsRightHanded(self, cellFaceIsRightHanded: "uint8_t *") -> "void":
        r"""
        Retrieves the orientation of each truncated face (i.e. if each truncated face is right handed
        or not).

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::logic_error	 	If the orientation of the truncated faces is neither
            										stored in a HDF5 boolean array nor in a boolean constant
            										array.
        :raises: std::invalid_argument	If this grid is not truncated.

        :param [out]:	cellFaceIsRightHanded	An array to receive the orientation of truncated faces.
            										Value '0' means left handed and value other than '0'
            										means right handed. It must be preallocated with
            										getTruncatedFaceCount()
        """
        return _fesapi.Resqml2_AbstractGridRepresentation_getTruncatedFaceIsRightHanded(self, cellFaceIsRightHanded)
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractGridRepresentation

# Register Resqml2_AbstractGridRepresentation in _fesapi:
_fesapi.Resqml2_AbstractGridRepresentation_swigregister(Resqml2_AbstractGridRepresentation)
class Resqml2_UnstructuredGridRepresentation(Resqml2_AbstractGridRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getCellFaceIsRightHanded(self, cellFaceIsRightHanded: "uint8_t *") -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_getCellFaceIsRightHanded(self, cellFaceIsRightHanded)

    def getFaceCount(self) -> "uint64_t":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_getFaceCount(self)

    def getFaceIndicesOfCells(self, faceIndices: "uint64_t *") -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_getFaceIndicesOfCells(self, faceIndices)

    def getCumulativeFaceCountPerCell(self, *args) -> "uint64_t const *":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_getCumulativeFaceCountPerCell(self, *args)

    def getFaceCountPerCell(self, faceCountPerCell: "uint64_t *") -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_getFaceCountPerCell(self, faceCountPerCell)

    def isFaceCountOfCellsConstant(self) -> "bool":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_isFaceCountOfCellsConstant(self)

    def getConstantFaceCountOfCells(self) -> "unsigned int":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_getConstantFaceCountOfCells(self)

    def getNodeIndicesOfFaces(self, nodeIndices: "uint64_t *") -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_getNodeIndicesOfFaces(self, nodeIndices)

    def getCumulativeNodeCountPerFace(self, nodeCountPerFace: "uint64_t *") -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_getCumulativeNodeCountPerFace(self, nodeCountPerFace)

    def getNodeCountPerFace(self, nodeCountPerFace: "uint64_t *") -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_getNodeCountPerFace(self, nodeCountPerFace)

    def isNodeCountOfFacesConstant(self) -> "bool":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_isNodeCountOfFacesConstant(self)

    def getConstantNodeCountOfFaces(self) -> "unsigned int":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_getConstantNodeCountOfFaces(self)

    def loadGeometry(self) -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_loadGeometry(self)

    def getFaceCountOfCell(self, cellIndex: "uint64_t") -> "uint64_t":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_getFaceCountOfCell(self, cellIndex)

    def getNodeCountOfFaceOfCell(self, cellIndex: "uint64_t", localFaceIndex: "unsigned int") -> "uint64_t":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_getNodeCountOfFaceOfCell(self, cellIndex, localFaceIndex)

    def getNodeIndicesOfFaceOfCell(self, cellIndex: "uint64_t", localFaceIndex: "unsigned int") -> "uint64_t const *":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_getNodeIndicesOfFaceOfCell(self, cellIndex, localFaceIndex)

    def unloadGeometry(self) -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_unloadGeometry(self)

    def setGeometryUsingExistingDatasets(self, cellFaceIsRightHanded: "std::string const &", points: "std::string const &", pointCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", faceIndicesPerCell: "std::string const &", faceIndicesCumulativeCountPerCell: "std::string const &", faceCount: "uint64_t", nodeIndicesPerFace: "std::string const &", nodeIndicesCumulativeCountPerFace: "std::string const &", cellShape: "gsoap_resqml2_0_1::resqml20__CellShape", localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_setGeometryUsingExistingDatasets(self, cellFaceIsRightHanded, points, pointCount, proxy, faceIndicesPerCell, faceIndicesCumulativeCountPerCell, faceCount, nodeIndicesPerFace, nodeIndicesCumulativeCountPerFace, cellShape, localCrs)

    def setGeometry(self, cellFaceIsRightHanded: "uint8_t *", points: "double *", pointCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", faceIndicesPerCell: "uint64_t *", faceIndicesCumulativeCountPerCell: "uint64_t *", faceCount: "uint64_t", nodeIndicesPerFace: "uint64_t *", nodeIndicesCumulativeCountPerFace: "uint64_t *", cellShape: "gsoap_resqml2_0_1::resqml20__CellShape", localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_setGeometry(self, cellFaceIsRightHanded, points, pointCount, proxy, faceIndicesPerCell, faceIndicesCumulativeCountPerCell, faceCount, nodeIndicesPerFace, nodeIndicesCumulativeCountPerFace, cellShape, localCrs)

    def setTetrahedraOnlyGeometryUsingExistingDatasets(self, cellFaceIsRightHanded: "std::string const &", points: "std::string const &", pointCount: "uint64_t", faceCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", faceIndicesPerCell: "std::string const &", nodeIndicesPerFace: "std::string const &", localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_setTetrahedraOnlyGeometryUsingExistingDatasets(self, cellFaceIsRightHanded, points, pointCount, faceCount, proxy, faceIndicesPerCell, nodeIndicesPerFace, localCrs)

    def setTetrahedraOnlyGeometry(self, cellFaceIsRightHanded: "uint8_t *", points: "double *", pointCount: "uint64_t", faceCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", faceIndicesPerCell: "uint64_t *", nodeIndicesPerFace: "uint64_t *", localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_setTetrahedraOnlyGeometry(self, cellFaceIsRightHanded, points, pointCount, faceCount, proxy, faceIndicesPerCell, nodeIndicesPerFace, localCrs)

    def setHexahedraOnlyGeometryUsingExistingDatasets(self, cellFaceIsRightHanded: "std::string const &", points: "std::string const &", pointCount: "uint64_t", faceCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", faceIndicesPerCell: "std::string const &", nodeIndicesPerFace: "std::string const &", localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_setHexahedraOnlyGeometryUsingExistingDatasets(self, cellFaceIsRightHanded, points, pointCount, faceCount, proxy, faceIndicesPerCell, nodeIndicesPerFace, localCrs)

    def setHexahedraOnlyGeometry(self, cellFaceIsRightHanded: "uint8_t *", points: "double *", pointCount: "uint64_t", faceCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", faceIndicesPerCell: "uint64_t *", nodeIndicesPerFace: "uint64_t *", localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_UnstructuredGridRepresentation_setHexahedraOnlyGeometry(self, cellFaceIsRightHanded, points, pointCount, faceCount, proxy, faceIndicesPerCell, nodeIndicesPerFace, localCrs)
    __swig_destroy__ = _fesapi.delete_Resqml2_UnstructuredGridRepresentation

# Register Resqml2_UnstructuredGridRepresentation in _fesapi:
_fesapi.Resqml2_UnstructuredGridRepresentation_swigregister(Resqml2_UnstructuredGridRepresentation)
class Resqml2_AbstractColumnLayerGridRepresentation(Resqml2_AbstractGridRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getKCellCount(self) -> "uint64_t":
        r"""
        Gets the K layer count of this grid

        :raises: std::logic_error	If this grid is partial or if the underlying gSOAP instance
            									is not a RESQML2.0 one.

        :rtype: int
        :return: The K layer count of this grid.
        """
        return _fesapi.Resqml2_AbstractColumnLayerGridRepresentation_getKCellCount(self)

    def setKCellCount(self, kCount: "uint64_t") -> "void":
        r"""
        Sets the K layer count of this grid

        :raises: std::logic_error	If this grid is partial or if the underlying gSOAP instance is not a RESQML2.0 one.

        :type kCount: int
        :param kCount:	The K layer count to set to this grid.
        """
        return _fesapi.Resqml2_AbstractColumnLayerGridRepresentation_setKCellCount(self, kCount)

    def setIntervalAssociationWithStratigraphicOrganizationInterpretation(self, stratiUnitIndices: "int64_t *", nullValue: "int64_t", stratiOrgInterp: "Resqml2_AbstractStratigraphicOrganizationInterpretation", hdfProxy: "Eml2_AbstractHdfProxy") -> "void":
        return _fesapi.Resqml2_AbstractColumnLayerGridRepresentation_setIntervalAssociationWithStratigraphicOrganizationInterpretation(self, stratiUnitIndices, nullValue, stratiOrgInterp, hdfProxy)

    def getStratigraphicOrganizationInterpretation(self) -> "resqml2::AbstractStratigraphicOrganizationInterpretation *":
        return _fesapi.Resqml2_AbstractColumnLayerGridRepresentation_getStratigraphicOrganizationInterpretation(self)

    def hasIntervalStratigraphicUnitIndices(self) -> "bool":
        return _fesapi.Resqml2_AbstractColumnLayerGridRepresentation_hasIntervalStratigraphicUnitIndices(self)

    def getIntervalStratigraphicUnitIndices(self, stratiUnitIndices: "int64_t *") -> "int64_t":
        return _fesapi.Resqml2_AbstractColumnLayerGridRepresentation_getIntervalStratigraphicUnitIndices(self, stratiUnitIndices)

    def getMostComplexPillarGeometry(self) -> "gsoap_resqml2_0_1::resqml20__PillarShape":
        return _fesapi.Resqml2_AbstractColumnLayerGridRepresentation_getMostComplexPillarGeometry(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractColumnLayerGridRepresentation

# Register Resqml2_AbstractColumnLayerGridRepresentation in _fesapi:
_fesapi.Resqml2_AbstractColumnLayerGridRepresentation_swigregister(Resqml2_AbstractColumnLayerGridRepresentation)
class Resqml2_AbstractIjkGridRepresentation(Resqml2_AbstractColumnLayerGridRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    geometryKind_UNKNOWN = _fesapi.Resqml2_AbstractIjkGridRepresentation_geometryKind_UNKNOWN
    geometryKind_EXPLICIT = _fesapi.Resqml2_AbstractIjkGridRepresentation_geometryKind_EXPLICIT
    geometryKind_PARAMETRIC = _fesapi.Resqml2_AbstractIjkGridRepresentation_geometryKind_PARAMETRIC
    geometryKind_LATTICE = _fesapi.Resqml2_AbstractIjkGridRepresentation_geometryKind_LATTICE
    geometryKind_NO_GEOMETRY = _fesapi.Resqml2_AbstractIjkGridRepresentation_geometryKind_NO_GEOMETRY

    def getICellCount(self) -> "unsigned int":
        r"""
        Gets the count of cells in the I direction.

        :raises: std::logic_error	If this grid is partial.
        :raises: std::range_error	If the count is strictly greater than unsigned int max.

        :rtype: int
        :return: The count of cell in the I direction.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getICellCount(self)

    def setICellCount(self, iCount: "unsigned int") -> "void":
        r"""
        Sets the count of cells in the I direction.

        :raises: std::logic_error	If this grid is partial.

        :type iCount: int
        :param iCount:	The count of cells to set in the I direction.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_setICellCount(self, iCount)

    def getJCellCount(self) -> "unsigned int":
        r"""
        Gets the count of cells in the J direction.

        :raises: std::logic_error	If this grid is partial.
        :raises: std::range_error	If the count is strictly greater than unsigned int max.

        :rtype: int
        :return: The count of cell in the J direction.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getJCellCount(self)

    def setJCellCount(self, jCount: "unsigned int") -> "void":
        r"""
        Sets the count of cells in the J direction.

        :raises: std::logic_error	If this grid is partial.

        :type jCount: int
        :param jCount:	The count of cells to set in the J direction.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_setJCellCount(self, jCount)

    def getColumnCount(self) -> "unsigned int":
        r"""
        Gets the count of columns in this grid.

        :raises: std::logic_error	If this grid is partial.
        :raises: std::range_error	If the count of cells in I or J direction is
            									strictly greater than unsigned int max.

        :rtype: int
        :return: The column count.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getColumnCount(self)

    def getPillarCount(self) -> "unsigned int":
        r"""
        Gets the count of pillars in this grid.

        :raises: std::logic_error	If this grid is partial.
        :raises: std::range_error	If the count of cells in I or J direction is
            									strictly greater than unsigned int max.

        :rtype: int
        :return: The pillar count.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getPillarCount(self)

    def getKGapsCount(self) -> "uint64_t":
        r"""
        Gets the count of K layer gaps in this grid.

        :raises: std::logic_error	If this grid is partial.
        :raises: std::range_error	If the count of cells in I or J direction is
            									strictly greater than unsigned int max.

        :rtype: int
        :return: The K Layer gaps count.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getKGapsCount(self)

    def getKGaps(self, kGaps: "bool *") -> "void":
        r"""
        For each K Layer except the last one, indicate wether there is a layer or not after it.

        :param [out]:	kGaps	An array for receiving the information about kGaps.
            						It must have a count of getKCellCount() - 1. It won't be free. A false value in
            						``kGaps`` means that the corresponding k layer has no gaps just after it.
            						A true value means that the corresponding k layer has a gap just after it.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getKGaps(self, kGaps)

    def getFaceCount(self) -> "uint64_t":
        r"""
        Gets the count of faces in this grid. This method requires you have already loaded the split
        information thanks to loadSplitInformation().

        :raises: std::logic_error	 	If this grid is partial.
        :raises: std::range_error	 	If the count of cells in I, J or K
            										direction is strictly greater than unsigned int max.
        :raises: std::invalid_argument	If there is no geometry on this grid.

        :rtype: int
        :return: The face count.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getFaceCount(self)

    def getIPillarFromGlobalIndex(self, globalIndex: "unsigned int") -> "unsigned int":
        r"""
        Gets the I index of a pillar from its global index in this grid. The global (or
        linearized) index of a given pillar is i pillar + j pillar * (nI pillar) where
        i pillar and j pillar are respectively the I and J indices of the
        pillar and nI pillar is the count of pillars in the I direction.

        :raises: std::logic_error	If this grid is partial.
        :raises: std::range_error 	If the count of cells in I or J direction is
            									strictly greater than unsigned int max.
        :raises: std::out_of_range	If ``globalIndex`` is out of range (greater than or equal to
            									getPillarCount()).

        :type globalIndex: int
        :param globalIndex:	The global index of the pillar for which we want to get the I index.

        :rtype: int
        :return: The I index of the pillar.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getIPillarFromGlobalIndex(self, globalIndex)

    def getJPillarFromGlobalIndex(self, globalIndex: "unsigned int") -> "unsigned int":
        r"""
        Gets the J index of a pillar from its global index in this grid. The global (or
        linearized) index of a given pillar is i pillar + j pillar * (nI pillar) where
        i pillar and j pillar are respectively the I and J indices of the
        pillar and nI pillar is the count of pillars in the I direction.

        :raises: std::logic_error	If this grid is partial.
        :raises: std::range_error 	If the count of cells in I or J direction is
            									strictly greater than unsigned int max.
        :raises: std::out_of_range	If ``globalIndex`` is out of range (greater than or equal to
            									getPillarCount()).

        :type globalIndex: int
        :param globalIndex:	The global index of the pillar for which we want to get the J index.

        :rtype: int
        :return: The J index of the pillar.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getJPillarFromGlobalIndex(self, globalIndex)

    def getGlobalIndexPillarFromIjIndex(self, iPillar: "unsigned int", jPillar: "unsigned int") -> "unsigned int":
        r"""
        Gets the global index of a pillar from its I and J indices in the grid. The global (or
        linearized) index of a given pillar is i pillar + j pillar * (nI pillar) where
        i pillar and j pillar are respectively the I and J indices of the
        pillar and nI pillar is the count of pillars in the I direction.

        :raises: std::logic_error	If this grid is partial.
        :raises: std::range_error 	If the count of cells in I or J direction is strictly greater
            									than unsigned int max.
        :raises: std::out_of_range	If ``iPillar`` is strictly greater than getICellCount().
        :raises: std::out_of_range	If ``jPillar`` is strictly greater than getJCellCount().

        :type iPillar: int
        :param iPillar:	The I index of the pillar.
        :type jPillar: int
        :param jPillar:	The J index of the pillar.

        :rtype: int
        :return: The global index of the pillar.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getGlobalIndexPillarFromIjIndex(self, iPillar, jPillar)

    def getIColumnFromGlobalIndex(self, globalIndex: "unsigned int") -> "unsigned int":
        r"""
        Gets the I index of a column from its global index in the grid. The global (or linearized)
        index of a given column is i column + j column * (nI cell) where
        i column and j column are respectively the I and J indices of the
        column and nI cell is the count of cells in the I direction.

        :raises: std::logic_error	If this grid is partial.
        :raises: std::range_error 	If the count of cells in I or J direction is strictly greater
            									than unsigned int max.
        :raises: std::out_of_range	If ``globalIndex`` is out of range (greater than or equal to
            									getColumnCount()).

        :type globalIndex: int
        :param globalIndex:	The global index of the column for which we want to get the I index.

        :rtype: int
        :return: The I index of the column.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getIColumnFromGlobalIndex(self, globalIndex)

    def getJColumnFromGlobalIndex(self, globalIndex: "unsigned int") -> "unsigned int":
        r"""
        Gets the J index of a column from its global index in the grid. The global (or linearized)
        index of a given column is i column + j column * (nI cell) where
        i column and j column are respectively the I and J indices of the
        column and nI cell is the count of cells in the I direction.

        :raises: std::logic_error	If this grid is partial.
        :raises: std::range_error 	If the count of cells in I or J direction is strictly greater
            									than unsigned int max.
        :raises: std::out_of_range	If ``globalIndex`` is out of range (greater than or equal to
            									getColumnCount()).

        :type globalIndex: int
        :param globalIndex:	The global index of the column for which we want to get the J index.

        :rtype: int
        :return: The J index of the column.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getJColumnFromGlobalIndex(self, globalIndex)

    def getGlobalIndexColumnFromIjIndex(self, iColumn: "unsigned int", jColumn: "unsigned int") -> "unsigned int":
        r"""
        Gets the global index of a column from its I and J indices in the grid. The global (or
        linearized) index of a given column is i column + j column * (nI cell) where
        i column and j column are respectively the I and J indices of the
        column and nI cell is the count of cells in the I direction.

        :raises: std::logic_error	If this grid is partial.
        :raises: std::range_error 	If the count of cells in I or J direction is strictly greater
            									than unsigned int max.
        :raises: std::out_of_range	If ``iColumn`` is greater than or equal to getICellCount().
        :raises: std::out_of_range	If ``jColumn`` is greater than or equal to getJCellCount().

        :type iColumn: int
        :param iColumn:	The I index of the column.
        :type jColumn: int
        :param jColumn:	The J index of the column.

        :rtype: int
        :return: The global index of the column.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getGlobalIndexColumnFromIjIndex(self, iColumn, jColumn)

    def getGlobalIndexCellFromIjkIndex(self, iCell: "unsigned int", jCell: "unsigned int", kCell: "unsigned int") -> "unsigned int":
        r"""
        Gets the global index of a cell from its I, J and K indices in the grid.

        :raises: std::logic_error	If this grid is partial.
        :raises: std::range_error 	If the count of cells in I, J or K direction is strictly
            									greater than unsigned int max.
        :raises: std::out_of_range	If ``iCell`` is greater than or equal to getICellCount().
        :raises: std::out_of_range	If ``jCell`` is greater than or equal to getJCellCount().
        :raises: std::out_of_range	If ``kCell`` is greater than or equal to getKCellCount().

        :type iCell: int
        :param iCell:	The I index of the cell.
        :type jCell: int
        :param jCell:	The J index of the cell.
        :type kCell: int
        :param kCell:	The K index of the cell.

        :rtype: int
        :return: The global index of the cell.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getGlobalIndexCellFromIjkIndex(self, iCell, jCell, kCell)

    def isRightHanded(self) -> "bool":
        r"""
        Queries if this grid is right handed, as determined by the triple product of tangent vectors
        in the I, J, and K directions.

        :raises: std::logic_error	If this grid has no geometry. Or, if it is in an unrecognized
            									version of RESQML.

        :rtype: boolean
        :return: True if this grid is right handed, false if it is not.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_isRightHanded(self)

    def getPillarsOfSplitCoordinateLines(self, pillarIndices: "unsigned int *", reverseIAxis: "bool"=False, reverseJAxis: "bool"=False) -> "void":
        r"""
        Gets all the pillars which correspond to all split coordinate lines. The order of the pillars
        corresponds to the order of the split coordinate lines.

        :raises: std::invalid_argument	If the HDF proxy is missing.
        :raises: std::invalid_argument	If there is no geometry or no split coordinate line in
            										this grid.
        :raises: std::logic_error	 	If the indices of the pillars corresponding to the split
            										coordinate lines are not stored within an HDF5 integer
            										array.

        :param [out]:	pillarIndices	An array for receiving the indices of the pillars corresponding
            								to the split coordinate lines. It must be preallocated with a
            								size of getSplitCoordinateLineCount().
        :type reverseIAxis: boolean, optional
        :param reverseIAxis: 	(Optional) True to reverse I axis. Default value is false.
        :type reverseJAxis: boolean, optional
        :param reverseJAxis: 	(Optional) True to reverse J axis. Default value is false.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getPillarsOfSplitCoordinateLines(self, pillarIndices, reverseIAxis, reverseJAxis)

    def getColumnsOfSplitCoordinateLines(self, columnIndices: "unsigned int *", reverseIAxis: "bool"=False, reverseJAxis: "bool"=False) -> "void":
        r"""
        Gets all the columns impacted by all the split coordinate lines. The order of the columns
        corresponds to the order of the split coordinate lines.

        :raises: std::invalid_argument	If the HDF proxy is missing.
        :raises: std::invalid_argument	If there is no geometry or no split coordinate line in
            										this grid.
        :raises: std::logic_error	 	If the indices of the columns impacted by the split
            										coordinate lines are not stored within an HDF5 integer
            										array.

        :param [out]:	columnIndices	An array for receiving the indices of the columns impacted by the
            								split coordinate lines. It must be preallocated with a size equal
            								to the last value of the array outputted from
            								getColumnCountOfSplitCoordinateLines().
        :type reverseIAxis: boolean, optional
        :param reverseIAxis: 	(Optional) True to reverse i axis. Default value is false.
        :type reverseJAxis: boolean, optional
        :param reverseJAxis: 	(Optional) True to reverse j axis. Default value is false.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getColumnsOfSplitCoordinateLines(self, columnIndices, reverseIAxis, reverseJAxis)

    def getColumnCountOfSplitCoordinateLines(self, columnIndexCountPerSplitCoordinateLine: "unsigned int *") -> "void":
        r"""
        Gets the cumulative count of columns impacted by all the split coordinate lines. The order of
        the cumulative count values corresponds to the order of the split coordinates lines.

        :raises: std::invalid_argument	If the HDF proxy is missing.
        :raises: std::invalid_argument	If there is no geometry or no split coordinate line in
            										this grid.
        :raises: std::logic_error	 	If the cumulative count of the columns impacted by the
            										split coordinate lines are not stored within an HDF5
            										integer array.

        :param [out]:	columnIndexCountPerSplitCoordinateLine	An array for receiving the cumulative
            														count of columns impacted by the split
            														coordinate lines.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getColumnCountOfSplitCoordinateLines(self, columnIndexCountPerSplitCoordinateLine)

    def getSplitCoordinateLineCount(self) -> "uint64_t":
        r"""
        Gets the split coordinate lines count.

        :raises: std::invalid_argument	If there is no geometry on this IJK grid.
        :raises: std::range_error	 	If the count of split coordinate lines is strictly
            										greater than unsigned int max.

        :rtype: int
        :return: The split coordinate lines count.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getSplitCoordinateLineCount(self)

    def getBlockSplitCoordinateLineCount(self) -> "uint64_t":
        r"""
        Gets the split coordinate lines count within the block. Block information must be loaded thanks
        to loadBlockInformation().

        :raises: std::invalid_argument	If the block information is not loaded.

        :rtype: int
        :return: The split coordinate lines count within the block.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getBlockSplitCoordinateLineCount(self)

    def getSplitNodeCount(self) -> "uint64_t":
        r"""
        Gets the split nodes count.

        :raises: std::invalid_argument	If there is no geometry on this IJK grid.

        :rtype: int
        :return: The split nodes count.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getSplitNodeCount(self)

    def loadSplitInformation(self) -> "void":
        r"""
        Loads the split information into memory to speed up processes. Be aware that you must unload
        by yourself this memory thanks to unloadSplitInformation().
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_loadSplitInformation(self)

    def unloadSplitInformation(self) -> "void":
        r""" Unloads the split information from memory."""
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_unloadSplitInformation(self)

    def isColumnEdgeSplitted(self, iColumn: "unsigned int", jColumn: "unsigned int", edge: "unsigned int") -> "bool":
        r"""
        Checks either a given column edge is splitted or not. This method requires that you
        			have already loaded the split information.

        :raises: std::logic_error	 	If this grid is partial.
        :raises: std::invalid_argument	If the split information is not loaded.
        :raises: std::out_of_range	 	If ``iColumn`` is strictly greater than getICellCount().
        :raises: std::out_of_range	 	If ``iColumn`` is strictly greater than getJCellCount().
        :raises: std::out_of_range	 	If ``edge`` is strictly greater than 3.

        :type iColumn: int
        :param iColumn:	The I index of the column.
        :type jColumn: int
        :param jColumn:	The J index of the column.
        :type edge: int
        :param edge:   	0 for edge from i to i+1, lower j connection; 1 for edge from j to j+1, upper
            					i connection; 2 for edge from i+1 to i, upper j connection; 3 for edge from
            					j+1 to j, lower i connection.

        :rtype: boolean
        :return: True if the column edge is splitted, false if not.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_isColumnEdgeSplitted(self, iColumn, jColumn, edge)

    def getXyzPointIndexFromCellCorner(self, iCell: "unsigned int", jCell: "unsigned int", kCell: "unsigned int", corner: "unsigned int") -> "uint64_t":
        r"""
        Gets the XYZ point index in the HDF dataset from the corner of a cell. This method
        			requires that you have already loaded the split information.

        :raises: std::logic_error	 	If this grid is partial.
        :raises: std::invalid_argument	If the split information is not loaded.
        :raises: std::out_of_range	 	If ``iCell`` > getICellCount(), ``jCell`` >
            										getJCellCount() or ``kCell`` > getKCellCount().
        :raises: std::out_of_range	 	If ``corner`` > 7.

        :type iCell: int
        :param iCell: 	The I index of the cell.
        :type jCell: int
        :param jCell: 	The J index of the cell.
        :type kCell: int
        :param kCell: 	The K index of the cell.
        :type corner: int
        :param corner:	Index of the corner: 0 for (0,0,0); 1 for (1,0,0); 2 for (1,1,0); 3 for (0,1,
            					0); 4 for (0,0,1); 5 for (1,0,1); 6 for (1,1,1); 7 for (0,1,1).

        :rtype: int
        :return: The index of the XYZ point in the HDF dataset corresponding to the corner of the
            			cell. Keep in mind to multiply the result by 3 to get the X index since the points
            			are triplet of values.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getXyzPointIndexFromCellCorner(self, iCell, jCell, kCell, corner)

    def getPillarGeometryIsDefined(self, pillarGeometryIsDefined: "bool *", reverseIAxis: "bool"=False, reverseJAxis: "bool"=False) -> "void":
        r"""
        Tells for each pillar if its geometry is defined. This method only looks at the corresponding
        ``PillarGeometryIsDefined`` attribute in the gSOAP proxy.

        :raises: std::logic_error	 	If this grid is partial.
        :raises: std::range_error	 	If the count of cells in I or J direction is strictly
            										greater than unsigned int max.
        :raises: std::invalid_argument	If there is no geometry on this IJK grid.
        :raises: std::invalid_argument	If the values indicating for each pillar if its geometry
            										is defined are neither stored in an HDF5 boolean array
            										nor in a boolean constant array.

        :param [out]:	pillarGeometryIsDefined	An array for receiving a boolean value for each pillar
            										indicating if its geometry is defined or not. It must be
            										preallocated with a size of getPillarCount().
        :type reverseIAxis: boolean, optional
        :param reverseIAxis:		   	(Optional) True to reverse i axis. Default value is false.
        :type reverseJAxis: boolean, optional
        :param reverseJAxis:		   	(Optional) True to reverse j axis. Default value is false.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getPillarGeometryIsDefined(self, pillarGeometryIsDefined, reverseIAxis, reverseJAxis)

    def hasCellGeometryIsDefinedFlags(self) -> "bool":
        r"""
        Indicates if this grid contains a flag on each cell indicating if its geometry is defined or not
        (i.e. meaning that at least one of the coordinates of at least one of the cell vertex is NaN).
        Do not mix this flag with the active one : http://docs.energistics.org/#RESQML/RESQML_TOPICS/RESQML-000-289-0-C-sv2010.html

        :rtype: boolean
        :return: True if this grid contains a flag on each cell indicating if its geometry is defined or not, false if not.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_hasCellGeometryIsDefinedFlags(self)

    def getCellGeometryIsDefinedFlags(self, cellGeometryIsDefinedFlags: "bool *", reverseIAxis: "bool"=False, reverseJAxis: "bool"=False, reverseKAxis: "bool"=False) -> "void":
        r"""
        Get the flags for each cell indicating if its geometry is defined or not
        (i.e. meaning that at least one of the coordinates of at least one of the cell vertex is NaN).
        Do not mix this flag with the active one : http://docs.energistics.org/#RESQML/RESQML_TOPICS/RESQML-000-289-0-C-sv2010.html

        :raises: std::invalid_argument	If this grid has no geometry or no CellGeometryIsDefined flags.
        :raises: std::invalid_argument	If the CellGeometryIsDefined flags are neither
            										stored in an HDF5 boolean array nor in a boolean constant
            										array.

        :param [out]:	cellGeometryIsDefinedFlags	An array for receiving the information about CellGeometryIsDefined flags.
            								It must have a count of getCellCount() and must follow the
            								index ordering I then J then K. It won't be free. A zero value in
            								``cellGeometryIsDefinedFlags`` means that the corresponding cell geometry is not defined. A non
            								zero value means that the corresponding cell geometry is defined.
        :type reverseIAxis: boolean, optional
        :param reverseIAxis:	(Optional) True to reverse i axis. Default value is false.
        :type reverseJAxis: boolean, optional
        :param reverseJAxis:	(Optional) True to reverse j axis. Default value is false.
        :type reverseKAxis: boolean, optional
        :param reverseKAxis:	(Optional) True to reverse k axis. Default value is false.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getCellGeometryIsDefinedFlags(self, cellGeometryIsDefinedFlags, reverseIAxis, reverseJAxis, reverseKAxis)

    def setCellGeometryIsDefinedFlags(self, cellGeometryIsDefinedFlags: "uint8_t *", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Sets the flags for each cell indicating if its geometry is defined or not
        (i.e. meaning that at least one of the coordinates of at least one of the cell vertex is NaN).
        Do not mix this flag with the active one : http://docs.energistics.org/#RESQML/RESQML_TOPICS/RESQML-000-289-0-C-sv2010.html

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If this grid has no geometry.

        :param [in]:	  	cellGeometryIsDefinedFlags	An array containing the CellGeometryIsDefined flags.
            									It must have a count of getCellCount() and must follow the
            									index ordering I then J then K. A zero value in
            									``cellGeometryIsDefinedFlags`` means that the corresponding cell geometry is not defined. A non
            									zero value means that the corresponding cell geometry is defined.
        :param [in]:		proxy			(Optional) The HDF proxy for writing the ``cellGeometryIsDefinedFlags``
            									values. If ``nullptr`` (default), then the default HDF proxy will be
            									used.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_setCellGeometryIsDefinedFlags(self, cellGeometryIsDefinedFlags, proxy)

    def setAllCellGeometryFlagsToDefined(self) -> "void":
        r"""
        Set to "defined" the flags for each cell indicating if its geometry is defined or not
        (i.e. meaning that at least one of the coordinates of at least one of the cell vertex is NaN).
        Do not mix this flag with the active one : http://docs.energistics.org/#RESQML/RESQML_TOPICS/RESQML-000-289-0-C-sv2010.html
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_setAllCellGeometryFlagsToDefined(self)

    def getXyzPointCountOfKInterface(self) -> "uint64_t":
        r"""
        Get the XYZ points count in each K layer interface.

        :raises: std::logic_error	 	If this grid is partial.
        :raises: std::range_error	 	If the count of cells in I or J direction is strictly
            										greater than unsigned int max.
        :raises: std::invalid_argument	If there is no geometry on this IJK grid.
        :raises: std::range_error	 	If the count of split coordinate lines is strictly
            										greater than unsigned int max.

        :rtype: int
        :return: The XYZ point count of each K layer interface.
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getXyzPointCountOfKInterface(self)

    def getXyzPointsOfKInterface(self, kInterface: "unsigned int", xyzPoints: "double *") -> "void":
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getXyzPointsOfKInterface(self, kInterface, xyzPoints)

    def getXyzPointsOfKInterfaceSequence(self, kInterfaceStart: "unsigned int", kInterfaceEnd: "unsigned int", xyzPoints: "double *") -> "void":
        r"""
        Gets all the XYZ points of a particular sequence of K interfaces. XYZ points are given in the
        local CRS.

        :raises: std::out_of_range	 	If ``kInterfaceStart`` > getKCellCount() or
            ``kInterfaceEnd`` > getKCellCount() + getKGapsCount().
        :raises: std::range_error	 	If ``kInterfaceStart`` > ``kInterfaceEnd``.
        :raises: std::invalid_argument	If ``xyzPoints`` is nullptr.

        :type kInterfaceStart: int
        :param kInterfaceStart:	The K index of the starting interface taken from zero to
            								getKCellCount().
        :type kInterfaceEnd: int
        :param kInterfaceEnd:  	The K index of the ending interface taken from zero to
            								getKCellCount() + getKGapsCount().
        :param [out]:	xyzPoints	   	A linearized 2d array where the first (quickest) dimension is
            								coordinate dimension (XYZ) and second dimension is vertex
            								dimension. It must be preallocated with a size of
            								3 * getXyzPointCountOfKInterface() *
            								(kInterfaceEnd - kInterfaceStart + 1).
        """
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getXyzPointsOfKInterfaceSequence(self, kInterfaceStart, kInterfaceEnd, xyzPoints)

    def isNodeGeometryCompressed(self) -> "bool":
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_isNodeGeometryCompressed(self)

    def getKDirection(self) -> "gsoap_resqml2_0_1::resqml20__KDirection":
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getKDirection(self)

    def getGeometryKind(self) -> "resqml2::AbstractIjkGridRepresentation::geometryKind":
        return _fesapi.Resqml2_AbstractIjkGridRepresentation_getGeometryKind(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractIjkGridRepresentation

# Register Resqml2_AbstractIjkGridRepresentation in _fesapi:
_fesapi.Resqml2_AbstractIjkGridRepresentation_swigregister(Resqml2_AbstractIjkGridRepresentation)
class Resqml2_IjkGridLatticeRepresentation(Resqml2_AbstractIjkGridRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def isASeismicCube(self) -> "bool":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_isASeismicCube(self)

    def isAFaciesCube(self) -> "bool":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_isAFaciesCube(self)

    def getXOrigin(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getXOrigin(self)

    def getYOrigin(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getYOrigin(self)

    def getZOrigin(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getZOrigin(self)

    def getXOriginInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getXOriginInGlobalCrs(self)

    def getYOriginInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getYOriginInGlobalCrs(self)

    def getZOriginInGlobalCrs(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getZOriginInGlobalCrs(self)

    def getXIOffset(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getXIOffset(self)

    def getYIOffset(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getYIOffset(self)

    def getZIOffset(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getZIOffset(self)

    def getXJOffset(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getXJOffset(self)

    def getYJOffset(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getYJOffset(self)

    def getZJOffset(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getZJOffset(self)

    def getXKOffset(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getXKOffset(self)

    def getYKOffset(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getYKOffset(self)

    def getZKOffset(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getZKOffset(self)

    def getISpacing(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getISpacing(self)

    def getJSpacing(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getJSpacing(self)

    def getKSpacing(self) -> "double":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getKSpacing(self)

    def getOriginInline(self) -> "int":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getOriginInline(self)

    def getOriginCrossline(self) -> "int":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getOriginCrossline(self)

    def getInlineIOffset(self) -> "int":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getInlineIOffset(self)

    def getInlineJOffset(self) -> "int":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getInlineJOffset(self)

    def getInlineKOffset(self) -> "int":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getInlineKOffset(self)

    def getCrosslineIOffset(self) -> "int":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getCrosslineIOffset(self)

    def getCrosslineJOffset(self) -> "int":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getCrosslineJOffset(self)

    def getCrosslineKOffset(self) -> "int":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_getCrosslineKOffset(self)

    def setGeometryAsCoordinateLineNodes(self, mostComplexPillarGeometry: "gsoap_resqml2_0_1::resqml20__PillarShape", kDirectionKind: "gsoap_resqml2_0_1::resqml20__KDirection", isRightHanded: "bool", originX: "double", originY: "double", originZ: "double", directionIX: "double", directionIY: "double", directionIZ: "double", spacingI: "double", directionJX: "double", directionJY: "double", directionJZ: "double", spacingJ: "double", directionKX: "double", directionKY: "double", directionKZ: "double", spacingK: "double", localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_setGeometryAsCoordinateLineNodes(self, mostComplexPillarGeometry, kDirectionKind, isRightHanded, originX, originY, originZ, directionIX, directionIY, directionIZ, spacingI, directionJX, directionJY, directionJZ, spacingJ, directionKX, directionKY, directionKZ, spacingK, localCrs)

    def addSeismic3dCoordinatesToPatch(self, patchIndex: "unsigned int", startInline: "double", incrInline: "double", countInline: "unsigned int", startCrossline: "double", incrCrossline: "double", countCrossline: "unsigned int", countSample: "unsigned int", seismicSupport: "Resqml2_AbstractRepresentation") -> "void":
        return _fesapi.Resqml2_IjkGridLatticeRepresentation_addSeismic3dCoordinatesToPatch(self, patchIndex, startInline, incrInline, countInline, startCrossline, incrCrossline, countCrossline, countSample, seismicSupport)
    __swig_destroy__ = _fesapi.delete_Resqml2_IjkGridLatticeRepresentation

# Register Resqml2_IjkGridLatticeRepresentation in _fesapi:
_fesapi.Resqml2_IjkGridLatticeRepresentation_swigregister(Resqml2_IjkGridLatticeRepresentation)
class Resqml2_IjkGridExplicitRepresentation(Resqml2_AbstractIjkGridRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setGeometryAsCoordinateLineNodes(self, mostComplexPillarGeometry: "gsoap_resqml2_0_1::resqml20__PillarShape", kDirectionKind: "gsoap_resqml2_0_1::resqml20__KDirection", isRightHanded: "bool", points: "double const *", proxy: "Eml2_AbstractHdfProxy"=None, splitCoordinateLineCount: "uint64_t"=0, pillarOfCoordinateLine: "unsigned int const *"=None, splitCoordinateLineColumnCumulativeCount: "unsigned int const *"=None, splitCoordinateLineColumns: "unsigned int const *"=None, definedPillars: "int8_t const *"=None, localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        r"""
        Sets the geometry of this IJK grid as explicit coordinate line nodes. See RESQML Usage,
        Technical guide and Enterprise Architect diagrams for details.

        :raises: std::invalid_argument	If ``points`` is ``nullptr``.
        :raises: std::invalid_argument	If (splitCoordinateLineCount != 0 &&
            										(pillarOfCoordinateLine == nullptr ||
            										splitCoordinateLineColumnCumulativeCount == nullptr ||
            										splitCoordinateLineColumns == nullptr)).
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If ``localCrs`` is ``nullptr`` and no default local 3d CRS
            										is defined.

        :type mostComplexPillarGeometry: int
        :param mostComplexPillarGeometry:					The most complex pillar geometry
            																which occurs on this reservoir grid.
        :type kDirectionKind: int
        :param kDirectionKind:								The direction of the K axis on
            																the earth. It is not directly related
            																to Z of the vertical CRS but to the
            																physical earth (as the vertical CRS
            																is).
        :type isRightHanded: boolean
        :param isRightHanded:								Indicates that the IJK grid is
            																right handed, as determined by the
            																triple product of tangent vectors in
            																the I, J, and K directions.
        :param [in]:	  	points										XYZ double triplets ordered by i
            																then j then split then k. Count must
            																be ((iCellCount+1) *
            																(jCellCount+1) +
            																splitCoordinateLineCount) *
            																kCellCount.
        :param [in,out]:	proxy										(Optional) The HDF proxy where
            																all numerical values will be stored.
            																If ``nullptr``, then the default HDF
            																proxy of the repository will be used.
        :type splitCoordinateLineCount: int, optional
        :param splitCoordinateLineCount:					(Optional) The count of split
            																coordinate line. A grid pillar is
            																splitted in up to 4 coordinate lines.
        :param [in]:	  	pillarOfCoordinateLine						(Optional) For each split
            																coordinate line, indicates which
            																pillar it belongs to. Pillars are
            																identified by their absolute 1d index
            																(iPillar + jPillar *
            																iPillarCount) where
            																iPillarCount ==
            																iCellCount+1. Count is
            																splitCoordinateLineCount.
        :param [in]:	  	splitCoordinateLineColumnCumulativeCount	(Optional) For each split
            																coordinate line, indicates how many
            																columns of the ijk grid are incident
            																to it (minimum is one and maximum is
            																3) + the count of all incident
            																columns of previous spit coordinate
            																lines in the array. For example
            																{1, 4, 6} would mean that
            																the first split coordinate line is
            																incident to only one column, the
            																second split coordinate line is
            																incident to 4 - 1 = 3
            																columns and the third column is
            																incident to 6 - 4 = 2
            																columns. Count is
            																splitCoordinateLineCount.
        :param [in]:	  	splitCoordinateLineColumns					(Optional) For each split
            																coordinate line, indicates which
            																columns are incident to it. Count is
            																the last value in the
            																splitCoordinateLineColumnCumulativeCount
            																array. Columns are identified by
            																their absolute 1d index
            																(iColumn
            																 + jColumn * iColumnCount)
            																where
            																Column == Cell.
        :param [in]:	  	definedPillars								(Optional) For each pillar : 0 if
            																pillar is not defined (i.e points
            																equal to NaN) else the pillar is
            																defined.  This information overrides
            																any pillar geometry information. If
            																null, then all pillars are assumed to
            																be defined.
        :param [in]:	  	localCrs									(Optional) The local CRS where
            																the points are given. If ``nullptr``
            																(default) then the default CRS of the
            																repository will be used.
        """
        return _fesapi.Resqml2_IjkGridExplicitRepresentation_setGeometryAsCoordinateLineNodes(self, mostComplexPillarGeometry, kDirectionKind, isRightHanded, points, proxy, splitCoordinateLineCount, pillarOfCoordinateLine, splitCoordinateLineColumnCumulativeCount, splitCoordinateLineColumns, definedPillars, localCrs)

    def setGeometryAsCoordinateLineNodesUsingExistingDatasets(self, *args) -> "void":
        return _fesapi.Resqml2_IjkGridExplicitRepresentation_setGeometryAsCoordinateLineNodesUsingExistingDatasets(self, *args)
    __swig_destroy__ = _fesapi.delete_Resqml2_IjkGridExplicitRepresentation

# Register Resqml2_IjkGridExplicitRepresentation in _fesapi:
_fesapi.Resqml2_IjkGridExplicitRepresentation_swigregister(Resqml2_IjkGridExplicitRepresentation)
class Resqml2_IjkGridParametricRepresentation(Resqml2_AbstractIjkGridRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getControlPointMaxCountPerPillar(self) -> "unsigned int":
        return _fesapi.Resqml2_IjkGridParametricRepresentation_getControlPointMaxCountPerPillar(self)

    def getControlPoints(self, controlPoints: "double *", reverseIAxis: "bool"=False, reverseJAxis: "bool"=False, reverseKAxis: "bool"=False) -> "void":
        return _fesapi.Resqml2_IjkGridParametricRepresentation_getControlPoints(self, controlPoints, reverseIAxis, reverseJAxis, reverseKAxis)

    def hasControlPointParameters(self) -> "bool":
        return _fesapi.Resqml2_IjkGridParametricRepresentation_hasControlPointParameters(self)

    def getControlPointParameters(self, controlPointParameters: "double *", reverseIAxis: "bool"=False, reverseJAxis: "bool"=False, reverseKAxis: "bool"=False) -> "void":
        return _fesapi.Resqml2_IjkGridParametricRepresentation_getControlPointParameters(self, controlPointParameters, reverseIAxis, reverseJAxis, reverseKAxis)

    def getParametricLineKind(self, pillarKind: "short *", reverseIAxis: "bool"=False, reverseJAxis: "bool"=False) -> "void":
        return _fesapi.Resqml2_IjkGridParametricRepresentation_getParametricLineKind(self, pillarKind, reverseIAxis, reverseJAxis)

    def getParametersOfNodes(self, parameters: "double *", reverseIAxis: "bool"=False, reverseJAxis: "bool"=False, reverseKAxis: "bool"=False) -> "void":
        return _fesapi.Resqml2_IjkGridParametricRepresentation_getParametersOfNodes(self, parameters, reverseIAxis, reverseJAxis, reverseKAxis)

    def setGeometryAsParametricNonSplittedPillarNodes(self, mostComplexPillarGeometry: "gsoap_resqml2_0_1::resqml20__PillarShape", isRightHanded: "bool", parameters: "double *", controlPoints: "double *", controlPointParameters: "double *", controlPointMaxCountPerPillar: "unsigned int", pillarKind: "short *", proxy: "Eml2_AbstractHdfProxy"=None, localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_IjkGridParametricRepresentation_setGeometryAsParametricNonSplittedPillarNodes(self, mostComplexPillarGeometry, isRightHanded, parameters, controlPoints, controlPointParameters, controlPointMaxCountPerPillar, pillarKind, proxy, localCrs)

    def setGeometryAsParametricNonSplittedPillarNodesUsingExistingDatasets(self, mostComplexPillarGeometry: "gsoap_resqml2_0_1::resqml20__PillarShape", kDirectionKind: "gsoap_resqml2_0_1::resqml20__KDirection", isRightHanded: "bool", parameters: "std::string const &", controlPoints: "std::string const &", controlPointParameters: "std::string const &", controlPointMaxCountPerPillar: "unsigned int", pillarKind: "std::string const &", definedPillars: "std::string const &", proxy: "Eml2_AbstractHdfProxy"=None, localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        return _fesapi.Resqml2_IjkGridParametricRepresentation_setGeometryAsParametricNonSplittedPillarNodesUsingExistingDatasets(self, mostComplexPillarGeometry, kDirectionKind, isRightHanded, parameters, controlPoints, controlPointParameters, controlPointMaxCountPerPillar, pillarKind, definedPillars, proxy, localCrs)

    def setGeometryAsParametricSplittedPillarNodes(self, *args) -> "void":
        return _fesapi.Resqml2_IjkGridParametricRepresentation_setGeometryAsParametricSplittedPillarNodes(self, *args)

    def setGeometryAsParametricSplittedPillarNodesUsingExistingDatasets(self, *args) -> "void":
        return _fesapi.Resqml2_IjkGridParametricRepresentation_setGeometryAsParametricSplittedPillarNodesUsingExistingDatasets(self, *args)
    __swig_destroy__ = _fesapi.delete_Resqml2_IjkGridParametricRepresentation

# Register Resqml2_IjkGridParametricRepresentation in _fesapi:
_fesapi.Resqml2_IjkGridParametricRepresentation_swigregister(Resqml2_IjkGridParametricRepresentation)
class Resqml2_IjkGridNoGeometryRepresentation(Resqml2_AbstractIjkGridRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml2_IjkGridNoGeometryRepresentation

# Register Resqml2_IjkGridNoGeometryRepresentation in _fesapi:
_fesapi.Resqml2_IjkGridNoGeometryRepresentation_swigregister(Resqml2_IjkGridNoGeometryRepresentation)
class Resqml2_GridConnectionSetRepresentation(Resqml2_AbstractRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def isAssociatedToInterpretations(self) -> "bool":
        r"""
        Indicates whether the cell connections are associated to interpretation or not.

        :rtype: boolean
        :return: True if associated to interpretations, false if not.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_isAssociatedToInterpretations(self)

    def getInterpretationIndexCumulativeCount(self, cumulativeCount: "uint64_t *") -> "void":
        r"""
        Gets the (fault) interpretation index cumulative counts of this grid connection
        representation.

        :raises: std::invalid_argument	If this grid connection set representation does not
            										contain any (fault) interpretation association.
        :raises: std::logic_error	 	If the intepretation indices cumulative counts are not
            										stored in a HDF5 integer array.

        :param [out]:	cumulativeCount	A buffer for receiving the cumulative counts. Must be
            								preallocated with a size of getCellIndexPairCount(). The number
            								of interpretations associated to the connection at index ``i`` is
            								cumulativeCount[i].
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getInterpretationIndexCumulativeCount(self, cumulativeCount)

    def getInterpretationIndices(self, interpretationIndices: "int64_t *") -> "void":
        r"""
        Gets the (fault) interpretation indices of this grid connection representation.

        :raises: std::invalid_argument	If this grid connection set representation does not
            										contain any (fault) interpretation association.
        :raises: std::logic_error	 	If the intepretation indices are not stored in a HDF5
            										integer array.

        :param [out]:	interpretationIndices	A buffer for receiving the interpretation indices. It
            										must be preallocated with a size equals to the last value
            										of ``cumulativeCount`` after calling
            										getInterpretationIndexCumulativeCount(cumulativeCount).
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getInterpretationIndices(self, interpretationIndices)

    def getInterpretationIndexNullValue(self) -> "int64_t":
        r"""
        Gets the null value for interpretation index.

        :raises: std::invalid_argument	If this grid connection set representation does not
            										contain any (fault) interpretation association.
        :raises: std::logic_error	 	If the intepretation indices are not stored in a HDF5
            										integer array.

        :rtype: int
        :return: The interpretation index null value.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getInterpretationIndexNullValue(self)

    def getCellIndexPairCount(self) -> "uint64_t":
        r"""
        Gets the cell index pair count of this grid connection set representation.

        :rtype: int
        :return: The cell index pair count.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getCellIndexPairCount(self)

    def getCellIndexPairCountFromInterpretationIndex(self, interpretationIndex: "int64_t") -> "uint64_t":
        r"""
        Gets the count of cell index pairs which correspond to a particular interpretation or to no interpretation.

        :raises: std::invalid_argument	If the HDF5 library could not read the count of
            										interpretation indices associated to this grid connection
            										set representation.
        :raises: std::logic_error	 	If the intepretation indices are not stored in a HDF5
            										integer array.
        :raises: std::out_of_range	 	If ``interpretationIndex`` is out of range.

        :type interpretationIndex: int
        :param interpretationIndex:	The index of an interpretation in the collection of feature
            								interpretation of this grid connection set.
            								Or -1 for having cell index pair count which are not associated to any interpretation at all.

        :rtype: int
        :return: The count of cell index pairs which correspond to the interpretation at index
            ``interpretationIndex`` or to no interpretation.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getCellIndexPairCountFromInterpretationIndex(self, interpretationIndex)

    def getCellIndexPairs(self, cellIndexPairs: "int64_t *") -> "int64_t":
        r"""
        Gets the cell index pairs of this grid connection set representation

        :raises: logic_error	If the cell index pairs are not stored in a HDF5 integer array.

        :param [out]:	cellIndexPairs	A buffer for receiving the cell index pairs. It must be
            								preallocated with a size of 2 * getCellIndexPairCount().
            								Two consecutive values cellIndexPairs[i] and
            								cellIndexPairs[i+1] constitute a pair of cell index.

        :rtype: int
        :return: The null value.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getCellIndexPairs(self, cellIndexPairs)

    def getGridConnectionSetInformationFromInterpretationIndex(self, cellIndexPairs: "int64_t *", gridIndexPairs: "unsigned short *", localFaceIndexPairs: "int *", interpretationIndex: "int64_t") -> "void":
        r"""
        Gets the cell index pairs, the grid index pairs (optional) and the local face index pairs
        (optional) which correspond to a particular interpretation or to no interpretation.

        :raises: std::logic_error	 	If the intepretation indices or interpretation indices
            										cumulative counts are not stored in a HDF5 integer array.
        :raises: std::out_of_range	 	If ``interpretationIndex`` is out of range.

        :param [out]:	  	cellIndexPairs	   	Mandatory buffer to receive the cell index pairs. Must be
            										preallocated with
            										2 * getCellIndexPairCountFromInterpretationIndex(interpretationIndex).
        :param [in,out]:	gridIndexPairs	   	Optional buffer to receive the grid index pairs. Please
            										set to ``nullptr`` for not collecting these pairs. Must be
            										preallocated with
            										2 * getCellIndexPairCountFromInterpretationIndex(interpretationIndex).
        :param [in,out]:	localFaceIndexPairs	Optional buffer to receive the local face index pairs.
            										Please set to ``nullptr`` for not collecting these pairs.
            										Must be preallocated with
            										2 * getCellIndexPairCountFromInterpretationIndex(interpretationIndex).
            										See http://docs.energistics.org/#RESQML/RESQML_TOPICS/RESQML-000-252-0-C-sv2010.html for IJK cell face index convention.
        :type interpretationIndex: int
        :param interpretationIndex:	The index of an interpretation in the collection of
            										feature interpretation of this grid connection set.
            										Or -1 for having information for cells which are not associated to any interpretation at all.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getGridConnectionSetInformationFromInterpretationIndex(self, cellIndexPairs, gridIndexPairs, localFaceIndexPairs, interpretationIndex)

    def hasLocalFacePerCell(self) -> "bool":
        r"""
        Indicates if this grid connection set representation contains information on the connected
        faces of the cell pairs.

        :rtype: boolean
        :return: True if there exists information on connected faces, false if not.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_hasLocalFacePerCell(self)

    def getLocalFacePerCellIndexPairs(self, localFacePerCellIndexPairs: "int *") -> "int64_t":
        r"""
        Gets the local face per cell index pairs of this grid connection representation. Please check
        that this grid connection set representation has local face per cell index pairs thanks to
        hasLocalFacePerCell() before calling this method.

        :raises: std::invalid_argument	If this representation has no local face per cell pair.
        :raises: std::logic_error	 	If the local face per cell index pairs are not stored
            										in a HDF5 integer array.

        :param [out]:	localFacePerCellIndexPairs	A buffer for receiving the local face per cell index
            											pairs. It must be preallocated with a size of
            											getCellIndexPairCount()*2 and won't be freed
            											by FESAPI.
            											See http://docs.energistics.org/#RESQML/RESQML_TOPICS/RESQML-000-252-0-C-sv2010.html for IJK cell face index convention.

        :rtype: int
        :return: The null value used in ``localFacePerCellIndexPairs``.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getLocalFacePerCellIndexPairs(self, localFacePerCellIndexPairs)

    def isBasedOnMultiGrids(self) -> "bool":
        r"""
        Indicates if this grid connection set representation is based on several grids.

        :rtype: boolean
        :return: True if it is based on several grids, false if not.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_isBasedOnMultiGrids(self)

    def getGridIndexPairs(self, gridIndexPairs: "unsigned short *") -> "void":
        r"""
        Gets the grid index pairs of this grid connection representation. Please check that this grid
        connection set representation is based on several grids thanks to isBasedOnMultiGrids()
        before calling this method.

        :raises: std::invalid_argument	If this representation is not based on several grids.
        :raises: std::logic_error	 	If the grid index pairs are not stored in a HDF5 integer
            										array.

        :param [out]:	gridIndexPairs	A buffer for receiving the grid index pairs. It must be
            								preallocated with a size getCellIndexPairCount()*2 and
            								won't be freed by fesapi.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getGridIndexPairs(self, gridIndexPairs)

    def pushBackSupportingGridRepresentation(self, supportingGridRep: "Resqml2_AbstractGridRepresentation") -> "void":
        r"""
        Pushes back a grid representation which is one of the support of this representation. Pushes
        back this representation as a grid connection information of the grid representation as well.

        :raises: std::invalid_argument	If ``supportingGridRep`` is ``nullptr``.

        :param [in]:	supportingGridRep	The supporting grid representation to push back.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_pushBackSupportingGridRepresentation(self, supportingGridRep)

    def setCellIndexPairs(self, *args) -> "void":
        r"""
        *Overload 1:*

        Sets the cell index pairs of this grid connection set representation.
        			If this instance is supported by a single grid, then optional gridIndex* parameters are not needed.
        			Default cell index null value is set to -1.

        :raises: std::invalid_argument	If ``cellIndexPairCount`` is 0.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If ``cellIndexPairNullValue`` is strictly greater than
            										uint64_t max. The XML null value cannot be greater than a
            										64 bits signed integer cause of gSOAP mappings.

        :type cellIndexPairCount: int
        :param cellIndexPairCount:	  	The count of cell index pairs. It is half the size of
            											``cellIndexPair`` (and of ``gridIndexPair`` if used).
        :param [in]:	  	cellIndexPair		  	All the cell index pair in a 1d array where the cell
            											indices go faster than the pair.
        :type cellIndexPairNullValue: int, optional
        :param cellIndexPairNullValue:	(Optional) The integer null value used in ``cellIndexPair``.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where the numerical values (cell
            											indices) are stored. If ``nullptr``, then the default
            											HDF proxy of the repository will be used.
        :param gridIndexPairNullValue:	(Optional) The integer null value used in
            ``gridIndexPair``.
        :param [in]:	  	gridIndexPair		  	(Optional) All the grid index pair in a 1d array
            											where the grid indices go faster than the pair. The
            											grid at an index must correspond to the cell at the
            											same index in the ``cellIndexPair`` array.

        |

        *Overload 2:*

        Sets the cell index pairs of this grid connection set representation.
        			If this instance is supported by a single grid, then optional gridIndex* parameters are not needed.
        			Default cell index null value is set to -1.

        :raises: std::invalid_argument	If ``cellIndexPairCount`` is 0.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If ``cellIndexPairNullValue`` is strictly greater than
            										uint64_t max. The XML null value cannot be greater than a
            										64 bits signed integer cause of gSOAP mappings.

        :type cellIndexPairCount: int
        :param cellIndexPairCount:	  	The count of cell index pairs. It is half the size of
            											``cellIndexPair`` (and of ``gridIndexPair`` if used).
        :param [in]:	  	cellIndexPair		  	All the cell index pair in a 1d array where the cell
            											indices go faster than the pair.
        :type cellIndexPairNullValue: int
        :param cellIndexPairNullValue:	(Optional) The integer null value used in ``cellIndexPair``.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where the numerical values (cell
            											indices) are stored. If ``nullptr``, then the default
            											HDF proxy of the repository will be used.
        :type gridIndexPairNullValue: int
        :param gridIndexPairNullValue:	(Optional) The integer null value used in
            ``gridIndexPair``.
        :param [in]:	  	gridIndexPair		  	(Optional) All the grid index pair in a 1d array
            											where the grid indices go faster than the pair. The
            											grid at an index must correspond to the cell at the
            											same index in the ``cellIndexPair`` array.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_setCellIndexPairs(self, *args)

    def setLocalFacePerCellIndexPairs(self, localFacePerCellIndexPair: "int *", nullValue: "int", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Sets the local face per cell index pairs of this grid connection set representation. Local
        face-per-cell indices are used because global face indices need not have been defined. The
        numerical values will be written as a new HDF5 dataset in an existing HDF5 file.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
            				std::logic_error		If the cell index pairs have not been set yet.

        :param [in]:	  	localFacePerCellIndexPair	All the local face per cell index pairs in a 1d
            												array where the local face per cell indices go
            												faster than the pair. The local face per cell at
            												an index must correspond to the cell at the same
            												index in the 1d array containing the cell index
            												pairs.
            												See http://docs.energistics.org/#RESQML/RESQML_TOPICS/RESQML-000-252-0-C-sv2010.html for IJK cell face index convention.
        :type nullValue: int
        :param nullValue:				 	The null value in ``localFacePerCellIndexPair``.
        :param [in,out]:	proxy					 	The HDF proxy where the numerical values (cell
            												indices) are stored. If ``nullptr``, then the
            												default HDF proxy of the repository will be used.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_setLocalFacePerCellIndexPairs(self, localFacePerCellIndexPair, nullValue, proxy)

    def setConnectionInterpretationIndices(self, cumulativeInterpCount: "uint64_t const *", interpIndices: "int64_t const *", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        For each connection in this grid connection set representation, allows to map zero to several
        feature interpretation.

        :raises: std::logic_error		If getCellIndexPairs() == 0.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :param [in]:	  	cumulativeInterpCount	 	For each connection, the cumulative count of the
            												associated interpretations. Count must be equal to getCellIndexPairs().
        :param [in]:	  	interpIndices			 	The index of the interpretation associated to cell index pairs.
            												The count of this array is
            ``cumulativeInterpCount[cumulativeInterpCount.size()`` - 1]. The nullValue is -1.
            												Interpretation index is related to pushBackInterpretation.
        :param [in,out]:	proxy					 	The Hdf proxy where the numerical values will be
            												stored.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_setConnectionInterpretationIndices(self, cumulativeInterpCount, interpIndices, proxy)

    def pushBackInterpretation(self, interp: "AbstractFeatureInterpretation") -> "void":
        r"""
        Pushes back an interpretation which can be mapped with some connections.
        Do not use this method when you assign a single interpreation to all connections. Use

        :raises: std::invalid_argument	If ``interp`` is ``nullptr``.

        :param [in]:	interp	The interpretation to push back.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_pushBackInterpretation(self, interp)

    def setInterpretationForAllConnections(self, interp: "AbstractFeatureInterpretation", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        For each connection in this grid connection set representation, associate the same interpretation.

        :raises: std::logic_error		If getCellIndexPairs() == 0.
        :raises: std::logic_error		If interpretation has already been pushed into this instance.

        :param [in]:	  	interp				The interpretation to associate to all connections.
        :param [in,out]:	proxy				The Hdf proxy where the numerical values will be stored.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_setInterpretationForAllConnections(self, interp, proxy)

    def getInterpretationUuidFromIndex(self, interpretationIndex: "unsigned int") -> "std::string":
        r"""
        Gets the UUID of a particular (fault) interpretation of this grid connection set.

        :raises: std::invalid_argument	If this grid connection set representation does not
            										contain fault interpretation association.
        :raises: std::invalid_argument	If the associated feature interpretation at position
            ``interpretationIndex`` is not a fault one. This is legal but
            										not yet implemented.
        :raises: std::out_of_range	 	If ``interpretationIndex`` is out of range.

        :type interpretationIndex: int
        :param interpretationIndex:	The index of a (fault) interpretation in the collection of
            								feature interpretation of this grid connection set.

        :rtype: string
        :return: The UUID of the (fault) interpretation at index ``interpretationIndex``.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getInterpretationUuidFromIndex(self, interpretationIndex)

    def getInterpretationFromIndex(self, interpretationIndex: "int64_t") -> "resqml2::AbstractFeatureInterpretation *":
        r"""
        Gets a particular (fault) interpretation of this grid connection set.

        :raises: std::invalid_argument	If this grid connection set representation does not
            										contain fault interpretation association.
        :raises: std::invalid_argument	If the associated feature interpretation at position
            ``interpretationIndex`` is not a fault one. This is legal but
            										not yet implemented.
        :raises: std::out_of_range	 	If ``interpretationIndex`` is out of range.

        :type interpretationIndex: int
        :param interpretationIndex:	The index of a (fault) interpretation in the collection of
            								feature interpretation of this grid connection set.

        :rtype: :py:class:`AbstractFeatureInterpretation`
        :return: The (fault) interpretation at index ``interpretationIndex``.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getInterpretationFromIndex(self, interpretationIndex)

    def getInterpretationCount(self) -> "uint64_t":
        r"""
        Get the count of interpretations in this grid connection set.

        :raises: range_error	If the count of associated interpretations is strictly greater than
            							unsigned int.

        :rtype: int
        :return: The interpretation count.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getInterpretationCount(self)

    def getSupportingGridRepresentationCount(self) -> "unsigned int":
        r"""
        Gets the count of supporting grid representations of this grid connection representation.

        :raises: std::range_error	If the count of supporting grid representations is strictly
            									greater than unsigned int maximum value.

        :rtype: int
        :return: The supporting grid representation count.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getSupportingGridRepresentationCount(self)

    def getSupportingGridRepresentation(self, index: "unsigned int") -> "resqml2::AbstractGridRepresentation *":
        r"""
        Gets the supporting grid representation located at a specific index of this grid connection set
        representation.

        :raises: std::out_of_range If ``index`` is out of range.

        :type index: int
        :param index:	Zero-based index of the supporting grid representation we look for.

        :rtype: :py:class:`AbstractGridRepresentation`
        :return: The supporting grid representation at position ``index``.
        """
        return _fesapi.Resqml2_GridConnectionSetRepresentation_getSupportingGridRepresentation(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_GridConnectionSetRepresentation

# Register Resqml2_GridConnectionSetRepresentation in _fesapi:
_fesapi.Resqml2_GridConnectionSetRepresentation_swigregister(Resqml2_GridConnectionSetRepresentation)
class Resqml2_StreamlinesFeature(Resqml2_AbstractTechnicalFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getTimeSeries(self) -> "eml2::TimeSeries *":
        r"""
        Gets the Time series associated to this streamlines feature.

        :raises: std::logic_error	If this feature is partial or if this feature is standard invalid.

        :rtype: :py:class:`TimeSeries`
        :return: The associated streamlines feature.
        """
        return _fesapi.Resqml2_StreamlinesFeature_getTimeSeries(self)

    def getTimeIndex(self) -> "uint64_t":
        r"""
        Gets the time index in the Time series associated to this streamlines feature.

        :raises: std::logic_error	If this feature is partial.

        :rtype: int
        :return: the time index in the Time series associated to this streamlines feature
        """
        return _fesapi.Resqml2_StreamlinesFeature_getTimeIndex(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_StreamlinesFeature

# Register Resqml2_StreamlinesFeature in _fesapi:
_fesapi.Resqml2_StreamlinesFeature_swigregister(Resqml2_StreamlinesFeature)
class Resqml2_StreamlinesRepresentation(Resqml2_AbstractRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getLineCount(self) -> "uint64_t":
        r"""
        Gets the count of line contained in this streamlines representation.

        :raises: std::logic_error	If this feature is partial.

        :rtype: int
        :return: The count of line contained in this streamlines representation.
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_getLineCount(self)

    def getWellboreTrajectoryCount(self) -> "uint64_t":
        r"""
        Gets the count of wellbore trajectories of this streamlines representation.

        :raises: std::range_error	If the count of wellbore trajectories is strictly
            									greater than unsigned int max.

        :rtype: int
        :return: The count of wellbore trajectories.
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_getWellboreTrajectoryCount(self)

    def getWellboreTrajectory(self, index: "uint64_t") -> "resqml2::WellboreTrajectoryRepresentation *":
        r"""
        Gets the wellbore trajectory located at a specific index of this streamlines
        representation.

        :raises: std::out_of_range	If index >=
            									getWellboreTrajectoryCount().

        :type index: int
        :param index:	Zero-based index of the wellbore trajectory we look for.

        :rtype: :py:class:`WellboreTrajectoryRepresentation`
        :return: The wellbore trajectory at position ``index``.
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_getWellboreTrajectory(self, index)

    def getInjectorPerLine(self, injectorPerLine: "uint32_t *") -> "uint32_t":
        r"""
        Gets all the wellbore indices which are injectors.
        			Null values signify that that line does not initiate at an injector, e.g., it may come from fluid expansion or an aquifer.

        :param [in/out]:	injectorPerLine 	The 0-based injector wellbore index defined by the order of the wellbore in the list of WellboreTrajectoryRepresentation references.
            									It must be preallocated with a size getWellboreTrajectories().size() and it won't be freed by FESAPI.

        :rtype: int
        :return: The null value used in injectorPerLine.
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_getInjectorPerLine(self, injectorPerLine)

    def getProducerPerLine(self, producerPerLine: "uint32_t *") -> "uint32_t":
        r"""
        Gets all the wellbore indices which are producers.
        			Null values signify that that line does not terminate at a producer, e.g., it may approach a stagnation area.

        :param [in/out]:	injectorPerLine 	The 0-based injector wellbore index defined by the order of the wellbore in the list of WellboreTrajectoryRepresentation references.
            									It must be preallocated with a size getWellboreTrajectories().size() and it won't be freed by FESAPI.

        :rtype: int
        :return: The null value used in producerPerLine.
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_getProducerPerLine(self, producerPerLine)

    def getNodeCountPerLine(self, nodeCountPerPolyline: "uint32_t *") -> "void":
        r"""
        Gets the node count per line.

        :param [out]:	nodeCountPerPolyline	A preallocated array to receive the node count per
            										line. Its size must be
            										getLineCount(patchIndex).
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_getNodeCountPerLine(self, nodeCountPerPolyline)

    def getIntervalCountPerLine(self, intervalCountPerPolyline: "uint32_t *") -> "void":
        r"""
        Gets the interval count per line.

        :param [out]:	intervalCountPerPolyline	A preallocated array to receive the interval count per
            											line. Its size must be
            											getLineCount(patchIndex).
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_getIntervalCountPerLine(self, intervalCountPerPolyline)

    def getIntervalCount(self) -> "uint64_t":
        r"""
        Gets the total interval count in this streamlines representation.

        :param [out]:	nodeCountPerPolyline	A preallocated array to receive the node count per
            										line. Its size must be
            										getLineCount(patchIndex).
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_getIntervalCount(self)

    def setGeometry(self, nodeCountPerPolyline: "uint32_t const *", xyzPoints: "double const *", hdfProxy: "Eml2_AbstractHdfProxy"=None, localCrs: "Eml2_AbstractLocal3dCrs"=None) -> "void":
        r"""
        Sets the geometry of the streamlines representation.

        :raises: std::invalid_argument	If proxy == nullptr and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If localCrs == nullptr and no default local CRS
            										id defined in the repository.

        :param [in]:	  	nodeCountPerPolyline  	The node count per polyline in this representation. It is
            											ordered by polyline. There must be getLineCount()
            											values in this array.
        :param [in]:	  	xyzPoints			  	The xyz values of the nodes. Ordered by xyz, then by
            											node and then by polyline. It must be three times the
            											total count of nodes.
            											If the streamlines are associated to grids then the there must be one point
            											one each face intersected by the a line + the start and end point.
        :param [in,out]:	hdfProxy			  	(Optional) The HDF proxy which defines where the
            											nodes will be stored. If ``nullptr`` (default), then
            											the repository default HDF proxy will be used.
        :param [in]:	  	localCrs			  	(Optional) The local CRS where the points are
            											defined. If ``nullptr`` (default value), then the
            											repository default local CRS will be used.
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_setGeometry(self, nodeCountPerPolyline, xyzPoints, hdfProxy, localCrs)

    def getGridIndices(self, gridIndices: "uint16_t *") -> "uint16_t":
        r"""
        For each interval of the lines of the representation, gets the index of the grid it is associated to.

        :raises: std::range_error	If the grid indices are stored in an integer constant array
            									and if the the constant value is strictly superior than uint16_t maximum value.
        :raises: std::logic_error	If the grid indices are neither stored in a HDF5 integer
            									array nor in an integer constant array.

        :param [out]:	gridIndices	An array for receiving the grids indices. The size of this array is
            							getIntervalCount.

        :rtype: int
        :return: The null value used in ``gridIndices`` in order to indicate that an interval does not
            			correspond to any intersected grid.
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_getGridIndices(self, gridIndices)

    def getCellIndices(self, cellIndices: "int64_t *") -> "int64_t":
        r"""
        For each interval of the lines of the representation, gets the index of the cell it is associated to.
        Cell index in in the scope of the associated grid at the same index.

        :raises: std::range_error	If the cell indices are stored in an integer constant array
            									and if the the constant value is strictly superior than uint64_t maximum value.
        :raises: std::logic_error	If the * indices are neither stored in a HDF5 integer
            									array nor in an integer constant array.

        :param [out]:	cellIndices	An array for receiving the cell indices. The size of this array is
            							getIntervalCount.

        :rtype: int
        :return: The null value used in ``cellIndices`` in order to indicate that an interval does not
            			correspond to any intersected grid.
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_getCellIndices(self, cellIndices)

    def getLocalFacePairPerCellIndices(self, localFacePairPerCellIndices: "uint8_t *") -> "uint8_t":
        r"""
        For each interval of the lines of the representation, gets the entry and exit intersection faces of the line in the cell.

        :raises: std::range_error	If the grid indices are stored in an integer constant array
            									and if the the constant value is strictly superior than uint8_t maximum value.
        :raises: std::logic_error	If the grid indices are neither stored in a HDF5 integer
            									array nor in an integer constant array.

        :param [out]:	gridIndices	An array for receiving the local Face Pair Per Cell Indices. The size of this array is twice
            							getIntervalCount.

        :rtype: uint8_t
        :return: The null value used in ``localFacePairPerCellIndices`` in order to indicate that a line interval does not intersect a face in this cell.
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_getLocalFacePairPerCellIndices(self, localFacePairPerCellIndices)

    def getGridRepresentationCount(self) -> "uint64_t":
        r"""
        Gets the count of grid representations of this streamlines representation.

        :raises: std::range_error	If the count of grid representations is strictly
            									greater than unsigned int max.

        :rtype: int
        :return: The count of grid representation.
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_getGridRepresentationCount(self)

    def getGridRepresentation(self, index: "uint64_t") -> "resqml2::AbstractGridRepresentation *":
        r"""
        Gets the grid representation located at a specific index of this streamlines
        representation.

        :raises: std::out_of_range	If index >=
            									getGridRepresentationCount().

        :type index: int
        :param index:	Zero-based index of the grid representation we look for.

        :rtype: :py:class:`AbstractGridRepresentation`
        :return: The grid representation at position ``index``.
        """
        return _fesapi.Resqml2_StreamlinesRepresentation_getGridRepresentation(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_StreamlinesRepresentation

# Register Resqml2_StreamlinesRepresentation in _fesapi:
_fesapi.Resqml2_StreamlinesRepresentation_swigregister(Resqml2_StreamlinesRepresentation)
class Resqml2_AbstractProperty(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getRepresentation(self) -> "resqml2::AbstractRepresentation *":
        return _fesapi.Resqml2_AbstractProperty_getRepresentation(self)

    def setRepresentation(self, rep: "Resqml2_AbstractRepresentation") -> "void":
        return _fesapi.Resqml2_AbstractProperty_setRepresentation(self, rep)

    def getValuesHdfDatatype(self) -> "common::AbstractObject::numericalDatatypeEnum":
        r"""
        Get the values data type in the HDF dataset

        :rtype: int
        :return: The data type of the values if successful, else ``UNKNOWN``.
        """
        return _fesapi.Resqml2_AbstractProperty_getValuesHdfDatatype(self)

    def getValuesCountPerDimensionOfPatch(self, patchIndex: "uint64_t") -> "std::vector< uint32_t,std::allocator< uint32_t > >":
        r"""
        Get the number of values in each dimension into the underlying HDF5 dataset.
        uint32_t is returned instead of uint64_t cause of some SWIG usage. I cannot SWIG port std::vector<uint64_t>
        :type patchIndex: int
        :param patchIndex:	The index of the patch we want to count the values from.
        """
        return _fesapi.Resqml2_AbstractProperty_getValuesCountPerDimensionOfPatch(self, patchIndex)

    def getValuesCountOfPatch(self, patchIndex: "uint64_t") -> "uint64_t":
        r"""
        Gets the count of all values contained into the underlying HDF5 dataset of a given patch of
        this property.

        :raises: std::range_error	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want to count the values from.

        :rtype: int
        :return: The count of values of the ``patchIndex`` patch.
        """
        return _fesapi.Resqml2_AbstractProperty_getValuesCountOfPatch(self, patchIndex)

    def getValuesCountOfDimensionOfPatch(self, dimIndex: "uint64_t", patchIndex: "uint64_t") -> "uint64_t":
        r"""
        Gets the count of values on a specific dimension of the underlying HDF5 dataset of a given
        patch of this property.

        :raises: std::out_of_range	If ``dimIndex`` is strictly greater than dimension count.
        :raises: std::range_error 	If ``patchIndex`` is strictly greater than patch count.

        :type dimIndex: int
        :param dimIndex:  	The index of the dimension we want to count the values from.
        :type patchIndex: int
        :param patchIndex:	The index of the patch we want to count the values from.

        :rtype: int
        :return: The count of values in the ``dimIndex`` dimension of ``patchIndex`` patch.
        """
        return _fesapi.Resqml2_AbstractProperty_getValuesCountOfDimensionOfPatch(self, dimIndex, patchIndex)

    def getDimensionsCountOfPatch(self, patchIndex: "uint64_t") -> "uint64_t":
        r"""
        Gets the count of dimensions of the underlying HDF5 dataset of a given patch of this property.

        :raises: std::range_error	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want to count the dimensions from.

        :rtype: int
        :return: The number of values, 0 otherwise.
        """
        return _fesapi.Resqml2_AbstractProperty_getDimensionsCountOfPatch(self, patchIndex)

    def getPropertyKindDescription(self) -> "std::string":
        return _fesapi.Resqml2_AbstractProperty_getPropertyKindDescription(self)

    def getPropertyKindAsString(self) -> "std::string":
        return _fesapi.Resqml2_AbstractProperty_getPropertyKindAsString(self)

    def getPropertyKindParentAsString(self) -> "std::string":
        return _fesapi.Resqml2_AbstractProperty_getPropertyKindParentAsString(self)

    def isAssociatedToOneStandardEnergisticsPropertyKind(self) -> "bool":
        return _fesapi.Resqml2_AbstractProperty_isAssociatedToOneStandardEnergisticsPropertyKind(self)

    def getPropertyKind(self) -> "eml2::PropertyKind *":
        return _fesapi.Resqml2_AbstractProperty_getPropertyKind(self)

    def getElementCountPerValue(self) -> "uint64_t":
        r"""
        Gets the count of elements per property value. If the property is a scalar one then it should
        be one. If it is a vectorial one, then it should be more than one. It is not possible to have
        some tensor property values (more dimensions than a vector)

        :rtype: int
        :return: The element count per value.
        """
        return _fesapi.Resqml2_AbstractProperty_getElementCountPerValue(self)

    def getAttachmentKind(self) -> "gsoap_eml2_3::eml23__IndexableElement":
        r"""
        Gets the kind of elements on which the property values are attached to

        :rtype: int
        :return: The kind of elements on which the property values are attached to.
        """
        return _fesapi.Resqml2_AbstractProperty_getAttachmentKind(self)

    def getPropertySetCount(self) -> "uint64_t":
        r"""
        Gets the count of property sets which contain this property

        :raises: std::range_error	If the count of property sets is strictly greater than
            									unsigned int max.

        :rtype: int
        :return: The count of property sets which contain this property.
        """
        return _fesapi.Resqml2_AbstractProperty_getPropertySetCount(self)

    def getPropertySet(self, index: "uint64_t") -> "resqml2_0_1::PropertySet *":
        r"""
        Gets a given property set taken from all property sets which contain this property

        :raises: std::out_of_range	If ``index`` is out of range.

        :type index: int
        :param index:	Zero-based index of the property set we look for.

        :rtype: :py:class:`PropertySet`
        :return: The property set at ``index``.
        """
        return _fesapi.Resqml2_AbstractProperty_getPropertySet(self, index)

    def hasRealizationIndices(self) -> "bool":
        return _fesapi.Resqml2_AbstractProperty_hasRealizationIndices(self)

    def getRealizationIndices(self) -> "std::vector< unsigned int,std::allocator< unsigned int > >":
        return _fesapi.Resqml2_AbstractProperty_getRealizationIndices(self)

    def setRealizationIndices(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractProperty_setRealizationIndices(self, *args)

    def setTimeSeries(self, ts: "TimeSeries") -> "void":
        return _fesapi.Resqml2_AbstractProperty_setTimeSeries(self, ts)

    def setSingleTimestamp(self, timestamp: "time_t", yearOffset: "LONG64"=0) -> "void":
        r"""
        Set a single associated timestamp for this property.
        RESQML2.0.1	: Must be used with and after setTimeSeries.
        RESQML2.2	: If, used the property must contain values for a single timestamp (as in 2.0.1). It cannot be used with setTimeSeries.

        :raises: invalid_argument	Regarding RESQML2.0.1, this method cannot be called if setTimeSeries has not been called before.

        :param [in]:	timestamp	The single timestamps to associate to this property
        :param [in]:	yearOffset	Indicates that the dateTime attribute must be translated according to this value.
        """
        return _fesapi.Resqml2_AbstractProperty_setSingleTimestamp(self, timestamp, yearOffset)

    def getSingleTimestamp(self) -> "time_t":
        r"""
        Get a single associated timestamp for this property.

        :rtype: int
        :return: -1 if there is not a single timestamp related to this property meaning that no timestamp is present or more than one (i.e. a whole time series)
        """
        return _fesapi.Resqml2_AbstractProperty_getSingleTimestamp(self)

    def getTimeSeries(self) -> "eml2::TimeSeries *":
        r"""
        Gets the time series which is associated to this property

        :rtype: :py:class:`TimeSeries`
        :return: Null pointer if no time series is associated to this property. Otherwise returns the
            			associated time series.
        """
        return _fesapi.Resqml2_AbstractProperty_getTimeSeries(self)

    def useInterval(self) -> "bool":
        r"""Check if the values are given at each time index or between each time index."""
        return _fesapi.Resqml2_AbstractProperty_useInterval(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractProperty

# Register Resqml2_AbstractProperty in _fesapi:
_fesapi.Resqml2_AbstractProperty_swigregister(Resqml2_AbstractProperty)
class Resqml2_AbstractValuesProperty(Resqml2_AbstractProperty):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackFacet(self, facet: "gsoap_eml2_3::eml23__FacetKind", facetValue: "std::string const &") -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackFacet(self, facet, facetValue)

    def getFacetCount(self) -> "unsigned int":
        return _fesapi.Resqml2_AbstractValuesProperty_getFacetCount(self)

    def getFacetKind(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__FacetKind":
        return _fesapi.Resqml2_AbstractValuesProperty_getFacetKind(self, index)

    def getFacetValue(self, index: "unsigned int") -> "std::string":
        return _fesapi.Resqml2_AbstractValuesProperty_getFacetValue(self, index)

    def pushBackInt64Hdf5Array1dOfValues(self, values: "int64_t const *", valueCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int64_t") -> "void":
        r"""
        Adds a 1d array of explicit int 64 bits values to the property values.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: int
        :param values:	  	All the property values to set ordered according to the topology
            								of the representation it is based on.
        :type valueCount: int
        :param valueCount:	The number of values to write.
        :param [in,out]:	proxy	  	The HDF proxy where to write the property values. It must be
            								already opened for writing and won't be closed in this method. If
            								``nullptr``, then a default HDF proxy must be defined in the
            								repository.
        :type nullValue: int
        :param nullValue: 	The null value.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt64Hdf5Array1dOfValues(self, values, valueCount, proxy, nullValue)

    def pushBackInt32Hdf5Array1dOfValues(self, values: "int const *", valueCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int") -> "void":
        r"""
        Adds a 1d array of explicit integer values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt32Hdf5Array1dOfValues(self, values, valueCount, proxy, nullValue)

    def pushBackInt16Hdf5Array1dOfValues(self, values: "short const *", valueCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "short") -> "void":
        r"""
        Adds a 1d array of explicit short values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt16Hdf5Array1dOfValues(self, values, valueCount, proxy, nullValue)

    def pushBackInt8Hdf5Array1dOfValues(self, values: "int8_t const *", valueCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int8_t") -> "void":
        r"""
        Adds a 1d array of explicit char values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt8Hdf5Array1dOfValues(self, values, valueCount, proxy, nullValue)

    def pushBackInt64Hdf5Array2dOfValues(self, values: "int64_t const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int64_t") -> "void":
        r"""
        Adds a 2d array of explicit int 64 bits values to the property values.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: int
        :param values:				  	All the property values to set ordered according to
            											the topology of the representation it is based on.
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly J dimension).
        :param [in,out]:	proxy				  	The HDF proxy where to write the property values. It
            											must be already opened for writing and won't be
            											closed in this method. If ``nullptr``, then a default
            											HDF proxy must be defined in the repository.
        :type nullValue: int
        :param nullValue:			  	The null value.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt64Hdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, proxy, nullValue)

    def pushBackInt32Hdf5Array2dOfValues(self, values: "int const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int") -> "void":
        r"""
        Adds a 2d array of explicit integer values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt32Hdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, proxy, nullValue)

    def pushBackInt16Hdf5Array2dOfValues(self, values: "short const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "short") -> "void":
        r"""
        Adds a 2d array of explicit short values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt16Hdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, proxy, nullValue)

    def pushBackUInt16Hdf5Array2dOfValues(self, values: "unsigned short const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "unsigned short") -> "void":
        r"""
        Adds a 2d array of explicit unsigned short values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackUInt16Hdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, proxy, nullValue)

    def pushBackInt8Hdf5Array2dOfValues(self, values: "int8_t const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int8_t") -> "void":
        r"""
        Adds a 2d array of explicit char values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt8Hdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, proxy, nullValue)

    def pushBackInt64Hdf5Array3dOfValues(self, values: "int64_t const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int64_t") -> "void":
        r"""
        Adds a 3d array of explicit int 64 bits values to the property values.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: int
        :param values:				  	All the property values to set ordered according the
            											topology of the representation it is based on.
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param [in,out]:	proxy				  	The HDF proxy where to write the property values. It
            											must be already opened for writing and won't be
            											closed in this method. If ``nullptr``, then a default
            											HDF proxy must be defined in the repository.
        :type nullValue: int
        :param nullValue:			  	The null value.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt64Hdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, proxy, nullValue)

    def pushBackInt32Hdf5Array3dOfValues(self, values: "int const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int") -> "void":
        r"""
        Adds a 3d array of explicit integer values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt32Hdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, proxy, nullValue)

    def pushBackInt16Hdf5Array3dOfValues(self, values: "short const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "short") -> "void":
        r"""
        Adds a 3d array of explicit short values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt16Hdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, proxy, nullValue)

    def pushBackUInt16Hdf5Array3dOfValues(self, values: "unsigned short const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "unsigned short") -> "void":
        r"""
        Adds a 3d array of explicit unsigned short values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackUInt16Hdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, proxy, nullValue)

    def pushBackInt8Hdf5Array3dOfValues(self, values: "int8_t const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int8_t") -> "void":
        r"""
        Adds a 3d array of explicit char values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt8Hdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, proxy, nullValue)

    def pushBackInt64Hdf5ArrayOfValues(self, values: "int64_t const *", numValues: "uint64_t const *", numDimensionsInArray: "unsigned int", proxy: "Eml2_AbstractHdfProxy", nullValue: "int64_t") -> "void":
        r"""
        Adds an nd array of explicit int 64 bits values to the property values.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: int
        :param values:					All the property values to set ordered according the
            											topology of the representation it is based on.
        :param [in]:	  	numValues				The number of property values ordered by dimension of
            											the array to write.
        :type numDimensionsInArray: int
        :param numDimensionsInArray:	The number of dimensions in the array to write.
        :param [in,out]:	proxy					The HDF proxy where to write the property values. It
            											must be already opened for writing and won't be closed in
            											this method. If ``nullptr``, then a default HDF proxy must
            											be defined in the repository.
        :type nullValue: int
        :param nullValue:				The null value.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt64Hdf5ArrayOfValues(self, values, numValues, numDimensionsInArray, proxy, nullValue)

    def pushBackInt32Hdf5ArrayOfValues(self, values: "int const *", numValues: "uint64_t const *", numDimensionsInArray: "unsigned int", proxy: "Eml2_AbstractHdfProxy", nullValue: "int") -> "void":
        r"""
        Adds an nd array of explicit integer values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt32Hdf5ArrayOfValues(self, values, numValues, numDimensionsInArray, proxy, nullValue)

    def pushBackInt16Hdf5ArrayOfValues(self, values: "short const *", numValues: "uint64_t const *", numDimensionsInArray: "unsigned int", proxy: "Eml2_AbstractHdfProxy", nullValue: "short") -> "void":
        r"""
        Adds an nd array of explicit short values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt16Hdf5ArrayOfValues(self, values, numValues, numDimensionsInArray, proxy, nullValue)

    def pushBackUInt16Hdf5ArrayOfValues(self, values: "unsigned short const *", numValues: "uint64_t const *", numDimensionsInArray: "unsigned int", proxy: "Eml2_AbstractHdfProxy", nullValue: "unsigned short") -> "void":
        r"""
        Adds an nd array of explicit unsigned short values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackUInt16Hdf5ArrayOfValues(self, values, numValues, numDimensionsInArray, proxy, nullValue)

    def pushBackInt8Hdf5ArrayOfValues(self, values: "int8_t const *", numValues: "uint64_t const *", numDimensionsInArray: "unsigned int", proxy: "Eml2_AbstractHdfProxy", nullValue: "int8_t") -> "void":
        r"""
        Adds an nd array of explicit int8_t values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackInt8Hdf5ArrayOfValues(self, values, numValues, numDimensionsInArray, proxy, nullValue)

    def pushBackRefToExistingIntegerDataset(self, *args) -> "std::string":
        r"""
        Pushes back a new patch of values for this property where the values have not to be written
        in the HDF5 file.The reason can be that the values already exist in an external file (only
        HDF5 for now) or that the writing of the values in the external file is differed in time.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``hdfProxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :param [in]:	hdfProxy 	The HDF5 proxy where the values are already or will be stored. If
            ``nullptr``, then a default HDF proxy must be defined in the repository.
        :type dataset: string, optional
        :param dataset:  	(Optional) If not provided during the method call, the dataset will
            							be named the same as the dataset naming convention of fesapi :
            							getHdfGroup() + "/values_patch" + patchIndex
        :type nullValue: int, optional
        :param nullValue:	(Optional) Only relevant for integer HDF5 datasets. Indeed, RESQML
            							(and fesapi) forces null value for floating point to be ``NaN`` value.

        :rtype: string
        :return: The name of the HDF5 dataset.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackRefToExistingIntegerDataset(self, *args)

    def hasConstantValues(self, patchIndex: "uint64_t") -> "bool":
        r"""
        Check if this property has all its values set to a constant ones.
        This method does not check if all given values are the same constant ones.
        It only checks if the property has been written using the optimized constant array.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want to check the values from.

        :rtype: boolean
        :return: True if the property has been written using the optimized constant array.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_hasConstantValues(self, patchIndex)

    def getInt64ConstantValuesOfPatch(self, patchIndex: "uint64_t") -> "int64_t":
        r"""
        Get the constant value of all values of this property as an integer one.
        This method does not check if all given values are the same constant ones.
        It only checks if the property has been written using the optimized constant array.

        :raises: std::logic_error 		If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range		If ``patchIndex`` is strictly greater than patch count.
        :raises: std::invalid_argument	If the property does not have any integer constant value.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want to get the constant value from.

        :rtype: int
        :return: The constant value of all values of this property as an integer one.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getInt64ConstantValuesOfPatch(self, patchIndex)

    def getDoubleConstantValuesOfPatch(self, patchIndex: "uint64_t") -> "double":
        r"""
        Get the constant value of all values of this property as a double one.
        This method does not check if all given values are the same constant ones.
        It only checks if the property has been written using the optimized constant array.

        :raises: std::logic_error 		If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range		If ``patchIndex`` is strictly greater than patch count.
        :raises: std::invalid_argument	If the property does not have any double constant value.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want to get the constant value from.

        :rtype: float
        :return: The constant value of all values of this property as a double one.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getDoubleConstantValuesOfPatch(self, patchIndex)

    def getNullValueOfPatch(self, patchIndex: "uint64_t") -> "int64_t":
        r"""
        Gets the null value of a given patch of this instance. Values are supposed to be integer ones.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::range_error	 	If ``patchIndex`` is strictly greater than patch count.
        :raises: std::invalid_argument	If the ``patchIndex`` patch does not contain integer
            										values.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want the values from.

        :rtype: int
        :return: the null value.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getNullValueOfPatch(self, patchIndex)

    def getUInt64ValuesOfPatch(self, patchIndex: "uint64_t", values: "uint64_t *") -> "uint64_t":
        r"""
        Gets all the values of a given patch of this instance. Values are supposed to be unsigned 64 bits integer.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want the values from.
        :param [out]:	values	  	Preallocated buffer for receiving the values. Size is
            							getValuesCountOfPatch(patchIndex).

        :rtype: int
        :return: The null value.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getUInt64ValuesOfPatch(self, patchIndex, values)

    def getInt32ValuesOfPatch(self, patchIndex: "uint64_t", values: "int32_t *") -> "int32_t":
        r"""
        Gets all the values of a given patch of this instance. Values are supposed to be signed 32 bits integer.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want the values from.
        :param [out]:	values	  	Preallocated buffer for receiving the values. Size is
            							getValuesCountOfPatch(patchIndex)

        :rtype: int
        :return: The null value.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getInt32ValuesOfPatch(self, patchIndex, values)

    def getUInt32ValuesOfPatch(self, patchIndex: "uint64_t", values: "uint32_t *") -> "uint32_t":
        r"""
        Gets all the values of a given patch of this instance. Values are supposed to be unsigned 32 bits integer.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want the values from.
        :param [out]:	values	  	Preallocated buffer for receiving the values. Size is
            							getValuesCountOfPatch(patchIndex)

        :rtype: int
        :return: The null value.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getUInt32ValuesOfPatch(self, patchIndex, values)

    def getInt16ValuesOfPatch(self, patchIndex: "uint64_t", values: "int16_t *") -> "int16_t":
        r"""
        Gets all the values of a given patch of this instance. Values are supposed to be signed 16 bits integer.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want the values from.
        :param [out]:	values	  	Preallocated buffer for receiving the values. Size is
            							getValuesCountOfPatch(patchIndex)

        :rtype: int
        :return: The null value.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getInt16ValuesOfPatch(self, patchIndex, values)

    def getUInt16ValuesOfPatch(self, patchIndex: "uint64_t", values: "uint16_t *") -> "uint16_t":
        r"""
        Gets all the values of a given patch of this instance. Values are supposed to be unsigned 16 bits integer.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want the values from.
        :param [out]:	values	  	Preallocated buffer for receiving the values. Size is
            							getValuesCountOfPatch(patchIndex)

        :rtype: int
        :return: The null value.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getUInt16ValuesOfPatch(self, patchIndex, values)

    def getInt8ValuesOfPatch(self, patchIndex: "uint64_t", values: "int8_t *") -> "int8_t":
        r"""
        Gets all the values of a given patch of this instance. Values are supposed to be signed 8 bits integer.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want the values from.
        :param [out]:	values	  	Preallocated buffer for receiving the values. Size is
            							getValuesCountOfPatch(patchIndex)

        :rtype: int8_t
        :return: The null value.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getInt8ValuesOfPatch(self, patchIndex, values)

    def getUInt8ValuesOfPatch(self, patchIndex: "uint64_t", values: "uint8_t *") -> "uint8_t":
        r"""
        Gets all the values of a given patch of this instance. Values are supposed to be unsigned 8 bits integer.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want the values from.
        :param [out]:	values	  	Preallocated buffer for receiving the values. Size is
            							getValuesCountOfPatch(patchIndex)

        :rtype: uint8_t
        :return: The null value.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getUInt8ValuesOfPatch(self, patchIndex, values)

    def pushBackHdf5ArrayOfValues(self, *args) -> "void":
        r"""
        Create an nd array of values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:			The datatype of the values
        :type numValues: int
        :param numValues:		  	The number of property values ordered by dimension of the
            										array to write.  It is ordered from slowest dimension to
            										fastest dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If ``nullptr`` (default), a
            										default HDF proxy must be defined into the data object
            										repository.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackHdf5ArrayOfValues(self, *args)

    def pushBackHdf5Array1dOfValues(self, *args) -> "void":
        r"""
        Creates a 1d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCount: int
        :param valueCount:			The number of values to write).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and
            										won't be closed in this method. If ``nullptr``
            										(default), a default HDF proxy must be defined into
            										the data object repository.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackHdf5Array1dOfValues(self, *args)

    def pushBackHdf5Array2dOfValues(self, *args) -> "void":
        r"""
        Creates a 2d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy					(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackHdf5Array2dOfValues(self, *args)

    def pushBackHdf5Array3dOfValues(self, *args) -> "void":
        r"""
        Creates a 3d array of explicit float values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:				The datatype of the values
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackHdf5Array3dOfValues(self, *args)

    def setValuesOfInt64Hdf5ArrayOfValues(self, *args) -> "void":
        r"""
        Adds an nd array of explicit int 64 bits values into to the property values. Since this
        methods only pushes back values into an existing array, it is to be used along with
        pushBackInt64Hdf5ArrayOfValues().

        :raises: std::invalid_argument	If ``proxy`` is null and no default HDF proxy is defined
            										into the data object repository.
        :raises: std::out_of_range	 	If ``patchIndex`` is strictly greater than patch count and
            										different from unsigned int maximum value.

        :param [in]:	  	values			  	All the property values to set ordered according to the
            										topology of the representation it is based on.
        :type numValues: int
        :param numValues:		  	The number of property values ordered by dimension of the
            										array to write. It is ordered from slowest dimension to
            										fastest dimension.
        :type offsetValues: int
        :param offsetValues:	  	The offset values ordered by dimension of the array to
            										write. It is ordered from slowest dimension to fastest
            										dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If null (default value), a
            										default HDF proxy must be defined into the data object
            										repository.
        :type patchIndex: int, optional
        :param patchIndex:		  	(Optional) Zero-based index of the patch where to write
            										the property values. If not provided, its default value
            										is by convention set to unsigned int maximum value and
            										the property values will be written in the last property
            										values patch (the one with the greatest index).
        """
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt64Hdf5ArrayOfValues(self, *args)

    def setValuesOfUInt64Hdf5ArrayOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt64Hdf5ArrayOfValues(self, *args)

    def setValuesOfInt32Hdf5ArrayOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt32Hdf5ArrayOfValues(self, *args)

    def setValuesOfUInt32Hdf5ArrayOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt32Hdf5ArrayOfValues(self, *args)

    def setValuesOfInt16Hdf5ArrayOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt16Hdf5ArrayOfValues(self, *args)

    def setValuesOfUInt16Hdf5ArrayOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt16Hdf5ArrayOfValues(self, *args)

    def setValuesOfInt8Hdf5ArrayOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt8Hdf5ArrayOfValues(self, *args)

    def setValuesOfUInt8Hdf5ArrayOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt8Hdf5ArrayOfValues(self, *args)

    def setValuesOfDoubleHdf5ArrayOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfDoubleHdf5ArrayOfValues(self, *args)

    def setValuesOfFloatHdf5ArrayOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfFloatHdf5ArrayOfValues(self, *args)

    def setValuesOfInt64Hdf5Array1dOfValues(self, *args) -> "void":
        r"""
        Adds a 1d array of explicit int 64 bits values into the property values. Since this methods
        only pushes back values into an existing array, it is to be used along with
        pushBackInt64Hdf5Array3dOfValues().

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.
        :raises: std::out_of_range	 	If ``patchIndex`` is strictly greater than patch count and
            										different from unsigned int maximum value.

        :param [in]:	  	values				  	All the property values to set ordered according to
            											the topology of the representation it is based on.
        :type valueCount: int
        :param valueCount:				The number of values to write.
        :type offset: int
        :param offset:	  				The offset value.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default value), a default HDF proxy must be defined
            											into the data object repository.
        :type patchIndex: int, optional
        :param patchIndex:			  	(Optional) Zero-based index of the patch where to
            											write the property values. If not provided, its
            											default value is by convention set to unsigned int
            											maximum value and the property values will be written
            											in the last property values patch (the one with the
            											greatest index).
        """
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt64Hdf5Array1dOfValues(self, *args)

    def setValuesOfUInt64Hdf5Array1dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt64Hdf5Array1dOfValues(self, *args)

    def setValuesOfInt32Hdf5Array1dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt32Hdf5Array1dOfValues(self, *args)

    def setValuesOfUInt32Hdf5Array1dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt32Hdf5Array1dOfValues(self, *args)

    def setValuesOfInt16Hdf5Array1dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt16Hdf5Array1dOfValues(self, *args)

    def setValuesOfUInt16Hdf5Array1dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt16Hdf5Array1dOfValues(self, *args)

    def setValuesOfInt8Hdf5Array1dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt8Hdf5Array1dOfValues(self, *args)

    def setValuesOfUInt8Hdf5Array1dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt8Hdf5Array1dOfValues(self, *args)

    def setValuesOfDoubleHdf5Array1dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfDoubleHdf5Array1dOfValues(self, *args)

    def setValuesOfFloatHdf5Array1dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfFloatHdf5Array1dOfValues(self, *args)

    def setValuesOfInt64Hdf5Array2dOfValues(self, *args) -> "void":
        r"""
        Adds a 2d array of explicit values into the property values. Since this methods
        only pushes back values into an existing array, it is to be used along with
        pushBackInt64Hdf5Array2dOfValues().

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.
        :raises: std::out_of_range	 	If ``patchIndex`` is strictly greater than patch count and
            										different from unsigned int maximum value.

        :param [in]:	  	values				  	All the property values to set ordered according to
            											the topology of the representation it is based on.
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly J dimension).
        :type offsetInFastestDim: int
        :param offsetInFastestDim:	  	The offset value for writing in the fastest dimension
            											(mainly I dimension).
        :type offsetInSlowestDim: int
        :param offsetInSlowestDim:	  	The offset value for writing in the slowest dimension
            											(mainly J dimension).		
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default value), a default HDF proxy must be defined
            											into the data object repository.
        :type patchIndex: int, optional
        :param patchIndex:			  	(Optional) Zero-based index of the patch where to
            											write the property values. If not provided, its
            											default value is by convention set to unsigned int
            											maximum value and the property values will be written
            											in the last property values patch (the one with the
            											greatest index).
        """
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt64Hdf5Array2dOfValues(self, *args)

    def setValuesOfUInt64Hdf5Array2dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt64Hdf5Array2dOfValues(self, *args)

    def setValuesOfInt32Hdf5Array2dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt32Hdf5Array2dOfValues(self, *args)

    def setValuesOfUInt32Hdf5Array2dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt32Hdf5Array2dOfValues(self, *args)

    def setValuesOfInt16Hdf5Array2dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt16Hdf5Array2dOfValues(self, *args)

    def setValuesOfUInt16Hdf5Array2dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt16Hdf5Array2dOfValues(self, *args)

    def setValuesOfInt8Hdf5Array2dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt8Hdf5Array2dOfValues(self, *args)

    def setValuesOfUInt8Hdf5Array2dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt8Hdf5Array2dOfValues(self, *args)

    def setValuesOfDoubleHdf5Array2dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfDoubleHdf5Array2dOfValues(self, *args)

    def setValuesOfFloatHdf5Array2dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfFloatHdf5Array2dOfValues(self, *args)

    def setValuesOfInt64Hdf5Array3dOfValues(self, *args) -> "void":
        r"""
        Adds a 3d array of explicit int 64 bits values into the property values. Since this methods
        only pushes back values into an existing array, it is to be used along with
        pushBackInt64Hdf5Array3dOfValues().

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.
        :raises: std::out_of_range	 	If ``patchIndex`` is strictly greater than patch count and
            										different from unsigned int maximum value.

        :param [in]:	  	values				  	All the property values to set ordered according to
            											the topology of the representation it is based on.
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :type offsetInFastestDim: int
        :param offsetInFastestDim:	  	The offset value for writing in the fastest dimension
            											(mainly I dimension).
        :type offsetInMiddleDim: int
        :param offsetInMiddleDim:	  	The offset value for writing in the middle dimension
            											(mainly J dimension).
        :type offsetInSlowestDim: int
        :param offsetInSlowestDim:	  	The offset value for writing in the slowest dimension
            											(mainly K dimension).
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default value), a default HDF proxy must be defined
            											into the data object repository.
        :type patchIndex: int, optional
        :param patchIndex:			  	(Optional) Zero-based index of the patch where to
            											write the property values. If not provided, its
            											default value is by convention set to unsigned int
            											maximum value and the property values will be written
            											in the last property values patch (the one with the
            											greatest index).
        """
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt64Hdf5Array3dOfValues(self, *args)

    def setValuesOfUInt64Hdf5Array3dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt64Hdf5Array3dOfValues(self, *args)

    def setValuesOfInt32Hdf5Array3dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt32Hdf5Array3dOfValues(self, *args)

    def setValuesOfUInt32Hdf5Array3dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt32Hdf5Array3dOfValues(self, *args)

    def setValuesOfInt16Hdf5Array3dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt16Hdf5Array3dOfValues(self, *args)

    def setValuesOfUInt16Hdf5Array3dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt16Hdf5Array3dOfValues(self, *args)

    def setValuesOfInt8Hdf5Array3dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfInt8Hdf5Array3dOfValues(self, *args)

    def setValuesOfUInt8Hdf5Array3dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfUInt8Hdf5Array3dOfValues(self, *args)

    def setValuesOfDoubleHdf5Array3dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfDoubleHdf5Array3dOfValues(self, *args)

    def setValuesOfFloatHdf5Array3dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_AbstractValuesProperty_setValuesOfFloatHdf5Array3dOfValues(self, *args)

    def getInt64ValuesOfPatch(self, *args) -> "void":
        r"""
        *Overload 1:*

        Gets all the values of a given patch of this instance. Values are supposed to be signed 64 bits integer.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want the values from.
        :param [out]:	values	  	Preallocated buffer for receiving the values. Size is
            							getValuesCountOfPatch(patchIndex).

        :rtype: int
        :return: The null value.

        |

        *Overload 2:*

        Gets some of the values of a given patch of this instance. Values are supposed to be int 64
        bits ones.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:					The index of the patch we want the values from.
        :param [out]:	values						The array (pointer) of values which must be
            											preallocated. Size is
            											getValuesCountOfPatch(patchIndex).
        :type numValuesInEachDimension: int
        :param numValuesInEachDimension:	The number of property values ordered by dimension of
            											the array to read. It is ordered from slowest dimension
            											to fastest dimension.
        :type offsetInEachDimension: int
        :param offsetInEachDimension:   	The offset values ordered by dimension of the array
            											to read. It is ordered from slowest dimension to fastest
            											dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:			The number of dimensions of the array to write.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getInt64ValuesOfPatch(self, *args)

    def getInt64ValuesOf3dPatch(self, patchIndex: "unsigned int", values: "int64_t *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", offsetInFastestDim: "uint64_t", offsetInMiddleDim: "uint64_t", offsetInSlowestDim: "uint64_t") -> "void":
        r"""
        Gets some of the values of a given patch of this instance. Values are supposed to be int 64
        bits ones.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:			  	The index of the patch we want the values from.
        :param [out]:	values				  	The array (pointer) of values must be preallocated. Size
            										is getValuesCountOfPatch(patchIndex).
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to read in the fastest dimension
            										(mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to read in the middle dimension
            										(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to read in the slowest dimension
            										(mainly K dimension).
        :type offsetInFastestDim: int
        :param offsetInFastestDim:	  	The offset value for reading in the fastest dimension
            										(mainly I dimension).
        :type offsetInMiddleDim: int
        :param offsetInMiddleDim:	  	The offset value for reading in the middle dimension
            										(mainly J dimension).
        :type offsetInSlowestDim: int
        :param offsetInSlowestDim:	  	The offset value for reading in the slowest dimension
            										(mainly K dimension).
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getInt64ValuesOf3dPatch(self, patchIndex, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, offsetInFastestDim, offsetInMiddleDim, offsetInSlowestDim)

    def getIntValuesOfPatch(self, patchIndex: "unsigned int", values: "int *", numValuesInEachDimension: "uint64_t const *", offsetInEachDimension: "uint64_t const *", numArrayDimensions: "unsigned int") -> "int":
        r"""
        Gets some of the values of a given patch of this instance. Values are supposed to be integer
        ones.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:					The index of the patch we want the values from.
        :param [out]:	values						The array (pointer) of values which must be
            											preallocated. Size is
            											getValuesCountOfPatch(patchIndex).
        :param [in]: 	numValuesInEachDimension	The number of property values ordered by
            											dimension of the array to read. It is ordered from
            											slowest dimension to fastest dimension.
        :param [in]: 	offsetInEachDimension   	The offset values ordered by dimension of the
            											array to read. It is ordered from slowest dimension to
            											fastest dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:			The number of dimensions of the array to read.

        :rtype: int
        :return: The null value.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getIntValuesOfPatch(self, patchIndex, values, numValuesInEachDimension, offsetInEachDimension, numArrayDimensions)

    def getIntValuesOf3dPatch(self, patchIndex: "unsigned int", values: "int *", valueCountInFastestDim: "unsigned int", valueCountInMiddleDim: "unsigned int", valueCountInSlowestDim: "unsigned int", offsetInFastestDim: "unsigned int", offsetInMiddleDim: "unsigned int", offsetInSlowestDim: "unsigned int") -> "void":
        r"""
        Gets some of the values of a given patch of this instance. Values are supposed to be integer
        ones.

        :raises: std::logic_error 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:			  	The index of the patch we want the values from.
        :param [out]:	values				  	The array (pointer) of values must be preallocated. Size
            										is getValuesCountOfPatch(patchIndex).
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to read in the fastest dimension
            										(mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to read in the middle dimension
            										(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to read in the slowest dimension
            										(mainly K dimension).
        :type offsetInFastestDim: int
        :param offsetInFastestDim:	  	The offset value for reading in the fastest dimension
            										(mainly I dimension).
        :type offsetInMiddleDim: int
        :param offsetInMiddleDim:	  	The offset value for reading in the middle dimension
            										(mainly J dimension).
        :type offsetInSlowestDim: int
        :param offsetInSlowestDim:	  	The offset value for reading in the slowest dimension
            										(mainly K dimension).
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getIntValuesOf3dPatch(self, patchIndex, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, offsetInFastestDim, offsetInMiddleDim, offsetInSlowestDim)

    def pushBackDoubleHdf5Array1dOfValues(self, values: "double const *", valueCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 1d array of explicit double values to the property values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: float
        :param values:			All the property values to set ordered according the topology
            									of the representation it is based on.
        :type valueCount: int
        :param valueCount:  	The number of values to write.
        :param [in,out]:	proxy			(Optional) The HDF proxy where to write the property values.
            									It must be already opened for writing and won't be closed in this
            									method. If ``nullptr`` (default value), then a default HDF proxy
            									must be defined in the repository.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackDoubleHdf5Array1dOfValues(self, values, valueCount, proxy)

    def pushBackDoubleHdf5Array2dOfValues(self, values: "double const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 2d array of explicit double values to the property values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: float
        :param values:				  	All the property values to set ordered according the
            											topology of the representation it is based on.
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly J dimension).
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default value), then a default HDF proxy must be
            											defined in the repository.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackDoubleHdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, proxy)

    def pushBackDoubleHdf5Array3dOfValues(self, values: "double const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 3d array of explicit double values to the property values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: float
        :param values:				  	All the property values to set ordered according the
            											topology of the representation it is based on.
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default value), then a default HDF proxy must be
            											defined in the repository.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackDoubleHdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, proxy)

    def pushBackDoubleHdf5ArrayOfValues(self, values: "double const *", numValues: "uint64_t const *", numArrayDimensions: "unsigned int", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds an nd array of explicit double values to the property values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: float
        :param values:			  	All the property values to set ordered according the
            										topology of the representation it is based on.
        :type numValues: int
        :param numValues:		  	The number of property values ordered by dimension of the
            										array to write.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If ``nullptr`` (default value),
            										then a default HDF proxy must be defined in the
            										repository.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackDoubleHdf5ArrayOfValues(self, values, numValues, numArrayDimensions, proxy)

    def pushBackFloatHdf5Array1dOfValues(self, values: "float const *", valueCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 1d array of explicit float values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackFloatHdf5Array1dOfValues(self, values, valueCount, proxy)

    def pushBackFloatHdf5Array2dOfValues(self, values: "float const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 2d array of explicit float values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackFloatHdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, proxy)

    def pushBackFloatHdf5Array3dOfValues(self, values: "float const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 3d array of explicit float values to the property values.

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackFloatHdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, proxy)

    def pushBackFloatHdf5ArrayOfValues(self, values: "float const *", numValues: "uint64_t const *", numArrayDimensions: "unsigned int", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds an nd array of explicit float values to the property values.

        :raises: std::invalid_argument If  minimumValue == nullptr  and  maximumValue != nullptr .
        :raises: std::invalid_argument	If  minimumValue != nullptr  and  maximumValue == nullptr .

        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackFloatHdf5ArrayOfValues(self, values, numValues, numArrayDimensions, proxy)

    def pushBackRefToExistingFloatingPointDataset(self, *args) -> "std::string":
        r"""
        Pushes back a reference to an existing (or a "to exist") HDF dataset in a particular HDF
        proxy. The reason can be that the values already exist in an external file (only HDF5 for
        now) or that the writing of the values in the external file is differed in time.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :param [in]:	proxy	   	The HDF5 proxy where the values are already or will be stored. If
            							``nullptr``, then a default HDF proxy must be defined in the
            							repository.
        :type datasetName: string, optional
        :param datasetName:	(Optional) The HDF5 dataset name where the values are stored. If
            							empty, the dataset will be named the same as the dataset naming
            							convention of fesapi :
            							getHdfGroup() + "/values_patch" + patchIndex

        :rtype: string
        :return: The name of the referenced HDF5 dataset.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_pushBackRefToExistingFloatingPointDataset(self, *args)

    def getDoubleValuesOfPatch(self, patchIndex: "unsigned int", values: "double *") -> "void":
        r"""
        Gets all the values of a particular patch of this instance which are supposed to be double
        ones.

        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want the values from.
        :param [out]:	values	  	Preallocated buffer for receiving the values. Size is
            							getValuesCountOfPatch(patchIndex).
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getDoubleValuesOfPatch(self, patchIndex, values)

    def getFloatValuesOfPatch(self, *args) -> "void":
        r"""
        *Overload 1:*

        Gets all the values of a particular patch of this instance which are supposed to be float
        ones.

        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:	The index of the patch we want the values from.
        :param [out]:	values	  	Preallocated buffer for receiving the values. Size is
            							getValuesCountOfPatch(patchIndex).

        |

        *Overload 2:*

        Get some of the values of a particular patch of the instance as float ones. This method makes
        use of HDF5 hyperslabbing.

        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:					The index of the patch we want the values from.
        :param [out]:	values						The array (pointer) of values must be
            											preallocated. Size is
            											getValuesCountOfPatch(patchIndex).
        :type numValuesInEachDimension: int
        :param numValuesInEachDimension:	The number of property values ordered by dimension of
            											the array to read. It is ordered from slowest dimension
            											to fastest dimension.
        :type offsetInEachDimension: int
        :param offsetInEachDimension:   	The offset values ordered by dimension of the array
            											to read. It is ordered from slowest dimension to fastest
            											dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:			The number of dimensions of the HDF5 array to read.
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getFloatValuesOfPatch(self, *args)

    def getFloatValuesOf3dPatch(self, patchIndex: "unsigned int", values: "float *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", offsetInFastestDim: "uint64_t", offsetInMiddleDim: "uint64_t", offsetInSlowestDim: "uint64_t") -> "void":
        r"""
        Get some of the values of a particular patch of the instance as float ones. This method makes
        use of HDF5 hyperslabbing.

        :raises: std::out_of_range	If ``patchIndex`` is strictly greater than patch count.

        :type patchIndex: int
        :param patchIndex:			  	The index of the patch we want the values from.
        :param [in,out]:	values				  	The array (pointer) of values must be preallocated.
            											Size is getValuesCountOfPatch(patchIndex).
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to read in the fastest dimension
            											(mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to read in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to read in the slowest dimension
            											(mainly K dimension).
        :type offsetInFastestDim: int
        :param offsetInFastestDim:	  	The offset value for reading in the fastest dimension
            											(mainly I dimension).
        :type offsetInMiddleDim: int
        :param offsetInMiddleDim:	  	The offset value for reading in the middle dimension
            											(mainly J dimension).
        :type offsetInSlowestDim: int
        :param offsetInSlowestDim:	  	The offset value for reading in the slowest dimension
            											(mainly K dimension).
        """
        return _fesapi.Resqml2_AbstractValuesProperty_getFloatValuesOf3dPatch(self, patchIndex, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, offsetInFastestDim, offsetInMiddleDim, offsetInSlowestDim)
    __swig_destroy__ = _fesapi.delete_Resqml2_AbstractValuesProperty

# Register Resqml2_AbstractValuesProperty in _fesapi:
_fesapi.Resqml2_AbstractValuesProperty_swigregister(Resqml2_AbstractValuesProperty)
class Resqml2_CommentProperty(Resqml2_AbstractValuesProperty):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackStringHdf5ArrayOfValues(self, values: "StringVector", proxy: "Eml2_AbstractHdfProxy") -> "void":
        return _fesapi.Resqml2_CommentProperty_pushBackStringHdf5ArrayOfValues(self, values, proxy)

    def getStringValuesOfPatch(self, patchIndex: "unsigned int") -> "std::vector< std::string,std::allocator< std::string > >":
        return _fesapi.Resqml2_CommentProperty_getStringValuesOfPatch(self, patchIndex)

    def pushBackRefToExistingDataset(self, *args) -> "std::string":
        r"""
        Pushes back a new patch of values for this property where the values have not to be written in
        the HDF5 file. The reason can be that the values already exist in an external file (only HDF5
        for now) or that the writing of the values in the external file is differed in time.

        :raises: std::invalid_argument	If ``hdfProxy`` is null.

        :param [in]:	hdfProxy   	The HDF5 proxy where the values are already or will be stored. It
            							cannot be null.
        :type datasetName: string, optional
        :param datasetName:	(Optional) If not provided during the method call, the dataset will
            							be named the same as the dataset naming convention of fesapi:
            							"/RESQML/" + prop->uuid + "/values_patch" + patchIndex
        :param nullValue:  	(Optional) Not used for comment properties.

        :rtype: string
        :return: The name of the HDF5 dataset.
        """
        return _fesapi.Resqml2_CommentProperty_pushBackRefToExistingDataset(self, *args)
    __swig_destroy__ = _fesapi.delete_Resqml2_CommentProperty

# Register Resqml2_CommentProperty in _fesapi:
_fesapi.Resqml2_CommentProperty_swigregister(Resqml2_CommentProperty)
class Resqml2_ContinuousProperty(Resqml2_AbstractValuesProperty):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getUom(self) -> "gsoap_resqml2_0_1::resqml20__ResqmlUom":
        return _fesapi.Resqml2_ContinuousProperty_getUom(self)

    def getUomAsString(self) -> "std::string":
        return _fesapi.Resqml2_ContinuousProperty_getUomAsString(self)

    def pushBackDoubleHdf5Array1dOfValues(self, values: "double const *", valueCount: "uint64_t", minimumValue: "double", maximumValue: "double", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 1d array of explicit double values to the property values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: float
        :param values:			All the property values to set ordered according the topology
            									of the representation it is based on.
        :type valueCount: int
        :param valueCount:  	The number of values to write.
        :type minimumValue: float
        :param minimumValue:	The minimum value of the values to add. If ``NaN`` is
            									provided then both minimum and maximum values will be computed
            									from the values.
        :type maximumValue: float
        :param maximumValue:	The maximum value of the values to add. If ``NaN`` is
            									provided then both maximum and minimum values will be computed
            									from the values.
        :param [in,out]:	proxy			(Optional) The HDF proxy where to write the property values.
            									It must be already opened for writing and won't be closed in this
            									method. If ``nullptr`` (default value), then a default HDF proxy
            									must be defined in the repository.
        """
        return _fesapi.Resqml2_ContinuousProperty_pushBackDoubleHdf5Array1dOfValues(self, values, valueCount, minimumValue, maximumValue, proxy)

    def pushBackDoubleHdf5Array2dOfValues(self, values: "double const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", minimumValue: "double", maximumValue: "double", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 2d array of explicit double values to the property values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: float
        :param values:				  	All the property values to set ordered according the
            											topology of the representation it is based on.
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly J dimension).
        :type minimumValue: float
        :param minimumValue:		  	The minimum value of the values to add. If
            											``NaN`` is provided then both minimum and maximum
            											values will be computed from the values.
        :type maximumValue: float
        :param maximumValue:		  	The maximum value of the values to add. If
            											``NaN`` is provided then both maximum and minimum
            											values will be computed from the values.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default value), then a default HDF proxy must be
            											defined in the repository.
        """
        return _fesapi.Resqml2_ContinuousProperty_pushBackDoubleHdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, minimumValue, maximumValue, proxy)

    def pushBackDoubleHdf5Array3dOfValues(self, values: "double const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", minimumValue: "double", maximumValue: "double", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 3d array of explicit double values to the property values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: float
        :param values:				  	All the property values to set ordered according the
            											topology of the representation it is based on.
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :type minimumValue: float
        :param minimumValue:		  	The minimum value of the values to add. If
            											``NaN`` is provided then both minimum and maximum
            											values will be computed from the values.
        :type maximumValue: float
        :param maximumValue:		  	The maximum value of the values to add. If
            											``NaN`` is provided then both maximum and minimum
            											values will be computed from the values.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default value), then a default HDF proxy must be
            											defined in the repository.
        """
        return _fesapi.Resqml2_ContinuousProperty_pushBackDoubleHdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, minimumValue, maximumValue, proxy)

    def pushBackDoubleHdf5ArrayOfValues(self, values: "double const *", numValues: "uint64_t const *", numArrayDimensions: "unsigned int", minimumValue: "double *", maximumValue: "double *", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds an nd array of explicit double values to the property values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: float
        :param values:			  	All the property values to set ordered according the
            										topology of the representation it is based on.
        :type numValues: int
        :param numValues:		  	The number of property values ordered by dimension of the
            										array to write.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If ``nullptr`` (default value),
            										then a default HDF proxy must be defined in the
            										repository.
        :param [in]:	  	minimumValue	  	The minimum value (or value vector) of the
            										values to add. If ``nullptr`` is provided for both
            ``minimumValue`` and ``maximumValue`` and if the dimension of
            										value is 1 then both minimum and maximum values will be
            										computed from the values.
        :param [in]:	  	maximumValue	  	The maximum value (or value vector) of the
            										values to add. If @ nullptr is provided for both
            ``maximumValue`` and ``minimumValue`` and if the dimension of
            										value is 1 then both maximum and minimum values will be
            										computed from the values.
        """
        return _fesapi.Resqml2_ContinuousProperty_pushBackDoubleHdf5ArrayOfValues(self, values, numValues, numArrayDimensions, minimumValue, maximumValue, proxy)

    def pushBackFloatHdf5Array1dOfValues(self, values: "float const *", valueCount: "uint64_t", minimumValue: "float", maximumValue: "float", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 1d array of explicit float values to the property values.

        """
        return _fesapi.Resqml2_ContinuousProperty_pushBackFloatHdf5Array1dOfValues(self, values, valueCount, minimumValue, maximumValue, proxy)

    def pushBackFloatHdf5Array2dOfValues(self, values: "float const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", minimumValue: "float", maximumValue: "float", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 2d array of explicit float values to the property values.

        """
        return _fesapi.Resqml2_ContinuousProperty_pushBackFloatHdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, minimumValue, maximumValue, proxy)

    def pushBackFloatHdf5Array3dOfValues(self, values: "float const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", minimumValue: "float", maximumValue: "float", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 3d array of explicit float values to the property values.

        """
        return _fesapi.Resqml2_ContinuousProperty_pushBackFloatHdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, minimumValue, maximumValue, proxy)

    def pushBackFloatHdf5ArrayOfValues(self, values: "float const *", numValues: "uint64_t const *", numArrayDimensions: "unsigned int", minimumValue: "float *", maximumValue: "float *", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds an nd array of explicit float values to the property values.

        :raises: std::invalid_argument If  minimumValue == nullptr  and  maximumValue != nullptr .
        :raises: std::invalid_argument	If  minimumValue != nullptr  and  maximumValue == nullptr .

        """
        return _fesapi.Resqml2_ContinuousProperty_pushBackFloatHdf5ArrayOfValues(self, values, numValues, numArrayDimensions, minimumValue, maximumValue, proxy)

    def getMinimumValue(self, index: "unsigned int"=0) -> "double":
        r"""
        Gets the minimum value of a non vector property or the minimum value of one given
        			value of a vector property. This minimum value is read (it is not computed).

        :type index: int, optional
        :param index:	(Optional) ``0`` (default value, corresponding to the non vector property case) or
            					zero-based index of the vector value for which we look for the minimum value
            					(vector property case).

        :rtype: float
        :return: The minimum value of the non vector property or the minimum value at position
            ``index`` of the vector value or ``NaN`` if ``index`` is out of range (strictly
            			greater than ``0`` for a non vector property or greater than the vector size for a
            			vector property).
        """
        return _fesapi.Resqml2_ContinuousProperty_getMinimumValue(self, index)

    def getMaximumValue(self, index: "unsigned int"=0) -> "double":
        r"""
        Gets the maximum value of a non vector property or the maximum value of one given
        			value of a vector property. This maximum value is read (it is not computed).

        :type index: int, optional
        :param index:	(Optional) ``0`` (default value, corresponding to the non vector property case) or
            					zero-based index of the vector value for which we look for the maximum value
            					(vector property case).

        :rtype: float
        :return: The maximum value of the non vector property or the maximum value at position
            ``index`` of the vector value or ``NaN`` if ``index`` is out of range (strictly
            			greater than ``0`` for a non vector property or greater than the vector size for a
            			vector property).
        """
        return _fesapi.Resqml2_ContinuousProperty_getMaximumValue(self, index)

    def setMinimumValue(self, value: "double", index: "unsigned int"=0) -> "void":
        r"""
        Sets the minimum value of a non vector property or the minimum value of one given
        			value of a vector property.

        :type value: float
        :param value:	The minimum value to set.
        :type index: int, optional
        :param index:	(Optional)  ``0`` (default value, corresponding to the non vector property
            					case) or zero-based index of the vector value for which we want to set the
            					minimum value (vector property case).
        """
        return _fesapi.Resqml2_ContinuousProperty_setMinimumValue(self, value, index)

    def setMaximumValue(self, value: "double", index: "unsigned int"=0) -> "void":
        r"""
        Sets the maximum value of a non vector property or the maximum value of one given
        			value of a vector property.

        :type value: float
        :param value:	The maximum value to set.
        :type index: int, optional
        :param index:	(Optional)  ``0`` (default value, corresponding to the non vector property
            					case) or zero-based index of the vector value for which we want to set the
            					maximum value (vector property case).
        """
        return _fesapi.Resqml2_ContinuousProperty_setMaximumValue(self, value, index)

    def pushBackHdf5ArrayOfValues(self, *args) -> "void":
        r"""
        *Overload 1:*

        Create an nd array of explicit float values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type numValues: int
        :param numValues:		  	The number of property values ordered by dimension of the
            										array to write.  It is ordered from slowest dimension to
            										fastest dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :param [in]:	  	minimumValue	  	The minimum value (or value vector) of the
            										values to add. If ``nullptr`` (default) is provided then
            										neither minimum nor maximum value will be set.
        :param [in]:	  	maximumValue	  	The maximum value (or value vector) of the
            										values to add. If ``nullptr`` (default) is provided then
            										neither maximum nor minimum value will be set.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If ``nullptr`` (default), a
            										default HDF proxy must be defined into the data object
            										repository.

        |

        *Overload 2:*

        Create an nd array of values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:			The datatype of the values
        :type numValues: int
        :param numValues:		  	The number of property values ordered by dimension of the
            										array to write.  It is ordered from slowest dimension to
            										fastest dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If ``nullptr`` (default), a
            										default HDF proxy must be defined into the data object
            										repository.

        |

        *Overload 3:*

        Create an nd array of values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:			The datatype of the values
        :type numValues: int
        :param numValues:		  	The number of property values ordered by dimension of the
            										array to write.  It is ordered from slowest dimension to
            										fastest dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If ``nullptr`` (default), a
            										default HDF proxy must be defined into the data object
            										repository.

        |

        *Overload 4:*

        Create an nd array of values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:			The datatype of the values
        :type numValues: int
        :param numValues:		  	The number of property values ordered by dimension of the
            										array to write.  It is ordered from slowest dimension to
            										fastest dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If ``nullptr`` (default), a
            										default HDF proxy must be defined into the data object
            										repository.
        """
        return _fesapi.Resqml2_ContinuousProperty_pushBackHdf5ArrayOfValues(self, *args)

    def pushBackHdf5Array1dOfValues(self, *args) -> "void":
        r"""
        *Overload 1:*

        Creates a 1d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:			The datatype of the values
        :type valueCount: int
        :param valueCount:			The number of values to write).
        :type minimumValue: float
        :param minimumValue:		The minimum value of the values to add. If
            										``NaN`` is provided (default) then neither minimum nor
            										maximum value will be set.
        :type maximumValue: float
        :param maximumValue:		The maximum value of the values to add. If
            										``NaN`` is provided (default) then neither maximum nor
            										minimum value will be set.
        :param [in,out]:	proxy				(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and
            										won't be closed in this method. If ``nullptr``
            										(default), a default HDF proxy must be defined into
            										the data object repository.

        |

        *Overload 2:*

        Creates a 1d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCount: int
        :param valueCount:			The number of values to write).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and
            										won't be closed in this method. If ``nullptr``
            										(default), a default HDF proxy must be defined into
            										the data object repository.

        |

        *Overload 3:*

        Creates a 1d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCount: int
        :param valueCount:			The number of values to write).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and
            										won't be closed in this method. If ``nullptr``
            										(default), a default HDF proxy must be defined into
            										the data object repository.

        |

        *Overload 4:*

        Creates a 1d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCount: int
        :param valueCount:			The number of values to write).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and
            										won't be closed in this method. If ``nullptr``
            										(default), a default HDF proxy must be defined into
            										the data object repository.
        """
        return _fesapi.Resqml2_ContinuousProperty_pushBackHdf5Array1dOfValues(self, *args)

    def pushBackHdf5Array2dOfValues(self, *args) -> "void":
        r"""
        *Overload 1:*

        Creates a 2d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :type minimumValue: float
        :param minimumValue:		  	The minimum value of the values to add. If
            											``NaN`` is provided (default) then neither minimum nor
            											maximum value will be set.
        :type maximumValue: float
        :param maximumValue:		  	The maximum value of the values to add. If
            											``NaN`` is provided (default) then neither maximum nor
            											minimum value will be set.
        :param [in,out]:	proxy					(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.

        |

        *Overload 2:*

        Creates a 2d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy					(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.

        |

        *Overload 3:*

        Creates a 2d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy					(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.

        |

        *Overload 4:*

        Creates a 2d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy					(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.
        """
        return _fesapi.Resqml2_ContinuousProperty_pushBackHdf5Array2dOfValues(self, *args)

    def pushBackHdf5Array3dOfValues(self, *args) -> "void":
        r"""
        *Overload 1:*

        Creates a 3d array of explicit float values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :type minimumValue: float
        :param minimumValue:		  	The minimum value of the values to add. If
            											``NaN`` is provided (default) then neither minimum nor
            											maximum value will be set.
        :type maximumValue: float
        :param maximumValue:		  	The maximum value of the values to add. If
            											``NaN`` is provided (default) then neither maximum nor
            											minimum value will be set.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.

        |

        *Overload 2:*

        Creates a 3d array of explicit float values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:				The datatype of the values
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.

        |

        *Overload 3:*

        Creates a 3d array of explicit float values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:				The datatype of the values
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.

        |

        *Overload 4:*

        Creates a 3d array of explicit float values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:				The datatype of the values
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.
        """
        return _fesapi.Resqml2_ContinuousProperty_pushBackHdf5Array3dOfValues(self, *args)

    def setValuesOfFloatHdf5Array3dOfValues(self, *args) -> "void":
        r"""
        Sets some values of an existing 3d array of explicit float values of a particular patch. This
        method makes use of HDF5 hyperslabbing. Since this methods only pushes back values into an
        existing array, it is to be used along with pushBackFloatHdf5Array3dOfValues().

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.
        :raises: std::out_of_range	 	If ``patchIndex`` is strictly greater than patch count and
            										different from unsigned int maximum value.

        :type values: float
        :param values:				  	All the property values to set ordered according to
            											the topology of the representation it is based on.
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :type offsetInFastestDim: int
        :param offsetInFastestDim:	  	The offset value for writing in the fastest dimension
            											(mainly I dimension).
        :type offsetInMiddleDim: int
        :param offsetInMiddleDim:	  	The offset value for writing in the middle dimension
            											(mainly J dimension).
        :type offsetInSlowestDim: int
        :param offsetInSlowestDim:	  	The offset value for writing in the slowest dimension
            											(mainly K dimension).
        :type computeMinMax: boolean
        :param computeMinMax:		  	True if FESAPI needs to compute
            											the min and  max from the given ``values`` in order to
            											set them.
        :param [in,out]:	proxy				  	The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.
        :type patchIndex: int, optional
        :param patchIndex:			  	(Optional) Zero-based index of the patch where to
            											write the property values. If not provided, its
            											default value is by convention set to unsigned int
            											maximum value and the property values will be written
            											in the last property values patch (the one with the
            											greatest index).
        """
        return _fesapi.Resqml2_ContinuousProperty_setValuesOfFloatHdf5Array3dOfValues(self, *args)

    def setValuesOfDoubleHdf5Array3dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_ContinuousProperty_setValuesOfDoubleHdf5Array3dOfValues(self, *args)

    def setValuesOfFloatHdf5ArrayOfValues(self, *args) -> "void":
        r"""
        Set some values of an existing 3d array of explicit float values of a particular patch.  This
        method makes use of HDF5 hyperslabbing. This method is to be used along with one of the
        pushBackFloatHdf5ArrayOfValues() methods which do not write any value.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.
        :raises: std::out_of_range	 	If ``patchIndex`` is strictly greater than patch count and
            										different from unsigned int maximum value.

        :type values: float
        :param values:			  	All the property values to set ordered according to the
            										topology of the representation it is based on.
        :type numValues: int
        :param numValues:		  	The number of property values ordered by dimension of the
            										array to write. It is ordered from slowest dimension to
            										fastest dimension.
        :type offsetValues: int
        :param offsetValues:	  	The offset values ordered by dimension of the array to
            										write. It is ordered from slowest dimension to fastest
            										dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :type computeMinMax: boolean
        :param computeMinMax:	  	True if FESAPI needs to compute the
            										min and  max from the given ``values`` in order to set
            										them.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If ``nullptr`` (default), a
            										default HDF proxy must be defined into the data object
            										repository.
        :type patchIndex: int, optional
        :param patchIndex:		  	(Optional) Zero-based index of the patch where to write
            										the property values. If not provided, its default value
            										is by convention set to unsigned int maximum value and
            										the property values will be written in the last property
            										values patch (the one with the greatest index).
        """
        return _fesapi.Resqml2_ContinuousProperty_setValuesOfFloatHdf5ArrayOfValues(self, *args)

    def setValuesOfDoubleHdf5ArrayOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_ContinuousProperty_setValuesOfDoubleHdf5ArrayOfValues(self, *args)
    __swig_destroy__ = _fesapi.delete_Resqml2_ContinuousProperty

# Register Resqml2_ContinuousProperty in _fesapi:
_fesapi.Resqml2_ContinuousProperty_swigregister(Resqml2_ContinuousProperty)
class Resqml2_DiscreteProperty(Resqml2_AbstractValuesProperty):
    r"""
    Proxy class for a discrete  property. Such property contains discrete integer values;
    typically used to store any type of index. So that the value range can be known before
    accessing all values, it also optionally stores the minimum and maximum value in the range.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackInt64Hdf5Array1dOfValues(self, values: "int64_t const *", valueCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int64_t", minimumValue: "int64_t", maximumValue: "int64_t") -> "void":
        r"""
        Adds a 1d array of explicit int 64 bits values to the property values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: int
        :param values:			All the property values to set ordered according to the
            									topology of the representation it is based on.
        :type valueCount: int
        :param valueCount:  	The number of values to write.
        :param [in,out]:	proxy			The HDF proxy where to write the property values. It must be
            									already opened for writing and won't be closed in this method. If
            									``nullptr``, then a default HDF proxy must be defined in the
            									repository.
        :type nullValue: int
        :param nullValue:   	The null value.
        :type minimumValue: int
        :param minimumValue:	The minimum value of the values to add.
        :type maximumValue: int
        :param maximumValue:	The maximum value of the values to add.
        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt64Hdf5Array1dOfValues(self, values, valueCount, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt32Hdf5Array1dOfValues(self, values: "int const *", valueCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int", minimumValue: "int", maximumValue: "int") -> "void":
        r"""
        Adds a 1d array of explicit integer values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt32Hdf5Array1dOfValues(self, values, valueCount, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt16Hdf5Array1dOfValues(self, values: "short const *", valueCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "short", minimumValue: "short", maximumValue: "short") -> "void":
        r"""
        Adds a 1d array of explicit short values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt16Hdf5Array1dOfValues(self, values, valueCount, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt8Hdf5Array1dOfValues(self, values: "int8_t const *", valueCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int8_t", minimumValue: "int8_t", maximumValue: "int8_t") -> "void":
        r"""
        Adds a 1d array of explicit int8_t values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt8Hdf5Array1dOfValues(self, values, valueCount, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt64Hdf5Array2dOfValues(self, values: "int64_t const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int64_t", minimumValue: "int64_t", maximumValue: "int64_t") -> "void":
        r"""
        Adds a 2d array of explicit int 64 bits values to the property values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: int
        :param values:				  	All the property values to set ordered according to
            											the topology of the representation it is based on.
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly J dimension).
        :param [in,out]:	proxy				  	The HDF proxy where to write the property values. It
            											must be already opened for writing and won't be
            											closed in this method. If ``nullptr``, then a default
            											HDF proxy must be defined in the repository.
        :type nullValue: int
        :param nullValue:			  	The null value.
        :type minimumValue: int
        :param minimumValue:		  	The minimum value of the values to add.
        :type maximumValue: int
        :param maximumValue:		  	The maximum value of the values to add.
        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt64Hdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt32Hdf5Array2dOfValues(self, values: "int const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int", minimumValue: "int", maximumValue: "int") -> "void":
        r"""
        Adds a 2d array of explicit integer values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt32Hdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt16Hdf5Array2dOfValues(self, values: "short const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "short", minimumValue: "short", maximumValue: "short") -> "void":
        r"""
        Adds a 2d array of explicit short values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt16Hdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, proxy, nullValue, minimumValue, maximumValue)

    def pushBackUInt16Hdf5Array2dOfValues(self, values: "unsigned short const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "unsigned short", minimumValue: "unsigned short", maximumValue: "unsigned short") -> "void":
        r"""
        Adds a 2d array of explicit unsigned short values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackUInt16Hdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt8Hdf5Array2dOfValues(self, values: "int8_t const *", valueCountInFastestDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int8_t", minimumValue: "int8_t", maximumValue: "int8_t") -> "void":
        r"""
        Adds a 2d array of explicit int8_t values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt8Hdf5Array2dOfValues(self, values, valueCountInFastestDim, valueCountInSlowestDim, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt64Hdf5Array3dOfValues(self, values: "int64_t const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int64_t", minimumValue: "int64_t", maximumValue: "int64_t") -> "void":
        r"""
        Adds a 3d array of explicit int 64 bits values to the property values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: int
        :param values:				  	All the property values to set ordered according the
            											topology of the representation it is based on.
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param [in,out]:	proxy				  	The HDF proxy where to write the property values. It
            											must be already opened for writing and won't be
            											closed in this method. If ``nullptr``, then a default
            											HDF proxy must be defined in the repository.
        :type nullValue: int
        :param nullValue:			  	The null value.
        :type minimumValue: int
        :param minimumValue:		  	The minimum value of the values to add.
        :type maximumValue: int
        :param maximumValue:		  	The maximum value of the values to add.
        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt64Hdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt32Hdf5Array3dOfValues(self, values: "int const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int", minimumValue: "int", maximumValue: "int") -> "void":
        r"""
        Adds a 3d array of explicit integer values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt32Hdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt16Hdf5Array3dOfValues(self, values: "short const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "short", minimumValue: "short", maximumValue: "short") -> "void":
        r"""
        Adds a 3d array of explicit short values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt16Hdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, proxy, nullValue, minimumValue, maximumValue)

    def pushBackUInt16Hdf5Array3dOfValues(self, values: "unsigned short const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "unsigned short", minimumValue: "unsigned short", maximumValue: "unsigned short") -> "void":
        r"""
        Adds a 3d array of explicit unsigned short values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackUInt16Hdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt8Hdf5Array3dOfValues(self, values: "int8_t const *", valueCountInFastestDim: "uint64_t", valueCountInMiddleDim: "uint64_t", valueCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy", nullValue: "int8_t", minimumValue: "int8_t", maximumValue: "int8_t") -> "void":
        r"""
        Adds a 3d array of explicit int8_t values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt8Hdf5Array3dOfValues(self, values, valueCountInFastestDim, valueCountInMiddleDim, valueCountInSlowestDim, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt64Hdf5ArrayOfValues(self, values: "int64_t const *", numValues: "uint64_t const *", numDimensionsInArray: "unsigned int", proxy: "Eml2_AbstractHdfProxy", nullValue: "int64_t", minimumValue: "int64_t", maximumValue: "int64_t") -> "void":
        r"""
        Adds an nd array of explicit int 64 bits values to the property values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type values: int
        :param values:					All the property values to set ordered according the
            											topology of the representation it is based on.
        :param [in]:	  	numValues				The number of property values ordered by dimension of
            											the array to write.
        :type numDimensionsInArray: int
        :param numDimensionsInArray:	The number of dimensions in the array to write.
        :param [in,out]:	proxy					The HDF proxy where to write the property values. It
            											must be already opened for writing and won't be closed in
            											this method. If ``nullptr``, then a default HDF proxy must
            											be defined in the repository.
        :type nullValue: int
        :param nullValue:				The null value.
        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt64Hdf5ArrayOfValues(self, values, numValues, numDimensionsInArray, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt32Hdf5ArrayOfValues(self, values: "int const *", numValues: "uint64_t const *", numDimensionsInArray: "unsigned int", proxy: "Eml2_AbstractHdfProxy", nullValue: "int", minimumValue: "int", maximumValue: "int") -> "void":
        r"""
        Adds an nd array of explicit integer values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt32Hdf5ArrayOfValues(self, values, numValues, numDimensionsInArray, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt16Hdf5ArrayOfValues(self, values: "short const *", numValues: "uint64_t const *", numDimensionsInArray: "unsigned int", proxy: "Eml2_AbstractHdfProxy", nullValue: "short", minimumValue: "short", maximumValue: "short") -> "void":
        r"""
        Adds an nd array of explicit short values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt16Hdf5ArrayOfValues(self, values, numValues, numDimensionsInArray, proxy, nullValue, minimumValue, maximumValue)

    def pushBackUInt16Hdf5ArrayOfValues(self, values: "unsigned short const *", numValues: "uint64_t const *", numDimensionsInArray: "unsigned int", proxy: "Eml2_AbstractHdfProxy", nullValue: "unsigned short", minimumValue: "unsigned short", maximumValue: "unsigned short") -> "void":
        r"""
        Adds an nd array of explicit unsigned short values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackUInt16Hdf5ArrayOfValues(self, values, numValues, numDimensionsInArray, proxy, nullValue, minimumValue, maximumValue)

    def pushBackInt8Hdf5ArrayOfValues(self, values: "int8_t const *", numValues: "uint64_t const *", numDimensionsInArray: "unsigned int", proxy: "Eml2_AbstractHdfProxy", nullValue: "int8_t", minimumValue: "int8_t", maximumValue: "int8_t") -> "void":
        r"""
        Adds an nd array of explicit int8_t values to the property values.

        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackInt8Hdf5ArrayOfValues(self, values, numValues, numDimensionsInArray, proxy, nullValue, minimumValue, maximumValue)

    def pushBackHdf5ArrayOfValues(self, *args) -> "void":
        r"""
        *Overload 1:*

        Creates an nd array of explicit int 64 bits values into the property values. No values are
        written to this array yet then the HDF5 array contains uninitialized values.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:			The datatype of the values
        :param [in]:	  	numValues		  	The number of property values ordered by dimension of the
            										array to write. It is ordered from slowest dimension to
            										fastest dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :param [in]:	  	minimumValue	  	If non-nullptr, a pointer to the minimum values. If non-
            										nullptr, the count of minimum values is this property
            										count.
        :param [in]:	  	maximumValue	  	If non-nullptr, a pointer to the maximum values. If non-
            										nullptr, the count of maximum values is this property
            										count.
        :type nullValue: int, optional
        :param nullValue:		  	(Optional) The null value. Default value is int 64 bits
            										maximum value.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If ``nullptr`` (default), a
            										default HDF proxy must be defined into the data object
            										repository.

        |

        *Overload 2:*

        Create an nd array of values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:			The datatype of the values
        :type numValues: int
        :param numValues:		  	The number of property values ordered by dimension of the
            										array to write.  It is ordered from slowest dimension to
            										fastest dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If ``nullptr`` (default), a
            										default HDF proxy must be defined into the data object
            										repository.

        |

        *Overload 3:*

        Create an nd array of values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:			The datatype of the values
        :type numValues: int
        :param numValues:		  	The number of property values ordered by dimension of the
            										array to write.  It is ordered from slowest dimension to
            										fastest dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If ``nullptr`` (default), a
            										default HDF proxy must be defined into the data object
            										repository.

        |

        *Overload 4:*

        Create an nd array of values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:			The datatype of the values
        :type numValues: int
        :param numValues:		  	The number of property values ordered by dimension of the
            										array to write.  It is ordered from slowest dimension to
            										fastest dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If ``nullptr`` (default), a
            										default HDF proxy must be defined into the data object
            										repository.
        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackHdf5ArrayOfValues(self, *args)

    def pushBackHdf5Array1dOfValues(self, *args) -> "void":
        r"""
        *Overload 1:*

        Creates a 1d array of values into the property values. No values are written
        to this array yet then the HDF5 array contains uninitialized values.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:			The datatype of the values
        :type valueCount: int
        :param valueCount:			The count of values.
        :type minimumValue: int
        :param minimumValue:		  	The minimum value of the values in the HDF5 dataset.
        :type maximumValue: int
        :param maximumValue:		  	The maximum value of the values in the HDF5 dataset.
        :type nullValue: int, optional
        :param nullValue:			  	(Optional) The null value. Default value is int 64
            											bits maximum value.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.

        |

        *Overload 2:*

        Creates a 1d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCount: int
        :param valueCount:			The number of values to write).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and
            										won't be closed in this method. If ``nullptr``
            										(default), a default HDF proxy must be defined into
            										the data object repository.

        |

        *Overload 3:*

        Creates a 1d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCount: int
        :param valueCount:			The number of values to write).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and
            										won't be closed in this method. If ``nullptr``
            										(default), a default HDF proxy must be defined into
            										the data object repository.

        |

        *Overload 4:*

        Creates a 1d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCount: int
        :param valueCount:			The number of values to write).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and
            										won't be closed in this method. If ``nullptr``
            										(default), a default HDF proxy must be defined into
            										the data object repository.
        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackHdf5Array1dOfValues(self, *args)

    def pushBackHdf5Array2dOfValues(self, *args) -> "void":
        r"""
        *Overload 1:*

        Creates a 2d array of explicit int 64 values into the property values. No values are written
        to this array yet then the HDF5 array contains uninitialized values.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:			The datatype of the values
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values in the fastest dimension (mainly
            											I dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values in the slowest dimension (mainly
            											K dimension).
        :type minimumValue: int
        :param minimumValue:		  	The minimum value of the values in the HDF5 dataset.
        :type maximumValue: int
        :param maximumValue:		  	The maximum value of the values in the HDF5 dataset.
        :type nullValue: int, optional
        :param nullValue:			  	(Optional) The null value. Default value is int 64
            											bits maximum value.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.

        |

        *Overload 2:*

        Creates a 2d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy					(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.

        |

        *Overload 3:*

        Creates a 2d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy					(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.

        |

        *Overload 4:*

        Creates a 2d array of explicit double values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy					(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.
        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackHdf5Array2dOfValues(self, *args)

    def pushBackHdf5Array3dOfValues(self, *args) -> "void":
        r"""
        *Overload 1:*

        Creates a 3d array of explicit int 64 values into the property values. No values are written
        to this array yet then the HDF5 array contains uninitialized values.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:			The datatype of the values
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values in the fastest dimension (mainly
            											I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values in the middle dimension (mainly
            											J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values in the slowest dimension (mainly
            											K dimension).
        :type minimumValue: int
        :param minimumValue:		  	The minimum value of the values in the HDF5 dataset.
        :type maximumValue: int
        :param maximumValue:		  	The maximum value of the values in the HDF5 dataset.
        :type nullValue: int, optional
        :param nullValue:			  	(Optional) The null value. Default value is int 64
            											bits maximum value.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.

        |

        *Overload 2:*

        Creates a 3d array of explicit float values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:				The datatype of the values
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.

        |

        *Overload 3:*

        Creates a 3d array of explicit float values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:				The datatype of the values
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.

        |

        *Overload 4:*

        Creates a 3d array of explicit float values to the property values. No values are written to
        this array yet then the HDF5 array contains uninitialized values.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.

        :type datatype: int
        :param datatype:				The datatype of the values
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :param nullvalue:			The integer null value in case we create an integer array.
            										It is ignored if the ``datatype`` is a floating point one.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.
        """
        return _fesapi.Resqml2_DiscreteProperty_pushBackHdf5Array3dOfValues(self, *args)

    def setValuesOfInt64Hdf5Array3dOfValues(self, *args) -> "void":
        r"""
        Adds a 3d array of explicit int 64 bits values into the property values. Since this methods
        only pushes back values into an existing array, it is to be used along with
        pushBackInt64Hdf5Array3dOfValues().

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined into the data object repository.
        :raises: std::out_of_range	 	If ``patchIndex`` is strictly greater than patch count and
            										different from unsigned int maximum value.

        :param [in]:	  	values				  	All the property values to set ordered according to
            											the topology of the representation it is based on.
        :type valueCountInFastestDim: int
        :param valueCountInFastestDim:	The number of values to write in the fastest
            											dimension (mainly I dimension).
        :type valueCountInMiddleDim: int
        :param valueCountInMiddleDim: 	The number of values to write in the middle dimension
            											(mainly J dimension).
        :type valueCountInSlowestDim: int
        :param valueCountInSlowestDim:	The number of values to write in the slowest
            											dimension (mainly K dimension).
        :type offsetInFastestDim: int
        :param offsetInFastestDim:	  	The offset value for writing in the fastest dimension
            											(mainly I dimension).
        :type offsetInMiddleDim: int
        :param offsetInMiddleDim:	  	The offset value for writing in the middle dimension
            											(mainly J dimension).
        :type offsetInSlowestDim: int
        :param offsetInSlowestDim:	  	The offset value for writing in the slowest dimension
            											(mainly K dimension).
        :type computeMinMax: boolean
        :param computeMinMax:		  	True if FESAPI needs to compute the min and  max from
            											the given ``values`` in order to set them.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											values. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default), a default HDF proxy must be defined into
            											the data object repository.
        :type patchIndex: int, optional
        :param patchIndex:			  	(Optional) Zero-based index of the patch where to
            											write the property values. If not provided, its
            											default value is by convention set to unsigned int
            											maximum value and the property values will be written
            											in the last property values patch (the one with the
            											greatest index).
        """
        return _fesapi.Resqml2_DiscreteProperty_setValuesOfInt64Hdf5Array3dOfValues(self, *args)

    def setValuesOfInt32Hdf5Array3dOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_DiscreteProperty_setValuesOfInt32Hdf5Array3dOfValues(self, *args)

    def setValuesOfInt64Hdf5ArrayOfValues(self, *args) -> "void":
        r"""
        Adds an nd array of explicit int 64 bits values into to the property values. Since this
        methods only pushes back values into an existing array, it is to be used along with
        pushBackInt64Hdf5ArrayOfValues().

        :raises: std::invalid_argument	If ``proxy`` is null and no default HDF proxy is defined
            										into the data object repository.
        :raises: std::out_of_range	 	If ``patchIndex`` is strictly greater than patch count and
            										different from unsigned int maximum value.

        :param [in]:	  	values			  	All the property values to set ordered according to the
            										topology of the representation it is based on.
        :type numValues: int
        :param numValues:		  	The number of property values ordered by dimension of the
            										array to write. It is ordered from slowest dimension to
            										fastest dimension.
        :type offsetValues: int
        :param offsetValues:	  	The offset values ordered by dimension of the array to
            										write. It is ordered from slowest dimension to fastest
            										dimension.
        :type numArrayDimensions: int
        :param numArrayDimensions:	The number of dimensions of the array to write.
        :type computeMinMax: boolean
        :param computeMinMax:	  	True to compute and to set minimum and maximum values.
        :param [in,out]:	proxy			  	(Optional) The HDF proxy where to write the property
            										values. It must be already opened for writing and won't
            										be closed in this method. If null (default value), a
            										default HDF proxy must be defined into the data object
            										repository.
        :type patchIndex: int, optional
        :param patchIndex:		  	(Optional) Zero-based index of the patch where to write
            										the property values. If not provided, its default value
            										is by convention set to unsigned int maximum value and
            										the property values will be written in the last property
            										values patch (the one with the greatest index).
        """
        return _fesapi.Resqml2_DiscreteProperty_setValuesOfInt64Hdf5ArrayOfValues(self, *args)

    def setValuesOfInt32Hdf5ArrayOfValues(self, *args) -> "void":
        return _fesapi.Resqml2_DiscreteProperty_setValuesOfInt32Hdf5ArrayOfValues(self, *args)

    def hasMinimumValue(self, index: "uint64_t"=0) -> "bool":
        r"""
        Checks if a non vector property or a given value of a vector property has got a
        			minimum value already computed (or set).

        :type index: int, optional
        :param index:	(Optional) ``0`` (default value, corresponding to the non vector property
            					case) or zero-based index of the vector value for which we want to know if a
            					minimum value exists (vector property case).

        :rtype: boolean
        :return: True if there exists a minimum value, false if not.
        """
        return _fesapi.Resqml2_DiscreteProperty_hasMinimumValue(self, index)

    def getMinimumValue(self, index: "uint64_t"=0) -> "int64_t":
        r"""
        Gets the minimum value of a non vector property or the minimum value of one given
        			value of a vector property. This minimum value is read (it is not computed).

        :raises: std::logic_error	If this property has no minimum value.

        :type index: int, optional
        :param index:	(Optional) ``0`` (default value, corresponding to the non vector property
            					case) or zero-based index of the vector value for which we look for the
            					minimum value (vector property case).

        :rtype: int
        :return: The minimum value of the non vector property or the minimum value at position
            ``index`` of the vector value or ``NaN`` if ``index`` is out of range (strictly greater
            			than ``0`` for a non vector property or greater than the vector size for a vector
            			property).
        """
        return _fesapi.Resqml2_DiscreteProperty_getMinimumValue(self, index)

    def hasMaximumValue(self, index: "uint64_t"=0) -> "bool":
        r"""
        Checks if a non vector property or a given value of a vector property has got a
        			maximum value already computed (or set).

        :type index: int, optional
        :param index:	(Optional) ``0`` (default value, corresponding to the non vector property
            					case) or zero-based index of the vector value for which we want to know if a
            					maximum value exists (vector property case).

        :rtype: boolean
        :return: True if there exists a maximum value, false if not.
        """
        return _fesapi.Resqml2_DiscreteProperty_hasMaximumValue(self, index)

    def getMaximumValue(self, index: "uint64_t"=0) -> "int64_t":
        r"""
        Gets the maximum value of a non vector property or the maximum value of one given
        			value of a vector property. This maximum value is read (it is not computed).

        :raises: std::logic_error	If this property has no maximum value.

        :type index: int, optional
        :param index:	(Optional) ``0`` (default value, corresponding to the non vector property
            					case) or zero-based index of the vector value for which we look for the
            					maximum value (vector property case).

        :rtype: int
        :return: The maximum value of the non vector property or the maximum value at position
            ``index`` of the vector value or ``NaN`` if ``index`` is out of range (strictly greater
            			than ``0`` for a non vector property or greater than the vector size for a vector
            			property).
        """
        return _fesapi.Resqml2_DiscreteProperty_getMaximumValue(self, index)

    def setMinimumValue(self, value: "int64_t", index: "uint64_t"=0) -> "void":
        r"""
        Sets the minimum value of a non vector property or the minimum value of one given
        			value of a vector property.

        :type value: int
        :param value:	The minimum value to set.
        :type index: int, optional
        :param index:	(Optional)  ``0`` (default value, corresponding to the non vector property
            					case) or zero-based index of the vector value for which we want to set the
            					minimum value (vector property case).
        """
        return _fesapi.Resqml2_DiscreteProperty_setMinimumValue(self, value, index)

    def setMaximumValue(self, value: "int64_t", index: "uint64_t"=0) -> "void":
        r"""
        Sets the maximum value of a non vector property or the maximum value of one given
        			value of a vector property.

        :type value: int
        :param value:	The maximum value to set.
        :type index: int, optional
        :param index:	(Optional)  ``0`` (default value, corresponding to the non vector property
            					case) or zero-based index of the vector value for which we want to set the
            					maximum value (vector property case).
        """
        return _fesapi.Resqml2_DiscreteProperty_setMaximumValue(self, value, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_DiscreteProperty

# Register Resqml2_DiscreteProperty in _fesapi:
_fesapi.Resqml2_DiscreteProperty_swigregister(Resqml2_DiscreteProperty)
class Resqml2_DoubleTableLookup(AbstractObject):
    r"""
    Defines a function for table lookups. For example, used for linear interpolation, such as PVT.

    			Used for categorical properties, which also may use a double table lookup.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def containsKey(self, key: "double") -> "bool":
        r"""
        Checks whether a key is contained within this double table lookup.

        :type key: float
        :param key:	A key.

        :rtype: boolean
        :return: True if ``key`` is a key of this double table lookup, false if not.
        """
        return _fesapi.Resqml2_DoubleTableLookup_containsKey(self, key)

    def getItemCount(self) -> "uint64_t":
        r"""
        Gets the count of items in the double table lookup (in its map).

        :rtype: int
        :return: The count of items.
        """
        return _fesapi.Resqml2_DoubleTableLookup_getItemCount(self)

    def getKeyAtIndex(self, index: "uint64_t") -> "double":
        r"""
        Gets the key of a key/value pair at a particular index of this double table lookup (in its
        map).

        :raises: std::out_of_range	If index >= getItemCount().

        :type index: int
        :param index:	Zero-based index of the key/value pair.

        :rtype: float
        :return: The key of the key/value pair at position ``index``.
        """
        return _fesapi.Resqml2_DoubleTableLookup_getKeyAtIndex(self, index)

    def getValueAtIndex(self, index: "uint64_t") -> "double":
        r"""
        Gets the value of a key/value pair at a particular index of this double table lookup
        (in its map).

        :raises: std::out_of_range	If index >= getItemCount().

        :type index: int
        :param index:	Zero-based index of the key/value pair.

        :rtype: float
        :return: The value of the key/value pair at position ``index``.
        """
        return _fesapi.Resqml2_DoubleTableLookup_getValueAtIndex(self, index)

    def getValueAtKey(self, key: "double") -> "double":
        r"""
        Gets a value from its associated key.

        :param longValue:	A key.

        :rtype: float
        :return: The value corresponding to the key ``longValue`` if it exists, NaN if
            			not.
        """
        return _fesapi.Resqml2_DoubleTableLookup_getValueAtKey(self, key)

    def addValue(self, key: "double", longValue: "double") -> "void":
        r"""
        Adds a key/value pair to this double table lookup. No verification that the key already exists is done.

        :type key: float
        :param key:		A key.
        :param value:	Teh associated value.
        """
        return _fesapi.Resqml2_DoubleTableLookup_addValue(self, key, longValue)

    def setValue(self, key: "double", longValue: "double") -> "void":
        r"""
        Modifies the value associated to a key. If the key does not exist, nothing is
        done.

        :type key: float
        :param key:		A key.
        :param value:	Teh associated value.
        """
        return _fesapi.Resqml2_DoubleTableLookup_setValue(self, key, longValue)

    def getMinimumValue(self) -> "double":
        r"""
        Gets the minimum key in this double table lookup. It reads it from file.

        :rtype: float
        :return: The minimum key if some key/value pairs exists in this double table lookup, otherwise
            			the double maximum value.
        """
        return _fesapi.Resqml2_DoubleTableLookup_getMinimumValue(self)

    def getMaximumValue(self) -> "double":
        r"""
        Gets the maximum key in this double table lookup. It reads it from file.

        :rtype: float
        :return: The maximum key if some key/value pairs exists in this double table lookup, otherwise
            			the double lowest value.
        """
        return _fesapi.Resqml2_DoubleTableLookup_getMaximumValue(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_DoubleTableLookup

# Register Resqml2_DoubleTableLookup in _fesapi:
_fesapi.Resqml2_DoubleTableLookup_swigregister(Resqml2_DoubleTableLookup)
class Resqml2_StringTableLookup(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def containsKey(self, key: "int64_t") -> "bool":
        r"""
        Checks whether a key is contained within this string lookup.

        :type key: int
        :param key:	A key.

        :rtype: boolean
        :return: True if ``longValue`` is a key of this string table lookup, false if not.
        """
        return _fesapi.Resqml2_StringTableLookup_containsKey(self, key)

    def getItemCount(self) -> "uint64_t":
        r"""
        Gets the count of items in the string table lookup (in its map).

        :rtype: int
        :return: The count of items.
        """
        return _fesapi.Resqml2_StringTableLookup_getItemCount(self)

    def getKeyAtIndex(self, index: "uint64_t") -> "int64_t":
        r"""
        Gets the key of a key/value pair at a particular index of this string table lookup (in its
        map).

        :raises: std::out_of_range	If index >= getItemCount().

        :type index: int
        :param index:	Zero-based index of the key/value pair.

        :rtype: int
        :return: The key of the key/value pair at position ``index``.
        """
        return _fesapi.Resqml2_StringTableLookup_getKeyAtIndex(self, index)

    def getStringValueAtIndex(self, index: "uint64_t") -> "std::string":
        r"""
        Gets the string value of a key/value pair at a particular index of this string table lookup
        (in its map).

        :raises: std::out_of_range	If index >= getItemCount().

        :type index: int
        :param index:	Zero-based index of the key/value pair.

        :rtype: string
        :return: The string value of the key/value pair at position ``index``.
        """
        return _fesapi.Resqml2_StringTableLookup_getStringValueAtIndex(self, index)

    def getStringValue(self, key: "int64_t") -> "std::string":
        r"""
        Gets a string value from its associated key.

        :type key: int
        :param key:	A key.

        :rtype: string
        :return: The string value corresponding to the key ``longValue`` if it exists, empty string if
            			not.
        """
        return _fesapi.Resqml2_StringTableLookup_getStringValue(self, key)

    def addValue(self, strValue: "std::string const &", key: "int64_t") -> "void":
        r"""
        Adds a key/value pair to this string table lookup. No verification that the key (or string
        value) already exists is done.

        :type strValue: string
        :param strValue: 	A string value.
        :param longValue:	A key.
        """
        return _fesapi.Resqml2_StringTableLookup_addValue(self, strValue, key)

    def setValue(self, strValue: "std::string const &", key: "int64_t") -> "void":
        r"""
        Modifies the string value associated to a key. If the key does not exist, nothing is
        done.

        :type strValue: string
        :param strValue: 	The new string value.
        :param longValue:	A key.
        """
        return _fesapi.Resqml2_StringTableLookup_setValue(self, strValue, key)

    def getMinimumValue(self) -> "int64_t":
        r"""
        Gets the minimum key in this string table lookup. It reads it from file.

        :rtype: int
        :return: The minimum key if some key/value pairs exists in this string table lookup, otherwise
            			the int64_t maximum value.
        """
        return _fesapi.Resqml2_StringTableLookup_getMinimumValue(self)

    def getMaximumValue(self) -> "int64_t":
        r"""
        Gets the maximum key in this string table lookup. It reads it from file.

        :rtype: int
        :return: The maximum key if some key/value pairs exists in this string table lookup, otherwise
            			the int64_t minimum value.
        """
        return _fesapi.Resqml2_StringTableLookup_getMaximumValue(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_StringTableLookup

# Register Resqml2_StringTableLookup in _fesapi:
_fesapi.Resqml2_StringTableLookup_swigregister(Resqml2_StringTableLookup)
class Resqml2_CategoricalProperty(Resqml2_AbstractValuesProperty):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getDoubleLookup(self) -> "resqml2::DoubleTableLookup *":
        return _fesapi.Resqml2_CategoricalProperty_getDoubleLookup(self)

    def getStringLookup(self) -> "resqml2::StringTableLookup *":
        return _fesapi.Resqml2_CategoricalProperty_getStringLookup(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_CategoricalProperty

# Register Resqml2_CategoricalProperty in _fesapi:
_fesapi.Resqml2_CategoricalProperty_swigregister(Resqml2_CategoricalProperty)
class Resqml2_PointsProperty(Resqml2_AbstractProperty):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getXyzPointCountOfPatch(self, patchIndex: "unsigned int") -> "uint64_t":
        r"""
        Get the xyz point count in a given patch of this property.

        :raises: std::out_of_range	If ``patchIndex`` is out of range.
        :raises: std::logic_error 	If this representation is partial.

        :type patchIndex: int
        :param patchIndex:	Zero-based index of the patch from which we look for the xyz points.

        :rtype: int
        :return: The xyz point count of the patch at position ``patchIndex``.
        """
        return _fesapi.Resqml2_PointsProperty_getXyzPointCountOfPatch(self, patchIndex)

    def getXyzPointCountOfAllPatches(self) -> "uint64_t":
        r"""
        Get the xyz point count of all patches of this property.

        :rtype: int
        :return: The xyz point count of all patches.
        """
        return _fesapi.Resqml2_PointsProperty_getXyzPointCountOfAllPatches(self)

    def getXyzPointsOfPatch(self, patchIndex: "unsigned int", xyzPoints: "double *") -> "void":
        r"""
        Gets all the xyz points of a particular patch of this property. xyz points are
        			given in the local CRS.

        :raises: std::out_of_range	If ``patchIndex`` is out of range.
        :raises: std::logic_error 	If this property is partial.

        :type patchIndex: int
        :param patchIndex:	Zero-based index of the patch from which we look for the xyz points.
        :param [out]:	xyzPoints 	A linearized 2d array where the first (quickest) dimension is the
            							coordinate dimension (x, y or z) and second dimension is vertex
            							dimension. It must be preallocated with a size of 3 *
            							getXyzPointCountOfPatch(patchIndex).
        """
        return _fesapi.Resqml2_PointsProperty_getXyzPointsOfPatch(self, patchIndex, xyzPoints)

    def getXyzPointsOfPatchInGlobalCrs(self, patchIndex: "unsigned int", xyzPoints: "double *") -> "void":
        r"""
        Gets all the xyz points of a particular patch of this property. xyz points are given in
        the global CRS.

        :raises: std::out_of_range	If ``patchIndex`` is out of range.

        :type patchIndex: int
        :param patchIndex:	Zero-based index of the patch from which we look for the xyz points.
        :param [out]:	xyzPoints 	A linearized 2d array where the first (quickest) dimension is the
            							coordinate dimension (x, y or z) and second dimension is vertex
            							dimension. It must be preallocated with a size of 3 *
            							getXyzPointCountOfPatch(patchIndex).
        """
        return _fesapi.Resqml2_PointsProperty_getXyzPointsOfPatchInGlobalCrs(self, patchIndex, xyzPoints)

    def getXyzPointsOfAllPatches(self, xyzPoints: "double *") -> "void":
        r"""
        Gets all the xyz points of all patches of this property. xyz points are given in the
        local CRS.

        :param [out]:	xyzPoints	A linearized 2d array where the first (quickest) dimension is the
            							coordinate dimension (x, y or z) and second dimension is vertex
            							dimension. It must be preallocated with a size of 3 *
            							getXyzPointCountOfAllPatches().
        """
        return _fesapi.Resqml2_PointsProperty_getXyzPointsOfAllPatches(self, xyzPoints)

    def getXyzPointsOfAllPatchesInGlobalCrs(self, xyzPoints: "double *") -> "void":
        r"""
        Gets all the xyz points of all patches of this property. xyz points are
        given in the global CRS.

        :param [out]:	xyzPoints	A linearized 2d array where the first (quickest) dimension is the
            							coordinate dimension (x, y or Z) and second dimension is vertex
            							dimension. Thus, its size is 3*(3*[count of all xyz points]). It must
            							be preallocated.
        """
        return _fesapi.Resqml2_PointsProperty_getXyzPointsOfAllPatchesInGlobalCrs(self, xyzPoints)

    def pushBackArray1dOfXyzPoints(self, xyzPoints: "double const *", pointCount: "uint64_t", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 1d array of points (in local CRS) to the property.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type xyzPoints: float
        :param xyzPoints:		All the property values to set ordered according the topology
            									of the representation it is based on.
        :type pointCount: int
        :param pointCount:  	The number of points to write.
        :param [in,out]:	proxy			(Optional) The HDF proxy where to write the property points.
            									It must be already opened for writing and won't be closed in this
            									method. If ``nullptr`` (default value), then a default HDF proxy
            									must be defined in the repository.
        """
        return _fesapi.Resqml2_PointsProperty_pushBackArray1dOfXyzPoints(self, xyzPoints, pointCount, proxy)

    def pushBackArray2dOfXyzPoints(self, xyzPoints: "double const *", pointCountInFastestDim: "uint64_t", pointCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 2d array of points (in local CRS) to the property.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type xyzPoints: float
        :param xyzPoints:				All the property values to set ordered according the
            											topology of the representation it is based on.
        :type pointCountInFastestDim: int
        :param pointCountInFastestDim:	The number of points to write in the fastest
            											dimension (mainly I dimension).
        :type pointCountInSlowestDim: int
        :param pointCountInSlowestDim:	The number of points to write in the slowest
            											dimension (mainly J dimension).
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											points. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default value), then a default HDF proxy must be
            											defined in the repository.
        """
        return _fesapi.Resqml2_PointsProperty_pushBackArray2dOfXyzPoints(self, xyzPoints, pointCountInFastestDim, pointCountInSlowestDim, proxy)

    def pushBackArray3dOfXyzPoints(self, xyzPoints: "double const *", pointCountInFastestDim: "uint64_t", pointCountInMiddleDim: "uint64_t", pointCountInSlowestDim: "uint64_t", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds a 3d array of points (in local CRS) to the property.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type xyzPoints: float
        :param xyzPoints:				All the property values to set ordered according the
            											topology of the representation it is based on.
        :type pointCountInFastestDim: int
        :param pointCountInFastestDim:	The number of points to write in the fastest
            											dimension (mainly I dimension).
        :type pointCountInMiddleDim: int
        :param pointCountInMiddleDim: 	The number of points to write in the middle dimension
            											(mainly J dimension).
        :type pointCountInSlowestDim: int
        :param pointCountInSlowestDim:	The number of points to write in the slowest
            											dimension (mainly K dimension).
        :param [in,out]:	proxy				  	(Optional) The HDF proxy where to write the property
            											points. It must be already opened for writing and
            											won't be closed in this method. If ``nullptr``
            											(default value), then a default HDF proxy must be
            											defined in the repository.
        """
        return _fesapi.Resqml2_PointsProperty_pushBackArray3dOfXyzPoints(self, xyzPoints, pointCountInFastestDim, pointCountInMiddleDim, pointCountInSlowestDim, proxy)

    def pushBackArrayOfXyzPoints(self, xyzPoints: "double const *", pointCountByDimension: "uint64_t const *", numArrayDimensions: "uint32_t", proxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Adds an nd array of points (in local CRS) to the property.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type xyzPoints: float
        :param xyzPoints:				All the property values to set ordered according the
            											topology of the representation it is based on.
        :type pointCountByDimension: int
        :param pointCountByDimension:	The number of property points ordered by dimension of the
            											array to write.
        :type numArrayDimensions: int
        :param numArrayDimensions:		The number of dimensions of the array to write.
        :param [in,out]:	proxy			  		(Optional) The HDF proxy where to write the property
            											points. It must be already opened for writing and won't
            											be closed in this method. If ``nullptr`` (default value),
            											then a default HDF proxy must be defined in the
            											repository.
        """
        return _fesapi.Resqml2_PointsProperty_pushBackArrayOfXyzPoints(self, xyzPoints, pointCountByDimension, numArrayDimensions, proxy)

    def pushBackRefToExistingDataset(self, *args) -> "std::string":
        r"""
        Pushes back a reference to an existing (or a "to exist") HDF dataset in a particular HDF
        proxy. The reason can be that the values already exist in an external file (only HDF5 for
        now) or that the writing of the values in the external file is differed in time.

        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :param [in]:	proxy	   	The HDF5 proxy where the values are already or will be stored. If
            							``nullptr``, then a default HDF proxy must be defined in the
            							repository.
        :type datasetName: string, optional
        :param datasetName:	(Optional) The HDF5 dataset name where the values are stored. If
            							empty, the dataset will be named the same as the dataset naming
            							convention of fesapi :
            							getHdfGroup() + "/points_patch" + patchIndex

        :rtype: string
        :return: The name of the referenced HDF5 dataset.
        """
        return _fesapi.Resqml2_PointsProperty_pushBackRefToExistingDataset(self, *args)
    __swig_destroy__ = _fesapi.delete_Resqml2_PointsProperty

# Register Resqml2_PointsProperty in _fesapi:
_fesapi.Resqml2_PointsProperty_swigregister(Resqml2_PointsProperty)
class Resqml2_WellboreTrajectoryRepresentation(Resqml2_AbstractRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getWellboreFrameRepresentationCount(self) -> "uint64_t":
        r"""
        Gets the count of wellbore frame representations which are associated with this wellbore
        trajectory.

        :rtype: int
        :return: The count of associated wellbore frame representations.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_getWellboreFrameRepresentationCount(self)

    def getWellboreFrameRepresentation(self, index: "uint64_t") -> "resqml2::WellboreFrameRepresentation *":
        r"""
        Gets a particular wellbore frame representation of this wellbore trajectory representation
        according to its position in the repository.

        :raises: std::out_of_range If index >= getWellboreFrameRepresentationCount().

        :rtype: :py:class:`WellboreFrameRepresentation`
        :return: The associated wellbore frame representation at position ``index``.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_getWellboreFrameRepresentation(self, index)

    def setMinimalGeometry(self, startMd: "double", endMd: "double") -> "void":
        r"""
        Sets the minimal geometry of the representation by means of start and end MDs.

        :type startMd: float
        :param startMd:	The start MD of the trajectory. Uom is the same as the one for the associated
            					MdDatum coordinates.
        :type endMd: float
        :param endMd:  	The end MD of the trajectory. Uom is the same as the one for the associated
            					MdDatum coordinates.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_setMinimalGeometry(self, startMd, endMd)

    def setGeometry(self, *args) -> "void":
        r"""
        *Overload 1:*

        Sets the geometry of the representation by means of a parametric line without MD information
        (only start and end MDs).

        :raises: std::invalid_argument	If ``controlPoints`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointCount`` is 0.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If ``localCrs`` is ``nullptr`` and no default CRS is
            										defined in the repository.

        :param [in]:	  	controlPoints	 	All the control points of the cubic parametric line in
            										the order of the MDs. Count is controlPointCount *
            										3 and for each control point (x,y,z) =
            										(controlPoints[2i], controlPoints[2i+1],
            										controlPoints[2i+2]).
        :type startMd: float
        :param startMd:			 	The start MD of the trajectory.
        :type endMd: float
        :param endMd:			 	The end MD of the trajectory.
        :type controlPointCount: int
        :param controlPointCount:	The count of control points and control point parameters
            										per cubic parametric line.
        :type lineKind: int
        :param lineKind:		 	Integer indicating the parametric line kind: 0 for
            										vertical, 1 for linear spline, 2 for natural cubic spline,
            										3 for cubic spline, 4 for z linear cubic spline, 5 for
            										minimum-curvature spline, (-1) for null: no line.
        :param [in,out]:	proxy			 	(Optional) The HDF proxy which indicates in which HDF5
            										file the control points and its parameters will be
            										stored. It must be already opened for writing and won't
            										be closed. If null, then the default HDF Proxy of the
            										data object repository will be arbitrarily selected for
            										writing.
        :param [in]:	  	localCrs		 	(Optional) The local CRS where the control points are
            										given. If ``nullptr`` (default), then the default Local
            										CRS of the data object repository will be arbitrarily
            										selected.

        |

        *Overload 2:*

        Sets the geometry of the representation by means of a parametric line with MD information.

        :raises: std::invalid_argument	If ``controlPoints`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointParameters`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointCount`` is 0.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If ``localCrs`` is ``nullptr`` and no default CRS is
            										defined in the repository.

        :param [in]:	  	controlPoints		  	All the control points of the cubic parametric line
            											in the order of the MDs. Count is
            											controlPointCount * 3 and for each control
            											point (x,y, z) = (controlPoints[2i],
            											controlPoints[2i+1], controlPoints[2i+2]).
        :param [in]:	  	controlPointParameters	The arrays of control point parameters (ordered
            											regarding the control points). It corresponds to the
            											MD values in a WellboreFeature context. Count is
            ``controlPointCount``.
        :type controlPointCount: int
        :param controlPointCount:	  	The count of control points and control point
            											parameters per cubic parametric line.
        :type lineKind: int
        :param lineKind:			  	Integer indicating the parametric line kind: 0 for
            											vertical, 1 for linear spline, 2 for natural cubic
            											spline, 3 for cubic spline, 4 for z linear cubic
            											spline, 5 for minimum-curvature spline, (-1) for
            											null: no line.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy which indicates in which
            											HDF5 file the control points and its parameters will
            											be stored. It must be already opened for writing and
            											won't be closed. If null, then the default HDF Proxy
            											of the DataObject repository will be arbitrarily
            											selected for writing.
        :param [in]:	  	localCrs			  	(Optional) The local CRS where the control points are
            											given. If ``nullptr`` (default), then the default
            											Local CRS of the DataObject repository will be
            											arbitrarily selected.

        |

        *Overload 3:*

        Sets the geometry of the representation by means of a parametric line with MD information.

        :raises: std::invalid_argument	If ``controlPoints`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointParameters`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointCount`` is 0.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If ``localCrs`` is ``nullptr`` and no default CRS is
            										defined in the repository.

        :param [in]:	  	controlPoints		  	All the control points of the cubic parametric line
            											in the order of the MDs. Count is
            											controlPointCount * 3 and for each control
            											point (x,y, z) = (controlPoints[2i],
            											controlPoints[2i+1], controlPoints[2i+2]).
        :param [in]:	  	controlPointParameters	The arrays of control point parameters (ordered
            											regarding the control points). It corresponds to the
            											MD values in a WellboreFeature context. Count is
            ``controlPointCount``.
        :type controlPointCount: int
        :param controlPointCount:	  	The count of control points and control point
            											parameters per cubic parametric line.
        :type lineKind: int
        :param lineKind:			  	Integer indicating the parametric line kind: 0 for
            											vertical, 1 for linear spline, 2 for natural cubic
            											spline, 3 for cubic spline, 4 for z linear cubic
            											spline, 5 for minimum-curvature spline, (-1) for
            											null: no line.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy which indicates in which
            											HDF5 file the control points and its parameters will
            											be stored. It must be already opened for writing and
            											won't be closed. If null, then the default HDF Proxy
            											of the DataObject repository will be arbitrarily
            											selected for writing.
        :param [in]:	  	localCrs			  	(Optional) The local CRS where the control points are
            											given. If ``nullptr`` (default), then the default
            											Local CRS of the DataObject repository will be
            											arbitrarily selected.

        |

        *Overload 4:*

        Sets the geometry of the representation by means of a parametric line with MD information.

        :raises: std::invalid_argument	If ``controlPoints`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointParameters`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointCount`` is 0.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If ``localCrs`` is ``nullptr`` and no default CRS is
            										defined in the repository.

        :param [in]:	  	controlPoints		  	All the control points of the cubic parametric line
            											in the order of the MDs. Count is
            											controlPointCount * 3 and for each control
            											point (x,y, z) = (controlPoints[2i],
            											controlPoints[2i+1], controlPoints[2i+2]).
        :param [in]:	  	controlPointParameters	The arrays of control point parameters (ordered
            											regarding the control points). It corresponds to the
            											MD values in a WellboreFeature context. Count is
            ``controlPointCount``.
        :type controlPointCount: int
        :param controlPointCount:	  	The count of control points and control point
            											parameters per cubic parametric line.
        :type lineKind: int
        :param lineKind:			  	Integer indicating the parametric line kind: 0 for
            											vertical, 1 for linear spline, 2 for natural cubic
            											spline, 3 for cubic spline, 4 for z linear cubic
            											spline, 5 for minimum-curvature spline, (-1) for
            											null: no line.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy which indicates in which
            											HDF5 file the control points and its parameters will
            											be stored. It must be already opened for writing and
            											won't be closed. If null, then the default HDF Proxy
            											of the DataObject repository will be arbitrarily
            											selected for writing.
        :param [in]:	  	localCrs			  	(Optional) The local CRS where the control points are
            											given. If ``nullptr`` (default), then the default
            											Local CRS of the DataObject repository will be
            											arbitrarily selected.

        |

        *Overload 5:*

        Sets the geometry of the representation by means of a parametric line with MD and tangent
        vector information.

        :raises: std::invalid_argument	If ``controlPoints`` is ``nullptr``.
        :raises: std::invalid_argument	If ``tangentVectors`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointParameters`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointCount`` is 0.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If ``localCrs`` is ``nullptr`` and no default CRS is
            										defined in the repository.

        :param [in]:	  	controlPoints		  	All the control points of the cubic parametric line
            											in the ascending order of the MDs. Count is
            											controlPointCount * 3 and for each control
            											point (x,y, z) = (controlPoints[2i],
            											controlPoints[2i+1], controlPoints[2i+2]).
        :param [in]:	  	tangentVectors		  	All the tangent vectors of all the control points of
            											all the cubic parametric lines. They are ordered
            											according to the control points. Count is
            											controlPointCount * 3 and for each tangent
            											vector (u,v, w) = (tangentVectors[2i],
            											tangentVectors[2i+1], tangentVectors[2i+2]).
        :param [in]:	  	controlPointParameters	The arrays of control point parameters (ordered
            											regarding the control points). It corresponds to the
            											MD values in this context. Count is ``controlPointCount``.
        :type controlPointCount: int
        :param controlPointCount:	  	The count of control points and control point
            											parameters and tangent vectors per cubic parametric
            											line.
        :type lineKind: int
        :param lineKind:			  	Integer indicating the parametric line kind: 0 for
            											vertical, 1 for linear spline, 2 for natural cubic
            											spline, 3 for cubic spline, 4 for z linear cubic
            											spline, 5 for minimum-curvature spline, (-1) for
            											null: no line.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy which indicates in which
            											HDF5 file the parameters and the tangent vectors will
            											be stored. It must be already opened for writing and
            											won't be closed. If null, then the default HDF Proxy
            											of the DataObject repository will be arbitrarily
            											selected for writing.
        :param [in]:	  	localCrs			  	(Optional) The local CRS where the control points are
            											given. If ``nullptr``, then the default Local CRS of
            											the DataObject repository will be arbitrarily
            											selected.

        |

        *Overload 6:*

        Sets the geometry of the representation by means of a parametric line with MD and tangent
        vector information.

        :raises: std::invalid_argument	If ``controlPoints`` is ``nullptr``.
        :raises: std::invalid_argument	If ``tangentVectors`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointParameters`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointCount`` is 0.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If ``localCrs`` is ``nullptr`` and no default CRS is
            										defined in the repository.

        :param [in]:	  	controlPoints		  	All the control points of the cubic parametric line
            											in the ascending order of the MDs. Count is
            											controlPointCount * 3 and for each control
            											point (x,y, z) = (controlPoints[2i],
            											controlPoints[2i+1], controlPoints[2i+2]).
        :param [in]:	  	tangentVectors		  	All the tangent vectors of all the control points of
            											all the cubic parametric lines. They are ordered
            											according to the control points. Count is
            											controlPointCount * 3 and for each tangent
            											vector (u,v, w) = (tangentVectors[2i],
            											tangentVectors[2i+1], tangentVectors[2i+2]).
        :param [in]:	  	controlPointParameters	The arrays of control point parameters (ordered
            											regarding the control points). It corresponds to the
            											MD values in this context. Count is ``controlPointCount``.
        :type controlPointCount: int
        :param controlPointCount:	  	The count of control points and control point
            											parameters and tangent vectors per cubic parametric
            											line.
        :type lineKind: int
        :param lineKind:			  	Integer indicating the parametric line kind: 0 for
            											vertical, 1 for linear spline, 2 for natural cubic
            											spline, 3 for cubic spline, 4 for z linear cubic
            											spline, 5 for minimum-curvature spline, (-1) for
            											null: no line.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy which indicates in which
            											HDF5 file the parameters and the tangent vectors will
            											be stored. It must be already opened for writing and
            											won't be closed. If null, then the default HDF Proxy
            											of the DataObject repository will be arbitrarily
            											selected for writing.
        :param [in]:	  	localCrs			  	(Optional) The local CRS where the control points are
            											given. If ``nullptr``, then the default Local CRS of
            											the DataObject repository will be arbitrarily
            											selected.

        |

        *Overload 7:*

        Sets the geometry of the representation by means of a parametric line with MD and tangent
        vector information.

        :raises: std::invalid_argument	If ``controlPoints`` is ``nullptr``.
        :raises: std::invalid_argument	If ``tangentVectors`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointParameters`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointCount`` is 0.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If ``localCrs`` is ``nullptr`` and no default CRS is
            										defined in the repository.

        :param [in]:	  	controlPoints		  	All the control points of the cubic parametric line
            											in the ascending order of the MDs. Count is
            											controlPointCount * 3 and for each control
            											point (x,y, z) = (controlPoints[2i],
            											controlPoints[2i+1], controlPoints[2i+2]).
        :param [in]:	  	tangentVectors		  	All the tangent vectors of all the control points of
            											all the cubic parametric lines. They are ordered
            											according to the control points. Count is
            											controlPointCount * 3 and for each tangent
            											vector (u,v, w) = (tangentVectors[2i],
            											tangentVectors[2i+1], tangentVectors[2i+2]).
        :param [in]:	  	controlPointParameters	The arrays of control point parameters (ordered
            											regarding the control points). It corresponds to the
            											MD values in this context. Count is ``controlPointCount``.
        :type controlPointCount: int
        :param controlPointCount:	  	The count of control points and control point
            											parameters and tangent vectors per cubic parametric
            											line.
        :type lineKind: int
        :param lineKind:			  	Integer indicating the parametric line kind: 0 for
            											vertical, 1 for linear spline, 2 for natural cubic
            											spline, 3 for cubic spline, 4 for z linear cubic
            											spline, 5 for minimum-curvature spline, (-1) for
            											null: no line.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy which indicates in which
            											HDF5 file the parameters and the tangent vectors will
            											be stored. It must be already opened for writing and
            											won't be closed. If null, then the default HDF Proxy
            											of the DataObject repository will be arbitrarily
            											selected for writing.
        :param [in]:	  	localCrs			  	(Optional) The local CRS where the control points are
            											given. If ``nullptr``, then the default Local CRS of
            											the DataObject repository will be arbitrarily
            											selected.

        |

        *Overload 8:*

        Sets the geometry of the representation by means of a parametric line with MD and tangent
        vector information.

        :raises: std::invalid_argument	If ``controlPoints`` is ``nullptr``.
        :raises: std::invalid_argument	If ``tangentVectors`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointParameters`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointCount`` is 0.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If ``localCrs`` is ``nullptr`` and no default CRS is
            										defined in the repository.

        :param [in]:	  	controlPoints		  	All the control points of the cubic parametric line
            											in the ascending order of the MDs. Count is
            											controlPointCount * 3 and for each control
            											point (x,y, z) = (controlPoints[2i],
            											controlPoints[2i+1], controlPoints[2i+2]).
        :param [in]:	  	inclinations		  	All the inclinations (angle against vertical) in radians of all the trajectory stations
            											of the cubic parametric line. They are ordered
            											according to the control points. Count is controlPointCount.
        :param [in]:	  	azimuths			  	All the azimuths (clockwise angle against grid north) in radians of all the trajectory stations
            											of the cubic parametric line. They are ordered
            											according to the control points. Count is controlPointCount.
        :param [in]:	  	controlPointParameters	The arrays of control point parameters (ordered
            											regarding the control points). It corresponds to the
            											MD values in this context. Count is ``controlPointCount``.
        :type controlPointCount: int
        :param controlPointCount:	  	The count of control points and control point
            											parameters and tangent vectors per cubic parametric
            											line. Control points correspond to the trajectory stations.
        :type lineKind: int
        :param lineKind:			  	Integer indicating the parametric line kind: 0 for
            											vertical, 1 for linear spline, 2 for natural cubic
            											spline, 3 for cubic spline, 4 for z linear cubic
            											spline, 5 for minimum-curvature spline, (-1) for
            											null: no line.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy which indicates in which
            											HDF5 file the parameters and the tangent vectors will
            											be stored. It must be already opened for writing and
            											won't be closed. If null, then the default HDF Proxy
            											of the DataObject repository will be arbitrarily
            											selected for writing.
        :param [in]:	  	localCrs			  	(Optional) The local CRS where the control points are
            											given. If ``nullptr``, then the default Local CRS of
            											the DataObject repository will be arbitrarily
            											selected.

        |

        *Overload 9:*

        Sets the geometry of the representation by means of a parametric line with MD and tangent
        vector information.

        :raises: std::invalid_argument	If ``controlPoints`` is ``nullptr``.
        :raises: std::invalid_argument	If ``tangentVectors`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointParameters`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointCount`` is 0.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If ``localCrs`` is ``nullptr`` and no default CRS is
            										defined in the repository.

        :param [in]:	  	controlPoints		  	All the control points of the cubic parametric line
            											in the ascending order of the MDs. Count is
            											controlPointCount * 3 and for each control
            											point (x,y, z) = (controlPoints[2i],
            											controlPoints[2i+1], controlPoints[2i+2]).
        :param [in]:	  	inclinations		  	All the inclinations (angle against vertical) in radians of all the trajectory stations
            											of the cubic parametric line. They are ordered
            											according to the control points. Count is controlPointCount.
        :param [in]:	  	azimuths			  	All the azimuths (clockwise angle against grid north) in radians of all the trajectory stations
            											of the cubic parametric line. They are ordered
            											according to the control points. Count is controlPointCount.
        :param [in]:	  	controlPointParameters	The arrays of control point parameters (ordered
            											regarding the control points). It corresponds to the
            											MD values in this context. Count is ``controlPointCount``.
        :type controlPointCount: int
        :param controlPointCount:	  	The count of control points and control point
            											parameters and tangent vectors per cubic parametric
            											line. Control points correspond to the trajectory stations.
        :type lineKind: int
        :param lineKind:			  	Integer indicating the parametric line kind: 0 for
            											vertical, 1 for linear spline, 2 for natural cubic
            											spline, 3 for cubic spline, 4 for z linear cubic
            											spline, 5 for minimum-curvature spline, (-1) for
            											null: no line.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy which indicates in which
            											HDF5 file the parameters and the tangent vectors will
            											be stored. It must be already opened for writing and
            											won't be closed. If null, then the default HDF Proxy
            											of the DataObject repository will be arbitrarily
            											selected for writing.
        :param [in]:	  	localCrs			  	(Optional) The local CRS where the control points are
            											given. If ``nullptr``, then the default Local CRS of
            											the DataObject repository will be arbitrarily
            											selected.

        |

        *Overload 10:*

        Sets the geometry of the representation by means of a parametric line with MD and tangent
        vector information.

        :raises: std::invalid_argument	If ``controlPoints`` is ``nullptr``.
        :raises: std::invalid_argument	If ``tangentVectors`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointParameters`` is ``nullptr``.
        :raises: std::invalid_argument	If ``controlPointCount`` is 0.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.
        :raises: std::invalid_argument	If ``localCrs`` is ``nullptr`` and no default CRS is
            										defined in the repository.

        :param [in]:	  	controlPoints		  	All the control points of the cubic parametric line
            											in the ascending order of the MDs. Count is
            											controlPointCount * 3 and for each control
            											point (x,y, z) = (controlPoints[2i],
            											controlPoints[2i+1], controlPoints[2i+2]).
        :param [in]:	  	inclinations		  	All the inclinations (angle against vertical) in radians of all the trajectory stations
            											of the cubic parametric line. They are ordered
            											according to the control points. Count is controlPointCount.
        :param [in]:	  	azimuths			  	All the azimuths (clockwise angle against grid north) in radians of all the trajectory stations
            											of the cubic parametric line. They are ordered
            											according to the control points. Count is controlPointCount.
        :param [in]:	  	controlPointParameters	The arrays of control point parameters (ordered
            											regarding the control points). It corresponds to the
            											MD values in this context. Count is ``controlPointCount``.
        :type controlPointCount: int
        :param controlPointCount:	  	The count of control points and control point
            											parameters and tangent vectors per cubic parametric
            											line. Control points correspond to the trajectory stations.
        :type lineKind: int
        :param lineKind:			  	Integer indicating the parametric line kind: 0 for
            											vertical, 1 for linear spline, 2 for natural cubic
            											spline, 3 for cubic spline, 4 for z linear cubic
            											spline, 5 for minimum-curvature spline, (-1) for
            											null: no line.
        :param [in,out]:	proxy				  	(Optional) The HDF proxy which indicates in which
            											HDF5 file the parameters and the tangent vectors will
            											be stored. It must be already opened for writing and
            											won't be closed. If null, then the default HDF Proxy
            											of the DataObject repository will be arbitrarily
            											selected for writing.
        :param [in]:	  	localCrs			  	(Optional) The local CRS where the control points are
            											given. If ``nullptr``, then the default Local CRS of
            											the DataObject repository will be arbitrarily
            											selected.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_setGeometry(self, *args)

    def setMdDatum(self, mdDatum: "Resqml2_MdDatum") -> "void":
        r"""
        Sets the MD datum of this trajectory.

        :raises: std::invalid_argument	If ``mdDatum`` is ``nullptr``.

        :param [in]:	mdDatum	The MD damtum to set to this trajectory. It cannot be null.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_setMdDatum(self, mdDatum)

    def getMdDatum(self) -> "resqml2::MdDatum *":
        r"""
        Gets the MD information associated to this wellbore trajectory representation.

        :rtype: :py:class:`MdDatum`
        :return: The associated MD information.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_getMdDatum(self)

    def hasGeometry(self) -> "bool":
        r"""
        Queries if this trajectory has a geometry.

        :rtype: boolean
        :return: True if this trajectory has a geometry, false if not.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_hasGeometry(self)

    def getGeometryKind(self) -> "int":
        r"""
        Gets the geometry kind.

        :raises: std::logic_error 	If this trajectory has no geometry.
        :raises: std::logic_error 	If the geometry of this trajectory is not a parametric line.
        :raises: std::out_of_range	If the geometry kind index is not in the range [-1,
            									5].

        :rtype: int
        :return: 0 for vertical, 1 for linear spline, 2 for natural cubic spline, 3 for cubic spline,
            			4 for z linear cubic spline, 5 for minimum-curvature spline, (-1) for null: no line.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_getGeometryKind(self)

    def hasTangentVectors(self) -> "bool":
        r"""
        Indicates if the wellbore trajectory has got tangent vectors attached to each trajectory
        station. Tangent vectors ussually transport inclination and azimuth of a trajectory station.

        :raises: std::logic_error	If the geometry of this trajectory is not a parametric line.

        :rtype: boolean
        :return: True if there is some tangent vectors, false if not.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_hasTangentVectors(self)

    def getTangentVectors(self, tangentVectors: "double *") -> "void":
        r"""
        Gets the tangent vectors associated to each trajectory station of this trajectory.

        :raises: std::invalid_argument	If this trajectory has no tanget vector.
        :raises: std::invalid_argument	If the HDF proxy is missing.

        :param [out]:	tangentVectors	A buffer for receiving the tangent vectors. It must be
            								preallocated with size of 3 *
            								getXyzPointCountOfAllPatches(). It won't be freed by FESAPI.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_getTangentVectors(self, tangentVectors)

    def getInclinationsAndAzimuths(self, inclinations: "double *", azimuths: "double *") -> "void":
        r"""
        Gets the inclination (angle against vertical) and the azimuths (clockwise angle against grid north)
        both in radians for each trajectory station of this trajectory.

        :raises: std::invalid_argument	If this trajectory has no tangent vector.
        :raises: std::invalid_argument	If the HDF proxy is missing.

        :param [out]:	inclinations	A buffer for receiving the inclinations. It must be
            								preallocated with size getXyzPointCountOfAllPatches().
            								It won't be freed by FESAPI.
        :param [out]:	azimuths		A buffer for receiving the azimuths. It must be
            								preallocated with size getXyzPointCountOfAllPatches().
            								It won't be freed by FESAPI.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_getInclinationsAndAzimuths(self, inclinations, azimuths)

    def hasMdValues(self) -> "bool":
        r"""
        Indicates if the wellbore trajectory has got MD values attached to each trajectory station.

        :raises: std::logic_error	If the geometry of this trajectory is not a parametric line.

        :rtype: boolean
        :return: True if there is some MD values, false if not.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_hasMdValues(self)

    def getMdUom(self) -> "gsoap_resqml2_0_1::eml20__LengthUom":
        r"""
        Gets the unit of measure of the MDs along this trajectory.

        :rtype: int
        :return: The unit of measure of the MDs along this trajectory.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_getMdUom(self)

    def getMdUomAsString(self) -> "std::string":
        r"""
        Gets the unit of measure of the MDs along this trajectory as a string.

        :rtype: string
        :return: The unit of measure of the MDs along this trajectory as a string.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_getMdUomAsString(self)

    def getMdValues(self, values: "double *") -> "void":
        r"""
        Gets the MD double values associated to each trajectory station of this trajectory.

        :raises: std::invalid_argument	If this trajectory has no MD value.
        :raises: std::invalid_argument	If the HDF proxy is missing.
        :raises: std::invalid_argument	If MD values are not defined using the right data
            										structure.

        :param [out]:	values	A buffer for receiving the MD values. It must be preallocated with size
            						of getXyzPointCountOfAllPatches().
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_getMdValues(self, values)

    def convertMdValuesToXyzValues(self, mdValues: "double *", mdCount: "uint64_t", xyzValues: "double *") -> "void":
        r"""
        Converts an array MD values an array of corresponding XYZ values according to this trajectory.

        :param [in]:	mdValues	An array containing all MD values we want to convert.
        :param [in]:	mdCount		The count of MD values in ``mdValues``
        :param [out]:	xyzValues	A buffer for receiving the XYZ values converted from ``mdValues``. It must be preallocated with a size of 3*mdCount.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_convertMdValuesToXyzValues(self, mdValues, mdCount, xyzValues)

    def getStartMd(self) -> "double":
        r"""
        Gets the starting MD of this wellbore trajectory. Range may often be from kickoff to TD, but
        this is not necessary.

        :rtype: float
        :return: The start MD.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_getStartMd(self)

    def getFinishMd(self) -> "double":
        r"""
        Gets the ending MD of this wellbore trajectory. Range may often be from kickoff to TD, but
        this is not necessary.

        :rtype: float
        :return: The end MD.
        """
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_getFinishMd(self)

    def addParentTrajectory(self, kickoffMd: "double", parentMd: "double", parentTrajRep: "Resqml2_WellboreTrajectoryRepresentation") -> "void":
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_addParentTrajectory(self, kickoffMd, parentMd, parentTrajRep)

    def getParentTrajectory(self) -> "resqml2::WellboreTrajectoryRepresentation *":
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_getParentTrajectory(self)

    def getParentTrajectoryMd(self) -> "double":
        return _fesapi.Resqml2_WellboreTrajectoryRepresentation_getParentTrajectoryMd(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_WellboreTrajectoryRepresentation

# Register Resqml2_WellboreTrajectoryRepresentation in _fesapi:
_fesapi.Resqml2_WellboreTrajectoryRepresentation_swigregister(Resqml2_WellboreTrajectoryRepresentation)
class Resqml2_WellboreFrameRepresentation(Resqml2_AbstractRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setMdValues(self, *args) -> "void":
        r"""
        *Overload 1:*

        Sets the measured depth (MD) values of this wellbore frame representation as a 1d array of explicit values.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If ``proxy`` is ``nullptr`` and no default HDF proxy is
            										defined in the repository.

        :type mdValues: float
        :param mdValues:		All the MD values to set from top to bottom of the wellbore
            									trajectory. Size if ``mdValueCount``.
        :type mdValueCount: int
        :param mdValueCount:	The MD values count.
        :param [in,out]:	proxy			(Optional) The HDF proxy where to write the MD values. It
            									must be already opened for writing and won't be closed in this
            									method. If ``nullptr``, then a default HDF proxy must be defined
            									in the repository.

        |

        *Overload 2:*

        Sets the measured depth (MD) values of this wellbore frame representation as a regular
        discretization along the wellbore trajectory.

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0 one.

        :type firstMdValue: float
        :param firstMdValue:		The first MD value.
        :type incrementMdValue: float
        :param incrementMdValue:	The increment value between two MDs.
        :type mdValueCount: int
        :param mdValueCount:		The count of MD values in this wellbore frame representation.
        """
        return _fesapi.Resqml2_WellboreFrameRepresentation_setMdValues(self, *args)

    def areMdValuesRegularlySpaced(self) -> "bool":
        r"""
        Indicates either the MDs are regularly spaced or not (useful for optimization). Does not
        check the regularity if the writer has used a generic array to store regular MDs.

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0 one.

        :rtype: boolean
        :return: True if MD values are regularly spaced, false if not.
        """
        return _fesapi.Resqml2_WellboreFrameRepresentation_areMdValuesRegularlySpaced(self)

    def getMdConstantIncrementValue(self) -> "double":
        r"""
        Indicates the increment value between two MDs in case of regularly spaced MDs. Please check
        the regularity of MDs with areMdValuesRegularlySpaced() before using this method.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If the MD values are not regularly spaced.

        :rtype: float
        :return: The MD constant increment value.
        """
        return _fesapi.Resqml2_WellboreFrameRepresentation_getMdConstantIncrementValue(self)

    def getMdFirstValue(self) -> "double":
        r"""
        Returns the first MD value of this wellbore frame representation.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::logic_error	 	If the MD values are neither stored in a HDF5 double
            										array nor in a double lattice array.
        :raises: std::invalid_argument	If the MD values are stored in a HDF5 double array and
            										the HDF proxy is missing.

        :rtype: float
        :return: The first MD value.
        """
        return _fesapi.Resqml2_WellboreFrameRepresentation_getMdFirstValue(self)

    def getMdValuesCount(self) -> "unsigned int":
        r"""
        Gets the number of MD values in this wellbore frame representation.

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0 one.

        :rtype: int
        :return: The MD values count.
        """
        return _fesapi.Resqml2_WellboreFrameRepresentation_getMdValuesCount(self)

    def getMdHdfDatatype(self) -> "common::AbstractObject::numericalDatatypeEnum":
        r"""
        Gets the MD datatype in the HDF dataset.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::invalid_argument	If the MD values are stored in a HDF5 double array and
            										the HDF proxy is missing.

        :rtype: int
        :return: The MD datatype in the HDF dataset if MD values are actually stored in a HDF dataset.
            			Returns ``DOUBLE`` if MD values are stored as a regular discretization along the
            			wellbore trajectory.
        """
        return _fesapi.Resqml2_WellboreFrameRepresentation_getMdHdfDatatype(self)

    def getMdAsDoubleValues(self, values: "double *") -> "void":
        r"""
        Gets all the MD values of this instance which are supposed to be double ones.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::logic_error	 	If the MD values are neither stored in a HDF5 double
            										array nor in a double lattice array.
        :raises: std::invalid_argument	If the MD values are stored in a HDF5 double array and
            										the HDF proxy is missing.

        :param [out]:	values	A buffer to receive the MD values ordered from top to bottom of the
            						wellbore trajectory. It must be preallocated with size of
            						getMdValuesCount().
        """
        return _fesapi.Resqml2_WellboreFrameRepresentation_getMdAsDoubleValues(self, values)

    def getMdAsFloatValues(self, values: "float *") -> "void":
        r"""
        Gets all the MD values of this instance which are supposed to be float ones.

        :raises: std::logic_error	 	If the underlying gSOAP instance is not a RESQML2.0 one.
        :raises: std::logic_error	 	If the MD values are neither stored in a HDF5 double
            										array nor in a double lattice array.
        :raises: std::invalid_argument	If the MD values are stored in a HDF5 double array and
            										the HDF proxy is missing.

        :param [out]:	values	A buffer to receive the MD values ordered from top to bottom of the
            						wellbore trajectory. It must be preallocated with size of
            						getMdValuesCount().
        """
        return _fesapi.Resqml2_WellboreFrameRepresentation_getMdAsFloatValues(self, values)

    def getWellboreTrajectory(self) -> "resqml2::WellboreTrajectoryRepresentation *":
        r"""
        Gets the associated RESQML wellbore trajectory.

        :raises: std::logic_error	If the underlying gSOAP instance is not a RESQML2.0 one.

        :rtype: :py:class:`WellboreTrajectoryRepresentation`
        :return: The associated RESQML wellbore trajectory.
        """
        return _fesapi.Resqml2_WellboreFrameRepresentation_getWellboreTrajectory(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_WellboreFrameRepresentation

# Register Resqml2_WellboreFrameRepresentation in _fesapi:
_fesapi.Resqml2_WellboreFrameRepresentation_swigregister(Resqml2_WellboreFrameRepresentation)
class Resqml2_SeismicWellboreFrameRepresentation(Resqml2_WellboreFrameRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setTimeValues(self, *args) -> "void":
        r"""
        *Overload 1:*

        Set the time values of this SeismicWellboreFrameRepresentation frame to an array 1d of explicit values.
        :type timeValues: float
        :param timeValues:		All the time values to set from top of the well trajectory to bottom.
        :type timeValueCount: int
        :param timeValueCount:	The time values count. It must be the same that the md values count.
        :type proxy: :py:class:`AbstractHdfProxy`, optional
        :param proxy:			The HDF proxy where to write the time values. It must be already opened for writing and won't be closed in this method.


        |

        *Overload 2:*

        Set the time values of this WellboreFrameRepresentation frame as a regular discretization along the wellbore trajectory.
        :type firstTimeValue: float
        :param firstTimeValue:		The first time value.
        :type incrementTimeValue: float
        :param incrementTimeValue:	The increment value between two time values. It must be the same that the md values count.
        :type timeValueCount: int
        :param timeValueCount:		The count of time values in this WellboreFrameRepresentation.
        """
        return _fesapi.Resqml2_SeismicWellboreFrameRepresentation_setTimeValues(self, *args)

    def areTimeValuesRegularlySpaced(self) -> "bool":
        r"""
        Indicates either the times are regularly spaced or not (useful for optimization)
        Does not verify if the writer has used a generic array to store regular times.
        """
        return _fesapi.Resqml2_SeismicWellboreFrameRepresentation_areTimeValuesRegularlySpaced(self)

    def getTimeConstantIncrementValue(self) -> "double":
        r"""
        Indicates the increment value between two times only if the times are regularly spaced.
        Please use areTimeValuesRegularlySpaced before using this method.
        """
        return _fesapi.Resqml2_SeismicWellboreFrameRepresentation_getTimeConstantIncrementValue(self)

    def getTimeFirstValue(self) -> "double":
        r"""Returns the first time value of this SeismicWellboreFrameRepresentation"""
        return _fesapi.Resqml2_SeismicWellboreFrameRepresentation_getTimeFirstValue(self)

    def getTimeValuesCount(self) -> "unsigned int":
        r"""Get the number of time values in this seismic wellbore frame."""
        return _fesapi.Resqml2_SeismicWellboreFrameRepresentation_getTimeValuesCount(self)

    def getTimeHdfDatatype(self) -> "common::AbstractObject::numericalDatatypeEnum":
        r"""Get the time values datatype in the HDF dataset"""
        return _fesapi.Resqml2_SeismicWellboreFrameRepresentation_getTimeHdfDatatype(self)

    def getTimeAsDoubleValues(self, values: "double *") -> "void":
        r"""Get all the time values of the instance which are supposed to be double ones."""
        return _fesapi.Resqml2_SeismicWellboreFrameRepresentation_getTimeAsDoubleValues(self, values)

    def getTimeAsFloatValues(self, values: "float *") -> "void":
        r"""Get all the time values of the instance which are supposed to be float ones."""
        return _fesapi.Resqml2_SeismicWellboreFrameRepresentation_getTimeAsFloatValues(self, values)

    def getTimeCrs(self) -> "eml2::AbstractLocal3dCrs *":
        r"""
        Gets the Local Time CRS of this seismic wellbore frame.

        :rtype: :py:class:`AbstractLocal3dCrs`
        :return: Local Time CRS of this seismic wellbore frame.
        """
        return _fesapi.Resqml2_SeismicWellboreFrameRepresentation_getTimeCrs(self)

    def getSeismicReferenceDatum(self) -> "double":
        r"""Returns the seismic reference datum"""
        return _fesapi.Resqml2_SeismicWellboreFrameRepresentation_getSeismicReferenceDatum(self)

    def getWeatheringVelocity(self) -> "double":
        r"""Returns the weathering velocity"""
        return _fesapi.Resqml2_SeismicWellboreFrameRepresentation_getWeatheringVelocity(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_SeismicWellboreFrameRepresentation

# Register Resqml2_SeismicWellboreFrameRepresentation in _fesapi:
_fesapi.Resqml2_SeismicWellboreFrameRepresentation_swigregister(Resqml2_SeismicWellboreFrameRepresentation)
class Resqml2_BlockedWellboreRepresentation(Resqml2_WellboreFrameRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setIntervalGridCells(self, gridIndices: "int8_t const *", gridIndicesNullValue: "int8_t", cellIndices: "int64_t const *", localFacePairPerCellIndices: "int8_t const *", localFacePairPerCellIndicesNullValue: "int8_t", hdfProxy: "Eml2_AbstractHdfProxy"=None) -> "void":
        r"""
        Sets all information about the intersected grid cells. You must first provide MD values of
        the frame before to use this method.

        :raises: std::invalid_argument	If ``gridIndices``, ``cellIndices``,
            ``localFacePairPerCellIndices`` or ``hdfProxy`` is ``nullptr``.
        :raises: std::logic_error	 	If MD values of the frame have not been provided before
            										using this method.

        :type gridIndices: int8_t
        :param gridIndices:								An array containing for each interval
            															of the wellbore frame, the index of the
            															grid it is associated to. The size of
            															this array is the interval count of the
            															wellbore frame representation.
            ``cellCount`` must equal the number of non-
            															null entries in this array. The
            															associated grids (and there indices) are
            															defined using
            															pushBackSupportingGridRepresentation()
            															method.
        :type gridIndicesNullValue: int8_t
        :param gridIndicesNullValue:					The null value used in ``gridIndices``
            															in order to indicate that an interval
            															does not correspond to any intersected
            															grid. Generally -1.
        :type cellIndices: int
        :param cellIndices:								An array containing the intersected
            															cell index for each entry in ``gridIndices``.
            															The size of this array is the interval count of the
            															wellbore frame representation.
            															The null value will be set to ``gridIndicesNullValue``
            															already informs about the presence or not of a cell.
        :type localFacePairPerCellIndices: int8_t
        :param localFacePairPerCellIndices:				An array containing, for each cell,
            															the entry and exit intersection faces of
            															the trajectory in the cell. The array
            															dimension must equal 2 *
            															intervalCount.
        :type localFacePairPerCellIndicesNullValue: int8_t
        :param localFacePairPerCellIndicesNullValue:	The null value used in
            ``localFacePerCellIndices`` in order to
            															indicate that it corresponds to a missing
            															intersection, e.g., when a trajectory
            															originates or terminates within a cell.
        :param [in,out]:	hdfProxy								The HDF proxy where the numerical
            															values will be stored. If set to nullptr,
            															the default HdfProxy will be used instead.
        """
        return _fesapi.Resqml2_BlockedWellboreRepresentation_setIntervalGridCells(self, gridIndices, gridIndicesNullValue, cellIndices, localFacePairPerCellIndices, localFacePairPerCellIndicesNullValue, hdfProxy)

    def getCellCount(self) -> "uint64_t":
        r"""
        Gets the cell count, that is to say the number of non-null entries in the grid indices array.

        :rtype: int
        :return: The cell count.
        """
        return _fesapi.Resqml2_BlockedWellboreRepresentation_getCellCount(self)

    def getGridIndices(self, gridIndices: "int8_t *") -> "int8_t":
        r"""
        For each interval of the wellbore frame, gets the index of the grid it is associated to.

        :raises: std::range_error	If the grid indices are stored in an integer constant array
            									and if the the constant value is strictly superior than unsigned
            									int maximum value.
        :raises: std::logic_error	If the grid indices are neither stored in a HDF5 integer
            									array nor in an integer constant array.

        :param [out]:	gridIndices	An array for receiving the grids indices. The size of this array is
            							the interval count of the wellbore frame representation. The
            							associated grids (and there indices) are defined using
            							pushBackSupportingGridRepresentation() method.

        :rtype: int8_t
        :return: The null value used in ``gridIndices`` in order to indicate that an interval does not
            			correspond to any intersected grid.
        """
        return _fesapi.Resqml2_BlockedWellboreRepresentation_getGridIndices(self, gridIndices)

    def getCellIndices(self, cellIndices: "int64_t *") -> "int64_t":
        r"""
        For each interval of the wellbore frame, gets the index of the cell it is associated to.

        :raises: std::range_error	If the cell indices are stored in an integer constant array
            									and if the the constant value is strictly superior than
            									int64_t maximum value.
        :raises: std::logic_error	If the cell indices are neither stored in a HDF5 integer
            									array nor in an integer constant array.

        :param [out]:	gridIndices	An array for receiving the cell indices. The size of this array is
            							the interval count of the wellbore frame representation.

        :rtype: int
        :return: The null value used in ``cellIndices`` in order to indicate that an interval does not
            			correspond to any intersected cell.
        """
        return _fesapi.Resqml2_BlockedWellboreRepresentation_getCellIndices(self, cellIndices)

    def getLocalFacePairPerCellIndices(self, localFacePairPerCellIndices: "int8_t *") -> "int8_t":
        r"""
        For each interval of the wellbore frame, gets the index of the entry and exit local face it is associated to.

        :raises: std::range_error	If the local face indices are stored in an integer constant array
            									and if the the constant value is strictly superior than
            									char maximum value.
        :raises: std::logic_error	If the local face indices are neither stored in a HDF5 integer
            									array nor in an integer constant array.

        :param [out]:	gridIndices	An array for receiving the local face indices. The size of this array is twice
            							the interval count of the wellbore frame representation.

        :rtype: int8_t
        :return: The null value used in ``localFacePairPerCellIndices`` in order to indicate that no face is intersected.
        """
        return _fesapi.Resqml2_BlockedWellboreRepresentation_getLocalFacePairPerCellIndices(self, localFacePairPerCellIndices)

    def pushBackSupportingGridRepresentation(self, supportingGridRep: "Resqml2_AbstractGridRepresentation") -> "void":
        r"""
        Pushes back a grid representation which is one of the support of this representation.

        :raises: std::invalid_argument	If supportingGridRep == nullptr.

        :param [in]:	supportingGridRep	The supporting grid representation to push back.
        """
        return _fesapi.Resqml2_BlockedWellboreRepresentation_pushBackSupportingGridRepresentation(self, supportingGridRep)

    def getSupportingGridRepresentationCount(self) -> "uint64_t":
        r"""
        Gets the count of supporting grid representations of this blocked wellbore representation.

        :raises: std::range_error	If the count of supporting grid representations is strictly
            									greater than unsigned int max.

        :rtype: int
        :return: The count of supporting grid representation.
        """
        return _fesapi.Resqml2_BlockedWellboreRepresentation_getSupportingGridRepresentationCount(self)

    def getSupportingGridRepresentation(self, index: "uint64_t") -> "resqml2::AbstractGridRepresentation *":
        r"""
        Gets the supporting grid representation located at a specific index of this blocked wellbore
        representation.

        :raises: std::out_of_range	If index >=
            									getSupportingGridRepresentationCount().

        :type index: int
        :param index:	Zero-based index of the supporting grid representation we look for.

        :rtype: :py:class:`AbstractGridRepresentation`
        :return: The supporting grid representation at position ``index``.
        """
        return _fesapi.Resqml2_BlockedWellboreRepresentation_getSupportingGridRepresentation(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml2_BlockedWellboreRepresentation

# Register Resqml2_BlockedWellboreRepresentation in _fesapi:
_fesapi.Resqml2_BlockedWellboreRepresentation_swigregister(Resqml2_BlockedWellboreRepresentation)
class Resqml2_WellboreMarkerFrameRepresentation(Resqml2_WellboreFrameRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getWellboreMarkerCount(self) -> "unsigned int":
        return _fesapi.Resqml2_WellboreMarkerFrameRepresentation_getWellboreMarkerCount(self)

    def getWellboreMarker(self, index: "unsigned int") -> "resqml2::WellboreMarker *":
        return _fesapi.Resqml2_WellboreMarkerFrameRepresentation_getWellboreMarker(self, index)

    def setIntervalStratigraphicUnits(self, stratiUnitIndices: "unsigned int *", nullValue: "unsigned int", stratiOccurrenceInterp: "Resqml2_StratigraphicOccurrenceInterpretation", proxy: "Eml2_AbstractHdfProxy") -> "void":
        return _fesapi.Resqml2_WellboreMarkerFrameRepresentation_setIntervalStratigraphicUnits(self, stratiUnitIndices, nullValue, stratiOccurrenceInterp, proxy)

    def getStratigraphicOccurrenceInterpretation(self) -> "resqml2::StratigraphicOccurrenceInterpretation *":
        return _fesapi.Resqml2_WellboreMarkerFrameRepresentation_getStratigraphicOccurrenceInterpretation(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_WellboreMarkerFrameRepresentation

# Register Resqml2_WellboreMarkerFrameRepresentation in _fesapi:
_fesapi.Resqml2_WellboreMarkerFrameRepresentation_swigregister(Resqml2_WellboreMarkerFrameRepresentation)
class Resqml2_WellboreMarker(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def hasAGeologicBoundaryKind(self) -> "bool":
        return _fesapi.Resqml2_WellboreMarker_hasAGeologicBoundaryKind(self)

    def getGeologicBoundaryKind(self) -> "gsoap_resqml2_0_1::resqml20__GeologicBoundaryKind":
        return _fesapi.Resqml2_WellboreMarker_getGeologicBoundaryKind(self)

    def getWellboreMarkerFrameRepresentation(self) -> "resqml2::WellboreMarkerFrameRepresentation const *":
        return _fesapi.Resqml2_WellboreMarker_getWellboreMarkerFrameRepresentation(self)

    def getBoundaryFeatureInterpretation(self) -> "resqml2::BoundaryFeatureInterpretation *":
        return _fesapi.Resqml2_WellboreMarker_getBoundaryFeatureInterpretation(self)

    def setBoundaryFeatureInterpretation(self, interp: "Resqml2_BoundaryFeatureInterpretation") -> "void":
        return _fesapi.Resqml2_WellboreMarker_setBoundaryFeatureInterpretation(self, interp)

    def getWitsmlWellboreMarker(self) -> "witsml2_1::WellboreMarker *":
        return _fesapi.Resqml2_WellboreMarker_getWitsmlWellboreMarker(self)

    def setWitsmlWellboreMarker(self, wellboreMarker: "Witsml21_WellboreMarker") -> "void":
        return _fesapi.Resqml2_WellboreMarker_setWitsmlWellboreMarker(self, wellboreMarker)

    def hasDipAngle(self) -> "bool":
        return _fesapi.Resqml2_WellboreMarker_hasDipAngle(self)

    def getDipAngleValue(self) -> "double":
        return _fesapi.Resqml2_WellboreMarker_getDipAngleValue(self)

    def getDipAngleUom(self) -> "gsoap_eml2_3::eml23__PlaneAngleUom":
        return _fesapi.Resqml2_WellboreMarker_getDipAngleUom(self)

    def getDipAngleUomAsString(self) -> "std::string":
        return _fesapi.Resqml2_WellboreMarker_getDipAngleUomAsString(self)

    def hasDipDirection(self) -> "bool":
        return _fesapi.Resqml2_WellboreMarker_hasDipDirection(self)

    def getDipDirectionValue(self) -> "double":
        return _fesapi.Resqml2_WellboreMarker_getDipDirectionValue(self)

    def getDipDirectionUom(self) -> "gsoap_eml2_3::eml23__PlaneAngleUom":
        return _fesapi.Resqml2_WellboreMarker_getDipDirectionUom(self)

    def getDipDirectionUomAsString(self) -> "std::string":
        return _fesapi.Resqml2_WellboreMarker_getDipDirectionUomAsString(self)
    __swig_destroy__ = _fesapi.delete_Resqml2_WellboreMarker

# Register Resqml2_WellboreMarker in _fesapi:
_fesapi.Resqml2_WellboreMarker_swigregister(Resqml2_WellboreMarker)
resqml20__TimeSetKind_single_x0020time = _fesapi.resqml20__TimeSetKind_single_x0020time
resqml20__TimeSetKind_equivalent_x0020times = _fesapi.resqml20__TimeSetKind_equivalent_x0020times
resqml20__TimeSetKind_not_x0020a_x0020time_x0020set = _fesapi.resqml20__TimeSetKind_not_x0020a_x0020time_x0020set
resqml20__ParameterKind_dataObject = _fesapi.resqml20__ParameterKind_dataObject
resqml20__ParameterKind_floatingPoint = _fesapi.resqml20__ParameterKind_floatingPoint
resqml20__ParameterKind_integer = _fesapi.resqml20__ParameterKind_integer
resqml20__ParameterKind_string = _fesapi.resqml20__ParameterKind_string
resqml20__ParameterKind_timestamp = _fesapi.resqml20__ParameterKind_timestamp
resqml20__ParameterKind_subActivity = _fesapi.resqml20__ParameterKind_subActivity
resqml20__ThrowKind_reverse = _fesapi.resqml20__ThrowKind_reverse
resqml20__ThrowKind_normal = _fesapi.resqml20__ThrowKind_normal
resqml20__ThrowKind_thrust = _fesapi.resqml20__ThrowKind_thrust
resqml20__ThrowKind_strike_x0020and_x0020slip = _fesapi.resqml20__ThrowKind_strike_x0020and_x0020slip
resqml20__ThrowKind_scissor = _fesapi.resqml20__ThrowKind_scissor
resqml20__ThrowKind_variable = _fesapi.resqml20__ThrowKind_variable
resqml20__ResqmlPropertyKind_absorbed_x0020dose = _fesapi.resqml20__ResqmlPropertyKind_absorbed_x0020dose
resqml20__ResqmlPropertyKind_acceleration_x0020linear = _fesapi.resqml20__ResqmlPropertyKind_acceleration_x0020linear
resqml20__ResqmlPropertyKind_activity_x0020_x0028of_x0020radioactivity_x0029 = _fesapi.resqml20__ResqmlPropertyKind_activity_x0020_x0028of_x0020radioactivity_x0029
resqml20__ResqmlPropertyKind_amount_x0020of_x0020substance = _fesapi.resqml20__ResqmlPropertyKind_amount_x0020of_x0020substance
resqml20__ResqmlPropertyKind_amplitude = _fesapi.resqml20__ResqmlPropertyKind_amplitude
resqml20__ResqmlPropertyKind_angle_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_angle_x0020per_x0020length
resqml20__ResqmlPropertyKind_angle_x0020per_x0020time = _fesapi.resqml20__ResqmlPropertyKind_angle_x0020per_x0020time
resqml20__ResqmlPropertyKind_angle_x0020per_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_angle_x0020per_x0020volume
resqml20__ResqmlPropertyKind_angular_x0020acceleration = _fesapi.resqml20__ResqmlPropertyKind_angular_x0020acceleration
resqml20__ResqmlPropertyKind_area = _fesapi.resqml20__ResqmlPropertyKind_area
resqml20__ResqmlPropertyKind_area_x0020per_x0020area = _fesapi.resqml20__ResqmlPropertyKind_area_x0020per_x0020area
resqml20__ResqmlPropertyKind_area_x0020per_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_area_x0020per_x0020volume
resqml20__ResqmlPropertyKind_attenuation = _fesapi.resqml20__ResqmlPropertyKind_attenuation
resqml20__ResqmlPropertyKind_attenuation_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_attenuation_x0020per_x0020length
resqml20__ResqmlPropertyKind_azimuth = _fesapi.resqml20__ResqmlPropertyKind_azimuth
resqml20__ResqmlPropertyKind_bubble_x0020point_x0020pressure = _fesapi.resqml20__ResqmlPropertyKind_bubble_x0020point_x0020pressure
resqml20__ResqmlPropertyKind_bulk_x0020modulus = _fesapi.resqml20__ResqmlPropertyKind_bulk_x0020modulus
resqml20__ResqmlPropertyKind_capacitance = _fesapi.resqml20__ResqmlPropertyKind_capacitance
resqml20__ResqmlPropertyKind_categorical = _fesapi.resqml20__ResqmlPropertyKind_categorical
resqml20__ResqmlPropertyKind_cell_x0020length = _fesapi.resqml20__ResqmlPropertyKind_cell_x0020length
resqml20__ResqmlPropertyKind_charge_x0020density = _fesapi.resqml20__ResqmlPropertyKind_charge_x0020density
resqml20__ResqmlPropertyKind_chemical_x0020potential = _fesapi.resqml20__ResqmlPropertyKind_chemical_x0020potential
resqml20__ResqmlPropertyKind_code = _fesapi.resqml20__ResqmlPropertyKind_code
resqml20__ResqmlPropertyKind_compressibility = _fesapi.resqml20__ResqmlPropertyKind_compressibility
resqml20__ResqmlPropertyKind_concentration_x0020of_x0020B = _fesapi.resqml20__ResqmlPropertyKind_concentration_x0020of_x0020B
resqml20__ResqmlPropertyKind_conductivity = _fesapi.resqml20__ResqmlPropertyKind_conductivity
resqml20__ResqmlPropertyKind_continuous = _fesapi.resqml20__ResqmlPropertyKind_continuous
resqml20__ResqmlPropertyKind_cross_x0020section_x0020absorption = _fesapi.resqml20__ResqmlPropertyKind_cross_x0020section_x0020absorption
resqml20__ResqmlPropertyKind_current_x0020density = _fesapi.resqml20__ResqmlPropertyKind_current_x0020density
resqml20__ResqmlPropertyKind_Darcy_x0020flow_x0020coefficient = _fesapi.resqml20__ResqmlPropertyKind_Darcy_x0020flow_x0020coefficient
resqml20__ResqmlPropertyKind_data_x0020transmission_x0020speed = _fesapi.resqml20__ResqmlPropertyKind_data_x0020transmission_x0020speed
resqml20__ResqmlPropertyKind_delta_x0020temperature = _fesapi.resqml20__ResqmlPropertyKind_delta_x0020temperature
resqml20__ResqmlPropertyKind_density = _fesapi.resqml20__ResqmlPropertyKind_density
resqml20__ResqmlPropertyKind_depth = _fesapi.resqml20__ResqmlPropertyKind_depth
resqml20__ResqmlPropertyKind_diffusion_x0020coefficient = _fesapi.resqml20__ResqmlPropertyKind_diffusion_x0020coefficient
resqml20__ResqmlPropertyKind_digital_x0020storage = _fesapi.resqml20__ResqmlPropertyKind_digital_x0020storage
resqml20__ResqmlPropertyKind_dimensionless = _fesapi.resqml20__ResqmlPropertyKind_dimensionless
resqml20__ResqmlPropertyKind_dip = _fesapi.resqml20__ResqmlPropertyKind_dip
resqml20__ResqmlPropertyKind_discrete = _fesapi.resqml20__ResqmlPropertyKind_discrete
resqml20__ResqmlPropertyKind_dose_x0020equivalent = _fesapi.resqml20__ResqmlPropertyKind_dose_x0020equivalent
resqml20__ResqmlPropertyKind_dose_x0020equivalent_x0020rate = _fesapi.resqml20__ResqmlPropertyKind_dose_x0020equivalent_x0020rate
resqml20__ResqmlPropertyKind_dynamic_x0020viscosity = _fesapi.resqml20__ResqmlPropertyKind_dynamic_x0020viscosity
resqml20__ResqmlPropertyKind_electric_x0020charge = _fesapi.resqml20__ResqmlPropertyKind_electric_x0020charge
resqml20__ResqmlPropertyKind_electric_x0020conductance = _fesapi.resqml20__ResqmlPropertyKind_electric_x0020conductance
resqml20__ResqmlPropertyKind_electric_x0020current = _fesapi.resqml20__ResqmlPropertyKind_electric_x0020current
resqml20__ResqmlPropertyKind_electric_x0020dipole_x0020moment = _fesapi.resqml20__ResqmlPropertyKind_electric_x0020dipole_x0020moment
resqml20__ResqmlPropertyKind_electric_x0020field_x0020strength = _fesapi.resqml20__ResqmlPropertyKind_electric_x0020field_x0020strength
resqml20__ResqmlPropertyKind_electric_x0020polarization = _fesapi.resqml20__ResqmlPropertyKind_electric_x0020polarization
resqml20__ResqmlPropertyKind_electric_x0020potential = _fesapi.resqml20__ResqmlPropertyKind_electric_x0020potential
resqml20__ResqmlPropertyKind_electrical_x0020resistivity = _fesapi.resqml20__ResqmlPropertyKind_electrical_x0020resistivity
resqml20__ResqmlPropertyKind_electrochemical_x0020equivalent = _fesapi.resqml20__ResqmlPropertyKind_electrochemical_x0020equivalent
resqml20__ResqmlPropertyKind_electromagnetic_x0020moment = _fesapi.resqml20__ResqmlPropertyKind_electromagnetic_x0020moment
resqml20__ResqmlPropertyKind_energy_x0020length_x0020per_x0020area = _fesapi.resqml20__ResqmlPropertyKind_energy_x0020length_x0020per_x0020area
resqml20__ResqmlPropertyKind_energy_x0020length_x0020per_x0020time_x0020area_x0020temperature = _fesapi.resqml20__ResqmlPropertyKind_energy_x0020length_x0020per_x0020time_x0020area_x0020temperature
resqml20__ResqmlPropertyKind_energy_x0020per_x0020area = _fesapi.resqml20__ResqmlPropertyKind_energy_x0020per_x0020area
resqml20__ResqmlPropertyKind_energy_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_energy_x0020per_x0020length
resqml20__ResqmlPropertyKind_equivalent_x0020per_x0020mass = _fesapi.resqml20__ResqmlPropertyKind_equivalent_x0020per_x0020mass
resqml20__ResqmlPropertyKind_equivalent_x0020per_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_equivalent_x0020per_x0020volume
resqml20__ResqmlPropertyKind_exposure_x0020_x0028radioactivity_x0029 = _fesapi.resqml20__ResqmlPropertyKind_exposure_x0020_x0028radioactivity_x0029
resqml20__ResqmlPropertyKind_fluid_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_fluid_x0020volume
resqml20__ResqmlPropertyKind_force = _fesapi.resqml20__ResqmlPropertyKind_force
resqml20__ResqmlPropertyKind_force_x0020area = _fesapi.resqml20__ResqmlPropertyKind_force_x0020area
resqml20__ResqmlPropertyKind_force_x0020length_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_force_x0020length_x0020per_x0020length
resqml20__ResqmlPropertyKind_force_x0020per_x0020force = _fesapi.resqml20__ResqmlPropertyKind_force_x0020per_x0020force
resqml20__ResqmlPropertyKind_force_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_force_x0020per_x0020length
resqml20__ResqmlPropertyKind_force_x0020per_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_force_x0020per_x0020volume
resqml20__ResqmlPropertyKind_formation_x0020volume_x0020factor = _fesapi.resqml20__ResqmlPropertyKind_formation_x0020volume_x0020factor
resqml20__ResqmlPropertyKind_frequency = _fesapi.resqml20__ResqmlPropertyKind_frequency
resqml20__ResqmlPropertyKind_frequency_x0020interval = _fesapi.resqml20__ResqmlPropertyKind_frequency_x0020interval
resqml20__ResqmlPropertyKind_gamma_x0020ray_x0020API_x0020unit = _fesapi.resqml20__ResqmlPropertyKind_gamma_x0020ray_x0020API_x0020unit
resqml20__ResqmlPropertyKind_heat_x0020capacity = _fesapi.resqml20__ResqmlPropertyKind_heat_x0020capacity
resqml20__ResqmlPropertyKind_heat_x0020flow_x0020rate = _fesapi.resqml20__ResqmlPropertyKind_heat_x0020flow_x0020rate
resqml20__ResqmlPropertyKind_heat_x0020transfer_x0020coefficient = _fesapi.resqml20__ResqmlPropertyKind_heat_x0020transfer_x0020coefficient
resqml20__ResqmlPropertyKind_illuminance = _fesapi.resqml20__ResqmlPropertyKind_illuminance
resqml20__ResqmlPropertyKind_index = _fesapi.resqml20__ResqmlPropertyKind_index
resqml20__ResqmlPropertyKind_irradiance = _fesapi.resqml20__ResqmlPropertyKind_irradiance
resqml20__ResqmlPropertyKind_isothermal_x0020compressibility = _fesapi.resqml20__ResqmlPropertyKind_isothermal_x0020compressibility
resqml20__ResqmlPropertyKind_kinematic_x0020viscosity = _fesapi.resqml20__ResqmlPropertyKind_kinematic_x0020viscosity
resqml20__ResqmlPropertyKind_Lambda_x0020Rho = _fesapi.resqml20__ResqmlPropertyKind_Lambda_x0020Rho
resqml20__ResqmlPropertyKind_Lame_x0020constant = _fesapi.resqml20__ResqmlPropertyKind_Lame_x0020constant
resqml20__ResqmlPropertyKind_length = _fesapi.resqml20__ResqmlPropertyKind_length
resqml20__ResqmlPropertyKind_length_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_length_x0020per_x0020length
resqml20__ResqmlPropertyKind_length_x0020per_x0020temperature = _fesapi.resqml20__ResqmlPropertyKind_length_x0020per_x0020temperature
resqml20__ResqmlPropertyKind_length_x0020per_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_length_x0020per_x0020volume
resqml20__ResqmlPropertyKind_level_x0020of_x0020power_x0020intensity = _fesapi.resqml20__ResqmlPropertyKind_level_x0020of_x0020power_x0020intensity
resqml20__ResqmlPropertyKind_light_x0020exposure = _fesapi.resqml20__ResqmlPropertyKind_light_x0020exposure
resqml20__ResqmlPropertyKind_linear_x0020thermal_x0020expansion = _fesapi.resqml20__ResqmlPropertyKind_linear_x0020thermal_x0020expansion
resqml20__ResqmlPropertyKind_luminance = _fesapi.resqml20__ResqmlPropertyKind_luminance
resqml20__ResqmlPropertyKind_luminous_x0020efficacy = _fesapi.resqml20__ResqmlPropertyKind_luminous_x0020efficacy
resqml20__ResqmlPropertyKind_luminous_x0020flux = _fesapi.resqml20__ResqmlPropertyKind_luminous_x0020flux
resqml20__ResqmlPropertyKind_luminous_x0020intensity = _fesapi.resqml20__ResqmlPropertyKind_luminous_x0020intensity
resqml20__ResqmlPropertyKind_magnetic_x0020dipole_x0020moment = _fesapi.resqml20__ResqmlPropertyKind_magnetic_x0020dipole_x0020moment
resqml20__ResqmlPropertyKind_magnetic_x0020field_x0020strength = _fesapi.resqml20__ResqmlPropertyKind_magnetic_x0020field_x0020strength
resqml20__ResqmlPropertyKind_magnetic_x0020flux = _fesapi.resqml20__ResqmlPropertyKind_magnetic_x0020flux
resqml20__ResqmlPropertyKind_magnetic_x0020induction = _fesapi.resqml20__ResqmlPropertyKind_magnetic_x0020induction
resqml20__ResqmlPropertyKind_magnetic_x0020permeability = _fesapi.resqml20__ResqmlPropertyKind_magnetic_x0020permeability
resqml20__ResqmlPropertyKind_magnetic_x0020vector_x0020potential = _fesapi.resqml20__ResqmlPropertyKind_magnetic_x0020vector_x0020potential
resqml20__ResqmlPropertyKind_mass = _fesapi.resqml20__ResqmlPropertyKind_mass
resqml20__ResqmlPropertyKind_mass_x0020attenuation_x0020coefficient = _fesapi.resqml20__ResqmlPropertyKind_mass_x0020attenuation_x0020coefficient
resqml20__ResqmlPropertyKind_mass_x0020concentration = _fesapi.resqml20__ResqmlPropertyKind_mass_x0020concentration
resqml20__ResqmlPropertyKind_mass_x0020flow_x0020rate = _fesapi.resqml20__ResqmlPropertyKind_mass_x0020flow_x0020rate
resqml20__ResqmlPropertyKind_mass_x0020length = _fesapi.resqml20__ResqmlPropertyKind_mass_x0020length
resqml20__ResqmlPropertyKind_mass_x0020per_x0020energy = _fesapi.resqml20__ResqmlPropertyKind_mass_x0020per_x0020energy
resqml20__ResqmlPropertyKind_mass_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_mass_x0020per_x0020length
resqml20__ResqmlPropertyKind_mass_x0020per_x0020time_x0020per_x0020area = _fesapi.resqml20__ResqmlPropertyKind_mass_x0020per_x0020time_x0020per_x0020area
resqml20__ResqmlPropertyKind_mass_x0020per_x0020time_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_mass_x0020per_x0020time_x0020per_x0020length
resqml20__ResqmlPropertyKind_mass_x0020per_x0020volume_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_mass_x0020per_x0020volume_x0020per_x0020length
resqml20__ResqmlPropertyKind_mobility = _fesapi.resqml20__ResqmlPropertyKind_mobility
resqml20__ResqmlPropertyKind_modulus_x0020of_x0020compression = _fesapi.resqml20__ResqmlPropertyKind_modulus_x0020of_x0020compression
resqml20__ResqmlPropertyKind_molar_x0020concentration = _fesapi.resqml20__ResqmlPropertyKind_molar_x0020concentration
resqml20__ResqmlPropertyKind_molar_x0020heat_x0020capacity = _fesapi.resqml20__ResqmlPropertyKind_molar_x0020heat_x0020capacity
resqml20__ResqmlPropertyKind_molar_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_molar_x0020volume
resqml20__ResqmlPropertyKind_mole_x0020per_x0020area = _fesapi.resqml20__ResqmlPropertyKind_mole_x0020per_x0020area
resqml20__ResqmlPropertyKind_mole_x0020per_x0020time = _fesapi.resqml20__ResqmlPropertyKind_mole_x0020per_x0020time
resqml20__ResqmlPropertyKind_mole_x0020per_x0020time_x0020per_x0020area = _fesapi.resqml20__ResqmlPropertyKind_mole_x0020per_x0020time_x0020per_x0020area
resqml20__ResqmlPropertyKind_moment_x0020of_x0020force = _fesapi.resqml20__ResqmlPropertyKind_moment_x0020of_x0020force
resqml20__ResqmlPropertyKind_moment_x0020of_x0020inertia = _fesapi.resqml20__ResqmlPropertyKind_moment_x0020of_x0020inertia
resqml20__ResqmlPropertyKind_moment_x0020of_x0020section = _fesapi.resqml20__ResqmlPropertyKind_moment_x0020of_x0020section
resqml20__ResqmlPropertyKind_momentum = _fesapi.resqml20__ResqmlPropertyKind_momentum
resqml20__ResqmlPropertyKind_Mu_x0020Rho = _fesapi.resqml20__ResqmlPropertyKind_Mu_x0020Rho
resqml20__ResqmlPropertyKind_net_x0020to_x0020gross_x0020ratio = _fesapi.resqml20__ResqmlPropertyKind_net_x0020to_x0020gross_x0020ratio
resqml20__ResqmlPropertyKind_neutron_x0020API_x0020unit = _fesapi.resqml20__ResqmlPropertyKind_neutron_x0020API_x0020unit
resqml20__ResqmlPropertyKind_nonDarcy_x0020flow_x0020coefficient = _fesapi.resqml20__ResqmlPropertyKind_nonDarcy_x0020flow_x0020coefficient
resqml20__ResqmlPropertyKind_operations_x0020per_x0020time = _fesapi.resqml20__ResqmlPropertyKind_operations_x0020per_x0020time
resqml20__ResqmlPropertyKind_parachor = _fesapi.resqml20__ResqmlPropertyKind_parachor
resqml20__ResqmlPropertyKind_per_x0020area = _fesapi.resqml20__ResqmlPropertyKind_per_x0020area
resqml20__ResqmlPropertyKind_per_x0020electric_x0020potential = _fesapi.resqml20__ResqmlPropertyKind_per_x0020electric_x0020potential
resqml20__ResqmlPropertyKind_per_x0020force = _fesapi.resqml20__ResqmlPropertyKind_per_x0020force
resqml20__ResqmlPropertyKind_per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_per_x0020length
resqml20__ResqmlPropertyKind_per_x0020mass = _fesapi.resqml20__ResqmlPropertyKind_per_x0020mass
resqml20__ResqmlPropertyKind_per_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_per_x0020volume
resqml20__ResqmlPropertyKind_permeability_x0020length = _fesapi.resqml20__ResqmlPropertyKind_permeability_x0020length
resqml20__ResqmlPropertyKind_permeability_x0020rock = _fesapi.resqml20__ResqmlPropertyKind_permeability_x0020rock
resqml20__ResqmlPropertyKind_permeability_x0020thickness = _fesapi.resqml20__ResqmlPropertyKind_permeability_x0020thickness
resqml20__ResqmlPropertyKind_permeance = _fesapi.resqml20__ResqmlPropertyKind_permeance
resqml20__ResqmlPropertyKind_permittivity = _fesapi.resqml20__ResqmlPropertyKind_permittivity
resqml20__ResqmlPropertyKind_pH = _fesapi.resqml20__ResqmlPropertyKind_pH
resqml20__ResqmlPropertyKind_plane_x0020angle = _fesapi.resqml20__ResqmlPropertyKind_plane_x0020angle
resqml20__ResqmlPropertyKind_Poisson_x0020ratio = _fesapi.resqml20__ResqmlPropertyKind_Poisson_x0020ratio
resqml20__ResqmlPropertyKind_pore_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_pore_x0020volume
resqml20__ResqmlPropertyKind_porosity = _fesapi.resqml20__ResqmlPropertyKind_porosity
resqml20__ResqmlPropertyKind_potential_x0020difference_x0020per_x0020power_x0020drop = _fesapi.resqml20__ResqmlPropertyKind_potential_x0020difference_x0020per_x0020power_x0020drop
resqml20__ResqmlPropertyKind_power = _fesapi.resqml20__ResqmlPropertyKind_power
resqml20__ResqmlPropertyKind_power_x0020per_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_power_x0020per_x0020volume
resqml20__ResqmlPropertyKind_pressure = _fesapi.resqml20__ResqmlPropertyKind_pressure
resqml20__ResqmlPropertyKind_pressure_x0020per_x0020time = _fesapi.resqml20__ResqmlPropertyKind_pressure_x0020per_x0020time
resqml20__ResqmlPropertyKind_pressure_x0020squared = _fesapi.resqml20__ResqmlPropertyKind_pressure_x0020squared
resqml20__ResqmlPropertyKind_pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area = _fesapi.resqml20__ResqmlPropertyKind_pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area
resqml20__ResqmlPropertyKind_pressure_x0020time_x0020per_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_pressure_x0020time_x0020per_x0020volume
resqml20__ResqmlPropertyKind_productivity_x0020index = _fesapi.resqml20__ResqmlPropertyKind_productivity_x0020index
resqml20__ResqmlPropertyKind_property_x0020multiplier = _fesapi.resqml20__ResqmlPropertyKind_property_x0020multiplier
resqml20__ResqmlPropertyKind_quantity = _fesapi.resqml20__ResqmlPropertyKind_quantity
resqml20__ResqmlPropertyKind_quantity_x0020of_x0020light = _fesapi.resqml20__ResqmlPropertyKind_quantity_x0020of_x0020light
resqml20__ResqmlPropertyKind_radiance = _fesapi.resqml20__ResqmlPropertyKind_radiance
resqml20__ResqmlPropertyKind_radiant_x0020intensity = _fesapi.resqml20__ResqmlPropertyKind_radiant_x0020intensity
resqml20__ResqmlPropertyKind_relative_x0020permeability = _fesapi.resqml20__ResqmlPropertyKind_relative_x0020permeability
resqml20__ResqmlPropertyKind_relative_x0020power = _fesapi.resqml20__ResqmlPropertyKind_relative_x0020power
resqml20__ResqmlPropertyKind_relative_x0020time = _fesapi.resqml20__ResqmlPropertyKind_relative_x0020time
resqml20__ResqmlPropertyKind_reluctance = _fesapi.resqml20__ResqmlPropertyKind_reluctance
resqml20__ResqmlPropertyKind_resistance = _fesapi.resqml20__ResqmlPropertyKind_resistance
resqml20__ResqmlPropertyKind_resistivity_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_resistivity_x0020per_x0020length
resqml20__ResqmlPropertyKind_RESQML_x0020root_x0020property = _fesapi.resqml20__ResqmlPropertyKind_RESQML_x0020root_x0020property
resqml20__ResqmlPropertyKind_Rock_x0020Impedance = _fesapi.resqml20__ResqmlPropertyKind_Rock_x0020Impedance
resqml20__ResqmlPropertyKind_rock_x0020permeability = _fesapi.resqml20__ResqmlPropertyKind_rock_x0020permeability
resqml20__ResqmlPropertyKind_rock_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_rock_x0020volume
resqml20__ResqmlPropertyKind_saturation = _fesapi.resqml20__ResqmlPropertyKind_saturation
resqml20__ResqmlPropertyKind_second_x0020moment_x0020of_x0020area = _fesapi.resqml20__ResqmlPropertyKind_second_x0020moment_x0020of_x0020area
resqml20__ResqmlPropertyKind_shear_x0020modulus = _fesapi.resqml20__ResqmlPropertyKind_shear_x0020modulus
resqml20__ResqmlPropertyKind_solid_x0020angle = _fesapi.resqml20__ResqmlPropertyKind_solid_x0020angle
resqml20__ResqmlPropertyKind_solution_x0020gas_oil_x0020ratio = _fesapi.resqml20__ResqmlPropertyKind_solution_x0020gas_oil_x0020ratio
resqml20__ResqmlPropertyKind_specific_x0020activity_x0020_x0028of_x0020radioactivity_x0029 = _fesapi.resqml20__ResqmlPropertyKind_specific_x0020activity_x0020_x0028of_x0020radioactivity_x0029
resqml20__ResqmlPropertyKind_specific_x0020energy = _fesapi.resqml20__ResqmlPropertyKind_specific_x0020energy
resqml20__ResqmlPropertyKind_specific_x0020heat_x0020capacity = _fesapi.resqml20__ResqmlPropertyKind_specific_x0020heat_x0020capacity
resqml20__ResqmlPropertyKind_specific_x0020productivity_x0020index = _fesapi.resqml20__ResqmlPropertyKind_specific_x0020productivity_x0020index
resqml20__ResqmlPropertyKind_specific_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_specific_x0020volume
resqml20__ResqmlPropertyKind_surface_x0020density = _fesapi.resqml20__ResqmlPropertyKind_surface_x0020density
resqml20__ResqmlPropertyKind_temperature_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_temperature_x0020per_x0020length
resqml20__ResqmlPropertyKind_temperature_x0020per_x0020time = _fesapi.resqml20__ResqmlPropertyKind_temperature_x0020per_x0020time
resqml20__ResqmlPropertyKind_thermal_x0020conductance = _fesapi.resqml20__ResqmlPropertyKind_thermal_x0020conductance
resqml20__ResqmlPropertyKind_thermal_x0020conductivity = _fesapi.resqml20__ResqmlPropertyKind_thermal_x0020conductivity
resqml20__ResqmlPropertyKind_thermal_x0020diffusivity = _fesapi.resqml20__ResqmlPropertyKind_thermal_x0020diffusivity
resqml20__ResqmlPropertyKind_thermal_x0020insulance = _fesapi.resqml20__ResqmlPropertyKind_thermal_x0020insulance
resqml20__ResqmlPropertyKind_thermal_x0020resistance = _fesapi.resqml20__ResqmlPropertyKind_thermal_x0020resistance
resqml20__ResqmlPropertyKind_thermodynamic_x0020temperature = _fesapi.resqml20__ResqmlPropertyKind_thermodynamic_x0020temperature
resqml20__ResqmlPropertyKind_thickness = _fesapi.resqml20__ResqmlPropertyKind_thickness
resqml20__ResqmlPropertyKind_time = _fesapi.resqml20__ResqmlPropertyKind_time
resqml20__ResqmlPropertyKind_time_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_time_x0020per_x0020length
resqml20__ResqmlPropertyKind_time_x0020per_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_time_x0020per_x0020volume
resqml20__ResqmlPropertyKind_transmissibility = _fesapi.resqml20__ResqmlPropertyKind_transmissibility
resqml20__ResqmlPropertyKind_unit_x0020productivity_x0020index = _fesapi.resqml20__ResqmlPropertyKind_unit_x0020productivity_x0020index
resqml20__ResqmlPropertyKind_unitless = _fesapi.resqml20__ResqmlPropertyKind_unitless
resqml20__ResqmlPropertyKind_vapor_x0020oil_gas_x0020ratio = _fesapi.resqml20__ResqmlPropertyKind_vapor_x0020oil_gas_x0020ratio
resqml20__ResqmlPropertyKind_velocity = _fesapi.resqml20__ResqmlPropertyKind_velocity
resqml20__ResqmlPropertyKind_volume = _fesapi.resqml20__ResqmlPropertyKind_volume
resqml20__ResqmlPropertyKind_volume_x0020flow_x0020rate = _fesapi.resqml20__ResqmlPropertyKind_volume_x0020flow_x0020rate
resqml20__ResqmlPropertyKind_volume_x0020length_x0020per_x0020time = _fesapi.resqml20__ResqmlPropertyKind_volume_x0020length_x0020per_x0020time
resqml20__ResqmlPropertyKind_volume_x0020per_x0020area = _fesapi.resqml20__ResqmlPropertyKind_volume_x0020per_x0020area
resqml20__ResqmlPropertyKind_volume_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_volume_x0020per_x0020length
resqml20__ResqmlPropertyKind_volume_x0020per_x0020time_x0020per_x0020area = _fesapi.resqml20__ResqmlPropertyKind_volume_x0020per_x0020time_x0020per_x0020area
resqml20__ResqmlPropertyKind_volume_x0020per_x0020time_x0020per_x0020length = _fesapi.resqml20__ResqmlPropertyKind_volume_x0020per_x0020time_x0020per_x0020length
resqml20__ResqmlPropertyKind_volume_x0020per_x0020time_x0020per_x0020time = _fesapi.resqml20__ResqmlPropertyKind_volume_x0020per_x0020time_x0020per_x0020time
resqml20__ResqmlPropertyKind_volume_x0020per_x0020time_x0020per_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_volume_x0020per_x0020time_x0020per_x0020volume
resqml20__ResqmlPropertyKind_volume_x0020per_x0020volume = _fesapi.resqml20__ResqmlPropertyKind_volume_x0020per_x0020volume
resqml20__ResqmlPropertyKind_volumetric_x0020heat_x0020transfer_x0020coefficient = _fesapi.resqml20__ResqmlPropertyKind_volumetric_x0020heat_x0020transfer_x0020coefficient
resqml20__ResqmlPropertyKind_volumetric_x0020thermal_x0020expansion = _fesapi.resqml20__ResqmlPropertyKind_volumetric_x0020thermal_x0020expansion
resqml20__ResqmlPropertyKind_work = _fesapi.resqml20__ResqmlPropertyKind_work
resqml20__ResqmlPropertyKind_Young_x0020modulus = _fesapi.resqml20__ResqmlPropertyKind_Young_x0020modulus
resqml20__Phase_aquifer = _fesapi.resqml20__Phase_aquifer
resqml20__Phase_gas_x0020cap = _fesapi.resqml20__Phase_gas_x0020cap
resqml20__Phase_oil_x0020column = _fesapi.resqml20__Phase_oil_x0020column
resqml20__Phase_seal = _fesapi.resqml20__Phase_seal
class Resqml20_ActivityTemplate(ActivityTemplate):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackParameter(self, title: "std::string const &", kind: "gsoap_resqml2_0_1::resqml20__ParameterKind", isInput: "bool", isOutput: "bool", minOccurs: "unsigned int", maxOccurs: "int") -> "void":
        return _fesapi.Resqml20_ActivityTemplate_pushBackParameter(self, title, kind, isInput, isOutput, minOccurs, maxOccurs)
    __swig_destroy__ = _fesapi.delete_Resqml20_ActivityTemplate

# Register Resqml20_ActivityTemplate in _fesapi:
_fesapi.Resqml20_ActivityTemplate_swigregister(Resqml20_ActivityTemplate)
class Resqml20_Activity(Activity):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackParameter(self, *args) -> "void":
        return _fesapi.Resqml20_Activity_pushBackParameter(self, *args)

    def getFloatingPointQuantityParameterUom(self, index: "unsigned int") -> "gsoap_resqml2_0_1::resqml20__ResqmlUom":
        return _fesapi.Resqml20_Activity_getFloatingPointQuantityParameterUom(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml20_Activity

# Register Resqml20_Activity in _fesapi:
_fesapi.Resqml20_Activity_swigregister(Resqml20_Activity)
class Resqml20_LocalDepth3dCrs(Eml2_AbstractLocal3dCrs):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_LocalDepth3dCrs

# Register Resqml20_LocalDepth3dCrs in _fesapi:
_fesapi.Resqml20_LocalDepth3dCrs_swigregister(Resqml20_LocalDepth3dCrs)
class Resqml20_LocalTime3dCrs(Eml2_AbstractLocal3dCrs):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_LocalTime3dCrs

# Register Resqml20_LocalTime3dCrs in _fesapi:
_fesapi.Resqml20_LocalTime3dCrs_swigregister(Resqml20_LocalTime3dCrs)
class Resqml20_MdDatum(Resqml2_MdDatum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_MdDatum

# Register Resqml20_MdDatum in _fesapi:
_fesapi.Resqml20_MdDatum_swigregister(Resqml20_MdDatum)
class Resqml20_BoundaryFeature(Resqml2_BoundaryFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_BoundaryFeature

# Register Resqml20_BoundaryFeature in _fesapi:
_fesapi.Resqml20_BoundaryFeature_swigregister(Resqml20_BoundaryFeature)
class Resqml20_GeologicUnitFeature(Resqml2_RockVolumeFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_GeologicUnitFeature

# Register Resqml20_GeologicUnitFeature in _fesapi:
_fesapi.Resqml20_GeologicUnitFeature_swigregister(Resqml20_GeologicUnitFeature)
class Resqml20_GeneticBoundaryFeature(Resqml20_BoundaryFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def isAnHorizon(self) -> "bool":
        return _fesapi.Resqml20_GeneticBoundaryFeature_isAnHorizon(self)

    def setAge(self, age: "unsigned int") -> "void":
        return _fesapi.Resqml20_GeneticBoundaryFeature_setAge(self, age)

    def hasAnAge(self) -> "bool":
        return _fesapi.Resqml20_GeneticBoundaryFeature_hasAnAge(self)

    def getAge(self) -> "uint64_t":
        return _fesapi.Resqml20_GeneticBoundaryFeature_getAge(self)
    __swig_destroy__ = _fesapi.delete_Resqml20_GeneticBoundaryFeature

# Register Resqml20_GeneticBoundaryFeature in _fesapi:
_fesapi.Resqml20_GeneticBoundaryFeature_swigregister(Resqml20_GeneticBoundaryFeature)
class Resqml20_Horizon(Resqml20_GeneticBoundaryFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_Horizon

# Register Resqml20_Horizon in _fesapi:
_fesapi.Resqml20_Horizon_swigregister(Resqml20_Horizon)
class Resqml20_TectonicBoundaryFeature(Resqml20_BoundaryFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def isAFracture(self) -> "bool":
        return _fesapi.Resqml20_TectonicBoundaryFeature_isAFracture(self)
    __swig_destroy__ = _fesapi.delete_Resqml20_TectonicBoundaryFeature

# Register Resqml20_TectonicBoundaryFeature in _fesapi:
_fesapi.Resqml20_TectonicBoundaryFeature_swigregister(Resqml20_TectonicBoundaryFeature)
class Resqml20_SeismicLineSetFeature(Resqml2_SeismicLineSetFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_SeismicLineSetFeature

# Register Resqml20_SeismicLineSetFeature in _fesapi:
_fesapi.Resqml20_SeismicLineSetFeature_swigregister(Resqml20_SeismicLineSetFeature)
class Resqml20_SeismicLineFeature(Resqml2_AbstractSeismicLineFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getTraceIndexIncrement(self) -> "int64_t":
        return _fesapi.Resqml20_SeismicLineFeature_getTraceIndexIncrement(self)

    def getFirstTraceIndex(self) -> "int64_t":
        return _fesapi.Resqml20_SeismicLineFeature_getFirstTraceIndex(self)
    __swig_destroy__ = _fesapi.delete_Resqml20_SeismicLineFeature

# Register Resqml20_SeismicLineFeature in _fesapi:
_fesapi.Resqml20_SeismicLineFeature_swigregister(Resqml20_SeismicLineFeature)
class Resqml20_SeismicLatticeFeature(Resqml2_SeismicLatticeFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_SeismicLatticeFeature

# Register Resqml20_SeismicLatticeFeature in _fesapi:
_fesapi.Resqml20_SeismicLatticeFeature_swigregister(Resqml20_SeismicLatticeFeature)
class Resqml20_WellboreFeature(Resqml2_WellboreFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_WellboreFeature

# Register Resqml20_WellboreFeature in _fesapi:
_fesapi.Resqml20_WellboreFeature_swigregister(Resqml20_WellboreFeature)
class Resqml20_OrganizationFeature(Resqml2_Model):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_OrganizationFeature

# Register Resqml20_OrganizationFeature in _fesapi:
_fesapi.Resqml20_OrganizationFeature_swigregister(Resqml20_OrganizationFeature)
class Resqml20_FrontierFeature(Resqml2_CulturalFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_FrontierFeature

# Register Resqml20_FrontierFeature in _fesapi:
_fesapi.Resqml20_FrontierFeature_swigregister(Resqml20_FrontierFeature)
class Resqml20_StratigraphicUnitFeature(Resqml20_GeologicUnitFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_StratigraphicUnitFeature

# Register Resqml20_StratigraphicUnitFeature in _fesapi:
_fesapi.Resqml20_StratigraphicUnitFeature_swigregister(Resqml20_StratigraphicUnitFeature)
class Resqml20_GeobodyFeature(Resqml20_GeologicUnitFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_GeobodyFeature

# Register Resqml20_GeobodyFeature in _fesapi:
_fesapi.Resqml20_GeobodyFeature_swigregister(Resqml20_GeobodyFeature)
class Resqml20_FluidBoundaryFeature(Resqml20_BoundaryFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_FluidBoundaryFeature

# Register Resqml20_FluidBoundaryFeature in _fesapi:
_fesapi.Resqml20_FluidBoundaryFeature_swigregister(Resqml20_FluidBoundaryFeature)
class Resqml20_GenericFeatureInterpretation(Resqml2_GenericFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_GenericFeatureInterpretation

# Register Resqml20_GenericFeatureInterpretation in _fesapi:
_fesapi.Resqml20_GenericFeatureInterpretation_swigregister(Resqml20_GenericFeatureInterpretation)
class Resqml20_BoundaryFeatureInterpretation(Resqml2_BoundaryFeatureInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_BoundaryFeatureInterpretation

# Register Resqml20_BoundaryFeatureInterpretation in _fesapi:
_fesapi.Resqml20_BoundaryFeatureInterpretation_swigregister(Resqml20_BoundaryFeatureInterpretation)
class Resqml20_FaultInterpretation(Resqml2_FaultInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_FaultInterpretation

# Register Resqml20_FaultInterpretation in _fesapi:
_fesapi.Resqml20_FaultInterpretation_swigregister(Resqml20_FaultInterpretation)
class Resqml20_HorizonInterpretation(Resqml2_HorizonInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_HorizonInterpretation

# Register Resqml20_HorizonInterpretation in _fesapi:
_fesapi.Resqml20_HorizonInterpretation_swigregister(Resqml20_HorizonInterpretation)
class Resqml20_GeobodyBoundaryInterpretation(Resqml2_GeobodyBoundaryInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_GeobodyBoundaryInterpretation

# Register Resqml20_GeobodyBoundaryInterpretation in _fesapi:
_fesapi.Resqml20_GeobodyBoundaryInterpretation_swigregister(Resqml20_GeobodyBoundaryInterpretation)
class Resqml20_WellboreInterpretation(Resqml2_WellboreInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_WellboreInterpretation

# Register Resqml20_WellboreInterpretation in _fesapi:
_fesapi.Resqml20_WellboreInterpretation_swigregister(Resqml20_WellboreInterpretation)
class Resqml20_StratigraphicUnitInterpretation(Resqml2_StratigraphicUnitInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_StratigraphicUnitInterpretation

# Register Resqml20_StratigraphicUnitInterpretation in _fesapi:
_fesapi.Resqml20_StratigraphicUnitInterpretation_swigregister(Resqml20_StratigraphicUnitInterpretation)
class Resqml20_GeobodyInterpretation(Resqml2_GeobodyInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_GeobodyInterpretation

# Register Resqml20_GeobodyInterpretation in _fesapi:
_fesapi.Resqml20_GeobodyInterpretation_swigregister(Resqml20_GeobodyInterpretation)
class Resqml20_StructuralOrganizationInterpretation(Resqml2_StructuralOrganizationInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_StructuralOrganizationInterpretation

# Register Resqml20_StructuralOrganizationInterpretation in _fesapi:
_fesapi.Resqml20_StructuralOrganizationInterpretation_swigregister(Resqml20_StructuralOrganizationInterpretation)
class Resqml20_StratigraphicColumnRankInterpretation(Resqml2_StratigraphicColumnRankInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_StratigraphicColumnRankInterpretation

# Register Resqml20_StratigraphicColumnRankInterpretation in _fesapi:
_fesapi.Resqml20_StratigraphicColumnRankInterpretation_swigregister(Resqml20_StratigraphicColumnRankInterpretation)
class Resqml20_RockFluidUnitFeature(Resqml20_GeologicUnitFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_RockFluidUnitFeature

# Register Resqml20_RockFluidUnitFeature in _fesapi:
_fesapi.Resqml20_RockFluidUnitFeature_swigregister(Resqml20_RockFluidUnitFeature)
class Resqml20_RockFluidUnitInterpretation(Resqml2_RockFluidUnitInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_RockFluidUnitInterpretation

# Register Resqml20_RockFluidUnitInterpretation in _fesapi:
_fesapi.Resqml20_RockFluidUnitInterpretation_swigregister(Resqml20_RockFluidUnitInterpretation)
class Resqml20_RockFluidOrganizationInterpretation(Resqml2_RockFluidOrganizationInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_RockFluidOrganizationInterpretation

# Register Resqml20_RockFluidOrganizationInterpretation in _fesapi:
_fesapi.Resqml20_RockFluidOrganizationInterpretation_swigregister(Resqml20_RockFluidOrganizationInterpretation)
class Resqml20_StratigraphicOccurrenceInterpretation(Resqml2_StratigraphicOccurrenceInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_StratigraphicOccurrenceInterpretation

# Register Resqml20_StratigraphicOccurrenceInterpretation in _fesapi:
_fesapi.Resqml20_StratigraphicOccurrenceInterpretation_swigregister(Resqml20_StratigraphicOccurrenceInterpretation)
class Resqml20_StratigraphicColumn(Resqml2_StratigraphicColumn):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_StratigraphicColumn

# Register Resqml20_StratigraphicColumn in _fesapi:
_fesapi.Resqml20_StratigraphicColumn_swigregister(Resqml20_StratigraphicColumn)
class Resqml20_EarthModelInterpretation(Resqml2_EarthModelInterpretation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_EarthModelInterpretation

# Register Resqml20_EarthModelInterpretation in _fesapi:
_fesapi.Resqml20_EarthModelInterpretation_swigregister(Resqml20_EarthModelInterpretation)
class Resqml20_SubRepresentation(Resqml2_SubRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_SubRepresentation

# Register Resqml20_SubRepresentation in _fesapi:
_fesapi.Resqml20_SubRepresentation_swigregister(Resqml20_SubRepresentation)
class Resqml20_PolylineSetRepresentation(Resqml2_PolylineSetRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_PolylineSetRepresentation

# Register Resqml20_PolylineSetRepresentation in _fesapi:
_fesapi.Resqml20_PolylineSetRepresentation_swigregister(Resqml20_PolylineSetRepresentation)
class Resqml20_PointSetRepresentation(Resqml2_PointSetRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_PointSetRepresentation

# Register Resqml20_PointSetRepresentation in _fesapi:
_fesapi.Resqml20_PointSetRepresentation_swigregister(Resqml20_PointSetRepresentation)
class Resqml20_PlaneSetRepresentation(Resqml2_PlaneSetRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_PlaneSetRepresentation

# Register Resqml20_PlaneSetRepresentation in _fesapi:
_fesapi.Resqml20_PlaneSetRepresentation_swigregister(Resqml20_PlaneSetRepresentation)
class Resqml20_PolylineRepresentation(Resqml2_PolylineRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_PolylineRepresentation

# Register Resqml20_PolylineRepresentation in _fesapi:
_fesapi.Resqml20_PolylineRepresentation_swigregister(Resqml20_PolylineRepresentation)
class Resqml20_Grid2dRepresentation(Resqml2_Grid2dRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_Grid2dRepresentation

# Register Resqml20_Grid2dRepresentation in _fesapi:
_fesapi.Resqml20_Grid2dRepresentation_swigregister(Resqml20_Grid2dRepresentation)
class Resqml20_TriangulatedSetRepresentation(Resqml2_TriangulatedSetRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_TriangulatedSetRepresentation

# Register Resqml20_TriangulatedSetRepresentation in _fesapi:
_fesapi.Resqml20_TriangulatedSetRepresentation_swigregister(Resqml20_TriangulatedSetRepresentation)
class Resqml20_WellboreTrajectoryRepresentation(Resqml2_WellboreTrajectoryRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setDeviationSurvey(self, deviationSurvey: "Resqml20_DeviationSurveyRepresentation") -> "void":
        r"""
        Sets the deviation survey which is the source of this trajectory.

        :raises: std::invalid_argument	If ``deviationSurvey`` is ``nullptr``.

        :param [in]:	deviationSurvey	The deviation survey to set as a source of this trajectory.
        """
        return _fesapi.Resqml20_WellboreTrajectoryRepresentation_setDeviationSurvey(self, deviationSurvey)

    def getDeviationSurvey(self) -> "resqml2_0_1::DeviationSurveyRepresentation *":
        r"""
        Gets the deviation survey which is the source of this trajectory.

        :rtype: :py:class:`DeviationSurveyRepresentation`
        :return: The deviation survey which is the source of this
            			trajectory if exists, else ``nullptr``.
        """
        return _fesapi.Resqml20_WellboreTrajectoryRepresentation_getDeviationSurvey(self)
    __swig_destroy__ = _fesapi.delete_Resqml20_WellboreTrajectoryRepresentation

# Register Resqml20_WellboreTrajectoryRepresentation in _fesapi:
_fesapi.Resqml20_WellboreTrajectoryRepresentation_swigregister(Resqml20_WellboreTrajectoryRepresentation)
class Resqml20_DeviationSurveyRepresentation(Resqml2_AbstractRepresentation):
    r"""
    A deviation survey representation. It Specifies the station data from a deviation
    			survey.

    			The deviation survey does not provide a complete specification of the geometry of a
    			wellbore trajectory. Although a minimum-curvature algorithm is used in most cases,
    			the implementation varies sufficiently that no single algorithmic specification is
    			available as a data transfer standard.

    			Instead, the geometry of a RESQML wellbore trajectory is represented by a parametric
    			line, parameterized by the MD.

    			CRS and units of measure do not need to be consistent with the CRS and units of
    			measure for wellbore trajectory representation.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setGeometry(self, firstStationLocation: "double const *", stationCount: "uint64_t", mdUom: "gsoap_resqml2_0_1::eml20__LengthUom", mds: "double const *", angleUom: "gsoap_resqml2_0_1::eml20__PlaneAngleUom", azimuths: "double const *", inclinations: "double const *", proxy: "Eml2_AbstractHdfProxy") -> "void":
        r"""
        Sets the geometry of this deviation survey representation.

        :raises: std::invalid_argument	If ``firstStationLocation``, ``mds``, ``azimuths`` or
            ``inclinations`` is @ nullptr.
        :raises: std::invalid_argument	If proxy == nullptr and no default HDF proxy is
            										defined in the repository.

        :type firstStationLocation: float
        :param firstStationLocation:	An array of size 3 containing the coordinates x, y
            											and z of the first station of this deviation survey in
            											the local CRS.
        :type stationCount: int
        :param stationCount:			The number of stations (including the first station).
        :type mdUom: int
        :param mdUom:					The units of measure of the measured depths along
            											this deviation survey.
        :type mds: float
        :param mds:						An array containing the MD values of the stations.
            											The array length equals ``stationCount``.
        :type angleUom: int
        :param angleUom:				The unit of measure of both ``azimuth`` and
            											``inclination`` values.
        :type azimuths: float
        :param azimuths:				An array of azimuth angles, one for each survey
            											station. The rotation is relative to the projected CRS
            											north with a positive value indicating a clockwise
            											rotation as seen from above. Array length equals
            ``stationCount``.
        :type inclinations: float
        :param inclinations:			Inclination (or dip) angle for each station. Array
            											length equals ``stationCount``.
        :param [in,out]:	proxy					The HDF proxy where the numerical values will be
            											stored. It must be already opened for writing and won't
            											be closed. If ``nullptr``, then the default HDF proxy of
            											the repository will be used.
        """
        return _fesapi.Resqml20_DeviationSurveyRepresentation_setGeometry(self, firstStationLocation, stationCount, mdUom, mds, angleUom, azimuths, inclinations, proxy)

    def setMdDatum(self, mdDatum: "Resqml2_MdDatum") -> "void":
        r"""
        Sets the MD datum of this deviation survey representation.

        :raises: std::invalid_argument	If mdDatum == nullptr.

        :param [in]:	mdDatum	The MD datum to set.
        """
        return _fesapi.Resqml20_DeviationSurveyRepresentation_setMdDatum(self, mdDatum)

    def getMdDatum(self) -> "resqml2::MdDatum *":
        r"""
        Gets the MD datum of this deviation survey representation.

        :rtype: :py:class:`MdDatum`
        :return: The MD datum of this deviation survey representation.
        """
        return _fesapi.Resqml20_DeviationSurveyRepresentation_getMdDatum(self)

    def isFinal(self) -> "bool":
        r"""
        Checks whether this is a final version of the deviation survey, as distinct from the
        interim interpretations.

        :rtype: boolean
        :return: True if it is a final version, false if not.
        """
        return _fesapi.Resqml20_DeviationSurveyRepresentation_isFinal(self)

    def getMdUom(self) -> "gsoap_resqml2_0_1::eml20__LengthUom":
        r"""
        Gets the unit of measure of the MDs along this deviation survey.

        :rtype: int
        :return: The unit of measure of the MDs.
        """
        return _fesapi.Resqml20_DeviationSurveyRepresentation_getMdUom(self)

    def getAngleUom(self) -> "gsoap_resqml2_0_1::eml20__PlaneAngleUom":
        r"""
        Gets the unit of measure of the azimuth and inclination angle values of this deviation survey.

        :rtype: int
        :return: The unit of measure of the azimuth and inclination angle values.
        """
        return _fesapi.Resqml20_DeviationSurveyRepresentation_getAngleUom(self)

    def getMdValues(self, values: "double *") -> "void":
        r"""
        Gets the MD double values associated to each trajectory station of this deviation survey
        representation. The uom is given by getMdUom().

        :raises: logic_error	If the data structure used to store the MD values cannot be read for
            							now by fesapi.

        :param [out]:	values	An array to receive the MD double values. It must preallocated with a
            						count of getXyzPointCountOfPatch(0).
        """
        return _fesapi.Resqml20_DeviationSurveyRepresentation_getMdValues(self, values)

    def getInclinations(self, values: "double *") -> "void":
        r"""
        Gets the inclination double values associated to each trajectory station of this deviation
        survey representation. The uom is given by getAngleUom().

        :raises: logic_error	If the data structure used to store the inclination values cannot be
            							read for now by fesapi.

        :param [out]:	values	An array to receive the inclination double values. It must preallocated
            						with a count of getXyzPointCountOfPatch(0).
        """
        return _fesapi.Resqml20_DeviationSurveyRepresentation_getInclinations(self, values)

    def getAzimuths(self, values: "double *") -> "void":
        r"""
        Gets the azimuth double values associated to each trajectory station of this deviation survey
        representation. The rotation is relative to the projected CRS north with a positive value
        indicating a clockwise rotation as seen from above. The uom is given by getAngleUom().

        :raises: logic_error	If the data structure used to store the azimuth values cannot be read
            							for now by fesapi.

        :param [out]:	values	An array to receive the azimuth double values. It must preallocated with
            						a count of getXyzPointCountOfPatch(0).
        """
        return _fesapi.Resqml20_DeviationSurveyRepresentation_getAzimuths(self, values)

    def getWellboreFrameRepresentationCount(self) -> "unsigned int":
        r"""
        Gets the count of wellbore frame representations of the associated wellbore trajectory which
        share the same MD datum and MD uom than this deviation survey representation.

        :rtype: int
        :return: The the count of wellbore frame representations of the associated wellbore trajectory
            			which share the same MD datum and MD uom than this deviation survey representation.
        """
        return _fesapi.Resqml20_DeviationSurveyRepresentation_getWellboreFrameRepresentationCount(self)

    def getWellboreFrameRepresentation(self, index: "unsigned int") -> "resqml2::WellboreFrameRepresentation *":
        r"""
        Gets a particular wellbore frame representation according to its position in the set of all
        the wellbore frame representations of the associated wellbore trajectory which share the same
        MD datum and MD uom than this deviation survey representation.

        :raises: std::invalid_argument If index >=  getWellboreFrameRepresentationCount().

        :type index: int
        :param index: Zero-based index of the wellbore frame representation we look for.

        :rtype: :py:class:`WellboreFrameRepresentation`
        :return: The wellbore frame representation at position ``index`` in the set of all the wellbore
            			frame representations of the associated wellbore trajectory which share the same MD
            			datum and MD uom than this deviation survey representation.
        """
        return _fesapi.Resqml20_DeviationSurveyRepresentation_getWellboreFrameRepresentation(self, index)

    def getWellboreTrajectoryRepresentationCount(self) -> "unsigned int":
        r"""
        Get the count of wellbore trajectories which are associated to this deviation survey.

        :raises: std::range_error	If the count of wellbore trajectories is strictly greater
            									than unsigned int max.

        :rtype: int
        :return: The count of associated wellbore trajectories.
        """
        return _fesapi.Resqml20_DeviationSurveyRepresentation_getWellboreTrajectoryRepresentationCount(self)

    def getWellboreTrajectoryRepresentation(self, index: "unsigned int") -> "resqml2::WellboreTrajectoryRepresentation *":
        r"""
        Gets the associated wellbore trajectory at a particular position.

        :raises: std::out_of_range If index >= getWellboreTrajectoryRepresentationCount().

        :type index: int
        :param index: Zero-based index of the wellbore trajectory we look for.

        :rtype: :py:class:`WellboreTrajectoryRepresentation`
        :return: The associated wellbore trajectory at position ``index``.
        """
        return _fesapi.Resqml20_DeviationSurveyRepresentation_getWellboreTrajectoryRepresentation(self, index)
    __swig_destroy__ = _fesapi.delete_Resqml20_DeviationSurveyRepresentation

# Register Resqml20_DeviationSurveyRepresentation in _fesapi:
_fesapi.Resqml20_DeviationSurveyRepresentation_swigregister(Resqml20_DeviationSurveyRepresentation)
class Resqml20_WellboreFrameRepresentation(Resqml2_WellboreFrameRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_WellboreFrameRepresentation

# Register Resqml20_WellboreFrameRepresentation in _fesapi:
_fesapi.Resqml20_WellboreFrameRepresentation_swigregister(Resqml20_WellboreFrameRepresentation)
class Resqml20_WellboreMarker(Resqml2_WellboreMarker):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_WellboreMarker

# Register Resqml20_WellboreMarker in _fesapi:
_fesapi.Resqml20_WellboreMarker_swigregister(Resqml20_WellboreMarker)
class Resqml20_WellboreMarkerFrameRepresentation(Resqml2_WellboreMarkerFrameRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_WellboreMarkerFrameRepresentation

# Register Resqml20_WellboreMarkerFrameRepresentation in _fesapi:
_fesapi.Resqml20_WellboreMarkerFrameRepresentation_swigregister(Resqml20_WellboreMarkerFrameRepresentation)
class Resqml20_RepresentationSetRepresentation(Resqml2_RepresentationSetRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_RepresentationSetRepresentation

# Register Resqml20_RepresentationSetRepresentation in _fesapi:
_fesapi.Resqml20_RepresentationSetRepresentation_swigregister(Resqml20_RepresentationSetRepresentation)
class Resqml20_NonSealedSurfaceFrameworkRepresentation(Resqml2_NonSealedSurfaceFrameworkRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_NonSealedSurfaceFrameworkRepresentation

# Register Resqml20_NonSealedSurfaceFrameworkRepresentation in _fesapi:
_fesapi.Resqml20_NonSealedSurfaceFrameworkRepresentation_swigregister(Resqml20_NonSealedSurfaceFrameworkRepresentation)
class Resqml20_SealedSurfaceFrameworkRepresentation(Resqml2_SealedSurfaceFrameworkRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_SealedSurfaceFrameworkRepresentation

# Register Resqml20_SealedSurfaceFrameworkRepresentation in _fesapi:
_fesapi.Resqml20_SealedSurfaceFrameworkRepresentation_swigregister(Resqml20_SealedSurfaceFrameworkRepresentation)
class Resqml20_SealedVolumeFrameworkRepresentation(Resqml2_SealedVolumeFrameworkRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_SealedVolumeFrameworkRepresentation

# Register Resqml20_SealedVolumeFrameworkRepresentation in _fesapi:
_fesapi.Resqml20_SealedVolumeFrameworkRepresentation_swigregister(Resqml20_SealedVolumeFrameworkRepresentation)
class Resqml20_UnstructuredGridRepresentation(Resqml2_UnstructuredGridRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_UnstructuredGridRepresentation

# Register Resqml20_UnstructuredGridRepresentation in _fesapi:
_fesapi.Resqml20_UnstructuredGridRepresentation_swigregister(Resqml20_UnstructuredGridRepresentation)
class Resqml20_IjkGridLatticeRepresentation(Resqml2_IjkGridLatticeRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_IjkGridLatticeRepresentation

# Register Resqml20_IjkGridLatticeRepresentation in _fesapi:
_fesapi.Resqml20_IjkGridLatticeRepresentation_swigregister(Resqml20_IjkGridLatticeRepresentation)
class Resqml20_IjkGridExplicitRepresentation(Resqml2_IjkGridExplicitRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_IjkGridExplicitRepresentation

# Register Resqml20_IjkGridExplicitRepresentation in _fesapi:
_fesapi.Resqml20_IjkGridExplicitRepresentation_swigregister(Resqml20_IjkGridExplicitRepresentation)
class Resqml20_IjkGridParametricRepresentation(Resqml2_IjkGridParametricRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_IjkGridParametricRepresentation

# Register Resqml20_IjkGridParametricRepresentation in _fesapi:
_fesapi.Resqml20_IjkGridParametricRepresentation_swigregister(Resqml20_IjkGridParametricRepresentation)
class Resqml20_IjkGridNoGeometryRepresentation(Resqml2_IjkGridNoGeometryRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_IjkGridNoGeometryRepresentation

# Register Resqml20_IjkGridNoGeometryRepresentation in _fesapi:
_fesapi.Resqml20_IjkGridNoGeometryRepresentation_swigregister(Resqml20_IjkGridNoGeometryRepresentation)
class Resqml20_GridConnectionSetRepresentation(Resqml2_GridConnectionSetRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_GridConnectionSetRepresentation

# Register Resqml20_GridConnectionSetRepresentation in _fesapi:
_fesapi.Resqml20_GridConnectionSetRepresentation_swigregister(Resqml20_GridConnectionSetRepresentation)
class Resqml20_BlockedWellboreRepresentation(Resqml2_BlockedWellboreRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_BlockedWellboreRepresentation

# Register Resqml20_BlockedWellboreRepresentation in _fesapi:
_fesapi.Resqml20_BlockedWellboreRepresentation_swigregister(Resqml20_BlockedWellboreRepresentation)
class Resqml20_StreamlinesFeature(Resqml2_StreamlinesFeature):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_StreamlinesFeature

# Register Resqml20_StreamlinesFeature in _fesapi:
_fesapi.Resqml20_StreamlinesFeature_swigregister(Resqml20_StreamlinesFeature)
class Resqml20_StreamlinesRepresentation(Resqml2_StreamlinesRepresentation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_StreamlinesRepresentation

# Register Resqml20_StreamlinesRepresentation in _fesapi:
_fesapi.Resqml20_StreamlinesRepresentation_swigregister(Resqml20_StreamlinesRepresentation)
class Resqml20_TimeSeries(TimeSeries):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_TimeSeries

# Register Resqml20_TimeSeries in _fesapi:
_fesapi.Resqml20_TimeSeries_swigregister(Resqml20_TimeSeries)
class Resqml20_PropertyKind(PropertyKind):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_PropertyKind

# Register Resqml20_PropertyKind in _fesapi:
_fesapi.Resqml20_PropertyKind_swigregister(Resqml20_PropertyKind)
class Resqml20_DoubleTableLookup(Resqml2_DoubleTableLookup):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_DoubleTableLookup

# Register Resqml20_DoubleTableLookup in _fesapi:
_fesapi.Resqml20_DoubleTableLookup_swigregister(Resqml20_DoubleTableLookup)
class Resqml20_StringTableLookup(Resqml2_StringTableLookup):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Resqml20_StringTableLookup

# Register Resqml20_StringTableLookup in _fesapi:
_fesapi.Resqml20_StringTableLookup_swigregister(Resqml20_StringTableLookup)
class Resqml20_PropertySet(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setParent(self, parent: "Resqml20_PropertySet") -> "void":
        r"""
        Sets the parent property set of this instance.

        :raises: std::invalid_argument	If ``parent`` is nullptr.

        :param [in]:	parent	The parent to set to this instance.
        """
        return _fesapi.Resqml20_PropertySet_setParent(self, parent)

    def getParent(self) -> "resqml2_0_1::PropertySet *":
        r"""
        Gets the parent property set of this instance.

        :rtype: :py:class:`PropertySet`
        :return: A pointer to the parent property set or nullptr if no parent property set is defined.
        """
        return _fesapi.Resqml20_PropertySet_getParent(self)

    def getChildrenCount(self) -> "uint64_t":
        r"""
        Gets the count of all children property set of this instance.

        :rtype: int
        :return: The children count.
        """
        return _fesapi.Resqml20_PropertySet_getChildrenCount(self)

    def getChildren(self, index: "unsigned int") -> "resqml2_0_1::PropertySet *":
        r"""
        Gets a particular child property set of this property set.

        :raises: std::out_of_range	If ``index`` is out of range.

        :type index: int
        :param index:	Zero-based index of the child property set we look for.

        :rtype: :py:class:`PropertySet`
        :return: The child property set at position ``index``.
        """
        return _fesapi.Resqml20_PropertySet_getChildren(self, index)

    def pushBackProperty(self, prop: "Resqml2_AbstractProperty") -> "void":
        r"""
        Pushes back a property into this property set.

        :raises: std::invalid_argument	If ``prop`` is nullptr.

        :param [in]:	prop	The property to push into this property set.
        """
        return _fesapi.Resqml20_PropertySet_pushBackProperty(self, prop)

    def getPropertyCount(self) -> "uint64_t":
        r"""
        Gets the count of all properties directly contained in this property set. "Directly
        contained" means that this method does not count properties contained in the children
        property set.

        :rtype: int
        :return: The count of contained properties.
        """
        return _fesapi.Resqml20_PropertySet_getPropertyCount(self)

    def getProperty(self, index: "uint64_t") -> "resqml2::AbstractProperty *":
        r"""
        Gets a particular property among the properties directly contained in this property set.
        "Directly contained" means that this method does not look at properties contained in the
        children property set.

        :raises: std::out_of_range	If ``index`` is out of range.

        :type index: int
        :param index:	Zero-based index of the property we look for.

        :rtype: :py:class:`AbstractProperty`
        :return: The contained property at position ``index``.
        """
        return _fesapi.Resqml20_PropertySet_getProperty(self, index)

    def hasMultipleRealizations(self) -> "bool":
        return _fesapi.Resqml20_PropertySet_hasMultipleRealizations(self)

    def hasSinglePropertyKind(self) -> "bool":
        return _fesapi.Resqml20_PropertySet_hasSinglePropertyKind(self)

    def getTimeSetKind(self) -> "gsoap_resqml2_0_1::resqml20__TimeSetKind":
        return _fesapi.Resqml20_PropertySet_getTimeSetKind(self)
    __swig_destroy__ = _fesapi.delete_Resqml20_PropertySet

# Register Resqml20_PropertySet in _fesapi:
_fesapi.Resqml20_PropertySet_swigregister(Resqml20_PropertySet)
class Resqml20_CommentProperty(Resqml2_CommentProperty):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getEnergisticsPropertyKind(self) -> "gsoap_resqml2_0_1::resqml20__ResqmlPropertyKind":
        return _fesapi.Resqml20_CommentProperty_getEnergisticsPropertyKind(self)
    __swig_destroy__ = _fesapi.delete_Resqml20_CommentProperty

# Register Resqml20_CommentProperty in _fesapi:
_fesapi.Resqml20_CommentProperty_swigregister(Resqml20_CommentProperty)
class Resqml20_ContinuousProperty(Resqml2_ContinuousProperty):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getEnergisticsPropertyKind(self) -> "gsoap_resqml2_0_1::resqml20__ResqmlPropertyKind":
        return _fesapi.Resqml20_ContinuousProperty_getEnergisticsPropertyKind(self)
    __swig_destroy__ = _fesapi.delete_Resqml20_ContinuousProperty

# Register Resqml20_ContinuousProperty in _fesapi:
_fesapi.Resqml20_ContinuousProperty_swigregister(Resqml20_ContinuousProperty)
class Resqml20_DiscreteProperty(Resqml2_DiscreteProperty):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getEnergisticsPropertyKind(self) -> "gsoap_resqml2_0_1::resqml20__ResqmlPropertyKind":
        return _fesapi.Resqml20_DiscreteProperty_getEnergisticsPropertyKind(self)
    __swig_destroy__ = _fesapi.delete_Resqml20_DiscreteProperty

# Register Resqml20_DiscreteProperty in _fesapi:
_fesapi.Resqml20_DiscreteProperty_swigregister(Resqml20_DiscreteProperty)
class Resqml20_CategoricalProperty(Resqml2_CategoricalProperty):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getEnergisticsPropertyKind(self) -> "gsoap_resqml2_0_1::resqml20__ResqmlPropertyKind":
        return _fesapi.Resqml20_CategoricalProperty_getEnergisticsPropertyKind(self)
    __swig_destroy__ = _fesapi.delete_Resqml20_CategoricalProperty

# Register Resqml20_CategoricalProperty in _fesapi:
_fesapi.Resqml20_CategoricalProperty_swigregister(Resqml20_CategoricalProperty)
class Resqml20_PointsProperty(Resqml2_PointsProperty):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getEnergisticsPropertyKind(self) -> "gsoap_resqml2_0_1::resqml20__ResqmlPropertyKind":
        return _fesapi.Resqml20_PointsProperty_getEnergisticsPropertyKind(self)
    __swig_destroy__ = _fesapi.delete_Resqml20_PointsProperty

# Register Resqml20_PointsProperty in _fesapi:
_fesapi.Resqml20_PointsProperty_swigregister(Resqml20_PointsProperty)
class Resqml20_PropertyKindMapper(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def loadMappingFilesFromDirectory(self, directory: "std::string const &") -> "std::string":
        return _fesapi.Resqml20_PropertyKindMapper_loadMappingFilesFromDirectory(self, directory)

    def getApplicationPropertyKindNameFromResqmlStandardPropertyKindName(self, resqmlStandardPropertyKindName: "gsoap_resqml2_0_1::resqml20__ResqmlPropertyKind", application: "std::string const &") -> "std::string":
        return _fesapi.Resqml20_PropertyKindMapper_getApplicationPropertyKindNameFromResqmlStandardPropertyKindName(self, resqmlStandardPropertyKindName, application)

    def getResqmlStandardPropertyKindNameFromApplicationPropertyKindName(self, applicationPropertyKindName: "std::string const &", application: "std::string const &") -> "gsoap_resqml2_0_1::resqml20__ResqmlPropertyKind":
        return _fesapi.Resqml20_PropertyKindMapper_getResqmlStandardPropertyKindNameFromApplicationPropertyKindName(self, applicationPropertyKindName, application)

    def getApplicationPropertyKindNameFromResqmlLocalPropertyKindUuid(self, resqmlLocalPropertyKindUuid: "std::string const &", application: "std::string const &") -> "std::string":
        return _fesapi.Resqml20_PropertyKindMapper_getApplicationPropertyKindNameFromResqmlLocalPropertyKindUuid(self, resqmlLocalPropertyKindUuid, application)

    def getResqmlLocalPropertyKindUuidFromApplicationPropertyKindName(self, applicationPropertyKindName: "std::string const &", application: "std::string const &") -> "std::string":
        return _fesapi.Resqml20_PropertyKindMapper_getResqmlLocalPropertyKindUuidFromApplicationPropertyKindName(self, applicationPropertyKindName, application)

    def addResqmlLocalPropertyKindToEpcDocumentFromApplicationPropertyKindName(self, applicationPropertyKindName: "std::string const &", application: "std::string const &") -> "resqml2_0_1::PropertyKind *":
        return _fesapi.Resqml20_PropertyKindMapper_addResqmlLocalPropertyKindToEpcDocumentFromApplicationPropertyKindName(self, applicationPropertyKindName, application)

    def isChildOf(self, child: "gsoap_resqml2_0_1::resqml20__ResqmlPropertyKind", parent: "gsoap_resqml2_0_1::resqml20__ResqmlPropertyKind") -> "bool":
        return _fesapi.Resqml20_PropertyKindMapper_isChildOf(self, child, parent)

    def isAbstract(self, resqmlStandardPropertyKindName: "gsoap_resqml2_0_1::resqml20__ResqmlPropertyKind") -> "bool":
        return _fesapi.Resqml20_PropertyKindMapper_isAbstract(self, resqmlStandardPropertyKindName)
    __swig_destroy__ = _fesapi.delete_Resqml20_PropertyKindMapper

# Register Resqml20_PropertyKindMapper in _fesapi:
_fesapi.Resqml20_PropertyKindMapper_swigregister(Resqml20_PropertyKindMapper)
eml23__WellStatus_abandoned = _fesapi.eml23__WellStatus_abandoned
eml23__WellStatus_active = _fesapi.eml23__WellStatus_active
eml23__WellStatus_active_x0020_x002d__x0020injecting = _fesapi.eml23__WellStatus_active_x0020_x002d__x0020injecting
eml23__WellStatus_active_x0020_x002d__x0020producing = _fesapi.eml23__WellStatus_active_x0020_x002d__x0020producing
eml23__WellStatus_completed = _fesapi.eml23__WellStatus_completed
eml23__WellStatus_drilling = _fesapi.eml23__WellStatus_drilling
eml23__WellStatus_partially_x0020plugged = _fesapi.eml23__WellStatus_partially_x0020plugged
eml23__WellStatus_permitted = _fesapi.eml23__WellStatus_permitted
eml23__WellStatus_plugged_x0020and_x0020abandoned = _fesapi.eml23__WellStatus_plugged_x0020and_x0020abandoned
eml23__WellStatus_proposed = _fesapi.eml23__WellStatus_proposed
eml23__WellStatus_sold = _fesapi.eml23__WellStatus_sold
eml23__WellStatus_suspended = _fesapi.eml23__WellStatus_suspended
eml23__WellStatus_temporarily_x0020abandoned = _fesapi.eml23__WellStatus_temporarily_x0020abandoned
eml23__WellStatus_testing = _fesapi.eml23__WellStatus_testing
eml23__WellStatus_tight = _fesapi.eml23__WellStatus_tight
eml23__WellStatus_working_x0020over = _fesapi.eml23__WellStatus_working_x0020over
eml23__WellStatus_unknown = _fesapi.eml23__WellStatus_unknown
witsml21__WellPurpose_appraisal = _fesapi.witsml21__WellPurpose_appraisal
witsml21__WellPurpose_appraisal_x0020_x002d__x0020confirmation_x0020appraisal = _fesapi.witsml21__WellPurpose_appraisal_x0020_x002d__x0020confirmation_x0020appraisal
witsml21__WellPurpose_appraisal_x0020_x002d__x0020exploratory_x0020appraisal = _fesapi.witsml21__WellPurpose_appraisal_x0020_x002d__x0020exploratory_x0020appraisal
witsml21__WellPurpose_exploration = _fesapi.witsml21__WellPurpose_exploration
witsml21__WellPurpose_exploration_x0020_x002d__x0020deeper_pool_x0020wildcat = _fesapi.witsml21__WellPurpose_exploration_x0020_x002d__x0020deeper_pool_x0020wildcat
witsml21__WellPurpose_exploration_x0020_x002d__x0020new_field_x0020wildcat = _fesapi.witsml21__WellPurpose_exploration_x0020_x002d__x0020new_field_x0020wildcat
witsml21__WellPurpose_exploration_x0020_x002d__x0020new_pool_x0020wildcat = _fesapi.witsml21__WellPurpose_exploration_x0020_x002d__x0020new_pool_x0020wildcat
witsml21__WellPurpose_exploration_x0020_x002d__x0020outpost_x0020wildcat = _fesapi.witsml21__WellPurpose_exploration_x0020_x002d__x0020outpost_x0020wildcat
witsml21__WellPurpose_exploration_x0020_x002d__x0020shallower_pool_x0020wildcat = _fesapi.witsml21__WellPurpose_exploration_x0020_x002d__x0020shallower_pool_x0020wildcat
witsml21__WellPurpose_development = _fesapi.witsml21__WellPurpose_development
witsml21__WellPurpose_development_x0020_x002d__x0020infill_x0020development = _fesapi.witsml21__WellPurpose_development_x0020_x002d__x0020infill_x0020development
witsml21__WellPurpose_development_x0020_x002d__x0020injector = _fesapi.witsml21__WellPurpose_development_x0020_x002d__x0020injector
witsml21__WellPurpose_development_x0020_x002d__x0020producer = _fesapi.witsml21__WellPurpose_development_x0020_x002d__x0020producer
witsml21__WellPurpose_fluid_x0020storage = _fesapi.witsml21__WellPurpose_fluid_x0020storage
witsml21__WellPurpose_fluid_x0020storage_x0020_x002d__x0020gas_x0020storage = _fesapi.witsml21__WellPurpose_fluid_x0020storage_x0020_x002d__x0020gas_x0020storage
witsml21__WellPurpose_general_x0020srvc = _fesapi.witsml21__WellPurpose_general_x0020srvc
witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020borehole_x0020re_acquisition = _fesapi.witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020borehole_x0020re_acquisition
witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020observation = _fesapi.witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020observation
witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020relief = _fesapi.witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020relief
witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020research = _fesapi.witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020research
witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020research_x0020_x002d__x0020drill_x0020test = _fesapi.witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020research_x0020_x002d__x0020drill_x0020test
witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020research_x0020_x002d__x0020strat_x0020test = _fesapi.witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020research_x0020_x002d__x0020strat_x0020test
witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020waste_x0020disposal = _fesapi.witsml21__WellPurpose_general_x0020srvc_x0020_x002d__x0020waste_x0020disposal
witsml21__WellPurpose_mineral = _fesapi.witsml21__WellPurpose_mineral
witsml21__WellFluid_air = _fesapi.witsml21__WellFluid_air
witsml21__WellFluid_condensate = _fesapi.witsml21__WellFluid_condensate
witsml21__WellFluid_dry = _fesapi.witsml21__WellFluid_dry
witsml21__WellFluid_gas = _fesapi.witsml21__WellFluid_gas
witsml21__WellFluid_gas_water = _fesapi.witsml21__WellFluid_gas_water
witsml21__WellFluid_non_x0020HC_x0020gas = _fesapi.witsml21__WellFluid_non_x0020HC_x0020gas
witsml21__WellFluid_non_x0020HC_x0020gas_x0020_x002d__x0020CO2 = _fesapi.witsml21__WellFluid_non_x0020HC_x0020gas_x0020_x002d__x0020CO2
witsml21__WellFluid_oil = _fesapi.witsml21__WellFluid_oil
witsml21__WellFluid_oil_gas = _fesapi.witsml21__WellFluid_oil_gas
witsml21__WellFluid_oil_water = _fesapi.witsml21__WellFluid_oil_water
witsml21__WellFluid_steam = _fesapi.witsml21__WellFluid_steam
witsml21__WellFluid_water = _fesapi.witsml21__WellFluid_water
witsml21__WellFluid_water_x0020_x002d__x0020brine = _fesapi.witsml21__WellFluid_water_x0020_x002d__x0020brine
witsml21__WellFluid_water_x0020_x002d__x0020fresh_x0020water = _fesapi.witsml21__WellFluid_water_x0020_x002d__x0020fresh_x0020water
witsml21__WellDirection_huff_n_puff = _fesapi.witsml21__WellDirection_huff_n_puff
witsml21__WellDirection_injector = _fesapi.witsml21__WellDirection_injector
witsml21__WellDirection_producer = _fesapi.witsml21__WellDirection_producer
witsml21__WellDirection_uncertain = _fesapi.witsml21__WellDirection_uncertain
eml23__ReferencePointKind_casing_x0020flange = _fesapi.eml23__ReferencePointKind_casing_x0020flange
eml23__ReferencePointKind_crown_x0020valve = _fesapi.eml23__ReferencePointKind_crown_x0020valve
eml23__ReferencePointKind_derrick_x0020floor = _fesapi.eml23__ReferencePointKind_derrick_x0020floor
eml23__ReferencePointKind_ground_x0020level = _fesapi.eml23__ReferencePointKind_ground_x0020level
eml23__ReferencePointKind_kelly_x0020bushing = _fesapi.eml23__ReferencePointKind_kelly_x0020bushing
eml23__ReferencePointKind_kickoff_x0020point = _fesapi.eml23__ReferencePointKind_kickoff_x0020point
eml23__ReferencePointKind_lowest_x0020astronomical_x0020tide = _fesapi.eml23__ReferencePointKind_lowest_x0020astronomical_x0020tide
eml23__ReferencePointKind_mean_x0020high_x0020water = _fesapi.eml23__ReferencePointKind_mean_x0020high_x0020water
eml23__ReferencePointKind_mean_x0020higher_x0020high_x0020water = _fesapi.eml23__ReferencePointKind_mean_x0020higher_x0020high_x0020water
eml23__ReferencePointKind_mean_x0020low_x0020water = _fesapi.eml23__ReferencePointKind_mean_x0020low_x0020water
eml23__ReferencePointKind_mean_x0020lower_x0020low_x0020water = _fesapi.eml23__ReferencePointKind_mean_x0020lower_x0020low_x0020water
eml23__ReferencePointKind_mean_x0020sea_x0020level = _fesapi.eml23__ReferencePointKind_mean_x0020sea_x0020level
eml23__ReferencePointKind_mean_x0020tide_x0020level = _fesapi.eml23__ReferencePointKind_mean_x0020tide_x0020level
eml23__ReferencePointKind_rotary_x0020bushing = _fesapi.eml23__ReferencePointKind_rotary_x0020bushing
eml23__ReferencePointKind_rotary_x0020table = _fesapi.eml23__ReferencePointKind_rotary_x0020table
eml23__ReferencePointKind_seafloor = _fesapi.eml23__ReferencePointKind_seafloor
eml23__ReferencePointKind_wellhead = _fesapi.eml23__ReferencePointKind_wellhead
eml23__ReferencePointKind_well_x0020surface_x0020location = _fesapi.eml23__ReferencePointKind_well_x0020surface_x0020location
eml23__NorthReferenceKind_astronomic_x0020north = _fesapi.eml23__NorthReferenceKind_astronomic_x0020north
eml23__NorthReferenceKind_compass_x0020north = _fesapi.eml23__NorthReferenceKind_compass_x0020north
eml23__NorthReferenceKind_grid_x0020north = _fesapi.eml23__NorthReferenceKind_grid_x0020north
eml23__NorthReferenceKind_magnetic_x0020north = _fesapi.eml23__NorthReferenceKind_magnetic_x0020north
eml23__NorthReferenceKind_plant_x0020north = _fesapi.eml23__NorthReferenceKind_plant_x0020north
eml23__NorthReferenceKind_true_x0020north = _fesapi.eml23__NorthReferenceKind_true_x0020north
witsml21__WellboreType_bypass = _fesapi.witsml21__WellboreType_bypass
witsml21__WellboreType_initial = _fesapi.witsml21__WellboreType_initial
witsml21__WellboreType_redrill = _fesapi.witsml21__WellboreType_redrill
witsml21__WellboreType_reentry = _fesapi.witsml21__WellboreType_reentry
witsml21__WellboreType_respud = _fesapi.witsml21__WellboreType_respud
witsml21__WellboreType_sidetrack = _fesapi.witsml21__WellboreType_sidetrack
witsml21__WellboreShape_build_x0020and_x0020hold = _fesapi.witsml21__WellboreShape_build_x0020and_x0020hold
witsml21__WellboreShape_deviated = _fesapi.witsml21__WellboreShape_deviated
witsml21__WellboreShape_double_x0020kickoff = _fesapi.witsml21__WellboreShape_double_x0020kickoff
witsml21__WellboreShape_horizontal = _fesapi.witsml21__WellboreShape_horizontal
witsml21__WellboreShape_S_shaped = _fesapi.witsml21__WellboreShape_S_shaped
witsml21__WellboreShape_vertical = _fesapi.witsml21__WellboreShape_vertical
witsml21__PhysicalStatus_closed = _fesapi.witsml21__PhysicalStatus_closed
witsml21__PhysicalStatus_open = _fesapi.witsml21__PhysicalStatus_open
witsml21__PhysicalStatus_proposed = _fesapi.witsml21__PhysicalStatus_proposed
witsml21__TrajStationType_azimuth_x0020on_x0020plane = _fesapi.witsml21__TrajStationType_azimuth_x0020on_x0020plane
witsml21__TrajStationType_buildrate_x0020to_x0020delta_MD = _fesapi.witsml21__TrajStationType_buildrate_x0020to_x0020delta_MD
witsml21__TrajStationType_buildrate_x0020to_x0020INCL = _fesapi.witsml21__TrajStationType_buildrate_x0020to_x0020INCL
witsml21__TrajStationType_buildrate_x0020to_x0020MD = _fesapi.witsml21__TrajStationType_buildrate_x0020to_x0020MD
witsml21__TrajStationType_buildrate_x0020and_x0020turnrate_x0020to_x0020AZI = _fesapi.witsml21__TrajStationType_buildrate_x0020and_x0020turnrate_x0020to_x0020AZI
witsml21__TrajStationType_buildrate_x0020and_x0020turnrate_x0020to_x0020delta_MD = _fesapi.witsml21__TrajStationType_buildrate_x0020and_x0020turnrate_x0020to_x0020delta_MD
witsml21__TrajStationType_buildrate_x0020and_x0020turnrate_x0020to_x0020INCL = _fesapi.witsml21__TrajStationType_buildrate_x0020and_x0020turnrate_x0020to_x0020INCL
witsml21__TrajStationType_buildrate_x0020and_x0020turnrate_x0020to_x0020INCL_x0020and_x0020AZI = _fesapi.witsml21__TrajStationType_buildrate_x0020and_x0020turnrate_x0020to_x0020INCL_x0020and_x0020AZI
witsml21__TrajStationType_buildrate_x0020and_x0020turnrate_x0020to_x0020MD = _fesapi.witsml21__TrajStationType_buildrate_x0020and_x0020turnrate_x0020to_x0020MD
witsml21__TrajStationType_buildrate_x0020and_x0020turnrate_x0020to_x0020TVD = _fesapi.witsml21__TrajStationType_buildrate_x0020and_x0020turnrate_x0020to_x0020TVD
witsml21__TrajStationType_buildrate_x0020TVD = _fesapi.witsml21__TrajStationType_buildrate_x0020TVD
witsml21__TrajStationType_casing_x0020MD = _fesapi.witsml21__TrajStationType_casing_x0020MD
witsml21__TrajStationType_casing_x0020TVD = _fesapi.witsml21__TrajStationType_casing_x0020TVD
witsml21__TrajStationType_DLS = _fesapi.witsml21__TrajStationType_DLS
witsml21__TrajStationType_DLS_x0020to_x0020AZI_x0020and_x0020MD = _fesapi.witsml21__TrajStationType_DLS_x0020to_x0020AZI_x0020and_x0020MD
witsml21__TrajStationType_DLS_x0020to_x0020AZI_TVD = _fesapi.witsml21__TrajStationType_DLS_x0020to_x0020AZI_TVD
witsml21__TrajStationType_DLS_x0020to_x0020INCL = _fesapi.witsml21__TrajStationType_DLS_x0020to_x0020INCL
witsml21__TrajStationType_DLS_x0020to_x0020INCL_x0020and_x0020AZI = _fesapi.witsml21__TrajStationType_DLS_x0020to_x0020INCL_x0020and_x0020AZI
witsml21__TrajStationType_DLS_x0020to_x0020INCL_x0020and_x0020MD = _fesapi.witsml21__TrajStationType_DLS_x0020to_x0020INCL_x0020and_x0020MD
witsml21__TrajStationType_DLS_x0020to_x0020INCL_x0020and_x0020TVD = _fesapi.witsml21__TrajStationType_DLS_x0020to_x0020INCL_x0020and_x0020TVD
witsml21__TrajStationType_DLS_x0020to_x0020NS = _fesapi.witsml21__TrajStationType_DLS_x0020to_x0020NS
witsml21__TrajStationType_DLS_x0020and_x0020toolface_x0020to_x0020AZI = _fesapi.witsml21__TrajStationType_DLS_x0020and_x0020toolface_x0020to_x0020AZI
witsml21__TrajStationType_DLS_x0020and_x0020toolface_x0020to_x0020delta_MD = _fesapi.witsml21__TrajStationType_DLS_x0020and_x0020toolface_x0020to_x0020delta_MD
witsml21__TrajStationType_DLS_x0020and_x0020toolface_x0020to_x0020INCL = _fesapi.witsml21__TrajStationType_DLS_x0020and_x0020toolface_x0020to_x0020INCL
witsml21__TrajStationType_DLS_x0020and_x0020toolface_x0020to_x0020INCL_AZI = _fesapi.witsml21__TrajStationType_DLS_x0020and_x0020toolface_x0020to_x0020INCL_AZI
witsml21__TrajStationType_DLS_x0020and_x0020toolface_x0020to_x0020MD = _fesapi.witsml21__TrajStationType_DLS_x0020and_x0020toolface_x0020to_x0020MD
witsml21__TrajStationType_DLS_x0020and_x0020toolface_x0020to_x0020TVD = _fesapi.witsml21__TrajStationType_DLS_x0020and_x0020toolface_x0020to_x0020TVD
witsml21__TrajStationType_extrapolated = _fesapi.witsml21__TrajStationType_extrapolated
witsml21__TrajStationType_formation_x0020MD = _fesapi.witsml21__TrajStationType_formation_x0020MD
witsml21__TrajStationType_formation_x0020TVD = _fesapi.witsml21__TrajStationType_formation_x0020TVD
witsml21__TrajStationType_hold_x0020to_x0020delta_MD = _fesapi.witsml21__TrajStationType_hold_x0020to_x0020delta_MD
witsml21__TrajStationType_hold_x0020to_x0020MD = _fesapi.witsml21__TrajStationType_hold_x0020to_x0020MD
witsml21__TrajStationType_hold_x0020to_x0020TVD = _fesapi.witsml21__TrajStationType_hold_x0020to_x0020TVD
witsml21__TrajStationType_INCL_x0020AZI_x0020and_x0020TVD = _fesapi.witsml21__TrajStationType_INCL_x0020AZI_x0020and_x0020TVD
witsml21__TrajStationType_interpolated = _fesapi.witsml21__TrajStationType_interpolated
witsml21__TrajStationType_marker_x0020MD = _fesapi.witsml21__TrajStationType_marker_x0020MD
witsml21__TrajStationType_marker_x0020TVD = _fesapi.witsml21__TrajStationType_marker_x0020TVD
witsml21__TrajStationType_MD_x0020and_x0020INCL = _fesapi.witsml21__TrajStationType_MD_x0020and_x0020INCL
witsml21__TrajStationType_MD_x0020INCL_x0020and_x0020AZI = _fesapi.witsml21__TrajStationType_MD_x0020INCL_x0020and_x0020AZI
witsml21__TrajStationType_N_x0020E_x0020and_x0020TVD = _fesapi.witsml21__TrajStationType_N_x0020E_x0020and_x0020TVD
witsml21__TrajStationType_NS_x0020EW_x0020and_x0020TVD = _fesapi.witsml21__TrajStationType_NS_x0020EW_x0020and_x0020TVD
witsml21__TrajStationType_target_x0020center = _fesapi.witsml21__TrajStationType_target_x0020center
witsml21__TrajStationType_target_x0020offset = _fesapi.witsml21__TrajStationType_target_x0020offset
witsml21__TrajStationType_tie_x0020in_x0020point = _fesapi.witsml21__TrajStationType_tie_x0020in_x0020point
witsml21__TrajStationType_turnrate_x0020to_x0020AZI = _fesapi.witsml21__TrajStationType_turnrate_x0020to_x0020AZI
witsml21__TrajStationType_turnrate_x0020to_x0020delta_MD = _fesapi.witsml21__TrajStationType_turnrate_x0020to_x0020delta_MD
witsml21__TrajStationType_turnrate_x0020to_x0020MD = _fesapi.witsml21__TrajStationType_turnrate_x0020to_x0020MD
witsml21__TrajStationType_turnrate_x0020to_x0020TVD = _fesapi.witsml21__TrajStationType_turnrate_x0020to_x0020TVD
witsml21__TrajStationType_unknown = _fesapi.witsml21__TrajStationType_unknown
witsml21__TypeSurveyTool_gyroscopic_x0020inertial = _fesapi.witsml21__TypeSurveyTool_gyroscopic_x0020inertial
witsml21__TypeSurveyTool_gyroscopic_x0020MWD = _fesapi.witsml21__TypeSurveyTool_gyroscopic_x0020MWD
witsml21__TypeSurveyTool_gyroscopic_x0020north_x0020seeking = _fesapi.witsml21__TypeSurveyTool_gyroscopic_x0020north_x0020seeking
witsml21__TypeSurveyTool_magnetic_x0020multiple_shot = _fesapi.witsml21__TypeSurveyTool_magnetic_x0020multiple_shot
witsml21__TypeSurveyTool_magnetic_x0020MWD = _fesapi.witsml21__TypeSurveyTool_magnetic_x0020MWD
witsml21__TypeSurveyTool_magnetic_x0020single_shot = _fesapi.witsml21__TypeSurveyTool_magnetic_x0020single_shot
witsml21__TrajStnCalcAlgorithm_average_x0020angle = _fesapi.witsml21__TrajStnCalcAlgorithm_average_x0020angle
witsml21__TrajStnCalcAlgorithm_balanced_x0020tangential = _fesapi.witsml21__TrajStnCalcAlgorithm_balanced_x0020tangential
witsml21__TrajStnCalcAlgorithm_constant_x0020tool_x0020face = _fesapi.witsml21__TrajStnCalcAlgorithm_constant_x0020tool_x0020face
witsml21__TrajStnCalcAlgorithm_custom = _fesapi.witsml21__TrajStnCalcAlgorithm_custom
witsml21__TrajStnCalcAlgorithm_inertial = _fesapi.witsml21__TrajStnCalcAlgorithm_inertial
witsml21__TrajStnCalcAlgorithm_minimum_x0020curvature = _fesapi.witsml21__TrajStnCalcAlgorithm_minimum_x0020curvature
witsml21__TrajStnCalcAlgorithm_radius_x0020of_x0020curvature = _fesapi.witsml21__TrajStnCalcAlgorithm_radius_x0020of_x0020curvature
witsml21__TrajStnCalcAlgorithm_tangential = _fesapi.witsml21__TrajStnCalcAlgorithm_tangential
witsml21__TrajStationStatus_open = _fesapi.witsml21__TrajStationStatus_open
witsml21__TrajStationStatus_rejected = _fesapi.witsml21__TrajStationStatus_rejected
witsml21__TrajStationStatus_position = _fesapi.witsml21__TrajStationStatus_position
witsml21__HoleCasingType_blow_x0020out_x0020preventer = _fesapi.witsml21__HoleCasingType_blow_x0020out_x0020preventer
witsml21__HoleCasingType_casing = _fesapi.witsml21__HoleCasingType_casing
witsml21__HoleCasingType_conductor = _fesapi.witsml21__HoleCasingType_conductor
witsml21__HoleCasingType_curved_x0020conductor = _fesapi.witsml21__HoleCasingType_curved_x0020conductor
witsml21__HoleCasingType_liner = _fesapi.witsml21__HoleCasingType_liner
witsml21__HoleCasingType_open_x0020hole = _fesapi.witsml21__HoleCasingType_open_x0020hole
witsml21__HoleCasingType_riser = _fesapi.witsml21__HoleCasingType_riser
witsml21__HoleCasingType_tubing = _fesapi.witsml21__HoleCasingType_tubing
witsml21__ChannelDataKind_boolean = _fesapi.witsml21__ChannelDataKind_boolean
witsml21__ChannelDataKind_bytes = _fesapi.witsml21__ChannelDataKind_bytes
witsml21__ChannelDataKind_double_ = _fesapi.witsml21__ChannelDataKind_double_
witsml21__ChannelDataKind_float_ = _fesapi.witsml21__ChannelDataKind_float_
witsml21__ChannelDataKind_int_ = _fesapi.witsml21__ChannelDataKind_int_
witsml21__ChannelDataKind_long_ = _fesapi.witsml21__ChannelDataKind_long_
witsml21__ChannelDataKind_string = _fesapi.witsml21__ChannelDataKind_string
witsml21__ChannelDataKind_measured_x0020depth = _fesapi.witsml21__ChannelDataKind_measured_x0020depth
witsml21__ChannelDataKind_true_x0020vertical_x0020depth = _fesapi.witsml21__ChannelDataKind_true_x0020vertical_x0020depth
witsml21__ChannelDataKind_pass_x0020indexed_x0020depth = _fesapi.witsml21__ChannelDataKind_pass_x0020indexed_x0020depth
witsml21__ChannelDataKind_date_x0020time = _fesapi.witsml21__ChannelDataKind_date_x0020time
witsml21__ChannelDataKind_elapsed_x0020time = _fesapi.witsml21__ChannelDataKind_elapsed_x0020time
class Witsml2_Well(AbstractObject):
    r"""Contains all information that is the same for all wellbores (sidetracks)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setNameLegal(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Well_setNameLegal(self, value)

    def getNameLegal(self) -> "std::string":
        return _fesapi.Witsml2_Well_getNameLegal(self)

    def hasNameLegal(self) -> "bool":
        return _fesapi.Witsml2_Well_hasNameLegal(self)

    def setNumLicense(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Well_setNumLicense(self, value)

    def getNumLicense(self) -> "std::string":
        return _fesapi.Witsml2_Well_getNumLicense(self)

    def hasNumLicense(self) -> "bool":
        return _fesapi.Witsml2_Well_hasNumLicense(self)

    def setNumGovt(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Well_setNumGovt(self, value)

    def getNumGovt(self) -> "std::string":
        return _fesapi.Witsml2_Well_getNumGovt(self)

    def hasNumGovt(self) -> "bool":
        return _fesapi.Witsml2_Well_hasNumGovt(self)

    def setField(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Well_setField(self, value)

    def getField(self) -> "std::string":
        return _fesapi.Witsml2_Well_getField(self)

    def hasField(self) -> "bool":
        return _fesapi.Witsml2_Well_hasField(self)

    def setCountry(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Well_setCountry(self, value)

    def getCountry(self) -> "std::string":
        return _fesapi.Witsml2_Well_getCountry(self)

    def hasCountry(self) -> "bool":
        return _fesapi.Witsml2_Well_hasCountry(self)

    def setState(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Well_setState(self, value)

    def getState(self) -> "std::string":
        return _fesapi.Witsml2_Well_getState(self)

    def hasState(self) -> "bool":
        return _fesapi.Witsml2_Well_hasState(self)

    def setCounty(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Well_setCounty(self, value)

    def getCounty(self) -> "std::string":
        return _fesapi.Witsml2_Well_getCounty(self)

    def hasCounty(self) -> "bool":
        return _fesapi.Witsml2_Well_hasCounty(self)

    def setRegion(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Well_setRegion(self, value)

    def getRegion(self) -> "std::string":
        return _fesapi.Witsml2_Well_getRegion(self)

    def hasRegion(self) -> "bool":
        return _fesapi.Witsml2_Well_hasRegion(self)

    def setDistrict(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Well_setDistrict(self, value)

    def getDistrict(self) -> "std::string":
        return _fesapi.Witsml2_Well_getDistrict(self)

    def hasDistrict(self) -> "bool":
        return _fesapi.Witsml2_Well_hasDistrict(self)

    def setBlock(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Well_setBlock(self, value)

    def getBlock(self) -> "std::string":
        return _fesapi.Witsml2_Well_getBlock(self)

    def hasBlock(self) -> "bool":
        return _fesapi.Witsml2_Well_hasBlock(self)

    def setOperatorDiv(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Well_setOperatorDiv(self, value)

    def getOperatorDiv(self) -> "std::string":
        return _fesapi.Witsml2_Well_getOperatorDiv(self)

    def hasOperatorDiv(self) -> "bool":
        return _fesapi.Witsml2_Well_hasOperatorDiv(self)

    def setNumAPI(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Well_setNumAPI(self, value)

    def getNumAPI(self) -> "std::string":
        return _fesapi.Witsml2_Well_getNumAPI(self)

    def hasNumAPI(self) -> "bool":
        return _fesapi.Witsml2_Well_hasNumAPI(self)

    def setStatusWell(self, value: "gsoap_eml2_3::eml23__WellStatus const &") -> "void":
        return _fesapi.Witsml2_Well_setStatusWell(self, value)

    def getStatusWell(self) -> "gsoap_eml2_3::eml23__WellStatus":
        return _fesapi.Witsml2_Well_getStatusWell(self)

    def hasStatusWell(self) -> "bool":
        return _fesapi.Witsml2_Well_hasStatusWell(self)

    def setPurposeWell(self, value: "gsoap_eml2_3::witsml21__WellPurpose const &") -> "void":
        return _fesapi.Witsml2_Well_setPurposeWell(self, value)

    def getPurposeWell(self) -> "gsoap_eml2_3::witsml21__WellPurpose":
        return _fesapi.Witsml2_Well_getPurposeWell(self)

    def hasPurposeWell(self) -> "bool":
        return _fesapi.Witsml2_Well_hasPurposeWell(self)

    def setFluidWell(self, value: "gsoap_eml2_3::witsml21__WellFluid const &") -> "void":
        return _fesapi.Witsml2_Well_setFluidWell(self, value)

    def getFluidWell(self) -> "gsoap_eml2_3::witsml21__WellFluid":
        return _fesapi.Witsml2_Well_getFluidWell(self)

    def hasFluidWell(self) -> "bool":
        return _fesapi.Witsml2_Well_hasFluidWell(self)

    def setDirectionWell(self, value: "gsoap_eml2_3::witsml21__WellDirection const &") -> "void":
        return _fesapi.Witsml2_Well_setDirectionWell(self, value)

    def getDirectionWell(self) -> "gsoap_eml2_3::witsml21__WellDirection":
        return _fesapi.Witsml2_Well_getDirectionWell(self)

    def hasDirectionWell(self) -> "bool":
        return _fesapi.Witsml2_Well_hasDirectionWell(self)

    def setWaterDepth(self, value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml2_Well_setWaterDepth(self, value, uom)

    def getWaterDepthValue(self) -> "double":
        return _fesapi.Witsml2_Well_getWaterDepthValue(self)

    def getWaterDepthUom(self) -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml2_Well_getWaterDepthUom(self)

    def hasWaterDepth(self) -> "bool":
        return _fesapi.Witsml2_Well_hasWaterDepth(self)

    def hasGroundElevation(self) -> "bool":
        return _fesapi.Witsml2_Well_hasGroundElevation(self)

    def setPcInterest(self, value: "double", uom: "gsoap_eml2_3::eml23__DimensionlessUom") -> "void":
        return _fesapi.Witsml2_Well_setPcInterest(self, value, uom)

    def getPcInterestValue(self) -> "double":
        return _fesapi.Witsml2_Well_getPcInterestValue(self)

    def getPcInterestUom(self) -> "gsoap_eml2_3::eml23__DimensionlessUom":
        return _fesapi.Witsml2_Well_getPcInterestUom(self)

    def hasPcInterest(self) -> "bool":
        return _fesapi.Witsml2_Well_hasPcInterest(self)

    def setDTimLicense(self, value: "time_t const &") -> "void":
        return _fesapi.Witsml2_Well_setDTimLicense(self, value)

    def getDTimLicense(self) -> "time_t":
        return _fesapi.Witsml2_Well_getDTimLicense(self)

    def hasDTimLicense(self) -> "bool":
        return _fesapi.Witsml2_Well_hasDTimLicense(self)

    def setDTimSpud(self, value: "time_t const &") -> "void":
        return _fesapi.Witsml2_Well_setDTimSpud(self, value)

    def getDTimSpud(self) -> "time_t":
        return _fesapi.Witsml2_Well_getDTimSpud(self)

    def hasDTimSpud(self) -> "bool":
        return _fesapi.Witsml2_Well_hasDTimSpud(self)

    def setDTimPa(self, value: "time_t const &") -> "void":
        return _fesapi.Witsml2_Well_setDTimPa(self, value)

    def getDTimPa(self) -> "time_t":
        return _fesapi.Witsml2_Well_getDTimPa(self)

    def hasDTimPa(self) -> "bool":
        return _fesapi.Witsml2_Well_hasDTimPa(self)

    def setGroundElevation(self, value: "double", uom: "gsoap_eml2_3::eml23__LengthUom", verticalCrs: "Eml23_VerticalCrs") -> "void":
        r"""
        Sets the ground level elevation (land rigs)

        :raises: std::invalid_argument	If ``value`` is undefined.

        :type value: float
        :param value:		The elevation value.
        :type uom: int
        :param uom:  		The elevation unit of measure.
        :type verticalCrs: :py:class:`VerticalCrs`
        :param verticalCrs:	The vertical CRS which is used as the datum for the ground elevation
        """
        return _fesapi.Witsml2_Well_setGroundElevation(self, value, uom, verticalCrs)

    def getGroundElevationValue(self) -> "double":
        r"""
        Gets the ground level elevation value

        :raises: std::invalid_argument	If the ground elevation does not exist.

        :rtype: float
        :return: The ground level elevation value.
        """
        return _fesapi.Witsml2_Well_getGroundElevationValue(self)

    def getGroundElevationUom(self) -> "gsoap_eml2_3::eml23__LengthUom":
        r"""
        Gets the ground level elevation unit of measure

        :raises: std::invalid_argument	If the ground elevation does not exist.

        :rtype: int
        :return: The ground level elevation unit of measure.
        """
        return _fesapi.Witsml2_Well_getGroundElevationUom(self)

    def getGroundElevationDatum(self) -> "eml2_3::VerticalCrs *":
        r"""
        Gets the vertical CRS which acts as the datum of this ground elevation.

        :rtype: :py:class:`VerticalCrs`
        :return: The vertical CRS which acts as the datum of this ground elevation..
        """
        return _fesapi.Witsml2_Well_getGroundElevationDatum(self)

    def setWellheadElevation(self, value: "double", uom: "gsoap_eml2_3::eml23__LengthUom", verticalCrs: "Eml23_VerticalCrs") -> "void":
        r"""
        Sets the well head elevation

        :raises: std::invalid_argument	If ``value`` is undefined.

        :type value: float
        :param value:		The elevation value.
        :type uom: int
        :param uom:  		The elevation unit of measure.
        :type verticalCrs: :py:class:`VerticalCrs`
        :param verticalCrs:	The vertical CRS which is used as the datum for the well head elevation
        """
        return _fesapi.Witsml2_Well_setWellheadElevation(self, value, uom, verticalCrs)

    def getWellheadElevationValue(self) -> "double":
        r"""
        Gets the well head elevation value

        :raises: std::invalid_argument	If the well head elevation does not exist.

        :rtype: float
        :return: The well head elevation value.
        """
        return _fesapi.Witsml2_Well_getWellheadElevationValue(self)

    def getWellheadElevationUom(self) -> "gsoap_eml2_3::eml23__LengthUom":
        r"""
        Gets the well head elevation unit of measure

        :raises: std::invalid_argument	If the well head elevation does not exist.

        :rtype: int
        :return: The well head elevation unit of measure.
        """
        return _fesapi.Witsml2_Well_getWellheadElevationUom(self)

    def getWellheadElevationDatum(self) -> "eml2_3::VerticalCrs *":
        r"""
        Gets the vertical CRS which acts as the datum of this well head elevation.

        :rtype: :py:class:`VerticalCrs`
        :return: The vertical CRS which acts as the datum of this well head elevation..
        """
        return _fesapi.Witsml2_Well_getWellheadElevationDatum(self)

    def setTimeZone(self, direction: "bool", hours: "unsigned short", minutes: "unsigned short") -> "void":
        r"""
        Set the time zone in which the well is located.It is the deviation in hours and minutes from
        UTC.This should be the normal time zone at the well and not a seasonally-adjusted value,
        such as daylight savings time

        :type direction: boolean
        :param direction:	True means the time zone is a positive offset from UTC, false means the
            						time zone is a negative offset from UTC.
        :type hours: int
        :param hours:	 	The deviation hours from UTC.
        :type minutes: int
        :param minutes:		The deviation minutes from UTC.
        """
        return _fesapi.Witsml2_Well_setTimeZone(self, direction, hours, minutes)

    def hasTimeZone(self) -> "bool":
        return _fesapi.Witsml2_Well_hasTimeZone(self)

    def getTimeZoneDirection(self) -> "bool":
        r"""
        Get the time zone direction in which the well is located.

        :rtype: boolean
        :return: True means the time zone is a positive offset from UTC, false means the time zone is
            			a negative offset from UTC. If the time zone is Z then an arbitrary '+' is returned.
        """
        return _fesapi.Witsml2_Well_getTimeZoneDirection(self)

    def getTimeZoneHours(self) -> "unsigned short":
        r"""
        Get the time zone hour(s) in which the well is located. Must be used with
        getTimeZoneDirection and getTimeZoneMinute() to have the complete time zone.

        :rtype: int
        :return: the deviation hour(s) from UTC.
        """
        return _fesapi.Witsml2_Well_getTimeZoneHours(self)

    def getTimeZoneMinutes(self) -> "unsigned short":
        r"""
        Get the time zone minute(s) in which the well is located. Must be used with
        getTimeZoneDirection and getTimeZoneHour() to have the complete time zone.

        :rtype: int
        :return: the deviation minute(s) from UTC.
        """
        return _fesapi.Witsml2_Well_getTimeZoneMinutes(self)

    def getLocationProjectedX(self, locationIndex: "uint64_t") -> "double":
        r"""
        Gets location projected x coordinate

        :type locationIndex: int
        :param locationIndex:	Zero-based index of the location.

        :rtype: float
        :return: The location projected x coordinate.
        """
        return _fesapi.Witsml2_Well_getLocationProjectedX(self, locationIndex)

    def getLocationProjectedY(self, locationIndex: "uint64_t") -> "double":
        r"""
        Gets location projected y coordinate

        :type locationIndex: int
        :param locationIndex:	Zero-based index of the location.

        :rtype: float
        :return: The location projected y coordinate.
        """
        return _fesapi.Witsml2_Well_getLocationProjectedY(self, locationIndex)

    def pushBackLocation(self, projectedX: "double", projectedY: "double", crs: "Eml23_LocalEngineering2dCrs") -> "void":
        r"""
        Pushes a back location

        :type projectedX: float
        :param projectedX:		The projected x coordinate.
        :type projectedY: float
        :param projectedY:		The projected y coordinate.
        :type crs: :py:class:`LocalEngineering2dCrs`
        :param crs:				The CRS of the X and Y coordinates.
        """
        return _fesapi.Witsml2_Well_pushBackLocation(self, projectedX, projectedY, crs)

    def geLocationCount(self) -> "uint64_t":
        r"""
        Get location count

        :rtype: int
        :return: An int.
        """
        return _fesapi.Witsml2_Well_geLocationCount(self)

    def getResqmlWellboreFeatureCount(self) -> "unsigned int":
        return _fesapi.Witsml2_Well_getResqmlWellboreFeatureCount(self)

    def getResqmlWellboreFeature(self, index: "unsigned int") -> "resqml2::WellboreFeature *":
        return _fesapi.Witsml2_Well_getResqmlWellboreFeature(self, index)

    def getWellboreCount(self) -> "unsigned int":
        return _fesapi.Witsml2_Well_getWellboreCount(self)

    def getWellbore(self, index: "unsigned int") -> "witsml2::Wellbore *":
        return _fesapi.Witsml2_Well_getWellbore(self, index)

    def getWellcompletionCount(self) -> "unsigned int":
        return _fesapi.Witsml2_Well_getWellcompletionCount(self)

    def getWellcompletion(self, index: "unsigned int") -> "witsml2_1::WellCompletion *":
        return _fesapi.Witsml2_Well_getWellcompletion(self, index)
    __swig_destroy__ = _fesapi.delete_Witsml2_Well

# Register Witsml2_Well in _fesapi:
_fesapi.Witsml2_Well_swigregister(Witsml2_Well)
class Witsml2_Wellbore(AbstractObject):
    r"""A wellbore represents the path from surface to a unique bottomhole location."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getWell(self) -> "witsml2::Well *":
        return _fesapi.Witsml2_Wellbore_getWell(self)

    def setWell(self, witsmlWell: "Witsml2_Well") -> "void":
        return _fesapi.Witsml2_Wellbore_setWell(self, witsmlWell)

    def setNumber(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Wellbore_setNumber(self, value)

    def getNumber(self) -> "std::string":
        return _fesapi.Witsml2_Wellbore_getNumber(self)

    def hasNumber(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasNumber(self)

    def setSuffixAPI(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Wellbore_setSuffixAPI(self, value)

    def getSuffixAPI(self) -> "std::string":
        return _fesapi.Witsml2_Wellbore_getSuffixAPI(self)

    def hasSuffixAPI(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasSuffixAPI(self)

    def setNumGovt(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Wellbore_setNumGovt(self, value)

    def getNumGovt(self) -> "std::string":
        return _fesapi.Witsml2_Wellbore_getNumGovt(self)

    def hasNumGovt(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasNumGovt(self)

    def setStatusWellbore(self, value: "gsoap_eml2_3::eml23__WellStatus const &") -> "void":
        return _fesapi.Witsml2_Wellbore_setStatusWellbore(self, value)

    def getStatusWellbore(self) -> "gsoap_eml2_3::eml23__WellStatus":
        return _fesapi.Witsml2_Wellbore_getStatusWellbore(self)

    def hasStatusWellbore(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasStatusWellbore(self)

    def setPurposeWellbore(self, value: "gsoap_eml2_3::witsml21__WellPurpose const &") -> "void":
        return _fesapi.Witsml2_Wellbore_setPurposeWellbore(self, value)

    def getPurposeWellbore(self) -> "gsoap_eml2_3::witsml21__WellPurpose":
        return _fesapi.Witsml2_Wellbore_getPurposeWellbore(self)

    def hasPurposeWellbore(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasPurposeWellbore(self)

    def setTypeWellbore(self, value: "gsoap_eml2_3::witsml21__WellboreType const &") -> "void":
        return _fesapi.Witsml2_Wellbore_setTypeWellbore(self, value)

    def getTypeWellbore(self) -> "gsoap_eml2_3::witsml21__WellboreType":
        return _fesapi.Witsml2_Wellbore_getTypeWellbore(self)

    def hasTypeWellbore(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasTypeWellbore(self)

    def setShape(self, value: "gsoap_eml2_3::witsml21__WellboreShape const &") -> "void":
        return _fesapi.Witsml2_Wellbore_setShape(self, value)

    def getShape(self) -> "gsoap_eml2_3::witsml21__WellboreShape":
        return _fesapi.Witsml2_Wellbore_getShape(self)

    def hasShape(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasShape(self)

    def setFluidWellbore(self, value: "gsoap_eml2_3::witsml21__WellFluid const &") -> "void":
        return _fesapi.Witsml2_Wellbore_setFluidWellbore(self, value)

    def getFluidWellbore(self) -> "gsoap_eml2_3::witsml21__WellFluid":
        return _fesapi.Witsml2_Wellbore_getFluidWellbore(self)

    def hasFluidWellbore(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasFluidWellbore(self)

    def setAchievedTD(self, value: "bool const &") -> "void":
        return _fesapi.Witsml2_Wellbore_setAchievedTD(self, value)

    def getAchievedTD(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_getAchievedTD(self)

    def hasAchievedTD(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasAchievedTD(self)

    def setMd(self, value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml2_Wellbore_setMd(self, value, uom)

    def getMdValue(self) -> "double":
        return _fesapi.Witsml2_Wellbore_getMdValue(self)

    def getMdUom(self) -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml2_Wellbore_getMdUom(self)

    def hasMd(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasMd(self)

    def setMdBit(self, value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml2_Wellbore_setMdBit(self, value, uom)

    def getMdBitValue(self) -> "double":
        return _fesapi.Witsml2_Wellbore_getMdBitValue(self)

    def getMdBitUom(self) -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml2_Wellbore_getMdBitUom(self)

    def hasMdBit(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasMdBit(self)

    def setMdKickoff(self, value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml2_Wellbore_setMdKickoff(self, value, uom)

    def getMdKickoffValue(self) -> "double":
        return _fesapi.Witsml2_Wellbore_getMdKickoffValue(self)

    def getMdKickoffUom(self) -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml2_Wellbore_getMdKickoffUom(self)

    def hasMdKickoff(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasMdKickoff(self)

    def setMdPlanned(self, value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml2_Wellbore_setMdPlanned(self, value, uom)

    def getMdPlannedValue(self) -> "double":
        return _fesapi.Witsml2_Wellbore_getMdPlannedValue(self)

    def getMdPlannedUom(self) -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml2_Wellbore_getMdPlannedUom(self)

    def hasMdPlanned(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasMdPlanned(self)

    def setMdSubSeaPlanned(self, value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml2_Wellbore_setMdSubSeaPlanned(self, value, uom)

    def getMdSubSeaPlannedValue(self) -> "double":
        return _fesapi.Witsml2_Wellbore_getMdSubSeaPlannedValue(self)

    def getMdSubSeaPlannedUom(self) -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml2_Wellbore_getMdSubSeaPlannedUom(self)

    def hasMdSubSeaPlanned(self) -> "bool":
        return _fesapi.Witsml2_Wellbore_hasMdSubSeaPlanned(self)

    def getResqmlWellboreFeatureCount(self) -> "unsigned int":
        return _fesapi.Witsml2_Wellbore_getResqmlWellboreFeatureCount(self)

    def getResqmlWellboreFeature(self, index: "unsigned int") -> "resqml2::WellboreFeature *":
        return _fesapi.Witsml2_Wellbore_getResqmlWellboreFeature(self, index)

    def getTrajectoryCount(self) -> "unsigned int":
        return _fesapi.Witsml2_Wellbore_getTrajectoryCount(self)

    def getTrajectory(self, index: "unsigned int") -> "witsml2::Trajectory *":
        return _fesapi.Witsml2_Wellbore_getTrajectory(self, index)

    def getWellboreCompletionCount(self) -> "unsigned int":
        return _fesapi.Witsml2_Wellbore_getWellboreCompletionCount(self)

    def getWellboreCompletion(self, index: "unsigned int") -> "witsml2_1::WellboreCompletion *":
        return _fesapi.Witsml2_Wellbore_getWellboreCompletion(self, index)

    def getWellboreGeometryCount(self) -> "unsigned int":
        return _fesapi.Witsml2_Wellbore_getWellboreGeometryCount(self)

    def getWellboreGeometry(self, index: "unsigned int") -> "witsml2_1::WellboreGeometry *":
        return _fesapi.Witsml2_Wellbore_getWellboreGeometry(self, index)

    def getLogCount(self) -> "unsigned int":
        return _fesapi.Witsml2_Wellbore_getLogCount(self)

    def getLog(self, index: "unsigned int") -> "witsml2_1::Log *":
        return _fesapi.Witsml2_Wellbore_getLog(self, index)
    __swig_destroy__ = _fesapi.delete_Witsml2_Wellbore

# Register Witsml2_Wellbore in _fesapi:
_fesapi.Witsml2_Wellbore_swigregister(Witsml2_Wellbore)
class Witsml2_WellboreObject(AbstractObject):
    r"""
    The class is the super class for all wellbore objects (all top level objects pointing to
    Wellbore)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getWellbore(self) -> "witsml2::Wellbore *":
        return _fesapi.Witsml2_WellboreObject_getWellbore(self)

    def setWellbore(self, witsmlWellbore: "Witsml2_Wellbore") -> "void":
        return _fesapi.Witsml2_WellboreObject_setWellbore(self, witsmlWellbore)
    __swig_destroy__ = _fesapi.delete_Witsml2_WellboreObject

# Register Witsml2_WellboreObject in _fesapi:
_fesapi.Witsml2_WellboreObject_swigregister(Witsml2_WellboreObject)
class Witsml2_Trajectory(Witsml2_WellboreObject):
    r"""It contains many trajectory stations to capture the information about individual survey points."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setDTimTrajStart(self, value: "time_t const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setDTimTrajStart(self, value)

    def getDTimTrajStart(self) -> "time_t":
        return _fesapi.Witsml2_Trajectory_getDTimTrajStart(self)

    def hasDTimTrajStart(self) -> "bool":
        return _fesapi.Witsml2_Trajectory_hasDTimTrajStart(self)

    def setDTimTrajEnd(self, value: "time_t const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setDTimTrajEnd(self, value)

    def getDTimTrajEnd(self) -> "time_t":
        return _fesapi.Witsml2_Trajectory_getDTimTrajEnd(self)

    def hasDTimTrajEnd(self) -> "bool":
        return _fesapi.Witsml2_Trajectory_hasDTimTrajEnd(self)

    def setAziRef(self, value: "gsoap_eml2_3::eml23__NorthReferenceKind const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setAziRef(self, value)

    def getAziRef(self) -> "gsoap_eml2_3::eml23__NorthReferenceKind":
        return _fesapi.Witsml2_Trajectory_getAziRef(self)

    def hasAziRef(self) -> "bool":
        return _fesapi.Witsml2_Trajectory_hasAziRef(self)

    def setDefinitive(self, value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setDefinitive(self, value)

    def getDefinitive(self) -> "bool":
        return _fesapi.Witsml2_Trajectory_getDefinitive(self)

    def hasDefinitive(self) -> "bool":
        return _fesapi.Witsml2_Trajectory_hasDefinitive(self)

    def setMemory(self, value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setMemory(self, value)

    def getMemory(self) -> "bool":
        return _fesapi.Witsml2_Trajectory_getMemory(self)

    def hasMemory(self) -> "bool":
        return _fesapi.Witsml2_Trajectory_hasMemory(self)

    def setFinalTraj(self, value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setFinalTraj(self, value)

    def getFinalTraj(self) -> "bool":
        return _fesapi.Witsml2_Trajectory_getFinalTraj(self)

    def hasFinalTraj(self) -> "bool":
        return _fesapi.Witsml2_Trajectory_hasFinalTraj(self)

    def setTrajectoryStationuid(self, index: "uint64_t", value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationuid(self, index, value)

    def getTrajectoryStationuid(self, index: "uint64_t") -> "std::string":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationuid(self, index)

    def setTrajectoryStationTypeTrajStation(self, index: "uint64_t", value: "gsoap_eml2_3::witsml21__TrajStationType const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationTypeTrajStation(self, index, value)

    def getTrajectoryStationTypeTrajStation(self, index: "uint64_t") -> "gsoap_eml2_3::witsml21__TrajStationType":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationTypeTrajStation(self, index)

    def setTrajectoryStationMd(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationMd(self, index, value, uom)

    def getTrajectoryStationMdValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMdValue(self, index)

    def getTrajectoryStationMdUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMdUom(self, index)

    def setTrajectoryStationCreation(self, index: "uint64_t", value: "time_t const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationCreation(self, index, value)

    def getTrajectoryStationCreation(self, index: "uint64_t") -> "time_t":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationCreation(self, index)

    def setTrajectoryStationLastUpdate(self, index: "uint64_t", value: "time_t const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationLastUpdate(self, index, value)

    def getTrajectoryStationLastUpdate(self, index: "uint64_t") -> "time_t":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationLastUpdate(self, index)

    def setTrajectoryStationManuallyEntered(self, index: "uint64_t", value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationManuallyEntered(self, index, value)

    def getTrajectoryStationManuallyEntered(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationManuallyEntered(self, index)

    def hasTrajectoryStationManuallyEntered(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationManuallyEntered(self, index)

    def setTrajectoryStationGravAccelCorUsed(self, index: "uint64_t", value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationGravAccelCorUsed(self, index, value)

    def getTrajectoryStationGravAccelCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationGravAccelCorUsed(self, index)

    def hasTrajectoryStationGravAccelCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationGravAccelCorUsed(self, index)

    def setTrajectoryStationMagXAxialCorUsed(self, index: "uint64_t", value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationMagXAxialCorUsed(self, index, value)

    def getTrajectoryStationMagXAxialCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMagXAxialCorUsed(self, index)

    def hasTrajectoryStationMagXAxialCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationMagXAxialCorUsed(self, index)

    def setTrajectoryStationSagCorUsed(self, index: "uint64_t", value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationSagCorUsed(self, index, value)

    def getTrajectoryStationSagCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationSagCorUsed(self, index)

    def hasTrajectoryStationSagCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationSagCorUsed(self, index)

    def setTrajectoryStationMagDrlstrCorUsed(self, index: "uint64_t", value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationMagDrlstrCorUsed(self, index, value)

    def getTrajectoryStationMagDrlstrCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMagDrlstrCorUsed(self, index)

    def hasTrajectoryStationMagDrlstrCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationMagDrlstrCorUsed(self, index)

    def setTrajectoryStationInfieldRefCorUsed(self, index: "uint64_t", value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationInfieldRefCorUsed(self, index, value)

    def getTrajectoryStationInfieldRefCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationInfieldRefCorUsed(self, index)

    def hasTrajectoryStationInfieldRefCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationInfieldRefCorUsed(self, index)

    def setTrajectoryStationInterpolatedInfieldRefCorUsed(self, index: "uint64_t", value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationInterpolatedInfieldRefCorUsed(self, index, value)

    def getTrajectoryStationInterpolatedInfieldRefCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationInterpolatedInfieldRefCorUsed(self, index)

    def hasTrajectoryStationInterpolatedInfieldRefCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationInterpolatedInfieldRefCorUsed(self, index)

    def setTrajectoryStationInHoleRefCorUsed(self, index: "uint64_t", value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationInHoleRefCorUsed(self, index, value)

    def getTrajectoryStationInHoleRefCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationInHoleRefCorUsed(self, index)

    def hasTrajectoryStationInHoleRefCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationInHoleRefCorUsed(self, index)

    def setTrajectoryStationAxialMagInterferenceCorUsed(self, index: "uint64_t", value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationAxialMagInterferenceCorUsed(self, index, value)

    def getTrajectoryStationAxialMagInterferenceCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationAxialMagInterferenceCorUsed(self, index)

    def hasTrajectoryStationAxialMagInterferenceCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationAxialMagInterferenceCorUsed(self, index)

    def setTrajectoryStationCosagCorUsed(self, index: "uint64_t", value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationCosagCorUsed(self, index, value)

    def getTrajectoryStationCosagCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationCosagCorUsed(self, index)

    def hasTrajectoryStationCosagCorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationCosagCorUsed(self, index)

    def setTrajectoryStationMSACorUsed(self, index: "uint64_t", value: "bool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationMSACorUsed(self, index, value)

    def getTrajectoryStationMSACorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMSACorUsed(self, index)

    def hasTrajectoryStationMSACorUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationMSACorUsed(self, index)

    def setTrajectoryStationMagModelUsed(self, index: "uint64_t", value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationMagModelUsed(self, index, value)

    def getTrajectoryStationMagModelUsed(self, index: "uint64_t") -> "std::string":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMagModelUsed(self, index)

    def hasTrajectoryStationMagModelUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationMagModelUsed(self, index)

    def setTrajectoryStationMagModelValid(self, index: "uint64_t", value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationMagModelValid(self, index, value)

    def getTrajectoryStationMagModelValid(self, index: "uint64_t") -> "std::string":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMagModelValid(self, index)

    def hasTrajectoryStationMagModelValid(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationMagModelValid(self, index)

    def setTrajectoryStationGeoModelUsed(self, index: "uint64_t", value: "std::string const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationGeoModelUsed(self, index, value)

    def getTrajectoryStationGeoModelUsed(self, index: "uint64_t") -> "std::string":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationGeoModelUsed(self, index)

    def hasTrajectoryStationGeoModelUsed(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationGeoModelUsed(self, index)

    def setTrajectoryStationDTimStn(self, index: "uint64_t", value: "time_t const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationDTimStn(self, index, value)

    def getTrajectoryStationDTimStn(self, index: "uint64_t") -> "time_t":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationDTimStn(self, index)

    def hasTrajectoryStationDTimStn(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationDTimStn(self, index)

    def setTrajectoryStationTypeSurveyTool(self, index: "uint64_t", value: "gsoap_eml2_3::witsml21__TypeSurveyTool const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationTypeSurveyTool(self, index, value)

    def getTrajectoryStationTypeSurveyTool(self, index: "uint64_t") -> "gsoap_eml2_3::witsml21__TypeSurveyTool":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationTypeSurveyTool(self, index)

    def hasTrajectoryStationTypeSurveyTool(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationTypeSurveyTool(self, index)

    def setTrajectoryStationCalcAlgorithm(self, index: "uint64_t", value: "gsoap_eml2_3::witsml21__TrajStnCalcAlgorithm const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationCalcAlgorithm(self, index, value)

    def getTrajectoryStationCalcAlgorithm(self, index: "uint64_t") -> "gsoap_eml2_3::witsml21__TrajStnCalcAlgorithm":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationCalcAlgorithm(self, index)

    def hasTrajectoryStationCalcAlgorithm(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationCalcAlgorithm(self, index)

    def setTrajectoryStationStatusTrajStation(self, index: "uint64_t", value: "gsoap_eml2_3::witsml21__TrajStationStatus const &") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationStatusTrajStation(self, index, value)

    def getTrajectoryStationStatusTrajStation(self, index: "uint64_t") -> "gsoap_eml2_3::witsml21__TrajStationStatus":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationStatusTrajStation(self, index)

    def hasTrajectoryStationStatusTrajStation(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationStatusTrajStation(self, index)

    def setTrajectoryStationTvd(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationTvd(self, index, value, uom)

    def getTrajectoryStationTvdValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationTvdValue(self, index)

    def getTrajectoryStationTvdUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationTvdUom(self, index)

    def hasTrajectoryStationTvd(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationTvd(self, index)

    def setTrajectoryStationDispNs(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationDispNs(self, index, value, uom)

    def getTrajectoryStationDispNsValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationDispNsValue(self, index)

    def getTrajectoryStationDispNsUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationDispNsUom(self, index)

    def hasTrajectoryStationDispNs(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationDispNs(self, index)

    def setTrajectoryStationDispEw(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationDispEw(self, index, value, uom)

    def getTrajectoryStationDispEwValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationDispEwValue(self, index)

    def getTrajectoryStationDispEwUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationDispEwUom(self, index)

    def hasTrajectoryStationDispEw(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationDispEw(self, index)

    def setTrajectoryStationVertSect(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationVertSect(self, index, value, uom)

    def getTrajectoryStationVertSectValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationVertSectValue(self, index)

    def getTrajectoryStationVertSectUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationVertSectUom(self, index)

    def hasTrajectoryStationVertSect(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationVertSect(self, index)

    def setTrajectoryStationMdDelta(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationMdDelta(self, index, value, uom)

    def getTrajectoryStationMdDeltaValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMdDeltaValue(self, index)

    def getTrajectoryStationMdDeltaUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMdDeltaUom(self, index)

    def hasTrajectoryStationMdDelta(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationMdDelta(self, index)

    def setTrajectoryStationTvdDelta(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationTvdDelta(self, index, value, uom)

    def getTrajectoryStationTvdDeltaValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationTvdDeltaValue(self, index)

    def getTrajectoryStationTvdDeltaUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationTvdDeltaUom(self, index)

    def hasTrajectoryStationTvdDelta(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationTvdDelta(self, index)

    def setTrajectoryStationIncl(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__PlaneAngleUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationIncl(self, index, value, uom)

    def getTrajectoryStationInclValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationInclValue(self, index)

    def getTrajectoryStationInclUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__PlaneAngleUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationInclUom(self, index)

    def hasTrajectoryStationIncl(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationIncl(self, index)

    def setTrajectoryStationAzi(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__PlaneAngleUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationAzi(self, index, value, uom)

    def getTrajectoryStationAziValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationAziValue(self, index)

    def getTrajectoryStationAziUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__PlaneAngleUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationAziUom(self, index)

    def hasTrajectoryStationAzi(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationAzi(self, index)

    def setTrajectoryStationMtf(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__PlaneAngleUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationMtf(self, index, value, uom)

    def getTrajectoryStationMtfValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMtfValue(self, index)

    def getTrajectoryStationMtfUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__PlaneAngleUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMtfUom(self, index)

    def hasTrajectoryStationMtf(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationMtf(self, index)

    def setTrajectoryStationGtf(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__PlaneAngleUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationGtf(self, index, value, uom)

    def getTrajectoryStationGtfValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationGtfValue(self, index)

    def getTrajectoryStationGtfUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__PlaneAngleUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationGtfUom(self, index)

    def hasTrajectoryStationGtf(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationGtf(self, index)

    def setTrajectoryStationDipAngleUncert(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__PlaneAngleUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationDipAngleUncert(self, index, value, uom)

    def getTrajectoryStationDipAngleUncertValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationDipAngleUncertValue(self, index)

    def getTrajectoryStationDipAngleUncertUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__PlaneAngleUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationDipAngleUncertUom(self, index)

    def hasTrajectoryStationDipAngleUncert(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationDipAngleUncert(self, index)

    def setTrajectoryStationMagDipAngleReference(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__PlaneAngleUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationMagDipAngleReference(self, index, value, uom)

    def getTrajectoryStationMagDipAngleReferenceValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMagDipAngleReferenceValue(self, index)

    def getTrajectoryStationMagDipAngleReferenceUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__PlaneAngleUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMagDipAngleReferenceUom(self, index)

    def hasTrajectoryStationMagDipAngleReference(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationMagDipAngleReference(self, index)

    def setTrajectoryStationDls(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__AnglePerLengthUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationDls(self, index, value, uom)

    def getTrajectoryStationDlsValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationDlsValue(self, index)

    def getTrajectoryStationDlsUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__AnglePerLengthUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationDlsUom(self, index)

    def hasTrajectoryStationDls(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationDls(self, index)

    def setTrajectoryStationRateTurn(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__AnglePerLengthUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationRateTurn(self, index, value, uom)

    def getTrajectoryStationRateTurnValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationRateTurnValue(self, index)

    def getTrajectoryStationRateTurnUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__AnglePerLengthUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationRateTurnUom(self, index)

    def hasTrajectoryStationRateTurn(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationRateTurn(self, index)

    def setTrajectoryStationRateBuild(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__AnglePerLengthUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationRateBuild(self, index, value, uom)

    def getTrajectoryStationRateBuildValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationRateBuildValue(self, index)

    def getTrajectoryStationRateBuildUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__AnglePerLengthUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationRateBuildUom(self, index)

    def hasTrajectoryStationRateBuild(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationRateBuild(self, index)

    def setTrajectoryStationGravTotalUncert(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__LinearAccelerationUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationGravTotalUncert(self, index, value, uom)

    def getTrajectoryStationGravTotalUncertValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationGravTotalUncertValue(self, index)

    def getTrajectoryStationGravTotalUncertUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LinearAccelerationUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationGravTotalUncertUom(self, index)

    def hasTrajectoryStationGravTotalUncert(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationGravTotalUncert(self, index)

    def setTrajectoryStationGravTotalFieldReference(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__LinearAccelerationUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationGravTotalFieldReference(self, index, value, uom)

    def getTrajectoryStationGravTotalFieldReferenceValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationGravTotalFieldReferenceValue(self, index)

    def getTrajectoryStationGravTotalFieldReferenceUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LinearAccelerationUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationGravTotalFieldReferenceUom(self, index)

    def hasTrajectoryStationGravTotalFieldReference(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationGravTotalFieldReference(self, index)

    def setTrajectoryStationMagTotalUncert(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__MagneticFluxDensityUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationMagTotalUncert(self, index, value, uom)

    def getTrajectoryStationMagTotalUncertValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMagTotalUncertValue(self, index)

    def getTrajectoryStationMagTotalUncertUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__MagneticFluxDensityUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMagTotalUncertUom(self, index)

    def hasTrajectoryStationMagTotalUncert(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationMagTotalUncert(self, index)

    def setTrajectoryStationMagTotalFieldReference(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__MagneticFluxDensityUom") -> "void":
        return _fesapi.Witsml2_Trajectory_setTrajectoryStationMagTotalFieldReference(self, index, value, uom)

    def getTrajectoryStationMagTotalFieldReferenceValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMagTotalFieldReferenceValue(self, index)

    def getTrajectoryStationMagTotalFieldReferenceUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__MagneticFluxDensityUom":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationMagTotalFieldReferenceUom(self, index)

    def hasTrajectoryStationMagTotalFieldReference(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml2_Trajectory_hasTrajectoryStationMagTotalFieldReference(self, index)

    def pushBackTrajectoryStation(self, *args) -> "void":
        return _fesapi.Witsml2_Trajectory_pushBackTrajectoryStation(self, *args)

    def getTrajectoryStationCount(self) -> "unsigned int":
        return _fesapi.Witsml2_Trajectory_getTrajectoryStationCount(self)
    __swig_destroy__ = _fesapi.delete_Witsml2_Trajectory

# Register Witsml2_Trajectory in _fesapi:
_fesapi.Witsml2_Trajectory_swigregister(Witsml2_Trajectory)
class Witsml21_Well(Witsml2_Well):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Witsml21_Well

# Register Witsml21_Well in _fesapi:
_fesapi.Witsml21_Well_swigregister(Witsml21_Well)
class Witsml21_Wellbore(Witsml2_Wellbore):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Witsml21_Wellbore

# Register Witsml21_Wellbore in _fesapi:
_fesapi.Witsml21_Wellbore_swigregister(Witsml21_Wellbore)
class Witsml21_WellCompletion(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getWell(self) -> "witsml2_1::Well *":
        return _fesapi.Witsml21_WellCompletion_getWell(self)

    def setWell(self, witsmlWell: "Witsml21_Well") -> "void":
        return _fesapi.Witsml21_WellCompletion_setWell(self, witsmlWell)
    __swig_destroy__ = _fesapi.delete_Witsml21_WellCompletion

# Register Witsml21_WellCompletion in _fesapi:
_fesapi.Witsml21_WellCompletion_swigregister(Witsml21_WellCompletion)
class Witsml21_WellboreCompletion(Witsml2_WellboreObject):
    r""" The location/interval of the connections between well and reservoir and its history."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    WellReservoirConnectionType_PERFORATION = _fesapi.Witsml21_WellboreCompletion_WellReservoirConnectionType_PERFORATION
    WellReservoirConnectionType_GRAVEL_PACK = _fesapi.Witsml21_WellboreCompletion_WellReservoirConnectionType_GRAVEL_PACK
    WellReservoirConnectionType_OPEN_HOLE = _fesapi.Witsml21_WellboreCompletion_WellReservoirConnectionType_OPEN_HOLE
    WellReservoirConnectionType_SLOTS = _fesapi.Witsml21_WellboreCompletion_WellReservoirConnectionType_SLOTS

    def getWellCompletion(self) -> "witsml2_1::WellCompletion *":
        return _fesapi.Witsml21_WellboreCompletion_getWellCompletion(self)

    def setWellCompletion(self, wellCompletion: "Witsml21_WellCompletion") -> "void":
        return _fesapi.Witsml21_WellboreCompletion_setWellCompletion(self, wellCompletion)

    def pushBackConnection(self, wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", MdUnit: "gsoap_eml2_3::eml23__LengthUom", TopMd: "double", BaseMd: "double", uid: "std::string const &") -> "void":
        r"""
        Pushes back a connection

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection from reservoir to wellbore to add
        :type MdUnit: int
        :param MdUnit:	The md unit.
        :type TopMd: float
        :param TopMd: 	The top md.
        :type BaseMd: float
        :param BaseMd:	The base md.
        :param guid:  	Unique identifier of the connection.
        """
        return _fesapi.Witsml21_WellboreCompletion_pushBackConnection(self, wellReservoirConnection, MdUnit, TopMd, BaseMd, uid)

    def pushBackConnectionExtraMetadata(self, wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t", key: "std::string const &", value: "std::string const &") -> "void":
        r"""
        Pushes back connection extra metadata

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.
        :type key: string
        :param key:  			The key of the metadata.
        :type value: string
        :param value:			The value of the metadata.
        """
        return _fesapi.Witsml21_WellboreCompletion_pushBackConnectionExtraMetadata(self, wellReservoirConnection, connectionIndex, key, value)

    def pushBackConnectionHistory(self, *args) -> "void":
        r"""
        *Overload 1:*

        Pushes a back perforaconnectiontion history

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.
        :type historyGuid: string, optional
        :param historyGuid: 		(Optional) Unique identifier.

        |

        *Overload 2:*

        Pushes back connection history

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.
        :type status: int
        :param status:				The connection status.
        :type startDate: int
        :param startDate:		 	The start date.
        :type historyGuid: string, optional
        :param historyGuid:			 (Optional) Unique identifier.

        |

        *Overload 3:*

        Pushes back connection history

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.
        :type status: int
        :param status:				The connection status.
        :type startDate: int
        :param startDate:		 	The start date.
        :param historyGuid:			 (Optional) Unique identifier.
        """
        return _fesapi.Witsml21_WellboreCompletion_pushBackConnectionHistory(self, *args)

    def getConnectionCount(self, wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType") -> "uint64_t":
        r"""
        Gets connection count of a certin type

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connections to count

        :rtype: int
        :return: The connection count of type wellReservoirConnection in this completion.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionCount(self, wellReservoirConnection)

    def getConnectionUid(self, wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "std::string":
        r"""
        Gets the UID of the connection of a particular type at a particular index

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.

        :rtype: string
        :return: The connection UIDs of the completion.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionUid(self, wellReservoirConnection, connectionIndex)

    def getConnectionExtraMetadata(self, wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t", key: "std::string const &") -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Gets an extra metadata of a particular connection according to its key

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.
        :type key: string
        :param key:	The key of an extra metadata.

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: The vector of all metadata values sharing this ``key`` (empty vector if there is no such value) in the connection at ``index``.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionExtraMetadata(self, wellReservoirConnection, connectionIndex, key)

    def hasConnectionMdDatum(self, wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "bool":
        r"""
        Query if 'index' has connection md datum

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.

        :rtype: boolean
        :return: True if connection md datum, false if not.
        """
        return _fesapi.Witsml21_WellboreCompletion_hasConnectionMdDatum(self, wellReservoirConnection, connectionIndex)

    def getConnectionMdUnit(self, wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        r"""
        Returns md base uom if exists, else returns md top uom. Raises an exception if no md is
        defined.

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.

        :rtype: int
        :return: The connection md unit.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionMdUnit(self, wellReservoirConnection, connectionIndex)

    def getConnectionMdUnitAsString(self, wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "std::string":
        r"""
        Returns md base uom (as string) if exists, else returns md top uom (as string). Raises an
        exception if no md is defined.

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.

        :rtype: string
        :return: The connection md unit as string.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionMdUnitAsString(self, wellReservoirConnection, connectionIndex)

    def getConnectionTopMd(self, wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "double":
        r"""
        Gets connection top md

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.

        :rtype: float
        :return: The connection top md.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionTopMd(self, wellReservoirConnection, connectionIndex)

    def getConnectionBaseMd(self, wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "double":
        r"""
        Gets connection base md

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.

        :rtype: float
        :return: The connection base md.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionBaseMd(self, wellReservoirConnection, connectionIndex)

    def getConnectionHistoryCount(self, wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "uint64_t":
        r"""
        Gets connection history count

        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.

        :rtype: int
        :return: The connection history count.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionHistoryCount(self, wellReservoirConnection, connectionIndex)

    def hasConnectionHistoryStatus(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "bool":
        r"""
        Query if 'historyIndex' has connection history status

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.

        :rtype: boolean
        :return: True if connection history status, false if not.
        """
        return _fesapi.Witsml21_WellboreCompletion_hasConnectionHistoryStatus(self, historyIndex, wellReservoirConnection, connectionIndex)

    def getConnectionHistoryStatus(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "gsoap_eml2_3::witsml21__PhysicalStatus":
        r"""
        Gets connection history status

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.

        :rtype: int
        :return: The connection history status.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionHistoryStatus(self, historyIndex, wellReservoirConnection, connectionIndex)

    def getConnectionHistoryStatusToString(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "std::string":
        r"""
        Gets connection history status to string

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.

        :rtype: string
        :return: The connection history status to string.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionHistoryStatusToString(self, historyIndex, wellReservoirConnection, connectionIndex)

    def setConnectionHistoryStatus(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t", connectionStatus: "gsoap_eml2_3::witsml21__PhysicalStatus") -> "void":
        r"""
        Sets connection history status

        :type historyIndex: int
        :param historyIndex:	 	Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.
        :type connectionStatus: int
        :param connectionStatus:	The connection status.
        """
        return _fesapi.Witsml21_WellboreCompletion_setConnectionHistoryStatus(self, historyIndex, wellReservoirConnection, connectionIndex, connectionStatus)

    def hasConnectionHistoryStartDate(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "bool":
        r"""
        Query if 'historyIndex' has connection history start date

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex: The index of the connection in the array of type wellReservoirConnection.

        :rtype: boolean
        :return: True if connection history start date, false if not.
        """
        return _fesapi.Witsml21_WellboreCompletion_hasConnectionHistoryStartDate(self, historyIndex, wellReservoirConnection, connectionIndex)

    def getConnectionHistoryStartDate(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "time_t":
        r"""
        Gets connection history start date

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.

        :rtype: int
        :return: The connection history start date.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionHistoryStartDate(self, historyIndex, wellReservoirConnection, connectionIndex)

    def setConnectionHistoryStartDate(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t", startDate: "time_t") -> "void":
        r"""
        Sets connection history start date

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.
        :type startDate: int
        :param startDate:			The start date.
        """
        return _fesapi.Witsml21_WellboreCompletion_setConnectionHistoryStartDate(self, historyIndex, wellReservoirConnection, connectionIndex, startDate)

    def hasConnectionHistoryEndDate(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "bool":
        r"""
        Query if 'historyIndex' has connection history end date

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.

        :rtype: boolean
        :return: True if connection history end date, false if not.
        """
        return _fesapi.Witsml21_WellboreCompletion_hasConnectionHistoryEndDate(self, historyIndex, wellReservoirConnection, connectionIndex)

    def getConnectionHistoryEndDate(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "time_t":
        r"""
        Gets connection history end date

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.

        :rtype: int
        :return: The connection history end date.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionHistoryEndDate(self, historyIndex, wellReservoirConnection, connectionIndex)

    def setConnectionHistoryEndDate(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t", endDate: "time_t") -> "void":
        r"""
        Sets connection history end date

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.
        :type endDate: int
        :param endDate:				The end date.
        """
        return _fesapi.Witsml21_WellboreCompletion_setConnectionHistoryEndDate(self, historyIndex, wellReservoirConnection, connectionIndex, endDate)

    def hasConnectionHistoryMdDatum(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "bool":
        r"""
        Query if 'historyIndex' has connection history md datum

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.

        :rtype: boolean
        :return: True if connection history md datum, false if not.
        """
        return _fesapi.Witsml21_WellboreCompletion_hasConnectionHistoryMdDatum(self, historyIndex, wellReservoirConnection, connectionIndex)

    def hasConnectionHistoryMdInterval(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "bool":
        r"""
        Query if 'historyIndex' has connection history MD interval

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.

        :rtype: boolean
        :return: True if connection history has MD interval, false if not.
        """
        return _fesapi.Witsml21_WellboreCompletion_hasConnectionHistoryMdInterval(self, historyIndex, wellReservoirConnection, connectionIndex)

    def getConnectionHistoryMdUnit(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        r"""
        Returns md base uom if exists, else returns md top uom. Raises an exception if no md is
        defined.

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.

        :rtype: int
        :return: The connection history md unit.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionHistoryMdUnit(self, historyIndex, wellReservoirConnection, connectionIndex)

    def getConnectionHistoryMdUnitAsString(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "std::string":
        r"""
        Returns md base uom (as string) if exists, else returns md top uom (as string). Raises an
        exception if no md is defined.

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.

        :rtype: string
        :return: The connection history md unit as string.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionHistoryMdUnitAsString(self, historyIndex, wellReservoirConnection, connectionIndex)

    def getConnectionHistoryTopMd(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "double":
        r"""
        Gets connection history top md

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.

        :rtype: float
        :return: The connection history top md.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionHistoryTopMd(self, historyIndex, wellReservoirConnection, connectionIndex)

    def setConnectionHistoryMdInterval(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t", MdUnit: "gsoap_eml2_3::eml23__LengthUom", TopMd: "double", baseMd: "double") -> "void":
        r"""
        Connection history datum is overwritten if exists. For instance if a base md is already
        defined.

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.
        :type MdUnit: int
        :param MdUnit:				The md unit.
        :type TopMd: float
        :param TopMd:				The top md.
        :param BaseMd:				The base md.
        """
        return _fesapi.Witsml21_WellboreCompletion_setConnectionHistoryMdInterval(self, historyIndex, wellReservoirConnection, connectionIndex, MdUnit, TopMd, baseMd)

    def getConnectionHistoryBaseMd(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "double":
        r"""
        Gets connection history base md

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.

        :rtype: float
        :return: The connection history base md.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionHistoryBaseMd(self, historyIndex, wellReservoirConnection, connectionIndex)

    def hasConnectionHistoryComment(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "bool":
        r"""
        Query if 'historyIndex' has connection history comment

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.

        :rtype: boolean
        :return: True if connection history comment, false if not.
        """
        return _fesapi.Witsml21_WellboreCompletion_hasConnectionHistoryComment(self, historyIndex, wellReservoirConnection, connectionIndex)

    def getConnectionHistoryComment(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t") -> "std::string":
        r"""
        Gets connection history comment

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.

        :rtype: string
        :return: The connection history comment.
        """
        return _fesapi.Witsml21_WellboreCompletion_getConnectionHistoryComment(self, historyIndex, wellReservoirConnection, connectionIndex)

    def setConnectionHistoryComment(self, historyIndex: "uint64_t", wellReservoirConnection: "witsml2_1::WellboreCompletion::WellReservoirConnectionType", connectionIndex: "uint64_t", comment: "std::string const &") -> "void":
        r"""
        Sets connection history comment

        :type historyIndex: int
        :param historyIndex:		Zero-based index of the history.
        :type wellReservoirConnection: int
        :param wellReservoirConnection:	The physical nature of the connection
        :type connectionIndex: int
        :param connectionIndex:	Zero-based index of the connection.
        :type comment: string
        :param comment:				The comment.
        """
        return _fesapi.Witsml21_WellboreCompletion_setConnectionHistoryComment(self, historyIndex, wellReservoirConnection, connectionIndex, comment)
    __swig_destroy__ = _fesapi.delete_Witsml21_WellboreCompletion

# Register Witsml21_WellboreCompletion in _fesapi:
_fesapi.Witsml21_WellboreCompletion_swigregister(Witsml21_WellboreCompletion)
class Witsml21_WellboreGeometry(Witsml2_WellboreObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setWellboreGeometrySectionuid(self, index: "uint64_t", value: "std::string const &") -> "void":
        return _fesapi.Witsml21_WellboreGeometry_setWellboreGeometrySectionuid(self, index, value)

    def getWellboreGeometrySectionuid(self, index: "uint64_t") -> "std::string":
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionuid(self, index)

    def setWellboreGeometrySectionCurveConductor(self, index: "uint64_t", value: "bool const &") -> "void":
        return _fesapi.Witsml21_WellboreGeometry_setWellboreGeometrySectionCurveConductor(self, index, value)

    def getWellboreGeometrySectionCurveConductor(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionCurveConductor(self, index)

    def hasWellboreGeometrySectionCurveConductor(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml21_WellboreGeometry_hasWellboreGeometrySectionCurveConductor(self, index)

    def setWellboreGeometrySectionFactFric(self, index: "uint64_t", value: "double const &") -> "void":
        return _fesapi.Witsml21_WellboreGeometry_setWellboreGeometrySectionFactFric(self, index, value)

    def getWellboreGeometrySectionFactFric(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionFactFric(self, index)

    def hasWellboreGeometrySectionFactFric(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml21_WellboreGeometry_hasWellboreGeometrySectionFactFric(self, index)

    def setWellboreGeometrySectionGrade(self, index: "uint64_t", value: "std::string const &") -> "void":
        return _fesapi.Witsml21_WellboreGeometry_setWellboreGeometrySectionGrade(self, index, value)

    def getWellboreGeometrySectionGrade(self, index: "uint64_t") -> "std::string":
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionGrade(self, index)

    def hasWellboreGeometrySectionGrade(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml21_WellboreGeometry_hasWellboreGeometrySectionGrade(self, index)

    def setWellboreGeometrySectionTypeHoleCasing(self, index: "uint64_t", value: "gsoap_eml2_3::witsml21__HoleCasingType const &") -> "void":
        return _fesapi.Witsml21_WellboreGeometry_setWellboreGeometrySectionTypeHoleCasing(self, index, value)

    def getWellboreGeometrySectionTypeHoleCasing(self, index: "uint64_t") -> "gsoap_eml2_3::witsml21__HoleCasingType":
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionTypeHoleCasing(self, index)

    def hasWellboreGeometrySectionTypeHoleCasing(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml21_WellboreGeometry_hasWellboreGeometrySectionTypeHoleCasing(self, index)

    def setWellboreGeometrySectionIdSection(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml21_WellboreGeometry_setWellboreGeometrySectionIdSection(self, index, value, uom)

    def getWellboreGeometrySectionIdSectionValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionIdSectionValue(self, index)

    def getWellboreGeometrySectionIdSectionUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionIdSectionUom(self, index)

    def hasWellboreGeometrySectionIdSection(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml21_WellboreGeometry_hasWellboreGeometrySectionIdSection(self, index)

    def setWellboreGeometrySectionOdSection(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml21_WellboreGeometry_setWellboreGeometrySectionOdSection(self, index, value, uom)

    def getWellboreGeometrySectionOdSectionValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionOdSectionValue(self, index)

    def getWellboreGeometrySectionOdSectionUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionOdSectionUom(self, index)

    def hasWellboreGeometrySectionOdSection(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml21_WellboreGeometry_hasWellboreGeometrySectionOdSection(self, index)

    def setWellboreGeometrySectionDiaDrift(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml21_WellboreGeometry_setWellboreGeometrySectionDiaDrift(self, index, value, uom)

    def getWellboreGeometrySectionDiaDriftValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionDiaDriftValue(self, index)

    def getWellboreGeometrySectionDiaDriftUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionDiaDriftUom(self, index)

    def hasWellboreGeometrySectionDiaDrift(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml21_WellboreGeometry_hasWellboreGeometrySectionDiaDrift(self, index)

    def setWellboreGeometrySectionWtPerLen(self, index: "uint64_t", value: "double", uom: "gsoap_eml2_3::eml23__MassPerLengthUom") -> "void":
        return _fesapi.Witsml21_WellboreGeometry_setWellboreGeometrySectionWtPerLen(self, index, value, uom)

    def getWellboreGeometrySectionWtPerLenValue(self, index: "uint64_t") -> "double":
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionWtPerLenValue(self, index)

    def getWellboreGeometrySectionWtPerLenUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__MassPerLengthUom":
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionWtPerLenUom(self, index)

    def hasWellboreGeometrySectionWtPerLen(self, index: "uint64_t") -> "bool":
        return _fesapi.Witsml21_WellboreGeometry_hasWellboreGeometrySectionWtPerLen(self, index)

    def getWellboreGeometrySectionMdIntervalTop(self, index: "uint64_t") -> "double":
        r"""
        Gets wellbore geometry section md interval top

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: float
        :return: The wellbore geometry section md interval top.
        """
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionMdIntervalTop(self, index)

    def getWellboreGeometrySectionMdIntervalBase(self, index: "uint64_t") -> "double":
        r"""
        Gets wellbore geometry section md interval base

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: float
        :return: The wellbore geometry section md interval base.
        """
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionMdIntervalBase(self, index)

    def getWellboreGeometrySectionMdIntervalUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        r"""
        Gets wellbore geometry section md interval uom

        :type index: int
        :param index:	Zero-based index of the section.

        :rtype: int
        :return: The wellbore geometry section md interval uom.
        """
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionMdIntervalUom(self, index)

    def setWellboreGeometrySectionTvdInterval(self, index: "uint64_t", top: "double", base: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        r"""
        Sets wellbore geometry section tvd interval

        :type index: int
        :param index:	Zero-based index of the.
        :type top: float
        :param top:  	The top.
        :type base: float
        :param base: 	The base.
        :param datum:	The datum.
        :type uom: int
        :param uom:  	The uom.
        """
        return _fesapi.Witsml21_WellboreGeometry_setWellboreGeometrySectionTvdInterval(self, index, top, base, uom)

    def getWellboreGeometrySectionTvdIntervalTop(self, index: "uint64_t") -> "double":
        r"""
        Gets wellbore geometry section tvd interval top

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: float
        :return: The wellbore geometry section tvd interval top.
        """
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionTvdIntervalTop(self, index)

    def getWellboreGeometrySectionTvdIntervalUom(self, index: "uint64_t") -> "gsoap_eml2_3::eml23__LengthUom":
        r"""
        Gets wellbore geometry section tvd interval uom

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: int
        :return: The wellbore geometry section tvd interval uom.
        """
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionTvdIntervalUom(self, index)

    def getWellboreGeometrySectionTvdIntervalBase(self, index: "uint64_t") -> "double":
        r"""
        Gets wellbore geometry section tvd interval base

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: float
        :return: The wellbore geometry section tvd interval base.
        """
        return _fesapi.Witsml21_WellboreGeometry_getWellboreGeometrySectionTvdIntervalBase(self, index)

    def hasWellboreGeometrySectionTvdInterval(self, index: "uint64_t") -> "bool":
        r"""
        Query if 'index' has wellbore geometry section tvd interval

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: boolean
        :return: True if wellbore geometry section tvd interval, false if not.
        """
        return _fesapi.Witsml21_WellboreGeometry_hasWellboreGeometrySectionTvdInterval(self, index)

    def pushBackSection(self, *args) -> "void":
        r"""
        Push back an empty section into the instance.

        :type top: float
        :param top:  	The MD top.
        :type base: float
        :param base: 	The MD base.
        :type uom: int
        :param uom:  	The MD uom.
        :type uid: string, optional
        :param uid:	(Optional) The UID.
        """
        return _fesapi.Witsml21_WellboreGeometry_pushBackSection(self, *args)

    def getSectionCount(self) -> "uint64_t":
        r"""
        Get the count of sections in this instance

        :rtype: int
        :return: the count of sections in this instance.
        """
        return _fesapi.Witsml21_WellboreGeometry_getSectionCount(self)
    __swig_destroy__ = _fesapi.delete_Witsml21_WellboreGeometry

# Register Witsml21_WellboreGeometry in _fesapi:
_fesapi.Witsml21_WellboreGeometry_swigregister(Witsml21_WellboreGeometry)
class Witsml21_Trajectory(Witsml2_Trajectory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fesapi.delete_Witsml21_Trajectory

# Register Witsml21_Trajectory in _fesapi:
_fesapi.Witsml21_Trajectory_swigregister(Witsml21_Trajectory)
class ChannelIndexDataChannelSet(Witsml2_WellboreObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackChannelIndex(self, indexKind: "gsoap_eml2_3::eml23__DataIndexKind", uom: "gsoap_eml2_3::eml23__UnitOfMeasure", mnemonic: "std::string const &", isIncreasing: "bool"=True) -> "void":
        r"""
        Pushes a back channel index

        :type indexKind: int
        :param indexKind:  		The index.
        :type uom: int
        :param uom:				The uom.
        :type mnemonic: string
        :param mnemonic:		The mnemonic.
        :type isIncreasing: boolean, optional
        :param isIncreasing:	(Optional) True if is increasing, false if not.
        """
        return _fesapi.ChannelIndexDataChannelSet_pushBackChannelIndex(self, indexKind, uom, mnemonic, isIncreasing)

    def getChannelIndexCount(self) -> "unsigned int":
        r"""
        Gets channel index count

        :rtype: int
        :return: The channel index count.
        """
        return _fesapi.ChannelIndexDataChannelSet_getChannelIndexCount(self)

    def getChannelIndexKind(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__DataIndexKind":
        r"""
        Gets channel index type

        :raises: std::out_of_range	Thrown when an out of range error condition occurs.

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: int
        :return: The channel index type.
        """
        return _fesapi.ChannelIndexDataChannelSet_getChannelIndexKind(self, index)

    def getChannelIndexUom(self, index: "unsigned int") -> "std::string":
        r"""
        Gets channel index uom

        :raises: std::out_of_range	Thrown when an out of range error condition occurs.

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: string
        :return: The channel index uom.
        """
        return _fesapi.ChannelIndexDataChannelSet_getChannelIndexUom(self, index)

    def getChannelIndexIsIncreasing(self, index: "unsigned int") -> "bool":
        r"""
        Gets channel index is increasing

        :raises: std::out_of_range	Thrown when an out of range error condition occurs.

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: boolean
        :return: True if it succeeds, false if it fails.
        """
        return _fesapi.ChannelIndexDataChannelSet_getChannelIndexIsIncreasing(self, index)

    def getChannelIndexMnemonic(self, index: "unsigned int") -> "std::string":
        r"""
        Gets channel index mnemonic

        :raises: std::out_of_range	Thrown when an out of range error condition occurs.

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: string
        :return: The channel index mnemonic.
        """
        return _fesapi.ChannelIndexDataChannelSet_getChannelIndexMnemonic(self, index)
    __swig_destroy__ = _fesapi.delete_ChannelIndexDataChannelSet

# Register ChannelIndexDataChannelSet in _fesapi:
_fesapi.ChannelIndexDataChannelSet_swigregister(ChannelIndexDataChannelSet)
class ChannelIndexDataChannel(Witsml2_WellboreObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackChannelIndex(self, indexKind: "gsoap_eml2_3::eml23__DataIndexKind", uom: "gsoap_eml2_3::eml23__UnitOfMeasure", mnemonic: "std::string const &", isIncreasing: "bool"=True) -> "void":
        r"""
        Pushes a back channel index

        :type indexKind: int
        :param indexKind:  		The index.
        :type uom: int
        :param uom:				The uom.
        :type mnemonic: string
        :param mnemonic:		The mnemonic.
        :type isIncreasing: boolean, optional
        :param isIncreasing:	(Optional) True if is increasing, false if not.
        """
        return _fesapi.ChannelIndexDataChannel_pushBackChannelIndex(self, indexKind, uom, mnemonic, isIncreasing)

    def getChannelIndexCount(self) -> "unsigned int":
        r"""
        Gets channel index count

        :rtype: int
        :return: The channel index count.
        """
        return _fesapi.ChannelIndexDataChannel_getChannelIndexCount(self)

    def getChannelIndexKind(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__DataIndexKind":
        r"""
        Gets channel index type

        :raises: std::out_of_range	Thrown when an out of range error condition occurs.

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: int
        :return: The channel index type.
        """
        return _fesapi.ChannelIndexDataChannel_getChannelIndexKind(self, index)

    def getChannelIndexUom(self, index: "unsigned int") -> "std::string":
        r"""
        Gets channel index uom

        :raises: std::out_of_range	Thrown when an out of range error condition occurs.

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: string
        :return: The channel index uom.
        """
        return _fesapi.ChannelIndexDataChannel_getChannelIndexUom(self, index)

    def getChannelIndexIsIncreasing(self, index: "unsigned int") -> "bool":
        r"""
        Gets channel index is increasing

        :raises: std::out_of_range	Thrown when an out of range error condition occurs.

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: boolean
        :return: True if it succeeds, false if it fails.
        """
        return _fesapi.ChannelIndexDataChannel_getChannelIndexIsIncreasing(self, index)

    def getChannelIndexMnemonic(self, index: "unsigned int") -> "std::string":
        r"""
        Gets channel index mnemonic

        :raises: std::out_of_range	Thrown when an out of range error condition occurs.

        :type index: int
        :param index:	Zero-based index of the.

        :rtype: string
        :return: The channel index mnemonic.
        """
        return _fesapi.ChannelIndexDataChannel_getChannelIndexMnemonic(self, index)
    __swig_destroy__ = _fesapi.delete_ChannelIndexDataChannel

# Register ChannelIndexDataChannel in _fesapi:
_fesapi.ChannelIndexDataChannel_swigregister(ChannelIndexDataChannel)
class Witsml21_Log(Witsml2_WellboreObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackChannelSet(self, channelSet: "Witsml21_ChannelSet") -> "void":
        return _fesapi.Witsml21_Log_pushBackChannelSet(self, channelSet)

    def getChannelSets(self) -> "std::vector< witsml2_1::ChannelSet *,std::allocator< witsml2_1::ChannelSet * > >":
        return _fesapi.Witsml21_Log_getChannelSets(self)
    __swig_destroy__ = _fesapi.delete_Witsml21_Log

# Register Witsml21_Log in _fesapi:
_fesapi.Witsml21_Log_swigregister(Witsml21_Log)
class Witsml21_ChannelSet(ChannelIndexDataChannelSet):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackChannel(self, channel: "Witsml21_Channel") -> "void":
        return _fesapi.Witsml21_ChannelSet_pushBackChannel(self, channel)

    def setDataAsJsonArray(self, jsonArray: "std::string const &") -> "void":
        return _fesapi.Witsml21_ChannelSet_setDataAsJsonArray(self, jsonArray)

    def setDataAsFileUri(self, fileUri: "std::string const &") -> "void":
        return _fesapi.Witsml21_ChannelSet_setDataAsFileUri(self, fileUri)

    def hasDataAsJsonArray(self) -> "bool":
        return _fesapi.Witsml21_ChannelSet_hasDataAsJsonArray(self)

    def hasDataAsFileUri(self) -> "bool":
        return _fesapi.Witsml21_ChannelSet_hasDataAsFileUri(self)

    def getDataAsJsonArray(self) -> "std::string const &":
        return _fesapi.Witsml21_ChannelSet_getDataAsJsonArray(self)

    def getDataAsFileUri(self) -> "std::string const &":
        return _fesapi.Witsml21_ChannelSet_getDataAsFileUri(self)

    def getLogs(self) -> "std::vector< witsml2_1::Log *,std::allocator< witsml2_1::Log * > >":
        return _fesapi.Witsml21_ChannelSet_getLogs(self)

    def getChannels(self) -> "std::vector< witsml2_1::Channel *,std::allocator< witsml2_1::Channel * > >":
        return _fesapi.Witsml21_ChannelSet_getChannels(self)
    __swig_destroy__ = _fesapi.delete_Witsml21_ChannelSet

# Register Witsml21_ChannelSet in _fesapi:
_fesapi.Witsml21_ChannelSet_swigregister(Witsml21_ChannelSet)
class Witsml21_Channel(ChannelIndexDataChannel):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getChannelSets(self) -> "std::vector< witsml2_1::ChannelSet *,std::allocator< witsml2_1::ChannelSet * > >":
        return _fesapi.Witsml21_Channel_getChannelSets(self)

    def getPropertyKind(self) -> "eml2::PropertyKind *":
        return _fesapi.Witsml21_Channel_getPropertyKind(self)

    def setPropertyKind(self, propKind: "PropertyKind") -> "void":
        return _fesapi.Witsml21_Channel_setPropertyKind(self, propKind)

    def setMnemonic(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml21_Channel_setMnemonic(self, value)

    def getMnemonic(self) -> "std::string":
        return _fesapi.Witsml21_Channel_getMnemonic(self)

    def setUom(self, value: "std::string const &") -> "void":
        return _fesapi.Witsml21_Channel_setUom(self, value)

    def getUom(self) -> "std::string":
        return _fesapi.Witsml21_Channel_getUom(self)

    def setDataKind(self, value: "gsoap_eml2_3::witsml21__ChannelDataKind const &") -> "void":
        return _fesapi.Witsml21_Channel_setDataKind(self, value)

    def getDataKind(self) -> "gsoap_eml2_3::witsml21__ChannelDataKind":
        return _fesapi.Witsml21_Channel_getDataKind(self)
    __swig_destroy__ = _fesapi.delete_Witsml21_Channel

# Register Witsml21_Channel in _fesapi:
_fesapi.Witsml21_Channel_swigregister(Witsml21_Channel)
class Witsml21_WellboreMarker(Witsml2_WellboreObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setMd(self, value: "double", uom: "gsoap_eml2_3::eml23__LengthUom") -> "void":
        return _fesapi.Witsml21_WellboreMarker_setMd(self, value, uom)

    def getMdValue(self) -> "double":
        return _fesapi.Witsml21_WellboreMarker_getMdValue(self)

    def getMdUom(self) -> "gsoap_eml2_3::eml23__LengthUom":
        return _fesapi.Witsml21_WellboreMarker_getMdUom(self)

    def hasMd(self) -> "bool":
        return _fesapi.Witsml21_WellboreMarker_hasMd(self)

    def setDipAngle(self, value: "double", uom: "gsoap_eml2_3::eml23__PlaneAngleUom") -> "void":
        return _fesapi.Witsml21_WellboreMarker_setDipAngle(self, value, uom)

    def getDipAngleValue(self) -> "double":
        return _fesapi.Witsml21_WellboreMarker_getDipAngleValue(self)

    def getDipAngleUom(self) -> "gsoap_eml2_3::eml23__PlaneAngleUom":
        return _fesapi.Witsml21_WellboreMarker_getDipAngleUom(self)

    def hasDipAngle(self) -> "bool":
        return _fesapi.Witsml21_WellboreMarker_hasDipAngle(self)

    def setDipDirection(self, value: "double", uom: "gsoap_eml2_3::eml23__PlaneAngleUom") -> "void":
        return _fesapi.Witsml21_WellboreMarker_setDipDirection(self, value, uom)

    def getDipDirectionValue(self) -> "double":
        return _fesapi.Witsml21_WellboreMarker_getDipDirectionValue(self)

    def getDipDirectionUom(self) -> "gsoap_eml2_3::eml23__PlaneAngleUom":
        return _fesapi.Witsml21_WellboreMarker_getDipDirectionUom(self)

    def hasDipDirection(self) -> "bool":
        return _fesapi.Witsml21_WellboreMarker_hasDipDirection(self)
    __swig_destroy__ = _fesapi.delete_Witsml21_WellboreMarker

# Register Witsml21_WellboreMarker in _fesapi:
_fesapi.Witsml21_WellboreMarker_swigregister(Witsml21_WellboreMarker)
class FluidSystemVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fesapi.FluidSystemVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fesapi.FluidSystemVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fesapi.FluidSystemVector___bool__(self)

    def __len__(self) -> "std::vector< prodml2_2::FluidSystem * >::size_type":
        return _fesapi.FluidSystemVector___len__(self)

    def __getslice__(self, i: "std::vector< prodml2_2::FluidSystem * >::difference_type", j: "std::vector< prodml2_2::FluidSystem * >::difference_type") -> "std::vector< prodml2_2::FluidSystem *,std::allocator< prodml2_2::FluidSystem * > > *":
        return _fesapi.FluidSystemVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fesapi.FluidSystemVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< prodml2_2::FluidSystem * >::difference_type", j: "std::vector< prodml2_2::FluidSystem * >::difference_type") -> "void":
        return _fesapi.FluidSystemVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fesapi.FluidSystemVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< prodml2_2::FluidSystem * >::value_type":
        return _fesapi.FluidSystemVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fesapi.FluidSystemVector___setitem__(self, *args)

    def pop(self) -> "std::vector< prodml2_2::FluidSystem * >::value_type":
        return _fesapi.FluidSystemVector_pop(self)

    def append(self, x: "FluidSystem") -> "void":
        return _fesapi.FluidSystemVector_append(self, x)

    def empty(self) -> "bool":
        return _fesapi.FluidSystemVector_empty(self)

    def size(self) -> "std::vector< prodml2_2::FluidSystem * >::size_type":
        return _fesapi.FluidSystemVector_size(self)

    def swap(self, v: "FluidSystemVector") -> "void":
        return _fesapi.FluidSystemVector_swap(self, v)

    def begin(self) -> "std::vector< prodml2_2::FluidSystem * >::iterator":
        return _fesapi.FluidSystemVector_begin(self)

    def end(self) -> "std::vector< prodml2_2::FluidSystem * >::iterator":
        return _fesapi.FluidSystemVector_end(self)

    def rbegin(self) -> "std::vector< prodml2_2::FluidSystem * >::reverse_iterator":
        return _fesapi.FluidSystemVector_rbegin(self)

    def rend(self) -> "std::vector< prodml2_2::FluidSystem * >::reverse_iterator":
        return _fesapi.FluidSystemVector_rend(self)

    def clear(self) -> "void":
        return _fesapi.FluidSystemVector_clear(self)

    def get_allocator(self) -> "std::vector< prodml2_2::FluidSystem * >::allocator_type":
        return _fesapi.FluidSystemVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fesapi.FluidSystemVector_pop_back(self)

    def erase(self, *args) -> "std::vector< prodml2_2::FluidSystem * >::iterator":
        return _fesapi.FluidSystemVector_erase(self, *args)

    def __init__(self, *args):
        _fesapi.FluidSystemVector_swiginit(self, _fesapi.new_FluidSystemVector(*args))

    def push_back(self, x: "FluidSystem") -> "void":
        return _fesapi.FluidSystemVector_push_back(self, x)

    def front(self) -> "std::vector< prodml2_2::FluidSystem * >::value_type":
        return _fesapi.FluidSystemVector_front(self)

    def back(self) -> "std::vector< prodml2_2::FluidSystem * >::value_type":
        return _fesapi.FluidSystemVector_back(self)

    def assign(self, n: "std::vector< prodml2_2::FluidSystem * >::size_type", x: "FluidSystem") -> "void":
        return _fesapi.FluidSystemVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fesapi.FluidSystemVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fesapi.FluidSystemVector_insert(self, *args)

    def reserve(self, n: "std::vector< prodml2_2::FluidSystem * >::size_type") -> "void":
        return _fesapi.FluidSystemVector_reserve(self, n)

    def capacity(self) -> "std::vector< prodml2_2::FluidSystem * >::size_type":
        return _fesapi.FluidSystemVector_capacity(self)
    __swig_destroy__ = _fesapi.delete_FluidSystemVector

# Register FluidSystemVector in _fesapi:
_fesapi.FluidSystemVector_swigregister(FluidSystemVector)
class FluidCharacterizationVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fesapi.FluidCharacterizationVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fesapi.FluidCharacterizationVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fesapi.FluidCharacterizationVector___bool__(self)

    def __len__(self) -> "std::vector< prodml2_2::FluidCharacterization * >::size_type":
        return _fesapi.FluidCharacterizationVector___len__(self)

    def __getslice__(self, i: "std::vector< prodml2_2::FluidCharacterization * >::difference_type", j: "std::vector< prodml2_2::FluidCharacterization * >::difference_type") -> "std::vector< prodml2_2::FluidCharacterization *,std::allocator< prodml2_2::FluidCharacterization * > > *":
        return _fesapi.FluidCharacterizationVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fesapi.FluidCharacterizationVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< prodml2_2::FluidCharacterization * >::difference_type", j: "std::vector< prodml2_2::FluidCharacterization * >::difference_type") -> "void":
        return _fesapi.FluidCharacterizationVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fesapi.FluidCharacterizationVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< prodml2_2::FluidCharacterization * >::value_type":
        return _fesapi.FluidCharacterizationVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fesapi.FluidCharacterizationVector___setitem__(self, *args)

    def pop(self) -> "std::vector< prodml2_2::FluidCharacterization * >::value_type":
        return _fesapi.FluidCharacterizationVector_pop(self)

    def append(self, x: "FluidCharacterization") -> "void":
        return _fesapi.FluidCharacterizationVector_append(self, x)

    def empty(self) -> "bool":
        return _fesapi.FluidCharacterizationVector_empty(self)

    def size(self) -> "std::vector< prodml2_2::FluidCharacterization * >::size_type":
        return _fesapi.FluidCharacterizationVector_size(self)

    def swap(self, v: "FluidCharacterizationVector") -> "void":
        return _fesapi.FluidCharacterizationVector_swap(self, v)

    def begin(self) -> "std::vector< prodml2_2::FluidCharacterization * >::iterator":
        return _fesapi.FluidCharacterizationVector_begin(self)

    def end(self) -> "std::vector< prodml2_2::FluidCharacterization * >::iterator":
        return _fesapi.FluidCharacterizationVector_end(self)

    def rbegin(self) -> "std::vector< prodml2_2::FluidCharacterization * >::reverse_iterator":
        return _fesapi.FluidCharacterizationVector_rbegin(self)

    def rend(self) -> "std::vector< prodml2_2::FluidCharacterization * >::reverse_iterator":
        return _fesapi.FluidCharacterizationVector_rend(self)

    def clear(self) -> "void":
        return _fesapi.FluidCharacterizationVector_clear(self)

    def get_allocator(self) -> "std::vector< prodml2_2::FluidCharacterization * >::allocator_type":
        return _fesapi.FluidCharacterizationVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fesapi.FluidCharacterizationVector_pop_back(self)

    def erase(self, *args) -> "std::vector< prodml2_2::FluidCharacterization * >::iterator":
        return _fesapi.FluidCharacterizationVector_erase(self, *args)

    def __init__(self, *args):
        _fesapi.FluidCharacterizationVector_swiginit(self, _fesapi.new_FluidCharacterizationVector(*args))

    def push_back(self, x: "FluidCharacterization") -> "void":
        return _fesapi.FluidCharacterizationVector_push_back(self, x)

    def front(self) -> "std::vector< prodml2_2::FluidCharacterization * >::value_type":
        return _fesapi.FluidCharacterizationVector_front(self)

    def back(self) -> "std::vector< prodml2_2::FluidCharacterization * >::value_type":
        return _fesapi.FluidCharacterizationVector_back(self)

    def assign(self, n: "std::vector< prodml2_2::FluidCharacterization * >::size_type", x: "FluidCharacterization") -> "void":
        return _fesapi.FluidCharacterizationVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fesapi.FluidCharacterizationVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fesapi.FluidCharacterizationVector_insert(self, *args)

    def reserve(self, n: "std::vector< prodml2_2::FluidCharacterization * >::size_type") -> "void":
        return _fesapi.FluidCharacterizationVector_reserve(self, n)

    def capacity(self) -> "std::vector< prodml2_2::FluidCharacterization * >::size_type":
        return _fesapi.FluidCharacterizationVector_capacity(self)
    __swig_destroy__ = _fesapi.delete_FluidCharacterizationVector

# Register FluidCharacterizationVector in _fesapi:
_fesapi.FluidCharacterizationVector_swigregister(FluidCharacterizationVector)
class TimeSeriesDataVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fesapi.TimeSeriesDataVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fesapi.TimeSeriesDataVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fesapi.TimeSeriesDataVector___bool__(self)

    def __len__(self) -> "std::vector< prodml2_2::TimeSeriesData * >::size_type":
        return _fesapi.TimeSeriesDataVector___len__(self)

    def __getslice__(self, i: "std::vector< prodml2_2::TimeSeriesData * >::difference_type", j: "std::vector< prodml2_2::TimeSeriesData * >::difference_type") -> "std::vector< prodml2_2::TimeSeriesData *,std::allocator< prodml2_2::TimeSeriesData * > > *":
        return _fesapi.TimeSeriesDataVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fesapi.TimeSeriesDataVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< prodml2_2::TimeSeriesData * >::difference_type", j: "std::vector< prodml2_2::TimeSeriesData * >::difference_type") -> "void":
        return _fesapi.TimeSeriesDataVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fesapi.TimeSeriesDataVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< prodml2_2::TimeSeriesData * >::value_type":
        return _fesapi.TimeSeriesDataVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fesapi.TimeSeriesDataVector___setitem__(self, *args)

    def pop(self) -> "std::vector< prodml2_2::TimeSeriesData * >::value_type":
        return _fesapi.TimeSeriesDataVector_pop(self)

    def append(self, x: "TimeSeriesData") -> "void":
        return _fesapi.TimeSeriesDataVector_append(self, x)

    def empty(self) -> "bool":
        return _fesapi.TimeSeriesDataVector_empty(self)

    def size(self) -> "std::vector< prodml2_2::TimeSeriesData * >::size_type":
        return _fesapi.TimeSeriesDataVector_size(self)

    def swap(self, v: "TimeSeriesDataVector") -> "void":
        return _fesapi.TimeSeriesDataVector_swap(self, v)

    def begin(self) -> "std::vector< prodml2_2::TimeSeriesData * >::iterator":
        return _fesapi.TimeSeriesDataVector_begin(self)

    def end(self) -> "std::vector< prodml2_2::TimeSeriesData * >::iterator":
        return _fesapi.TimeSeriesDataVector_end(self)

    def rbegin(self) -> "std::vector< prodml2_2::TimeSeriesData * >::reverse_iterator":
        return _fesapi.TimeSeriesDataVector_rbegin(self)

    def rend(self) -> "std::vector< prodml2_2::TimeSeriesData * >::reverse_iterator":
        return _fesapi.TimeSeriesDataVector_rend(self)

    def clear(self) -> "void":
        return _fesapi.TimeSeriesDataVector_clear(self)

    def get_allocator(self) -> "std::vector< prodml2_2::TimeSeriesData * >::allocator_type":
        return _fesapi.TimeSeriesDataVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _fesapi.TimeSeriesDataVector_pop_back(self)

    def erase(self, *args) -> "std::vector< prodml2_2::TimeSeriesData * >::iterator":
        return _fesapi.TimeSeriesDataVector_erase(self, *args)

    def __init__(self, *args):
        _fesapi.TimeSeriesDataVector_swiginit(self, _fesapi.new_TimeSeriesDataVector(*args))

    def push_back(self, x: "TimeSeriesData") -> "void":
        return _fesapi.TimeSeriesDataVector_push_back(self, x)

    def front(self) -> "std::vector< prodml2_2::TimeSeriesData * >::value_type":
        return _fesapi.TimeSeriesDataVector_front(self)

    def back(self) -> "std::vector< prodml2_2::TimeSeriesData * >::value_type":
        return _fesapi.TimeSeriesDataVector_back(self)

    def assign(self, n: "std::vector< prodml2_2::TimeSeriesData * >::size_type", x: "TimeSeriesData") -> "void":
        return _fesapi.TimeSeriesDataVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fesapi.TimeSeriesDataVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fesapi.TimeSeriesDataVector_insert(self, *args)

    def reserve(self, n: "std::vector< prodml2_2::TimeSeriesData * >::size_type") -> "void":
        return _fesapi.TimeSeriesDataVector_reserve(self, n)

    def capacity(self) -> "std::vector< prodml2_2::TimeSeriesData * >::size_type":
        return _fesapi.TimeSeriesDataVector_capacity(self)
    __swig_destroy__ = _fesapi.delete_TimeSeriesDataVector

# Register TimeSeriesDataVector in _fesapi:
_fesapi.TimeSeriesDataVector_swigregister(TimeSeriesDataVector)
eml23__AmountOfSubstancePerAmountOfSubstanceUom__x0025 = _fesapi.eml23__AmountOfSubstancePerAmountOfSubstanceUom__x0025
eml23__AmountOfSubstancePerAmountOfSubstanceUom__x0025_x005bmolar_x005d = _fesapi.eml23__AmountOfSubstancePerAmountOfSubstanceUom__x0025_x005bmolar_x005d
eml23__AmountOfSubstancePerAmountOfSubstanceUom_Euc = _fesapi.eml23__AmountOfSubstancePerAmountOfSubstanceUom_Euc
eml23__AmountOfSubstancePerAmountOfSubstanceUom_mol_x002fmol = _fesapi.eml23__AmountOfSubstancePerAmountOfSubstanceUom_mol_x002fmol
eml23__AmountOfSubstancePerAmountOfSubstanceUom_nEuc = _fesapi.eml23__AmountOfSubstancePerAmountOfSubstanceUom_nEuc
eml23__AmountOfSubstancePerAmountOfSubstanceUom_ppk = _fesapi.eml23__AmountOfSubstancePerAmountOfSubstanceUom_ppk
eml23__AmountOfSubstancePerAmountOfSubstanceUom_ppm = _fesapi.eml23__AmountOfSubstancePerAmountOfSubstanceUom_ppm
eml23__ThermodynamicTemperatureUom_K = _fesapi.eml23__ThermodynamicTemperatureUom_K
eml23__ThermodynamicTemperatureUom_degC = _fesapi.eml23__ThermodynamicTemperatureUom_degC
eml23__ThermodynamicTemperatureUom_degF = _fesapi.eml23__ThermodynamicTemperatureUom_degF
eml23__ThermodynamicTemperatureUom_degR = _fesapi.eml23__ThermodynamicTemperatureUom_degR
prodml22__ThermodynamicPhase_aqueous = _fesapi.prodml22__ThermodynamicPhase_aqueous
prodml22__ThermodynamicPhase_oleic = _fesapi.prodml22__ThermodynamicPhase_oleic
prodml22__ThermodynamicPhase_vapor = _fesapi.prodml22__ThermodynamicPhase_vapor
prodml22__ThermodynamicPhase_total_x0020hydrocarbon = _fesapi.prodml22__ThermodynamicPhase_total_x0020hydrocarbon
eml23__PressureUom__0_x002e01_x0020lbf_x002fft2 = _fesapi.eml23__PressureUom__0_x002e01_x0020lbf_x002fft2
eml23__PressureUom_at = _fesapi.eml23__PressureUom_at
eml23__PressureUom_atm = _fesapi.eml23__PressureUom_atm
eml23__PressureUom_bar = _fesapi.eml23__PressureUom_bar
eml23__PressureUom_cmH2O_x005b4degC_x005d = _fesapi.eml23__PressureUom_cmH2O_x005b4degC_x005d
eml23__PressureUom_cPa = _fesapi.eml23__PressureUom_cPa
eml23__PressureUom_dPa = _fesapi.eml23__PressureUom_dPa
eml23__PressureUom_dyne_x002fcm2 = _fesapi.eml23__PressureUom_dyne_x002fcm2
eml23__PressureUom_EPa = _fesapi.eml23__PressureUom_EPa
eml23__PressureUom_fPa = _fesapi.eml23__PressureUom_fPa
eml23__PressureUom_GPa = _fesapi.eml23__PressureUom_GPa
eml23__PressureUom_hbar = _fesapi.eml23__PressureUom_hbar
eml23__PressureUom_inH2O_x005b39degF_x005d = _fesapi.eml23__PressureUom_inH2O_x005b39degF_x005d
eml23__PressureUom_inH2O_x005b60degF_x005d = _fesapi.eml23__PressureUom_inH2O_x005b60degF_x005d
eml23__PressureUom_inHg_x005b32degF_x005d = _fesapi.eml23__PressureUom_inHg_x005b32degF_x005d
eml23__PressureUom_inHg_x005b60degF_x005d = _fesapi.eml23__PressureUom_inHg_x005b60degF_x005d
eml23__PressureUom_kgf_x002fcm2 = _fesapi.eml23__PressureUom_kgf_x002fcm2
eml23__PressureUom_kgf_x002fm2 = _fesapi.eml23__PressureUom_kgf_x002fm2
eml23__PressureUom_kgf_x002fmm2 = _fesapi.eml23__PressureUom_kgf_x002fmm2
eml23__PressureUom_kN_x002fm2 = _fesapi.eml23__PressureUom_kN_x002fm2
eml23__PressureUom_kPa = _fesapi.eml23__PressureUom_kPa
eml23__PressureUom_kpsi = _fesapi.eml23__PressureUom_kpsi
eml23__PressureUom_lbf_x002fft2 = _fesapi.eml23__PressureUom_lbf_x002fft2
eml23__PressureUom_mbar = _fesapi.eml23__PressureUom_mbar
eml23__PressureUom_mmHg_x005b0degC_x005d = _fesapi.eml23__PressureUom_mmHg_x005b0degC_x005d
eml23__PressureUom_mPa = _fesapi.eml23__PressureUom_mPa
eml23__PressureUom_MPa = _fesapi.eml23__PressureUom_MPa
eml23__PressureUom_Mpsi = _fesapi.eml23__PressureUom_Mpsi
eml23__PressureUom_N_x002fm2 = _fesapi.eml23__PressureUom_N_x002fm2
eml23__PressureUom_N_x002fmm2 = _fesapi.eml23__PressureUom_N_x002fmm2
eml23__PressureUom_nPa = _fesapi.eml23__PressureUom_nPa
eml23__PressureUom_Pa = _fesapi.eml23__PressureUom_Pa
eml23__PressureUom_pPa = _fesapi.eml23__PressureUom_pPa
eml23__PressureUom_psi = _fesapi.eml23__PressureUom_psi
eml23__PressureUom_tonf_x005bUK_x005d_x002fft2 = _fesapi.eml23__PressureUom_tonf_x005bUK_x005d_x002fft2
eml23__PressureUom_tonf_x005bUS_x005d_x002fft2 = _fesapi.eml23__PressureUom_tonf_x005bUS_x005d_x002fft2
eml23__PressureUom_tonf_x005bUS_x005d_x002fin2 = _fesapi.eml23__PressureUom_tonf_x005bUS_x005d_x002fin2
eml23__PressureUom_torr = _fesapi.eml23__PressureUom_torr
eml23__PressureUom_TPa = _fesapi.eml23__PressureUom_TPa
eml23__PressureUom_ubar = _fesapi.eml23__PressureUom_ubar
eml23__PressureUom_umHg_x005b0degC_x005d = _fesapi.eml23__PressureUom_umHg_x005b0degC_x005d
eml23__PressureUom_uPa = _fesapi.eml23__PressureUom_uPa
eml23__PressureUom_upsi = _fesapi.eml23__PressureUom_upsi
prodml22__ReservoirFluidKind_black_x0020oil = _fesapi.prodml22__ReservoirFluidKind_black_x0020oil
prodml22__ReservoirFluidKind_critical_x0020or_x0020near_x0020critical = _fesapi.prodml22__ReservoirFluidKind_critical_x0020or_x0020near_x0020critical
prodml22__ReservoirFluidKind_dry_x0020gas = _fesapi.prodml22__ReservoirFluidKind_dry_x0020gas
prodml22__ReservoirFluidKind_heavy_x0020oil = _fesapi.prodml22__ReservoirFluidKind_heavy_x0020oil
prodml22__ReservoirFluidKind_wet_x0020gas_x0020or_x0020condensate = _fesapi.prodml22__ReservoirFluidKind_wet_x0020gas_x0020or_x0020condensate
prodml22__ReservoirFluidKind_volatile_x0020oil = _fesapi.prodml22__ReservoirFluidKind_volatile_x0020oil
prodml22__ReservoirFluidKind_unknown = _fesapi.prodml22__ReservoirFluidKind_unknown
eml23__VolumePerVolumeUom__x0025 = _fesapi.eml23__VolumePerVolumeUom__x0025
eml23__VolumePerVolumeUom__x0025_x005bvol_x005d = _fesapi.eml23__VolumePerVolumeUom__x0025_x005bvol_x005d
eml23__VolumePerVolumeUom__0_x002e001_x0020bbl_x002fft3 = _fesapi.eml23__VolumePerVolumeUom__0_x002e001_x0020bbl_x002fft3
eml23__VolumePerVolumeUom__0_x002e001_x0020bbl_x002fm3 = _fesapi.eml23__VolumePerVolumeUom__0_x002e001_x0020bbl_x002fm3
eml23__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUK_x005d_x002fbbl = _fesapi.eml23__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUK_x005d_x002fbbl
eml23__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d = _fesapi.eml23__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d
eml23__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fbbl = _fesapi.eml23__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fbbl
eml23__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fft3 = _fesapi.eml23__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fft3
eml23__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d = _fesapi.eml23__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d
eml23__VolumePerVolumeUom__0_x002e001_x0020pt_x005bUK_x005d_x002fbbl = _fesapi.eml23__VolumePerVolumeUom__0_x002e001_x0020pt_x005bUK_x005d_x002fbbl
eml23__VolumePerVolumeUom__0_x002e01_x0020bbl_x002fbbl = _fesapi.eml23__VolumePerVolumeUom__0_x002e01_x0020bbl_x002fbbl
eml23__VolumePerVolumeUom__0_x002e1_x0020gal_x005bUS_x005d_x002fbbl = _fesapi.eml23__VolumePerVolumeUom__0_x002e1_x0020gal_x005bUS_x005d_x002fbbl
eml23__VolumePerVolumeUom__0_x002e1_x0020L_x002fbbl = _fesapi.eml23__VolumePerVolumeUom__0_x002e1_x0020L_x002fbbl
eml23__VolumePerVolumeUom__0_x002e1_x0020pt_x005bUS_x005d_x002fbbl = _fesapi.eml23__VolumePerVolumeUom__0_x002e1_x0020pt_x005bUS_x005d_x002fbbl
eml23__VolumePerVolumeUom__1000_x0020ft3_x002fbbl = _fesapi.eml23__VolumePerVolumeUom__1000_x0020ft3_x002fbbl
eml23__VolumePerVolumeUom__1000_x0020m3_x002fm3 = _fesapi.eml23__VolumePerVolumeUom__1000_x0020m3_x002fm3
eml23__VolumePerVolumeUom__1E_6_x0020acre_x002eft_x002fbbl = _fesapi.eml23__VolumePerVolumeUom__1E_6_x0020acre_x002eft_x002fbbl
eml23__VolumePerVolumeUom__1E_6_x0020bbl_x002fft3 = _fesapi.eml23__VolumePerVolumeUom__1E_6_x0020bbl_x002fft3
eml23__VolumePerVolumeUom__1E_6_x0020bbl_x002fm3 = _fesapi.eml23__VolumePerVolumeUom__1E_6_x0020bbl_x002fm3
eml23__VolumePerVolumeUom__1E6_x0020bbl_x002f_x0028acre_x002eft_x0029 = _fesapi.eml23__VolumePerVolumeUom__1E6_x0020bbl_x002f_x0028acre_x002eft_x0029
eml23__VolumePerVolumeUom__1E6_x0020ft3_x002f_x0028acre_x002eft_x0029 = _fesapi.eml23__VolumePerVolumeUom__1E6_x0020ft3_x002f_x0028acre_x002eft_x0029
eml23__VolumePerVolumeUom__1E6_x0020ft3_x002fbbl = _fesapi.eml23__VolumePerVolumeUom__1E6_x0020ft3_x002fbbl
eml23__VolumePerVolumeUom_bbl_x002f_x0028acre_x002eft_x0029 = _fesapi.eml23__VolumePerVolumeUom_bbl_x002f_x0028acre_x002eft_x0029
eml23__VolumePerVolumeUom_bbl_x002fbbl = _fesapi.eml23__VolumePerVolumeUom_bbl_x002fbbl
eml23__VolumePerVolumeUom_bbl_x002fft3 = _fesapi.eml23__VolumePerVolumeUom_bbl_x002fft3
eml23__VolumePerVolumeUom_bbl_x002fm3 = _fesapi.eml23__VolumePerVolumeUom_bbl_x002fm3
eml23__VolumePerVolumeUom_cEuc = _fesapi.eml23__VolumePerVolumeUom_cEuc
eml23__VolumePerVolumeUom_cm3_x002fcm3 = _fesapi.eml23__VolumePerVolumeUom_cm3_x002fcm3
eml23__VolumePerVolumeUom_cm3_x002fL = _fesapi.eml23__VolumePerVolumeUom_cm3_x002fL
eml23__VolumePerVolumeUom_cm3_x002fm3 = _fesapi.eml23__VolumePerVolumeUom_cm3_x002fm3
eml23__VolumePerVolumeUom_dm3_x002fm3 = _fesapi.eml23__VolumePerVolumeUom_dm3_x002fm3
eml23__VolumePerVolumeUom_Euc = _fesapi.eml23__VolumePerVolumeUom_Euc
eml23__VolumePerVolumeUom_ft3_x002fbbl = _fesapi.eml23__VolumePerVolumeUom_ft3_x002fbbl
eml23__VolumePerVolumeUom_ft3_x002fft3 = _fesapi.eml23__VolumePerVolumeUom_ft3_x002fft3
eml23__VolumePerVolumeUom_gal_x005bUK_x005d_x002fft3 = _fesapi.eml23__VolumePerVolumeUom_gal_x005bUK_x005d_x002fft3
eml23__VolumePerVolumeUom_gal_x005bUS_x005d_x002fbbl = _fesapi.eml23__VolumePerVolumeUom_gal_x005bUS_x005d_x002fbbl
eml23__VolumePerVolumeUom_gal_x005bUS_x005d_x002fft3 = _fesapi.eml23__VolumePerVolumeUom_gal_x005bUS_x005d_x002fft3
eml23__VolumePerVolumeUom_L_x002fm3 = _fesapi.eml23__VolumePerVolumeUom_L_x002fm3
eml23__VolumePerVolumeUom_m3_x002f_x0028ha_x002em_x0029 = _fesapi.eml23__VolumePerVolumeUom_m3_x002f_x0028ha_x002em_x0029
eml23__VolumePerVolumeUom_m3_x002fbbl = _fesapi.eml23__VolumePerVolumeUom_m3_x002fbbl
eml23__VolumePerVolumeUom_m3_x002fm3 = _fesapi.eml23__VolumePerVolumeUom_m3_x002fm3
eml23__VolumePerVolumeUom_mL_x002fgal_x005bUK_x005d = _fesapi.eml23__VolumePerVolumeUom_mL_x002fgal_x005bUK_x005d
eml23__VolumePerVolumeUom_mL_x002fgal_x005bUS_x005d = _fesapi.eml23__VolumePerVolumeUom_mL_x002fgal_x005bUS_x005d
eml23__VolumePerVolumeUom_mL_x002fmL = _fesapi.eml23__VolumePerVolumeUom_mL_x002fmL
eml23__VolumePerVolumeUom_ppk = _fesapi.eml23__VolumePerVolumeUom_ppk
eml23__VolumePerVolumeUom_ppm = _fesapi.eml23__VolumePerVolumeUom_ppm
eml23__VolumePerVolumeUom_ppm_x005bvol_x005d = _fesapi.eml23__VolumePerVolumeUom_ppm_x005bvol_x005d
eml23__MassPerMassUom__x0025 = _fesapi.eml23__MassPerMassUom__x0025
eml23__MassPerMassUom__x0025_x005bmass_x005d = _fesapi.eml23__MassPerMassUom__x0025_x005bmass_x005d
eml23__MassPerMassUom_Euc = _fesapi.eml23__MassPerMassUom_Euc
eml23__MassPerMassUom_g_x002fkg = _fesapi.eml23__MassPerMassUom_g_x002fkg
eml23__MassPerMassUom_g_x002ft = _fesapi.eml23__MassPerMassUom_g_x002ft
eml23__MassPerMassUom_kg_x002fkg = _fesapi.eml23__MassPerMassUom_kg_x002fkg
eml23__MassPerMassUom_kg_x002fsack_x005b94lbm_x005d = _fesapi.eml23__MassPerMassUom_kg_x002fsack_x005b94lbm_x005d
eml23__MassPerMassUom_kg_x002ft = _fesapi.eml23__MassPerMassUom_kg_x002ft
eml23__MassPerMassUom_mg_x002fg = _fesapi.eml23__MassPerMassUom_mg_x002fg
eml23__MassPerMassUom_mg_x002fkg = _fesapi.eml23__MassPerMassUom_mg_x002fkg
eml23__MassPerMassUom_ng_x002fg = _fesapi.eml23__MassPerMassUom_ng_x002fg
eml23__MassPerMassUom_ng_x002fmg = _fesapi.eml23__MassPerMassUom_ng_x002fmg
eml23__MassPerMassUom_ppk = _fesapi.eml23__MassPerMassUom_ppk
eml23__MassPerMassUom_ppm = _fesapi.eml23__MassPerMassUom_ppm
eml23__MassPerMassUom_ppm_x005bmass_x005d = _fesapi.eml23__MassPerMassUom_ppm_x005bmass_x005d
eml23__MassPerMassUom_ug_x002fg = _fesapi.eml23__MassPerMassUom_ug_x002fg
eml23__MassPerMassUom_ug_x002fmg = _fesapi.eml23__MassPerMassUom_ug_x002fmg
prodml22__PureComponentKind__1_2_4_trimethylbenzene = _fesapi.prodml22__PureComponentKind__1_2_4_trimethylbenzene
prodml22__PureComponentKind__2_dimethylbutane = _fesapi.prodml22__PureComponentKind__2_dimethylbutane
prodml22__PureComponentKind__3_dimethylbutane = _fesapi.prodml22__PureComponentKind__3_dimethylbutane
prodml22__PureComponentKind_ar = _fesapi.prodml22__PureComponentKind_ar
prodml22__PureComponentKind_c1 = _fesapi.prodml22__PureComponentKind_c1
prodml22__PureComponentKind_c2 = _fesapi.prodml22__PureComponentKind_c2
prodml22__PureComponentKind_c3 = _fesapi.prodml22__PureComponentKind_c3
prodml22__PureComponentKind_co2 = _fesapi.prodml22__PureComponentKind_co2
prodml22__PureComponentKind_cos = _fesapi.prodml22__PureComponentKind_cos
prodml22__PureComponentKind_h2 = _fesapi.prodml22__PureComponentKind_h2
prodml22__PureComponentKind_h2o = _fesapi.prodml22__PureComponentKind_h2o
prodml22__PureComponentKind_h2s = _fesapi.prodml22__PureComponentKind_h2s
prodml22__PureComponentKind_he = _fesapi.prodml22__PureComponentKind_he
prodml22__PureComponentKind_hg = _fesapi.prodml22__PureComponentKind_hg
prodml22__PureComponentKind_i_c4 = _fesapi.prodml22__PureComponentKind_i_c4
prodml22__PureComponentKind_i_c5 = _fesapi.prodml22__PureComponentKind_i_c5
prodml22__PureComponentKind_n2 = _fesapi.prodml22__PureComponentKind_n2
prodml22__PureComponentKind_n_c10 = _fesapi.prodml22__PureComponentKind_n_c10
prodml22__PureComponentKind_n_c4 = _fesapi.prodml22__PureComponentKind_n_c4
prodml22__PureComponentKind_n_c5 = _fesapi.prodml22__PureComponentKind_n_c5
prodml22__PureComponentKind_n_c6 = _fesapi.prodml22__PureComponentKind_n_c6
prodml22__PureComponentKind_n_c7 = _fesapi.prodml22__PureComponentKind_n_c7
prodml22__PureComponentKind_n_c8 = _fesapi.prodml22__PureComponentKind_n_c8
prodml22__PureComponentKind_n_c9 = _fesapi.prodml22__PureComponentKind_n_c9
prodml22__PureComponentKind_neo_c5 = _fesapi.prodml22__PureComponentKind_neo_c5
prodml22__PureComponentKind_ra = _fesapi.prodml22__PureComponentKind_ra
prodml22__PureComponentKind_benzene = _fesapi.prodml22__PureComponentKind_benzene
prodml22__PureComponentKind__2_methylpentane = _fesapi.prodml22__PureComponentKind__2_methylpentane
prodml22__PureComponentKind__3_methylpentane = _fesapi.prodml22__PureComponentKind__3_methylpentane
prodml22__PureComponentKind__2_methylhexane = _fesapi.prodml22__PureComponentKind__2_methylhexane
prodml22__PureComponentKind__3_methylhexane = _fesapi.prodml22__PureComponentKind__3_methylhexane
prodml22__PureComponentKind__2_methylheptane = _fesapi.prodml22__PureComponentKind__2_methylheptane
prodml22__PureComponentKind__3_methylheptane = _fesapi.prodml22__PureComponentKind__3_methylheptane
prodml22__PureComponentKind_cyclohexane = _fesapi.prodml22__PureComponentKind_cyclohexane
prodml22__PureComponentKind_ethylbenzene = _fesapi.prodml22__PureComponentKind_ethylbenzene
prodml22__PureComponentKind_ethylcyclohexane = _fesapi.prodml22__PureComponentKind_ethylcyclohexane
prodml22__PureComponentKind_methylcyclohexane = _fesapi.prodml22__PureComponentKind_methylcyclohexane
prodml22__PureComponentKind_methylcyclopentane = _fesapi.prodml22__PureComponentKind_methylcyclopentane
prodml22__PureComponentKind_toluene = _fesapi.prodml22__PureComponentKind_toluene
prodml22__PureComponentKind_m_xylene = _fesapi.prodml22__PureComponentKind_m_xylene
prodml22__PureComponentKind_o_xylene = _fesapi.prodml22__PureComponentKind_o_xylene
prodml22__PureComponentKind_p_xylene = _fesapi.prodml22__PureComponentKind_p_xylene
eml23__MolecularWeightUom_g_x002fmol = _fesapi.eml23__MolecularWeightUom_g_x002fmol
eml23__MolecularWeightUom_kg_x002fmol = _fesapi.eml23__MolecularWeightUom_kg_x002fmol
eml23__MolecularWeightUom_lbm_x002flbmol = _fesapi.eml23__MolecularWeightUom_lbm_x002flbmol
prodml22__PlusComponentKind_c10_x002b = _fesapi.prodml22__PlusComponentKind_c10_x002b
prodml22__PlusComponentKind_c11_x002b = _fesapi.prodml22__PlusComponentKind_c11_x002b
prodml22__PlusComponentKind_c12_x002b = _fesapi.prodml22__PlusComponentKind_c12_x002b
prodml22__PlusComponentKind_c20_x002b = _fesapi.prodml22__PlusComponentKind_c20_x002b
prodml22__PlusComponentKind_c25_x002b = _fesapi.prodml22__PlusComponentKind_c25_x002b
prodml22__PlusComponentKind_c30_x002b = _fesapi.prodml22__PlusComponentKind_c30_x002b
prodml22__PlusComponentKind_c36_x002b = _fesapi.prodml22__PlusComponentKind_c36_x002b
prodml22__PlusComponentKind_c5_x002b = _fesapi.prodml22__PlusComponentKind_c5_x002b
prodml22__PlusComponentKind_c6_x002b = _fesapi.prodml22__PlusComponentKind_c6_x002b
prodml22__PlusComponentKind_c7_x002b = _fesapi.prodml22__PlusComponentKind_c7_x002b
prodml22__PlusComponentKind_c8_x002b = _fesapi.prodml22__PlusComponentKind_c8_x002b
prodml22__PlusComponentKind_c9_x002b = _fesapi.prodml22__PlusComponentKind_c9_x002b
eml23__APIGravityUom_dAPI = _fesapi.eml23__APIGravityUom_dAPI
eml23__EnergyPerMassUom_Btu_x005bIT_x005d_x002flbm = _fesapi.eml23__EnergyPerMassUom_Btu_x005bIT_x005d_x002flbm
eml23__EnergyPerMassUom_cal_x005bth_x005d_x002fg = _fesapi.eml23__EnergyPerMassUom_cal_x005bth_x005d_x002fg
eml23__EnergyPerMassUom_cal_x005bth_x005d_x002fkg = _fesapi.eml23__EnergyPerMassUom_cal_x005bth_x005d_x002fkg
eml23__EnergyPerMassUom_cal_x005bth_x005d_x002flbm = _fesapi.eml23__EnergyPerMassUom_cal_x005bth_x005d_x002flbm
eml23__EnergyPerMassUom_erg_x002fg = _fesapi.eml23__EnergyPerMassUom_erg_x002fg
eml23__EnergyPerMassUom_erg_x002fkg = _fesapi.eml23__EnergyPerMassUom_erg_x002fkg
eml23__EnergyPerMassUom_hp_x002eh_x002flbm = _fesapi.eml23__EnergyPerMassUom_hp_x002eh_x002flbm
eml23__EnergyPerMassUom_J_x002fg = _fesapi.eml23__EnergyPerMassUom_J_x002fg
eml23__EnergyPerMassUom_J_x002fkg = _fesapi.eml23__EnergyPerMassUom_J_x002fkg
eml23__EnergyPerMassUom_kcal_x005bth_x005d_x002fg = _fesapi.eml23__EnergyPerMassUom_kcal_x005bth_x005d_x002fg
eml23__EnergyPerMassUom_kcal_x005bth_x005d_x002fkg = _fesapi.eml23__EnergyPerMassUom_kcal_x005bth_x005d_x002fkg
eml23__EnergyPerMassUom_kJ_x002fkg = _fesapi.eml23__EnergyPerMassUom_kJ_x002fkg
eml23__EnergyPerMassUom_kW_x002eh_x002fkg = _fesapi.eml23__EnergyPerMassUom_kW_x002eh_x002fkg
eml23__EnergyPerMassUom_lbf_x002eft_x002flbm = _fesapi.eml23__EnergyPerMassUom_lbf_x002eft_x002flbm
eml23__EnergyPerMassUom_MJ_x002fkg = _fesapi.eml23__EnergyPerMassUom_MJ_x002fkg
eml23__EnergyPerMassUom_MW_x002eh_x002fkg = _fesapi.eml23__EnergyPerMassUom_MW_x002eh_x002fkg
eml23__EnergyPerVolumeUom_Btu_x005bIT_x005d_x002fbbl = _fesapi.eml23__EnergyPerVolumeUom_Btu_x005bIT_x005d_x002fbbl
eml23__EnergyPerVolumeUom_Btu_x005bIT_x005d_x002fft3 = _fesapi.eml23__EnergyPerVolumeUom_Btu_x005bIT_x005d_x002fft3
eml23__EnergyPerVolumeUom_Btu_x005bIT_x005d_x002fgal_x005bUK_x005d = _fesapi.eml23__EnergyPerVolumeUom_Btu_x005bIT_x005d_x002fgal_x005bUK_x005d
eml23__EnergyPerVolumeUom_Btu_x005bIT_x005d_x002fgal_x005bUS_x005d = _fesapi.eml23__EnergyPerVolumeUom_Btu_x005bIT_x005d_x002fgal_x005bUS_x005d
eml23__EnergyPerVolumeUom_cal_x005bth_x005d_x002fcm3 = _fesapi.eml23__EnergyPerVolumeUom_cal_x005bth_x005d_x002fcm3
eml23__EnergyPerVolumeUom_cal_x005bth_x005d_x002fmL = _fesapi.eml23__EnergyPerVolumeUom_cal_x005bth_x005d_x002fmL
eml23__EnergyPerVolumeUom_cal_x005bth_x005d_x002fmm3 = _fesapi.eml23__EnergyPerVolumeUom_cal_x005bth_x005d_x002fmm3
eml23__EnergyPerVolumeUom_erg_x002fcm3 = _fesapi.eml23__EnergyPerVolumeUom_erg_x002fcm3
eml23__EnergyPerVolumeUom_erg_x002fm3 = _fesapi.eml23__EnergyPerVolumeUom_erg_x002fm3
eml23__EnergyPerVolumeUom_hp_x002eh_x002fbbl = _fesapi.eml23__EnergyPerVolumeUom_hp_x002eh_x002fbbl
eml23__EnergyPerVolumeUom_J_x002fdm3 = _fesapi.eml23__EnergyPerVolumeUom_J_x002fdm3
eml23__EnergyPerVolumeUom_J_x002fm3 = _fesapi.eml23__EnergyPerVolumeUom_J_x002fm3
eml23__EnergyPerVolumeUom_kcal_x005bth_x005d_x002fcm3 = _fesapi.eml23__EnergyPerVolumeUom_kcal_x005bth_x005d_x002fcm3
eml23__EnergyPerVolumeUom_kcal_x005bth_x005d_x002fm3 = _fesapi.eml23__EnergyPerVolumeUom_kcal_x005bth_x005d_x002fm3
eml23__EnergyPerVolumeUom_kJ_x002fdm3 = _fesapi.eml23__EnergyPerVolumeUom_kJ_x002fdm3
eml23__EnergyPerVolumeUom_kJ_x002fm3 = _fesapi.eml23__EnergyPerVolumeUom_kJ_x002fm3
eml23__EnergyPerVolumeUom_kW_x002eh_x002fdm3 = _fesapi.eml23__EnergyPerVolumeUom_kW_x002eh_x002fdm3
eml23__EnergyPerVolumeUom_kW_x002eh_x002fm3 = _fesapi.eml23__EnergyPerVolumeUom_kW_x002eh_x002fm3
eml23__EnergyPerVolumeUom_lbf_x002eft_x002fbbl = _fesapi.eml23__EnergyPerVolumeUom_lbf_x002eft_x002fbbl
eml23__EnergyPerVolumeUom_lbf_x002eft_x002fgal_x005bUS_x005d = _fesapi.eml23__EnergyPerVolumeUom_lbf_x002eft_x002fgal_x005bUS_x005d
eml23__EnergyPerVolumeUom_MJ_x002fm3 = _fesapi.eml23__EnergyPerVolumeUom_MJ_x002fm3
eml23__EnergyPerVolumeUom_MW_x002eh_x002fm3 = _fesapi.eml23__EnergyPerVolumeUom_MW_x002eh_x002fm3
eml23__EnergyPerVolumeUom_tonf_x005bUS_x005d_x002emi_x002fbbl = _fesapi.eml23__EnergyPerVolumeUom_tonf_x005bUS_x005d_x002emi_x002fbbl
prodml22__PseudoComponentKind_c10 = _fesapi.prodml22__PseudoComponentKind_c10
prodml22__PseudoComponentKind_c11 = _fesapi.prodml22__PseudoComponentKind_c11
prodml22__PseudoComponentKind_c12 = _fesapi.prodml22__PseudoComponentKind_c12
prodml22__PseudoComponentKind_c13 = _fesapi.prodml22__PseudoComponentKind_c13
prodml22__PseudoComponentKind_c14 = _fesapi.prodml22__PseudoComponentKind_c14
prodml22__PseudoComponentKind_c15 = _fesapi.prodml22__PseudoComponentKind_c15
prodml22__PseudoComponentKind_c16 = _fesapi.prodml22__PseudoComponentKind_c16
prodml22__PseudoComponentKind_c17 = _fesapi.prodml22__PseudoComponentKind_c17
prodml22__PseudoComponentKind_c18 = _fesapi.prodml22__PseudoComponentKind_c18
prodml22__PseudoComponentKind_c19 = _fesapi.prodml22__PseudoComponentKind_c19
prodml22__PseudoComponentKind_c20 = _fesapi.prodml22__PseudoComponentKind_c20
prodml22__PseudoComponentKind_c21 = _fesapi.prodml22__PseudoComponentKind_c21
prodml22__PseudoComponentKind_c22 = _fesapi.prodml22__PseudoComponentKind_c22
prodml22__PseudoComponentKind_c23 = _fesapi.prodml22__PseudoComponentKind_c23
prodml22__PseudoComponentKind_c24 = _fesapi.prodml22__PseudoComponentKind_c24
prodml22__PseudoComponentKind_c25 = _fesapi.prodml22__PseudoComponentKind_c25
prodml22__PseudoComponentKind_c26 = _fesapi.prodml22__PseudoComponentKind_c26
prodml22__PseudoComponentKind_c27 = _fesapi.prodml22__PseudoComponentKind_c27
prodml22__PseudoComponentKind_c28 = _fesapi.prodml22__PseudoComponentKind_c28
prodml22__PseudoComponentKind_c29 = _fesapi.prodml22__PseudoComponentKind_c29
prodml22__PseudoComponentKind_c2_c4_x002bn2 = _fesapi.prodml22__PseudoComponentKind_c2_c4_x002bn2
prodml22__PseudoComponentKind_c30 = _fesapi.prodml22__PseudoComponentKind_c30
prodml22__PseudoComponentKind_c31 = _fesapi.prodml22__PseudoComponentKind_c31
prodml22__PseudoComponentKind_c32 = _fesapi.prodml22__PseudoComponentKind_c32
prodml22__PseudoComponentKind_c33 = _fesapi.prodml22__PseudoComponentKind_c33
prodml22__PseudoComponentKind_c34 = _fesapi.prodml22__PseudoComponentKind_c34
prodml22__PseudoComponentKind_c35 = _fesapi.prodml22__PseudoComponentKind_c35
prodml22__PseudoComponentKind_c4 = _fesapi.prodml22__PseudoComponentKind_c4
prodml22__PseudoComponentKind_c5 = _fesapi.prodml22__PseudoComponentKind_c5
prodml22__PseudoComponentKind_c6 = _fesapi.prodml22__PseudoComponentKind_c6
prodml22__PseudoComponentKind_c7 = _fesapi.prodml22__PseudoComponentKind_c7
prodml22__PseudoComponentKind_c8 = _fesapi.prodml22__PseudoComponentKind_c8
prodml22__PseudoComponentKind_c9 = _fesapi.prodml22__PseudoComponentKind_c9
prodml22__PseudoComponentKind_rsh = _fesapi.prodml22__PseudoComponentKind_rsh
prodml22__OutputFluidProperty_Compressibility = _fesapi.prodml22__OutputFluidProperty_Compressibility
prodml22__OutputFluidProperty_Density = _fesapi.prodml22__OutputFluidProperty_Density
prodml22__OutputFluidProperty_Derivative_x0020of_x0020Density_x0020w_x002er_x002et_x0020Pressure = _fesapi.prodml22__OutputFluidProperty_Derivative_x0020of_x0020Density_x0020w_x002er_x002et_x0020Pressure
prodml22__OutputFluidProperty_Derivative_x0020of_x0020Density_x0020w_x002er_x002et_x0020Temperature = _fesapi.prodml22__OutputFluidProperty_Derivative_x0020of_x0020Density_x0020w_x002er_x002et_x0020Temperature
prodml22__OutputFluidProperty_Enthalpy = _fesapi.prodml22__OutputFluidProperty_Enthalpy
prodml22__OutputFluidProperty_Entropy = _fesapi.prodml22__OutputFluidProperty_Entropy
prodml22__OutputFluidProperty_Expansion_x0020Factor = _fesapi.prodml22__OutputFluidProperty_Expansion_x0020Factor
prodml22__OutputFluidProperty_Formation_x0020Volume_x0020Factor = _fesapi.prodml22__OutputFluidProperty_Formation_x0020Volume_x0020Factor
prodml22__OutputFluidProperty_Gas_Oil_x0020Interfacial_x0020Tension = _fesapi.prodml22__OutputFluidProperty_Gas_Oil_x0020Interfacial_x0020Tension
prodml22__OutputFluidProperty_Gas_Water_x0020Interfacial_x0020Tension = _fesapi.prodml22__OutputFluidProperty_Gas_Water_x0020Interfacial_x0020Tension
prodml22__OutputFluidProperty_Index = _fesapi.prodml22__OutputFluidProperty_Index
prodml22__OutputFluidProperty_K_x0020value = _fesapi.prodml22__OutputFluidProperty_K_x0020value
prodml22__OutputFluidProperty_Misc_x0020Bank_x0020Critical_x0020Solvent_x0020Saturation = _fesapi.prodml22__OutputFluidProperty_Misc_x0020Bank_x0020Critical_x0020Solvent_x0020Saturation
prodml22__OutputFluidProperty_Misc_x0020Bank_x0020Phase_x0020Density = _fesapi.prodml22__OutputFluidProperty_Misc_x0020Bank_x0020Phase_x0020Density
prodml22__OutputFluidProperty_Misc_x0020Bank_x0020Phase_x0020Viscosity = _fesapi.prodml22__OutputFluidProperty_Misc_x0020Bank_x0020Phase_x0020Viscosity
prodml22__OutputFluidProperty_Miscibility_x0020Parameter_x0020_x0028Alpha_x0029 = _fesapi.prodml22__OutputFluidProperty_Miscibility_x0020Parameter_x0020_x0028Alpha_x0029
prodml22__OutputFluidProperty_Mixing_x0020Parameter_x0020Oil_Gas = _fesapi.prodml22__OutputFluidProperty_Mixing_x0020Parameter_x0020Oil_Gas
prodml22__OutputFluidProperty_Normalized_x0020Pseudo_x0020Pressure = _fesapi.prodml22__OutputFluidProperty_Normalized_x0020Pseudo_x0020Pressure
prodml22__OutputFluidProperty_Oil_Gas_x0020Ratio = _fesapi.prodml22__OutputFluidProperty_Oil_Gas_x0020Ratio
prodml22__OutputFluidProperty_Oil_Water_x0020Interfacial_x0020Tension = _fesapi.prodml22__OutputFluidProperty_Oil_Water_x0020Interfacial_x0020Tension
prodml22__OutputFluidProperty_Parachor = _fesapi.prodml22__OutputFluidProperty_Parachor
prodml22__OutputFluidProperty_Pressure = _fesapi.prodml22__OutputFluidProperty_Pressure
prodml22__OutputFluidProperty_Pseudo_x0020Pressure = _fesapi.prodml22__OutputFluidProperty_Pseudo_x0020Pressure
prodml22__OutputFluidProperty_P_T_x0020Cross_x0020Term = _fesapi.prodml22__OutputFluidProperty_P_T_x0020Cross_x0020Term
prodml22__OutputFluidProperty_Saturation_x0020Pressure = _fesapi.prodml22__OutputFluidProperty_Saturation_x0020Pressure
prodml22__OutputFluidProperty_Solution_x0020GOR = _fesapi.prodml22__OutputFluidProperty_Solution_x0020GOR
prodml22__OutputFluidProperty_Solvent_x0020Density = _fesapi.prodml22__OutputFluidProperty_Solvent_x0020Density
prodml22__OutputFluidProperty_Specific_x0020Heat = _fesapi.prodml22__OutputFluidProperty_Specific_x0020Heat
prodml22__OutputFluidProperty_Temperature = _fesapi.prodml22__OutputFluidProperty_Temperature
prodml22__OutputFluidProperty_Thermal_x0020Conductivity = _fesapi.prodml22__OutputFluidProperty_Thermal_x0020Conductivity
prodml22__OutputFluidProperty_Viscosity = _fesapi.prodml22__OutputFluidProperty_Viscosity
prodml22__OutputFluidProperty_Viscosity_x0020Compressibility = _fesapi.prodml22__OutputFluidProperty_Viscosity_x0020Compressibility
prodml22__OutputFluidProperty_Water_x0020vapor_x0020mass_x0020fraction_x0020in_x0020gas_x0020phase = _fesapi.prodml22__OutputFluidProperty_Water_x0020vapor_x0020mass_x0020fraction_x0020in_x0020gas_x0020phase
prodml22__OutputFluidProperty_Z_x0020Factor = _fesapi.prodml22__OutputFluidProperty_Z_x0020Factor
prodml22__TimeSeriesKeyword_asset_x0020identifier = _fesapi.prodml22__TimeSeriesKeyword_asset_x0020identifier
prodml22__TimeSeriesKeyword_flow = _fesapi.prodml22__TimeSeriesKeyword_flow
prodml22__TimeSeriesKeyword_product = _fesapi.prodml22__TimeSeriesKeyword_product
prodml22__TimeSeriesKeyword_qualifier = _fesapi.prodml22__TimeSeriesKeyword_qualifier
prodml22__TimeSeriesKeyword_subqualifier = _fesapi.prodml22__TimeSeriesKeyword_subqualifier
prodml22__TimeSeriesKeyword_unknown = _fesapi.prodml22__TimeSeriesKeyword_unknown
eml23__MeasureClass_absorbed_x0020dose = _fesapi.eml23__MeasureClass_absorbed_x0020dose
eml23__MeasureClass_activity_x0020of_x0020radioactivity = _fesapi.eml23__MeasureClass_activity_x0020of_x0020radioactivity
eml23__MeasureClass_activity_x0020of_x0020radioactivity_x0020per_x0020volume = _fesapi.eml23__MeasureClass_activity_x0020of_x0020radioactivity_x0020per_x0020volume
eml23__MeasureClass_amount_x0020of_x0020substance = _fesapi.eml23__MeasureClass_amount_x0020of_x0020substance
eml23__MeasureClass_amount_x0020of_x0020substance_x0020per_x0020amount_x0020of_x0020substance = _fesapi.eml23__MeasureClass_amount_x0020of_x0020substance_x0020per_x0020amount_x0020of_x0020substance
eml23__MeasureClass_amount_x0020of_x0020substance_x0020per_x0020area = _fesapi.eml23__MeasureClass_amount_x0020of_x0020substance_x0020per_x0020area
eml23__MeasureClass_amount_x0020of_x0020substance_x0020per_x0020time = _fesapi.eml23__MeasureClass_amount_x0020of_x0020substance_x0020per_x0020time
eml23__MeasureClass_amount_x0020of_x0020substance_x0020per_x0020time_x0020per_x0020area = _fesapi.eml23__MeasureClass_amount_x0020of_x0020substance_x0020per_x0020time_x0020per_x0020area
eml23__MeasureClass_amount_x0020of_x0020substance_x0020per_x0020volume = _fesapi.eml23__MeasureClass_amount_x0020of_x0020substance_x0020per_x0020volume
eml23__MeasureClass_angle_x0020per_x0020length = _fesapi.eml23__MeasureClass_angle_x0020per_x0020length
eml23__MeasureClass_angle_x0020per_x0020volume = _fesapi.eml23__MeasureClass_angle_x0020per_x0020volume
eml23__MeasureClass_angular_x0020acceleration = _fesapi.eml23__MeasureClass_angular_x0020acceleration
eml23__MeasureClass_angular_x0020velocity = _fesapi.eml23__MeasureClass_angular_x0020velocity
eml23__MeasureClass_api_x0020gamma_x0020ray = _fesapi.eml23__MeasureClass_api_x0020gamma_x0020ray
eml23__MeasureClass_api_x0020gravity = _fesapi.eml23__MeasureClass_api_x0020gravity
eml23__MeasureClass_api_x0020neutron = _fesapi.eml23__MeasureClass_api_x0020neutron
eml23__MeasureClass_area = _fesapi.eml23__MeasureClass_area
eml23__MeasureClass_area_x0020per_x0020amount_x0020of_x0020substance = _fesapi.eml23__MeasureClass_area_x0020per_x0020amount_x0020of_x0020substance
eml23__MeasureClass_area_x0020per_x0020area = _fesapi.eml23__MeasureClass_area_x0020per_x0020area
eml23__MeasureClass_area_x0020per_x0020count = _fesapi.eml23__MeasureClass_area_x0020per_x0020count
eml23__MeasureClass_area_x0020per_x0020mass = _fesapi.eml23__MeasureClass_area_x0020per_x0020mass
eml23__MeasureClass_area_x0020per_x0020time = _fesapi.eml23__MeasureClass_area_x0020per_x0020time
eml23__MeasureClass_area_x0020per_x0020volume = _fesapi.eml23__MeasureClass_area_x0020per_x0020volume
eml23__MeasureClass_attenuation_x0020per_x0020frequency_x0020interval = _fesapi.eml23__MeasureClass_attenuation_x0020per_x0020frequency_x0020interval
eml23__MeasureClass_capacitance = _fesapi.eml23__MeasureClass_capacitance
eml23__MeasureClass_cation_x0020exchange_x0020capacity = _fesapi.eml23__MeasureClass_cation_x0020exchange_x0020capacity
eml23__MeasureClass_data_x0020transfer_x0020speed = _fesapi.eml23__MeasureClass_data_x0020transfer_x0020speed
eml23__MeasureClass_diffusion_x0020coefficient = _fesapi.eml23__MeasureClass_diffusion_x0020coefficient
eml23__MeasureClass_diffusive_x0020time_x0020of_x0020flight = _fesapi.eml23__MeasureClass_diffusive_x0020time_x0020of_x0020flight
eml23__MeasureClass_digital_x0020storage = _fesapi.eml23__MeasureClass_digital_x0020storage
eml23__MeasureClass_dimensionless = _fesapi.eml23__MeasureClass_dimensionless
eml23__MeasureClass_dipole_x0020moment = _fesapi.eml23__MeasureClass_dipole_x0020moment
eml23__MeasureClass_dose_x0020equivalent = _fesapi.eml23__MeasureClass_dose_x0020equivalent
eml23__MeasureClass_dynamic_x0020viscosity = _fesapi.eml23__MeasureClass_dynamic_x0020viscosity
eml23__MeasureClass_electric_x0020charge = _fesapi.eml23__MeasureClass_electric_x0020charge
eml23__MeasureClass_electric_x0020charge_x0020per_x0020area = _fesapi.eml23__MeasureClass_electric_x0020charge_x0020per_x0020area
eml23__MeasureClass_electric_x0020charge_x0020per_x0020mass = _fesapi.eml23__MeasureClass_electric_x0020charge_x0020per_x0020mass
eml23__MeasureClass_electric_x0020charge_x0020per_x0020volume = _fesapi.eml23__MeasureClass_electric_x0020charge_x0020per_x0020volume
eml23__MeasureClass_electric_x0020conductance = _fesapi.eml23__MeasureClass_electric_x0020conductance
eml23__MeasureClass_electric_x0020conductivity = _fesapi.eml23__MeasureClass_electric_x0020conductivity
eml23__MeasureClass_electric_x0020current = _fesapi.eml23__MeasureClass_electric_x0020current
eml23__MeasureClass_electric_x0020current_x0020density = _fesapi.eml23__MeasureClass_electric_x0020current_x0020density
eml23__MeasureClass_electric_x0020field_x0020strength = _fesapi.eml23__MeasureClass_electric_x0020field_x0020strength
eml23__MeasureClass_electric_x0020potential_x0020difference = _fesapi.eml23__MeasureClass_electric_x0020potential_x0020difference
eml23__MeasureClass_electric_x0020resistance = _fesapi.eml23__MeasureClass_electric_x0020resistance
eml23__MeasureClass_electric_x0020resistance_x0020per_x0020length = _fesapi.eml23__MeasureClass_electric_x0020resistance_x0020per_x0020length
eml23__MeasureClass_electrical_x0020resistivity = _fesapi.eml23__MeasureClass_electrical_x0020resistivity
eml23__MeasureClass_electromagnetic_x0020moment = _fesapi.eml23__MeasureClass_electromagnetic_x0020moment
eml23__MeasureClass_energy = _fesapi.eml23__MeasureClass_energy
eml23__MeasureClass_energy_x0020length_x0020per_x0020area = _fesapi.eml23__MeasureClass_energy_x0020length_x0020per_x0020area
eml23__MeasureClass_energy_x0020length_x0020per_x0020time_x0020area_x0020temperature = _fesapi.eml23__MeasureClass_energy_x0020length_x0020per_x0020time_x0020area_x0020temperature
eml23__MeasureClass_energy_x0020per_x0020area = _fesapi.eml23__MeasureClass_energy_x0020per_x0020area
eml23__MeasureClass_energy_x0020per_x0020length = _fesapi.eml23__MeasureClass_energy_x0020per_x0020length
eml23__MeasureClass_energy_x0020per_x0020mass = _fesapi.eml23__MeasureClass_energy_x0020per_x0020mass
eml23__MeasureClass_energy_x0020per_x0020mass_x0020per_x0020time = _fesapi.eml23__MeasureClass_energy_x0020per_x0020mass_x0020per_x0020time
eml23__MeasureClass_energy_x0020per_x0020volume = _fesapi.eml23__MeasureClass_energy_x0020per_x0020volume
eml23__MeasureClass_force = _fesapi.eml23__MeasureClass_force
eml23__MeasureClass_force_x0020area = _fesapi.eml23__MeasureClass_force_x0020area
eml23__MeasureClass_force_x0020length_x0020per_x0020length = _fesapi.eml23__MeasureClass_force_x0020length_x0020per_x0020length
eml23__MeasureClass_force_x0020per_x0020force = _fesapi.eml23__MeasureClass_force_x0020per_x0020force
eml23__MeasureClass_force_x0020per_x0020length = _fesapi.eml23__MeasureClass_force_x0020per_x0020length
eml23__MeasureClass_force_x0020per_x0020volume = _fesapi.eml23__MeasureClass_force_x0020per_x0020volume
eml23__MeasureClass_frequency = _fesapi.eml23__MeasureClass_frequency
eml23__MeasureClass_frequency_x0020interval = _fesapi.eml23__MeasureClass_frequency_x0020interval
eml23__MeasureClass_heat_x0020capacity = _fesapi.eml23__MeasureClass_heat_x0020capacity
eml23__MeasureClass_heat_x0020flow_x0020rate = _fesapi.eml23__MeasureClass_heat_x0020flow_x0020rate
eml23__MeasureClass_heat_x0020transfer_x0020coefficient = _fesapi.eml23__MeasureClass_heat_x0020transfer_x0020coefficient
eml23__MeasureClass_illuminance = _fesapi.eml23__MeasureClass_illuminance
eml23__MeasureClass_inductance = _fesapi.eml23__MeasureClass_inductance
eml23__MeasureClass_isothermal_x0020compressibility = _fesapi.eml23__MeasureClass_isothermal_x0020compressibility
eml23__MeasureClass_kinematic_x0020viscosity = _fesapi.eml23__MeasureClass_kinematic_x0020viscosity
eml23__MeasureClass_length = _fesapi.eml23__MeasureClass_length
eml23__MeasureClass_length_x0020per_x0020angle = _fesapi.eml23__MeasureClass_length_x0020per_x0020angle
eml23__MeasureClass_length_x0020per_x0020length = _fesapi.eml23__MeasureClass_length_x0020per_x0020length
eml23__MeasureClass_length_x0020per_x0020mass = _fesapi.eml23__MeasureClass_length_x0020per_x0020mass
eml23__MeasureClass_length_x0020per_x0020pressure = _fesapi.eml23__MeasureClass_length_x0020per_x0020pressure
eml23__MeasureClass_length_x0020per_x0020temperature = _fesapi.eml23__MeasureClass_length_x0020per_x0020temperature
eml23__MeasureClass_length_x0020per_x0020time = _fesapi.eml23__MeasureClass_length_x0020per_x0020time
eml23__MeasureClass_length_x0020per_x0020volume = _fesapi.eml23__MeasureClass_length_x0020per_x0020volume
eml23__MeasureClass_light_x0020exposure = _fesapi.eml23__MeasureClass_light_x0020exposure
eml23__MeasureClass_linear_x0020acceleration = _fesapi.eml23__MeasureClass_linear_x0020acceleration
eml23__MeasureClass_linear_x0020thermal_x0020expansion = _fesapi.eml23__MeasureClass_linear_x0020thermal_x0020expansion
eml23__MeasureClass_logarithmic_x0020power_x0020ratio = _fesapi.eml23__MeasureClass_logarithmic_x0020power_x0020ratio
eml23__MeasureClass_logarithmic_x0020power_x0020ratio_x0020per_x0020length = _fesapi.eml23__MeasureClass_logarithmic_x0020power_x0020ratio_x0020per_x0020length
eml23__MeasureClass_luminance = _fesapi.eml23__MeasureClass_luminance
eml23__MeasureClass_luminous_x0020efficacy = _fesapi.eml23__MeasureClass_luminous_x0020efficacy
eml23__MeasureClass_luminous_x0020flux = _fesapi.eml23__MeasureClass_luminous_x0020flux
eml23__MeasureClass_luminous_x0020intensity = _fesapi.eml23__MeasureClass_luminous_x0020intensity
eml23__MeasureClass_magnetic_x0020dipole_x0020moment = _fesapi.eml23__MeasureClass_magnetic_x0020dipole_x0020moment
eml23__MeasureClass_magnetic_x0020field_x0020strength = _fesapi.eml23__MeasureClass_magnetic_x0020field_x0020strength
eml23__MeasureClass_magnetic_x0020flux = _fesapi.eml23__MeasureClass_magnetic_x0020flux
eml23__MeasureClass_magnetic_x0020flux_x0020density = _fesapi.eml23__MeasureClass_magnetic_x0020flux_x0020density
eml23__MeasureClass_magnetic_x0020flux_x0020density_x0020per_x0020length = _fesapi.eml23__MeasureClass_magnetic_x0020flux_x0020density_x0020per_x0020length
eml23__MeasureClass_magnetic_x0020permeability = _fesapi.eml23__MeasureClass_magnetic_x0020permeability
eml23__MeasureClass_magnetic_x0020vector_x0020potential = _fesapi.eml23__MeasureClass_magnetic_x0020vector_x0020potential
eml23__MeasureClass_mass = _fesapi.eml23__MeasureClass_mass
eml23__MeasureClass_mass_x0020length = _fesapi.eml23__MeasureClass_mass_x0020length
eml23__MeasureClass_mass_x0020per_x0020area = _fesapi.eml23__MeasureClass_mass_x0020per_x0020area
eml23__MeasureClass_mass_x0020per_x0020energy = _fesapi.eml23__MeasureClass_mass_x0020per_x0020energy
eml23__MeasureClass_mass_x0020per_x0020length = _fesapi.eml23__MeasureClass_mass_x0020per_x0020length
eml23__MeasureClass_mass_x0020per_x0020mass = _fesapi.eml23__MeasureClass_mass_x0020per_x0020mass
eml23__MeasureClass_mass_x0020per_x0020time = _fesapi.eml23__MeasureClass_mass_x0020per_x0020time
eml23__MeasureClass_mass_x0020per_x0020time_x0020per_x0020area = _fesapi.eml23__MeasureClass_mass_x0020per_x0020time_x0020per_x0020area
eml23__MeasureClass_mass_x0020per_x0020time_x0020per_x0020length = _fesapi.eml23__MeasureClass_mass_x0020per_x0020time_x0020per_x0020length
eml23__MeasureClass_mass_x0020per_x0020volume = _fesapi.eml23__MeasureClass_mass_x0020per_x0020volume
eml23__MeasureClass_mass_x0020per_x0020volume_x0020per_x0020length = _fesapi.eml23__MeasureClass_mass_x0020per_x0020volume_x0020per_x0020length
eml23__MeasureClass_mass_x0020per_x0020volume_x0020per_x0020pressure = _fesapi.eml23__MeasureClass_mass_x0020per_x0020volume_x0020per_x0020pressure
eml23__MeasureClass_mass_x0020per_x0020volume_x0020per_x0020temperature = _fesapi.eml23__MeasureClass_mass_x0020per_x0020volume_x0020per_x0020temperature
eml23__MeasureClass_mobility = _fesapi.eml23__MeasureClass_mobility
eml23__MeasureClass_molar_x0020energy = _fesapi.eml23__MeasureClass_molar_x0020energy
eml23__MeasureClass_molar_x0020heat_x0020capacity = _fesapi.eml23__MeasureClass_molar_x0020heat_x0020capacity
eml23__MeasureClass_molar_x0020volume = _fesapi.eml23__MeasureClass_molar_x0020volume
eml23__MeasureClass_molecular_x0020weight = _fesapi.eml23__MeasureClass_molecular_x0020weight
eml23__MeasureClass_moment_x0020of_x0020force = _fesapi.eml23__MeasureClass_moment_x0020of_x0020force
eml23__MeasureClass_moment_x0020of_x0020inertia = _fesapi.eml23__MeasureClass_moment_x0020of_x0020inertia
eml23__MeasureClass_momentum = _fesapi.eml23__MeasureClass_momentum
eml23__MeasureClass_normalized_x0020power = _fesapi.eml23__MeasureClass_normalized_x0020power
eml23__MeasureClass_permeability_x0020length = _fesapi.eml23__MeasureClass_permeability_x0020length
eml23__MeasureClass_permeability_x0020rock = _fesapi.eml23__MeasureClass_permeability_x0020rock
eml23__MeasureClass_permittivity = _fesapi.eml23__MeasureClass_permittivity
eml23__MeasureClass_plane_x0020angle = _fesapi.eml23__MeasureClass_plane_x0020angle
eml23__MeasureClass_potential_x0020difference_x0020per_x0020power_x0020drop = _fesapi.eml23__MeasureClass_potential_x0020difference_x0020per_x0020power_x0020drop
eml23__MeasureClass_power = _fesapi.eml23__MeasureClass_power
eml23__MeasureClass_power_x0020per_x0020area = _fesapi.eml23__MeasureClass_power_x0020per_x0020area
eml23__MeasureClass_power_x0020per_x0020power = _fesapi.eml23__MeasureClass_power_x0020per_x0020power
eml23__MeasureClass_power_x0020per_x0020volume = _fesapi.eml23__MeasureClass_power_x0020per_x0020volume
eml23__MeasureClass_pressure = _fesapi.eml23__MeasureClass_pressure
eml23__MeasureClass_pressure_x0020per_x0020flowrate = _fesapi.eml23__MeasureClass_pressure_x0020per_x0020flowrate
eml23__MeasureClass_pressure_x0020per_x0020flowrate_x0020squared = _fesapi.eml23__MeasureClass_pressure_x0020per_x0020flowrate_x0020squared
eml23__MeasureClass_pressure_x0020per_x0020pressure = _fesapi.eml23__MeasureClass_pressure_x0020per_x0020pressure
eml23__MeasureClass_pressure_x0020per_x0020time = _fesapi.eml23__MeasureClass_pressure_x0020per_x0020time
eml23__MeasureClass_pressure_x0020per_x0020volume = _fesapi.eml23__MeasureClass_pressure_x0020per_x0020volume
eml23__MeasureClass_pressure_x0020squared = _fesapi.eml23__MeasureClass_pressure_x0020squared
eml23__MeasureClass_pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area = _fesapi.eml23__MeasureClass_pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area
eml23__MeasureClass_pressure_x0020time_x0020per_x0020volume = _fesapi.eml23__MeasureClass_pressure_x0020time_x0020per_x0020volume
eml23__MeasureClass_quantity_x0020of_x0020light = _fesapi.eml23__MeasureClass_quantity_x0020of_x0020light
eml23__MeasureClass_radiance = _fesapi.eml23__MeasureClass_radiance
eml23__MeasureClass_radiant_x0020intensity = _fesapi.eml23__MeasureClass_radiant_x0020intensity
eml23__MeasureClass_reciprocal_x0020area = _fesapi.eml23__MeasureClass_reciprocal_x0020area
eml23__MeasureClass_reciprocal_x0020electric_x0020potential_x0020difference = _fesapi.eml23__MeasureClass_reciprocal_x0020electric_x0020potential_x0020difference
eml23__MeasureClass_reciprocal_x0020force = _fesapi.eml23__MeasureClass_reciprocal_x0020force
eml23__MeasureClass_reciprocal_x0020length = _fesapi.eml23__MeasureClass_reciprocal_x0020length
eml23__MeasureClass_reciprocal_x0020mass = _fesapi.eml23__MeasureClass_reciprocal_x0020mass
eml23__MeasureClass_reciprocal_x0020mass_x0020time = _fesapi.eml23__MeasureClass_reciprocal_x0020mass_x0020time
eml23__MeasureClass_reciprocal_x0020pressure = _fesapi.eml23__MeasureClass_reciprocal_x0020pressure
eml23__MeasureClass_reciprocal_x0020time = _fesapi.eml23__MeasureClass_reciprocal_x0020time
eml23__MeasureClass_reciprocal_x0020volume = _fesapi.eml23__MeasureClass_reciprocal_x0020volume
eml23__MeasureClass_reluctance = _fesapi.eml23__MeasureClass_reluctance
eml23__MeasureClass_second_x0020moment_x0020of_x0020area = _fesapi.eml23__MeasureClass_second_x0020moment_x0020of_x0020area
eml23__MeasureClass_signaling_x0020event_x0020per_x0020time = _fesapi.eml23__MeasureClass_signaling_x0020event_x0020per_x0020time
eml23__MeasureClass_solid_x0020angle = _fesapi.eml23__MeasureClass_solid_x0020angle
eml23__MeasureClass_specific_x0020heat_x0020capacity = _fesapi.eml23__MeasureClass_specific_x0020heat_x0020capacity
eml23__MeasureClass_temperature_x0020interval = _fesapi.eml23__MeasureClass_temperature_x0020interval
eml23__MeasureClass_temperature_x0020interval_x0020per_x0020length = _fesapi.eml23__MeasureClass_temperature_x0020interval_x0020per_x0020length
eml23__MeasureClass_temperature_x0020interval_x0020per_x0020pressure = _fesapi.eml23__MeasureClass_temperature_x0020interval_x0020per_x0020pressure
eml23__MeasureClass_temperature_x0020interval_x0020per_x0020time = _fesapi.eml23__MeasureClass_temperature_x0020interval_x0020per_x0020time
eml23__MeasureClass_thermal_x0020conductance = _fesapi.eml23__MeasureClass_thermal_x0020conductance
eml23__MeasureClass_thermal_x0020conductivity = _fesapi.eml23__MeasureClass_thermal_x0020conductivity
eml23__MeasureClass_thermal_x0020diffusivity = _fesapi.eml23__MeasureClass_thermal_x0020diffusivity
eml23__MeasureClass_thermal_x0020insulance = _fesapi.eml23__MeasureClass_thermal_x0020insulance
eml23__MeasureClass_thermal_x0020resistance = _fesapi.eml23__MeasureClass_thermal_x0020resistance
eml23__MeasureClass_thermodynamic_x0020temperature = _fesapi.eml23__MeasureClass_thermodynamic_x0020temperature
eml23__MeasureClass_thermodynamic_x0020temperature_x0020per_x0020thermodynamic_x0020temperature = _fesapi.eml23__MeasureClass_thermodynamic_x0020temperature_x0020per_x0020thermodynamic_x0020temperature
eml23__MeasureClass_time = _fesapi.eml23__MeasureClass_time
eml23__MeasureClass_time_x0020per_x0020length = _fesapi.eml23__MeasureClass_time_x0020per_x0020length
eml23__MeasureClass_time_x0020per_x0020mass = _fesapi.eml23__MeasureClass_time_x0020per_x0020mass
eml23__MeasureClass_time_x0020per_x0020time = _fesapi.eml23__MeasureClass_time_x0020per_x0020time
eml23__MeasureClass_time_x0020per_x0020volume = _fesapi.eml23__MeasureClass_time_x0020per_x0020volume
eml23__MeasureClass_vertical_x0020coordinate = _fesapi.eml23__MeasureClass_vertical_x0020coordinate
eml23__MeasureClass_volume = _fesapi.eml23__MeasureClass_volume
eml23__MeasureClass_volume_x0020flow_x0020rate_x0020per_x0020volume_x0020flow_x0020rate = _fesapi.eml23__MeasureClass_volume_x0020flow_x0020rate_x0020per_x0020volume_x0020flow_x0020rate
eml23__MeasureClass_volume_x0020per_x0020area = _fesapi.eml23__MeasureClass_volume_x0020per_x0020area
eml23__MeasureClass_volume_x0020per_x0020length = _fesapi.eml23__MeasureClass_volume_x0020per_x0020length
eml23__MeasureClass_volume_x0020per_x0020mass = _fesapi.eml23__MeasureClass_volume_x0020per_x0020mass
eml23__MeasureClass_volume_x0020per_x0020pressure = _fesapi.eml23__MeasureClass_volume_x0020per_x0020pressure
eml23__MeasureClass_volume_x0020per_x0020rotation = _fesapi.eml23__MeasureClass_volume_x0020per_x0020rotation
eml23__MeasureClass_volume_x0020per_x0020time = _fesapi.eml23__MeasureClass_volume_x0020per_x0020time
eml23__MeasureClass_volume_x0020per_x0020time_x0020length = _fesapi.eml23__MeasureClass_volume_x0020per_x0020time_x0020length
eml23__MeasureClass_volume_x0020per_x0020time_x0020per_x0020area = _fesapi.eml23__MeasureClass_volume_x0020per_x0020time_x0020per_x0020area
eml23__MeasureClass_volume_x0020per_x0020time_x0020per_x0020length = _fesapi.eml23__MeasureClass_volume_x0020per_x0020time_x0020per_x0020length
eml23__MeasureClass_volume_x0020per_x0020time_x0020per_x0020pressure = _fesapi.eml23__MeasureClass_volume_x0020per_x0020time_x0020per_x0020pressure
eml23__MeasureClass_volume_x0020per_x0020time_x0020per_x0020pressure_x0020length = _fesapi.eml23__MeasureClass_volume_x0020per_x0020time_x0020per_x0020pressure_x0020length
eml23__MeasureClass_volume_x0020per_x0020time_x0020per_x0020time = _fesapi.eml23__MeasureClass_volume_x0020per_x0020time_x0020per_x0020time
eml23__MeasureClass_volume_x0020per_x0020time_x0020per_x0020volume = _fesapi.eml23__MeasureClass_volume_x0020per_x0020time_x0020per_x0020volume
eml23__MeasureClass_volume_x0020per_x0020volume = _fesapi.eml23__MeasureClass_volume_x0020per_x0020volume
eml23__MeasureClass_volumetric_x0020heat_x0020transfer_x0020coefficient = _fesapi.eml23__MeasureClass_volumetric_x0020heat_x0020transfer_x0020coefficient
eml23__MeasureClass_volumetric_x0020thermal_x0020expansion = _fesapi.eml23__MeasureClass_volumetric_x0020thermal_x0020expansion
eml23__MeasureClass_unitless = _fesapi.eml23__MeasureClass_unitless
prodml22__ValueStatus_access_x0020denied = _fesapi.prodml22__ValueStatus_access_x0020denied
prodml22__ValueStatus_bad = _fesapi.prodml22__ValueStatus_bad
prodml22__ValueStatus_bad_x0020calibration = _fesapi.prodml22__ValueStatus_bad_x0020calibration
prodml22__ValueStatus_calculation_x0020failure = _fesapi.prodml22__ValueStatus_calculation_x0020failure
prodml22__ValueStatus_comm_x0020failure = _fesapi.prodml22__ValueStatus_comm_x0020failure
prodml22__ValueStatus_device_x0020failure = _fesapi.prodml22__ValueStatus_device_x0020failure
prodml22__ValueStatus_frozen = _fesapi.prodml22__ValueStatus_frozen
prodml22__ValueStatus_not_x0020available = _fesapi.prodml22__ValueStatus_not_x0020available
prodml22__ValueStatus_overflow = _fesapi.prodml22__ValueStatus_overflow
prodml22__ValueStatus_questionable = _fesapi.prodml22__ValueStatus_questionable
prodml22__ValueStatus_range_x0020limit = _fesapi.prodml22__ValueStatus_range_x0020limit
prodml22__ValueStatus_sensor_x0020failure = _fesapi.prodml22__ValueStatus_sensor_x0020failure
prodml22__ValueStatus_substituted = _fesapi.prodml22__ValueStatus_substituted
prodml22__ValueStatus_timeout = _fesapi.prodml22__ValueStatus_timeout
class FluidSystem(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getReservoirFluidKind(self) -> "gsoap_eml2_3::prodml22__ReservoirFluidKind":
        return _fesapi.FluidSystem_getReservoirFluidKind(self)
    __swig_destroy__ = _fesapi.delete_FluidSystem

# Register FluidSystem in _fesapi:
_fesapi.FluidSystem_swigregister(FluidSystem)
class FluidCharacterization(AbstractObject):
    r"""
    The fluid characterization data object describes the characteristics and properties of a
    fluid sample or fluid system under the conditions expected in a historical or future state.
    Three basic formats are available to represent fluid characterization results for delivery to
    consumer applications:
    - Model (model kind + parameters)
    - Tabular
    - Set of Fluid Characterization Parameters
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStandardConditions(self, temperatureValue: "double", temperatureUom: "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom", pressureValue: "double", pressureUom: "gsoap_eml2_3::eml23__PressureUom") -> "void":
        r"""
        Sets standard conditions

        :type temperatureValue: float
        :param temperatureValue:	The temperature value.
        :type temperatureUom: int
        :param temperatureUom:  	The temperature uom.
        :type pressureValue: float
        :param pressureValue:   	The pressure value.
        :type pressureUom: int
        :param pressureUom:			The pressure uom.
        """
        return _fesapi.FluidCharacterization_setStandardConditions(self, temperatureValue, temperatureUom, pressureValue, pressureUom)

    def hasStandardConditions(self) -> "bool":
        r"""
        Query if this object has standard conditions

        :rtype: boolean
        :return: True if standard conditions, false if not.
        """
        return _fesapi.FluidCharacterization_hasStandardConditions(self)

    def getStandardTemperatureValue(self) -> "double":
        r"""
        Gets standard temperature value

        :rtype: float
        :return: The standard temperature value.
        """
        return _fesapi.FluidCharacterization_getStandardTemperatureValue(self)

    def getStandardTemperatureUom(self) -> "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom":
        r"""
        Gets standard temperature uom

        :rtype: int
        :return: The standard temperature uom.
        """
        return _fesapi.FluidCharacterization_getStandardTemperatureUom(self)

    def getStandardPressureValue(self) -> "double":
        r"""
        Gets standard pressure value

        :rtype: float
        :return: The standard pressure value.
        """
        return _fesapi.FluidCharacterization_getStandardPressureValue(self)

    def getStandardPressureUom(self) -> "gsoap_eml2_3::eml23__PressureUom":
        r"""
        Gets standard pressure uom

        :rtype: int
        :return: The standard pressure uom.
        """
        return _fesapi.FluidCharacterization_getStandardPressureUom(self)

    def getRockFluidUnit(self) -> "resqml2::RockFluidUnitInterpretation *":
        r"""
        Gets rock fluid unit

        :rtype: :py:class:`RockFluidUnitInterpretation`
        :return: Null if it fails, else the rock fluid unit.
        """
        return _fesapi.FluidCharacterization_getRockFluidUnit(self)

    def getFormationWaterCount(self) -> "unsigned int":
        r"""
        Gets formation water count

        :rtype: int
        :return: The formation water count.
        """
        return _fesapi.FluidCharacterization_getFormationWaterCount(self)

    def pushBackFormationWater(self, uid: "std::string const &") -> "void":
        r"""
        Pushes a back formation water

        :type uid: string
        :param uid:	The UID.
        """
        return _fesapi.FluidCharacterization_pushBackFormationWater(self, uid)

    def getFormationWateruid(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getFormationWateruid(self, index)

    def setFormationWaterRemark(self, index: "unsigned int", value: "std::string const &") -> "void":
        return _fesapi.FluidCharacterization_setFormationWaterRemark(self, index, value)

    def hasFormationWaterRemark(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasFormationWaterRemark(self, index)

    def getFormationWaterRemark(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getFormationWaterRemark(self, index)

    def setFormationWaterMassFraction(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__MassPerMassUom") -> "void":
        return _fesapi.FluidCharacterization_setFormationWaterMassFraction(self, index, value, uom)

    def hasFormationWaterMassFraction(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasFormationWaterMassFraction(self, index)

    def getFormationWaterMassFractionValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getFormationWaterMassFractionValue(self, index)

    def getFormationWaterMassFractionUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__MassPerMassUom":
        return _fesapi.FluidCharacterization_getFormationWaterMassFractionUom(self, index)

    def setFormationWaterMoleFraction(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__AmountOfSubstancePerAmountOfSubstanceUom") -> "void":
        return _fesapi.FluidCharacterization_setFormationWaterMoleFraction(self, index, value, uom)

    def hasFormationWaterMoleFraction(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasFormationWaterMoleFraction(self, index)

    def getFormationWaterMoleFractionValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getFormationWaterMoleFractionValue(self, index)

    def getFormationWaterMoleFractionUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__AmountOfSubstancePerAmountOfSubstanceUom":
        return _fesapi.FluidCharacterization_getFormationWaterMoleFractionUom(self, index)

    def setFormationWaterSalinity(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__MassPerMassUom") -> "void":
        return _fesapi.FluidCharacterization_setFormationWaterSalinity(self, index, value, uom)

    def hasFormationWaterSalinity(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasFormationWaterSalinity(self, index)

    def getFormationWaterSalinityValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getFormationWaterSalinityValue(self, index)

    def getFormationWaterSalinityUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__MassPerMassUom":
        return _fesapi.FluidCharacterization_getFormationWaterSalinityUom(self, index)

    def setFormationWaterSpecificGravity(self, index: "unsigned int", value: "double const &") -> "void":
        return _fesapi.FluidCharacterization_setFormationWaterSpecificGravity(self, index, value)

    def hasFormationWaterSpecificGravity(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasFormationWaterSpecificGravity(self, index)

    def getFormationWaterSpecificGravity(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getFormationWaterSpecificGravity(self, index)

    def getPureFluidComponentCount(self) -> "unsigned int":
        r"""
        Gets pure fluid component count

        :rtype: int
        :return: The pure fluid component count.
        """
        return _fesapi.FluidCharacterization_getPureFluidComponentCount(self)

    def pushBackPureFluidComponent(self, uid: "std::string const &", kind: "gsoap_eml2_3::prodml22__PureComponentKind", hydrocarbonFlag: "bool") -> "void":
        r"""
        Pushes a back pure fluid component

        :type uid: string
        :param uid:			   	The UID.
        :type kind: int
        :param kind:		   	The kind.
        :type hydrocarbonFlag: boolean
        :param hydrocarbonFlag:	True to hydrocarbon flag.
        """
        return _fesapi.FluidCharacterization_pushBackPureFluidComponent(self, uid, kind, hydrocarbonFlag)

    def getPureFluidComponentuid(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getPureFluidComponentuid(self, index)

    def setPureFluidComponentRemark(self, index: "unsigned int", value: "std::string const &") -> "void":
        return _fesapi.FluidCharacterization_setPureFluidComponentRemark(self, index, value)

    def hasPureFluidComponentRemark(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasPureFluidComponentRemark(self, index)

    def getPureFluidComponentRemark(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getPureFluidComponentRemark(self, index)

    def setPureFluidComponentMassFraction(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__MassPerMassUom") -> "void":
        return _fesapi.FluidCharacterization_setPureFluidComponentMassFraction(self, index, value, uom)

    def hasPureFluidComponentMassFraction(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPureFluidComponentMassFraction(self, index)

    def getPureFluidComponentMassFractionValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPureFluidComponentMassFractionValue(self, index)

    def getPureFluidComponentMassFractionUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__MassPerMassUom":
        return _fesapi.FluidCharacterization_getPureFluidComponentMassFractionUom(self, index)

    def setPureFluidComponentMoleFraction(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__AmountOfSubstancePerAmountOfSubstanceUom") -> "void":
        return _fesapi.FluidCharacterization_setPureFluidComponentMoleFraction(self, index, value, uom)

    def hasPureFluidComponentMoleFraction(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPureFluidComponentMoleFraction(self, index)

    def getPureFluidComponentMoleFractionValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPureFluidComponentMoleFractionValue(self, index)

    def getPureFluidComponentMoleFractionUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__AmountOfSubstancePerAmountOfSubstanceUom":
        return _fesapi.FluidCharacterization_getPureFluidComponentMoleFractionUom(self, index)

    def getPureFluidComponentKind(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getPureFluidComponentKind(self, index)

    def getPureFluidComponentHydrocarbonFlag(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_getPureFluidComponentHydrocarbonFlag(self, index)

    def setPureFluidComponentMolecularWeight(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__MolecularWeightUom") -> "void":
        return _fesapi.FluidCharacterization_setPureFluidComponentMolecularWeight(self, index, value, uom)

    def hasPureFluidComponentMolecularWeight(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPureFluidComponentMolecularWeight(self, index)

    def getPureFluidComponentMolecularWeightValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPureFluidComponentMolecularWeightValue(self, index)

    def getPureFluidComponentMolecularWeightUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__MolecularWeightUom":
        return _fesapi.FluidCharacterization_getPureFluidComponentMolecularWeightUom(self, index)

    def getPlusFluidComponentCount(self) -> "unsigned int":
        r"""
        Gets plus fluid component count

        :rtype: int
        :return: The plus fluid component count.
        """
        return _fesapi.FluidCharacterization_getPlusFluidComponentCount(self)

    def pushBackPlusFluidComponent(self, uid: "std::string const &", kind: "gsoap_eml2_3::prodml22__PlusComponentKind") -> "void":
        r"""
        Pushes a back plus fluid component

        :type uid: string
        :param uid: 	The UID.
        :type kind: int
        :param kind:	The kind.
        """
        return _fesapi.FluidCharacterization_pushBackPlusFluidComponent(self, uid, kind)

    def getPlusFluidComponentuid(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getPlusFluidComponentuid(self, index)

    def setPlusFluidComponentRemark(self, index: "unsigned int", value: "std::string const &") -> "void":
        return _fesapi.FluidCharacterization_setPlusFluidComponentRemark(self, index, value)

    def hasPlusFluidComponentRemark(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasPlusFluidComponentRemark(self, index)

    def getPlusFluidComponentRemark(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getPlusFluidComponentRemark(self, index)

    def setPlusFluidComponentMassFraction(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__MassPerMassUom") -> "void":
        return _fesapi.FluidCharacterization_setPlusFluidComponentMassFraction(self, index, value, uom)

    def hasPlusFluidComponentMassFraction(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPlusFluidComponentMassFraction(self, index)

    def getPlusFluidComponentMassFractionValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPlusFluidComponentMassFractionValue(self, index)

    def getPlusFluidComponentMassFractionUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__MassPerMassUom":
        return _fesapi.FluidCharacterization_getPlusFluidComponentMassFractionUom(self, index)

    def setPlusFluidComponentMoleFraction(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__AmountOfSubstancePerAmountOfSubstanceUom") -> "void":
        return _fesapi.FluidCharacterization_setPlusFluidComponentMoleFraction(self, index, value, uom)

    def hasPlusFluidComponentMoleFraction(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPlusFluidComponentMoleFraction(self, index)

    def getPlusFluidComponentMoleFractionValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPlusFluidComponentMoleFractionValue(self, index)

    def getPlusFluidComponentMoleFractionUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__AmountOfSubstancePerAmountOfSubstanceUom":
        return _fesapi.FluidCharacterization_getPlusFluidComponentMoleFractionUom(self, index)

    def setPlusFluidComponentSpecificGravity(self, index: "unsigned int", value: "double const &") -> "void":
        return _fesapi.FluidCharacterization_setPlusFluidComponentSpecificGravity(self, index, value)

    def hasPlusFluidComponentSpecificGravity(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasPlusFluidComponentSpecificGravity(self, index)

    def getPlusFluidComponentSpecificGravity(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPlusFluidComponentSpecificGravity(self, index)

    def setPlusFluidComponentStartingCarbonNumber(self, index: "unsigned int", value: "uint64_t const &") -> "void":
        return _fesapi.FluidCharacterization_setPlusFluidComponentStartingCarbonNumber(self, index, value)

    def hasPlusFluidComponentStartingCarbonNumber(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasPlusFluidComponentStartingCarbonNumber(self, index)

    def getPlusFluidComponentStartingCarbonNumber(self, index: "unsigned int") -> "uint64_t":
        return _fesapi.FluidCharacterization_getPlusFluidComponentStartingCarbonNumber(self, index)

    def setPlusFluidComponentStartingBoilingPoint(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom") -> "void":
        return _fesapi.FluidCharacterization_setPlusFluidComponentStartingBoilingPoint(self, index, value, uom)

    def hasPlusFluidComponentStartingBoilingPoint(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPlusFluidComponentStartingBoilingPoint(self, index)

    def getPlusFluidComponentStartingBoilingPointValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPlusFluidComponentStartingBoilingPointValue(self, index)

    def getPlusFluidComponentStartingBoilingPointUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom":
        return _fesapi.FluidCharacterization_getPlusFluidComponentStartingBoilingPointUom(self, index)

    def setPlusFluidComponentAvgDensity(self, index: "unsigned int", value: "double", uom: "std::string") -> "void":
        return _fesapi.FluidCharacterization_setPlusFluidComponentAvgDensity(self, index, value, uom)

    def hasPlusFluidComponentAvgDensity(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPlusFluidComponentAvgDensity(self, index)

    def getPlusFluidComponentAvgDensityValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPlusFluidComponentAvgDensityValue(self, index)

    def getPlusFluidComponentAvgDensityUom(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getPlusFluidComponentAvgDensityUom(self, index)

    def setPlusFluidComponentAvgMolecularWeight(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__MolecularWeightUom") -> "void":
        return _fesapi.FluidCharacterization_setPlusFluidComponentAvgMolecularWeight(self, index, value, uom)

    def hasPlusFluidComponentAvgMolecularWeight(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPlusFluidComponentAvgMolecularWeight(self, index)

    def getPlusFluidComponentAvgMolecularWeightValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPlusFluidComponentAvgMolecularWeightValue(self, index)

    def getPlusFluidComponentAvgMolecularWeightUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__MolecularWeightUom":
        return _fesapi.FluidCharacterization_getPlusFluidComponentAvgMolecularWeightUom(self, index)

    def getStockTankOilCount(self) -> "unsigned int":
        r"""
        Gets stock tank oil count

        :rtype: int
        :return: The stock tank oil count.
        """
        return _fesapi.FluidCharacterization_getStockTankOilCount(self)

    def pushBackStockTankOil(self, uid: "std::string const &") -> "void":
        r"""
        Pushes a back stock tank oil

        :type uid: string
        :param uid:	The UID.
        """
        return _fesapi.FluidCharacterization_pushBackStockTankOil(self, uid)

    def getStockTankOiluid(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getStockTankOiluid(self, index)

    def setStockTankOilRemark(self, index: "unsigned int", value: "std::string const &") -> "void":
        return _fesapi.FluidCharacterization_setStockTankOilRemark(self, index, value)

    def hasStockTankOilRemark(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasStockTankOilRemark(self, index)

    def getStockTankOilRemark(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getStockTankOilRemark(self, index)

    def setStockTankOilMassFraction(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__MassPerMassUom") -> "void":
        return _fesapi.FluidCharacterization_setStockTankOilMassFraction(self, index, value, uom)

    def hasStockTankOilMassFraction(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasStockTankOilMassFraction(self, index)

    def getStockTankOilMassFractionValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getStockTankOilMassFractionValue(self, index)

    def getStockTankOilMassFractionUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__MassPerMassUom":
        return _fesapi.FluidCharacterization_getStockTankOilMassFractionUom(self, index)

    def setStockTankOilMoleFraction(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__AmountOfSubstancePerAmountOfSubstanceUom") -> "void":
        return _fesapi.FluidCharacterization_setStockTankOilMoleFraction(self, index, value, uom)

    def hasStockTankOilMoleFraction(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasStockTankOilMoleFraction(self, index)

    def getStockTankOilMoleFractionValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getStockTankOilMoleFractionValue(self, index)

    def getStockTankOilMoleFractionUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__AmountOfSubstancePerAmountOfSubstanceUom":
        return _fesapi.FluidCharacterization_getStockTankOilMoleFractionUom(self, index)

    def setStockTankOilAPIGravity(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__APIGravityUom") -> "void":
        return _fesapi.FluidCharacterization_setStockTankOilAPIGravity(self, index, value, uom)

    def hasStockTankOilAPIGravity(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasStockTankOilAPIGravity(self, index)

    def getStockTankOilAPIGravityValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getStockTankOilAPIGravityValue(self, index)

    def getStockTankOilAPIGravityUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__APIGravityUom":
        return _fesapi.FluidCharacterization_getStockTankOilAPIGravityUom(self, index)

    def setStockTankOilMolecularWeight(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__MolecularWeightUom") -> "void":
        return _fesapi.FluidCharacterization_setStockTankOilMolecularWeight(self, index, value, uom)

    def hasStockTankOilMolecularWeight(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasStockTankOilMolecularWeight(self, index)

    def getStockTankOilMolecularWeightValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getStockTankOilMolecularWeightValue(self, index)

    def getStockTankOilMolecularWeightUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__MolecularWeightUom":
        return _fesapi.FluidCharacterization_getStockTankOilMolecularWeightUom(self, index)

    def setStockTankOilGrossEnergyContentPerUnitMass(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__EnergyPerMassUom") -> "void":
        return _fesapi.FluidCharacterization_setStockTankOilGrossEnergyContentPerUnitMass(self, index, value, uom)

    def hasStockTankOilGrossEnergyContentPerUnitMass(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasStockTankOilGrossEnergyContentPerUnitMass(self, index)

    def getStockTankOilGrossEnergyContentPerUnitMassValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getStockTankOilGrossEnergyContentPerUnitMassValue(self, index)

    def getStockTankOilGrossEnergyContentPerUnitMassUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__EnergyPerMassUom":
        return _fesapi.FluidCharacterization_getStockTankOilGrossEnergyContentPerUnitMassUom(self, index)

    def setStockTankOilNetEnergyContentPerUnitMass(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__EnergyPerMassUom") -> "void":
        return _fesapi.FluidCharacterization_setStockTankOilNetEnergyContentPerUnitMass(self, index, value, uom)

    def hasStockTankOilNetEnergyContentPerUnitMass(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasStockTankOilNetEnergyContentPerUnitMass(self, index)

    def getStockTankOilNetEnergyContentPerUnitMassValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getStockTankOilNetEnergyContentPerUnitMassValue(self, index)

    def getStockTankOilNetEnergyContentPerUnitMassUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__EnergyPerMassUom":
        return _fesapi.FluidCharacterization_getStockTankOilNetEnergyContentPerUnitMassUom(self, index)

    def setStockTankOilGrossEnergyContentPerUnitVolume(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__EnergyPerVolumeUom") -> "void":
        return _fesapi.FluidCharacterization_setStockTankOilGrossEnergyContentPerUnitVolume(self, index, value, uom)

    def hasStockTankOilGrossEnergyContentPerUnitVolume(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasStockTankOilGrossEnergyContentPerUnitVolume(self, index)

    def getStockTankOilGrossEnergyContentPerUnitVolumeValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getStockTankOilGrossEnergyContentPerUnitVolumeValue(self, index)

    def getStockTankOilGrossEnergyContentPerUnitVolumeUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__EnergyPerVolumeUom":
        return _fesapi.FluidCharacterization_getStockTankOilGrossEnergyContentPerUnitVolumeUom(self, index)

    def setStockTankOilNetEnergyContentPerUnitVolume(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__EnergyPerVolumeUom") -> "void":
        return _fesapi.FluidCharacterization_setStockTankOilNetEnergyContentPerUnitVolume(self, index, value, uom)

    def hasStockTankOilNetEnergyContentPerUnitVolume(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasStockTankOilNetEnergyContentPerUnitVolume(self, index)

    def getStockTankOilNetEnergyContentPerUnitVolumeValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getStockTankOilNetEnergyContentPerUnitVolumeValue(self, index)

    def getStockTankOilNetEnergyContentPerUnitVolumeUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__EnergyPerVolumeUom":
        return _fesapi.FluidCharacterization_getStockTankOilNetEnergyContentPerUnitVolumeUom(self, index)

    def getNaturalGasCount(self) -> "unsigned int":
        r"""
        Gets natural gas count

        :rtype: int
        :return: The natural gas count.
        """
        return _fesapi.FluidCharacterization_getNaturalGasCount(self)

    def pushBackNaturalGas(self, uid: "std::string const &") -> "void":
        r"""
        Pushes a back natural gas

        :type uid: string
        :param uid:	The UID.
        """
        return _fesapi.FluidCharacterization_pushBackNaturalGas(self, uid)

    def getNaturalGasuid(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getNaturalGasuid(self, index)

    def setNaturalGasRemark(self, index: "unsigned int", value: "std::string const &") -> "void":
        return _fesapi.FluidCharacterization_setNaturalGasRemark(self, index, value)

    def hasNaturalGasRemark(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasNaturalGasRemark(self, index)

    def getNaturalGasRemark(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getNaturalGasRemark(self, index)

    def setNaturalGasMassFraction(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__MassPerMassUom") -> "void":
        return _fesapi.FluidCharacterization_setNaturalGasMassFraction(self, index, value, uom)

    def hasNaturalGasMassFraction(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasNaturalGasMassFraction(self, index)

    def getNaturalGasMassFractionValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getNaturalGasMassFractionValue(self, index)

    def getNaturalGasMassFractionUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__MassPerMassUom":
        return _fesapi.FluidCharacterization_getNaturalGasMassFractionUom(self, index)

    def setNaturalGasMoleFraction(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__AmountOfSubstancePerAmountOfSubstanceUom") -> "void":
        return _fesapi.FluidCharacterization_setNaturalGasMoleFraction(self, index, value, uom)

    def hasNaturalGasMoleFraction(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasNaturalGasMoleFraction(self, index)

    def getNaturalGasMoleFractionValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getNaturalGasMoleFractionValue(self, index)

    def getNaturalGasMoleFractionUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__AmountOfSubstancePerAmountOfSubstanceUom":
        return _fesapi.FluidCharacterization_getNaturalGasMoleFractionUom(self, index)

    def setNaturalGasGasGravity(self, index: "unsigned int", value: "double const &") -> "void":
        return _fesapi.FluidCharacterization_setNaturalGasGasGravity(self, index, value)

    def hasNaturalGasGasGravity(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasNaturalGasGasGravity(self, index)

    def getNaturalGasGasGravity(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getNaturalGasGasGravity(self, index)

    def setNaturalGasMolecularWeight(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__MolecularWeightUom") -> "void":
        return _fesapi.FluidCharacterization_setNaturalGasMolecularWeight(self, index, value, uom)

    def hasNaturalGasMolecularWeight(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasNaturalGasMolecularWeight(self, index)

    def getNaturalGasMolecularWeightValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getNaturalGasMolecularWeightValue(self, index)

    def getNaturalGasMolecularWeightUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__MolecularWeightUom":
        return _fesapi.FluidCharacterization_getNaturalGasMolecularWeightUom(self, index)

    def setNaturalGasGrossEnergyContentPerUnitMass(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__EnergyPerMassUom") -> "void":
        return _fesapi.FluidCharacterization_setNaturalGasGrossEnergyContentPerUnitMass(self, index, value, uom)

    def hasNaturalGasGrossEnergyContentPerUnitMass(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasNaturalGasGrossEnergyContentPerUnitMass(self, index)

    def getNaturalGasGrossEnergyContentPerUnitMassValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getNaturalGasGrossEnergyContentPerUnitMassValue(self, index)

    def getNaturalGasGrossEnergyContentPerUnitMassUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__EnergyPerMassUom":
        return _fesapi.FluidCharacterization_getNaturalGasGrossEnergyContentPerUnitMassUom(self, index)

    def setNaturalGasNetEnergyContentPerUnitMass(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__EnergyPerMassUom") -> "void":
        return _fesapi.FluidCharacterization_setNaturalGasNetEnergyContentPerUnitMass(self, index, value, uom)

    def hasNaturalGasNetEnergyContentPerUnitMass(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasNaturalGasNetEnergyContentPerUnitMass(self, index)

    def getNaturalGasNetEnergyContentPerUnitMassValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getNaturalGasNetEnergyContentPerUnitMassValue(self, index)

    def getNaturalGasNetEnergyContentPerUnitMassUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__EnergyPerMassUom":
        return _fesapi.FluidCharacterization_getNaturalGasNetEnergyContentPerUnitMassUom(self, index)

    def setNaturalGasGrossEnergyContentPerUnitVolume(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__EnergyPerVolumeUom") -> "void":
        return _fesapi.FluidCharacterization_setNaturalGasGrossEnergyContentPerUnitVolume(self, index, value, uom)

    def hasNaturalGasGrossEnergyContentPerUnitVolume(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasNaturalGasGrossEnergyContentPerUnitVolume(self, index)

    def getNaturalGasGrossEnergyContentPerUnitVolumeValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getNaturalGasGrossEnergyContentPerUnitVolumeValue(self, index)

    def getNaturalGasGrossEnergyContentPerUnitVolumeUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__EnergyPerVolumeUom":
        return _fesapi.FluidCharacterization_getNaturalGasGrossEnergyContentPerUnitVolumeUom(self, index)

    def setNaturalGasNetEnergyContentPerUnitVolume(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__EnergyPerVolumeUom") -> "void":
        return _fesapi.FluidCharacterization_setNaturalGasNetEnergyContentPerUnitVolume(self, index, value, uom)

    def hasNaturalGasNetEnergyContentPerUnitVolume(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasNaturalGasNetEnergyContentPerUnitVolume(self, index)

    def getNaturalGasNetEnergyContentPerUnitVolumeValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getNaturalGasNetEnergyContentPerUnitVolumeValue(self, index)

    def getNaturalGasNetEnergyContentPerUnitVolumeUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__EnergyPerVolumeUom":
        return _fesapi.FluidCharacterization_getNaturalGasNetEnergyContentPerUnitVolumeUom(self, index)

    def getPseudoFluidComponentCount(self) -> "unsigned int":
        r"""
        Gets pseudo fluid component count

        :rtype: int
        :return: The pseudo fluid component count.
        """
        return _fesapi.FluidCharacterization_getPseudoFluidComponentCount(self)

    def pushBackPseudoFluidComponent(self, uid: "std::string const &", kind: "gsoap_eml2_3::prodml22__PseudoComponentKind") -> "void":
        r"""
        Pushes a back pseudo fluid component

        :type uid: string
        :param uid: 	The UID.
        :type kind: int
        :param kind:	The kind.
        """
        return _fesapi.FluidCharacterization_pushBackPseudoFluidComponent(self, uid, kind)

    def getPseudoFluidComponentuid(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentuid(self, index)

    def setPseudoFluidComponentRemark(self, index: "unsigned int", value: "std::string const &") -> "void":
        return _fesapi.FluidCharacterization_setPseudoFluidComponentRemark(self, index, value)

    def hasPseudoFluidComponentRemark(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasPseudoFluidComponentRemark(self, index)

    def getPseudoFluidComponentRemark(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentRemark(self, index)

    def setPseudoFluidComponentMassFraction(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__MassPerMassUom") -> "void":
        return _fesapi.FluidCharacterization_setPseudoFluidComponentMassFraction(self, index, value, uom)

    def hasPseudoFluidComponentMassFraction(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPseudoFluidComponentMassFraction(self, index)

    def getPseudoFluidComponentMassFractionValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentMassFractionValue(self, index)

    def getPseudoFluidComponentMassFractionUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__MassPerMassUom":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentMassFractionUom(self, index)

    def setPseudoFluidComponentMoleFraction(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__AmountOfSubstancePerAmountOfSubstanceUom") -> "void":
        return _fesapi.FluidCharacterization_setPseudoFluidComponentMoleFraction(self, index, value, uom)

    def hasPseudoFluidComponentMoleFraction(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPseudoFluidComponentMoleFraction(self, index)

    def getPseudoFluidComponentMoleFractionValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentMoleFractionValue(self, index)

    def getPseudoFluidComponentMoleFractionUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__AmountOfSubstancePerAmountOfSubstanceUom":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentMoleFractionUom(self, index)

    def setPseudoFluidComponentSpecificGravity(self, index: "unsigned int", value: "double const &") -> "void":
        return _fesapi.FluidCharacterization_setPseudoFluidComponentSpecificGravity(self, index, value)

    def hasPseudoFluidComponentSpecificGravity(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasPseudoFluidComponentSpecificGravity(self, index)

    def getPseudoFluidComponentSpecificGravity(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentSpecificGravity(self, index)

    def setPseudoFluidComponentStartingCarbonNumber(self, index: "unsigned int", value: "uint64_t const &") -> "void":
        return _fesapi.FluidCharacterization_setPseudoFluidComponentStartingCarbonNumber(self, index, value)

    def hasPseudoFluidComponentStartingCarbonNumber(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasPseudoFluidComponentStartingCarbonNumber(self, index)

    def getPseudoFluidComponentStartingCarbonNumber(self, index: "unsigned int") -> "uint64_t":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentStartingCarbonNumber(self, index)

    def setPseudoFluidComponentEndingCarbonNumber(self, index: "unsigned int", value: "uint64_t const &") -> "void":
        return _fesapi.FluidCharacterization_setPseudoFluidComponentEndingCarbonNumber(self, index, value)

    def hasPseudoFluidComponentEndingCarbonNumber(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasPseudoFluidComponentEndingCarbonNumber(self, index)

    def getPseudoFluidComponentEndingCarbonNumber(self, index: "unsigned int") -> "uint64_t":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentEndingCarbonNumber(self, index)

    def setPseudoFluidComponentStartingBoilingPoint(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom") -> "void":
        return _fesapi.FluidCharacterization_setPseudoFluidComponentStartingBoilingPoint(self, index, value, uom)

    def hasPseudoFluidComponentStartingBoilingPoint(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPseudoFluidComponentStartingBoilingPoint(self, index)

    def getPseudoFluidComponentStartingBoilingPointValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentStartingBoilingPointValue(self, index)

    def getPseudoFluidComponentStartingBoilingPointUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentStartingBoilingPointUom(self, index)

    def setPseudoFluidComponentEndingBoilingPoint(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom") -> "void":
        return _fesapi.FluidCharacterization_setPseudoFluidComponentEndingBoilingPoint(self, index, value, uom)

    def hasPseudoFluidComponentEndingBoilingPoint(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPseudoFluidComponentEndingBoilingPoint(self, index)

    def getPseudoFluidComponentEndingBoilingPointValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentEndingBoilingPointValue(self, index)

    def getPseudoFluidComponentEndingBoilingPointUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentEndingBoilingPointUom(self, index)

    def setPseudoFluidComponentAvgBoilingPoint(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom") -> "void":
        return _fesapi.FluidCharacterization_setPseudoFluidComponentAvgBoilingPoint(self, index, value, uom)

    def hasPseudoFluidComponentAvgBoilingPoint(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPseudoFluidComponentAvgBoilingPoint(self, index)

    def getPseudoFluidComponentAvgBoilingPointValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentAvgBoilingPointValue(self, index)

    def getPseudoFluidComponentAvgBoilingPointUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentAvgBoilingPointUom(self, index)

    def setPseudoFluidComponentAvgDensity(self, index: "unsigned int", value: "double", uom: "std::string") -> "void":
        return _fesapi.FluidCharacterization_setPseudoFluidComponentAvgDensity(self, index, value, uom)

    def hasPseudoFluidComponentAvgDensity(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPseudoFluidComponentAvgDensity(self, index)

    def getPseudoFluidComponentAvgDensityValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentAvgDensityValue(self, index)

    def getPseudoFluidComponentAvgDensityUom(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentAvgDensityUom(self, index)

    def setPseudoFluidComponentAvgMolecularWeight(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__MolecularWeightUom") -> "void":
        return _fesapi.FluidCharacterization_setPseudoFluidComponentAvgMolecularWeight(self, index, value, uom)

    def hasPseudoFluidComponentAvgMolecularWeight(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_hasPseudoFluidComponentAvgMolecularWeight(self, index)

    def getPseudoFluidComponentAvgMolecularWeightValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentAvgMolecularWeightValue(self, index)

    def getPseudoFluidComponentAvgMolecularWeightUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__MolecularWeightUom":
        return _fesapi.FluidCharacterization_getPseudoFluidComponentAvgMolecularWeightUom(self, index)

    def getModelCount(self) -> "unsigned int":
        r"""
        Gets model count

        :rtype: int
        :return: The model count.
        """
        return _fesapi.FluidCharacterization_getModelCount(self)

    def pushBackModel(self, *args) -> "void":
        r"""
        Pushes a back model

        :type uid: string, optional
        :param uid:	The UID. If empty, it will be set to its index in this Fluid Characterization
        """
        return _fesapi.FluidCharacterization_pushBackModel(self, *args)

    def setModelName(self, index: "unsigned int", value: "std::string const &") -> "void":
        return _fesapi.FluidCharacterization_setModelName(self, index, value)

    def getModelName(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getModelName(self, index)

    def hasModelName(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasModelName(self, index)

    def setModelRemark(self, index: "unsigned int", value: "std::string const &") -> "void":
        return _fesapi.FluidCharacterization_setModelRemark(self, index, value)

    def getModelRemark(self, index: "unsigned int") -> "std::string":
        return _fesapi.FluidCharacterization_getModelRemark(self, index)

    def hasModelRemark(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasModelRemark(self, index)

    def setModelReferenceTemperature(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom") -> "void":
        return _fesapi.FluidCharacterization_setModelReferenceTemperature(self, index, value, uom)

    def getModelReferenceTemperatureValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getModelReferenceTemperatureValue(self, index)

    def getModelReferenceTemperatureUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom":
        return _fesapi.FluidCharacterization_getModelReferenceTemperatureUom(self, index)

    def hasModelReferenceTemperature(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasModelReferenceTemperature(self, index)

    def setModelReferenceStockTankTemperature(self, index: "unsigned int", value: "double", uom: "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom") -> "void":
        return _fesapi.FluidCharacterization_setModelReferenceStockTankTemperature(self, index, value, uom)

    def getModelReferenceStockTankTemperatureValue(self, index: "unsigned int") -> "double":
        return _fesapi.FluidCharacterization_getModelReferenceStockTankTemperatureValue(self, index)

    def getModelReferenceStockTankTemperatureUom(self, index: "unsigned int") -> "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom":
        return _fesapi.FluidCharacterization_getModelReferenceStockTankTemperatureUom(self, index)

    def hasModelReferenceStockTankTemperature(self, index: "unsigned int") -> "bool":
        return _fesapi.FluidCharacterization_hasModelReferenceStockTankTemperature(self, index)

    def getTableFormatCount(self) -> "void":
        r"""
        Gets the table format count

        :rtype: void
        :return: The table format count.
        """
        return _fesapi.FluidCharacterization_getTableFormatCount(self)

    def pushBackTableFormat(self, *args) -> "void":
        r"""
        Pushes a table format

        :type uid: string, optional
        :param uid:	The UID. If empty, it will be set to its index in this Fluid Characterization
        """
        return _fesapi.FluidCharacterization_pushBackTableFormat(self, *args)

    def getTableFormatColumnUom(self, tableFormatUid: "std::string const &", columnIndex: "unsigned int") -> "std::string":
        r"""
        Gets the uom of a table format column

        :type tableFormatUid: string
        :param tableFormatUid:	The uid of the table format.
        :type columnIndex: int
        :param columnIndex:		The zero-based index of the column.
        :rtype: string
        :return: The uom of a table format column
        """
        return _fesapi.FluidCharacterization_getTableFormatColumnUom(self, tableFormatUid, columnIndex)

    def getTableFormatColumnProperty(self, tableFormatUid: "std::string const &", columnIndex: "unsigned int") -> "std::string":
        r"""
        Gets the property kind of a table format column

        :type tableFormatUid: string
        :param tableFormatUid:	The uid of the table format.
        :type columnIndex: int
        :param columnIndex:		The zero-based index of the column.
        :rtype: string
        :return: The property kind of a table format column
        """
        return _fesapi.FluidCharacterization_getTableFormatColumnProperty(self, tableFormatUid, columnIndex)

    def pushBackTableFormatColumn(self, *args) -> "void":
        r"""
        *Overload 1:*

        Pushes a table format colum

        :type tableFormatIndex: int
        :param tableFormatIndex:	Zero-based index of the table format.
        :type uom: int
        :param uom:					The uom associated to the values of this column
        :type fluidProperty: int
        :param fluidProperty:		The property that this column contains


        |

        *Overload 2:*

        Pushes a table format colum

        :type tableFormatIndex: int
        :param tableFormatIndex:	Zero-based index of the table format.
        :type uom: string
        :param uom:					The uom associated to the values of this column
        :type fluidProperty: string
        :param fluidProperty:		The non standard property name that this column contains
        """
        return _fesapi.FluidCharacterization_pushBackTableFormatColumn(self, *args)

    def getTableCount(self, modelIndex: "unsigned int") -> "unsigned int":
        r"""
        Gets the table count

        :type modelIndex: int
        :param modelIndex:		Zero-based index of the model in this fluid characterization.
        :rtype: int
        :return: The table count.
        """
        return _fesapi.FluidCharacterization_getTableCount(self, modelIndex)

    def getTableName(self, modelIndex: "unsigned int", tableIndex: "unsigned int") -> "std::string":
        r"""
        Gets the name of a table.

        :type modelIndex: int
        :param modelIndex:		Zero-based index of the model in this fluid characterization.
        :type tableIndex: int
        :param tableIndex:		Zero-based index of the table in a model of this fluid characterization.
        :rtype: string
        :return: The name of a table.
        """
        return _fesapi.FluidCharacterization_getTableName(self, modelIndex, tableIndex)

    def getTableFormatUid(self, modelIndex: "unsigned int", tableIndex: "unsigned int") -> "std::string":
        r"""
        Gets the uid of the table format of a table.

        :type modelIndex: int
        :param modelIndex:		Zero-based index of the model in this fluid characterization.
        :type tableIndex: int
        :param tableIndex:		Zero-based index of the table in a model of this fluid characterization.
        :rtype: string
        :return: The uid of the table format of a table.
        """
        return _fesapi.FluidCharacterization_getTableFormatUid(self, modelIndex, tableIndex)

    def pushBackTable(self, *args) -> "void":
        r"""
        Pushes back a table

        :type modelIndex: int
        :param modelIndex:		Zero-based index of the model.
        :type name: string
        :param name:			The name of this table.
        :type tableFormatUid: string
        :param tableFormatUid:	The UID of the table format this table is using.The table format defines the semantic of the colums and values.
        :type uid: string, optional
        :param uid:				The UID of this table. If empty, it will be set to its index in this Fluid Characterization
        """
        return _fesapi.FluidCharacterization_pushBackTable(self, *args)

    def getTableRowCount(self, modelIndex: "unsigned int", tableIndex: "unsigned int") -> "unsigned int":
        r"""
        Gets the table row count

        :type modelIndex: int
        :param modelIndex:		Zero-based index of the model in this fluid characterization.
        :type tableIndex: int
        :param tableIndex:		Zero-based index of the table in a model of this fluid characterization.
        :rtype: int
        :return: The table row count.
        """
        return _fesapi.FluidCharacterization_getTableRowCount(self, modelIndex, tableIndex)

    def getTableRowContent(self, modelIndex: "unsigned int", tableIndex: "unsigned int", rowIndex: "unsigned int") -> "std::string":
        r"""
        Gets the content of a row of a table.

        :type modelIndex: int
        :param modelIndex:		Zero-based index of the model in this fluid characterization.
        :type tableIndex: int
        :param tableIndex:		Zero-based index of the table in a model of this fluid characterization.
        :type rowIndex: int
        :param rowIndex:		Zero-based index of the row of the table in a model of this fluid characterization.
        :rtype: string
        :return: The content of a row of a table.
        """
        return _fesapi.FluidCharacterization_getTableRowContent(self, modelIndex, tableIndex, rowIndex)

    def pushBackTableRow(self, *args) -> "void":
        r"""
        *Overload 1:*

        Pushes back a row in a table of a model without indicating if the data are either saturated or under-saturated.

        :type modelIndex: int
        :param modelIndex:		Zero-based index of the model in this fluid characterization.
        :type tableIndex: int
        :param tableIndex:		Zero-based index of the table in a model of this fluid characterization.
        :type rowContent: std::vector< double,std::allocator< double > >
        :param rowContent:		The values representing the content of the row in the table.


        |

        *Overload 2:*

        Pushes back a row in a table of a model indicating if the data are either saturated or under-saturated.

        :type modelIndex: int
        :param modelIndex:		Zero-based index of the model in this fluid characterization.
        :type tableIndex: int
        :param tableIndex:		Zero-based index of the table in a model of this fluid characterization.
        :type rowContent: std::vector< double,std::allocator< double > >
        :param rowContent:		The values representing the content of the row in the table.
        :type isSaturated: boolean
        :param isSaturated:		True if the data correspond to saturated data, false if the data correspond to undersaturated data
        """
        return _fesapi.FluidCharacterization_pushBackTableRow(self, *args)

    def pushBackParameter(self, *args) -> "void":
        r"""
        *Overload 1:*

        Pushes back an phase-unrelated parameter in a model.

        :type modelIndex: int
        :param modelIndex:		Zero-based index of the model in this fluid characterization.
        :type value: float
        :param value:			The value of the parameter
        :type uom: int
        :param uom:				The uom associated to the value of this parameter
        :type fluidProperty: int
        :param fluidProperty:	The property kind of this value


        |

        *Overload 2:*

        Pushes back a phase related parameter in a model.

        :type modelIndex: int
        :param modelIndex:		Zero-based index of the model in this fluid characterization.
        :type value: float
        :param value:			The value of the parameter
        :type uom: int
        :param uom:				The uom associated to the value of this parameter
        :type fluidProperty: int
        :param fluidProperty:	The property kind of this value
        :type phase: int
        :param phase:			The pahse associated to the parameter
        """
        return _fesapi.FluidCharacterization_pushBackParameter(self, *args)
    __swig_destroy__ = _fesapi.delete_FluidCharacterization

# Register FluidCharacterization in _fesapi:
_fesapi.FluidCharacterization_swigregister(FluidCharacterization)
class TimeSeriesData(AbstractObject):
    r"""
     The time series data object is intended for use in transferring time series of data, e.g. from a historian.
    The Time Series data object describes a context free, time based series of measurement data for the
    purpose of targeted exchanges between consumers and providers of data services. This is intended for
    use in support of smart fields or high-frequency historian type interactions, not reporting. It provides a
    flat view of the data and uses a set of keyword-value pairs to define the business identity of the series,
    as described in the following generalized hierarchy.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def pushBackKeywordValue(self, keyword: "gsoap_eml2_3::prodml22__TimeSeriesKeyword", value: "std::string const &") -> "void":
        r"""
        The keyword value pairs are used to characterize the underlying nature of the values. The key value may provide part of the unique identity of an instance of a concept or it may characterize the underlying concept.
        :type keyword: int
        :param keyword:	One of this enumerated value
              - asset identifier :	A formatted URI identifier of the asset (facility) related to the value. This captures the
            							kind of asset as well as the unique identifier of the asset within a specified context
            							(the authority). The identifier may define a hierarchy of assets.
              - qualifier :			A qualifier of the meaning of the value. This is used to distinguish between variations
            							of an underlying meaning based on the method of creating the value (e.g., measured
            							versus simulated). The values associated with this keyword must be from the list
            							defined by type FlowQualifier.
            	- subqualifier :		A specialization of a qualifier. The values associated with this keyword must be from
            							the list defined by type FlowSubQualifier.
            	- product :				The type of product that is represented by the value. This is generally used with
            							things like volume or flow rate. It is generally meaningless for things like temperature
            							or pressure. The values associated with this keyword must be from the list defined by
            							type ReportingProduct.
            	- flow :				Defines the part of the flow network where the asset is located. This is most useful in
            							situations (e.g., reporting) where detailed knowledge of the network configuration is
            							not needed. Basically, this classifies different segments of the flow network based on
            							its purpose within the context of the whole network. The values associated with this
            							keyword must be from the list defined by type ReportingFlow.
        :type value: string
        :param value:	The string value associated to the keyword
        """
        return _fesapi.TimeSeriesData_pushBackKeywordValue(self, keyword, value)

    def setUom(self, uom: "gsoap_resqml2_0_1::resqml20__ResqmlUom") -> "void":
        r"""
        Set the uom of the data of the time series.

        :type uom: int
        :param uom:	The unit of measure taken from the standard Energistics
            				units of measure catalog. Please check
            				COMMON_NS::EnumStringMapper::getEnergisticsUnitOfMeasure in order
            				to minimize the use of non standard unit of measure.
        """
        return _fesapi.TimeSeriesData_setUom(self, uom)

    def setMeasureClass(self, measureClass: "gsoap_eml2_3::eml23__MeasureClass") -> "void":
        r"""
        Set the measure class of the data of the time series.

        :type measureClass: int
        :param measureClass:	The measure class to set.
        """
        return _fesapi.TimeSeriesData_setMeasureClass(self, measureClass)

    def pushBackDoubleValue(self, *args) -> "void":
        r"""
        *Overload 1:*

        Push back a new value (i.e data) in the time series

        :type value: float
        :param value:	The value to push back.
        :type value: float
        :param value:	(Optional) The time of the value to push back.


        |

        *Overload 2:*

        Push back a new value (i.e data) in the time series

        :type value: float
        :param value:	The value to push back.
        :type value: float
        :param value:	The time of the value to push back.
        :type value: float
        :param value:	The status of the value to push back.
        """
        return _fesapi.TimeSeriesData_pushBackDoubleValue(self, *args)

    def pushBackStringValue(self, value: "std::string const &", timestamp: "time_t"=-1) -> "void":
        r"""
        Push back a new value (i.e data) in the time series

        :type value: string
        :param value:	The value to push back.
        :type value: string
        :param value:	(Optional) The time of the value to push back.
        """
        return _fesapi.TimeSeriesData_pushBackStringValue(self, value, timestamp)

    def getUomAsString(self) -> "std::string":
        r"""
        Gets the unit of measure of the values of this time series as a string.

        :rtype: string
        :return: The unit of measure of the values of this time series as a string. Returns empty string if no uom is stored.
        """
        return _fesapi.TimeSeriesData_getUomAsString(self)

    def getMeasureClassAsString(self) -> "std::string":
        r"""
        Gets the measure class of the values of this time series as a string.

        :rtype: string
        :return: The measure class of the values of this time series as a string. Returns empty string if no measure class is stored.
        """
        return _fesapi.TimeSeriesData_getMeasureClassAsString(self)

    def getValueCount(self) -> "unsigned int":
        r"""Get the count of value in this time series"""
        return _fesapi.TimeSeriesData_getValueCount(self)

    def isDoubleValue(self, index: "unsigned int") -> "bool":
        r"""
        Check if a value at a particular index is a double one.

        :type index: int
        :param index:	The index of the value in this timeseries
        :rtype: boolean
        :return: true if the value at this index is a double one
        """
        return _fesapi.TimeSeriesData_isDoubleValue(self, index)

    def isStringValue(self, index: "unsigned int") -> "bool":
        r"""
        Check if a value at a particular index is a string one.

        :type index: int
        :param index:	The index of the value in this timeseries
        :rtype: boolean
        :return: true if the value at this index is a string one
        """
        return _fesapi.TimeSeriesData_isStringValue(self, index)

    def getDoubleValue(self, index: "unsigned int") -> "double":
        r"""
        Get a double value at a particular index.

        :type index: int
        :param index:	The index of the value in this timeseries
        :rtype: float
        :return: the double value at a particular index
        """
        return _fesapi.TimeSeriesData_getDoubleValue(self, index)

    def getStringValue(self, index: "unsigned int") -> "std::string":
        r"""
        Get a string value at a particular index.

        :type index: int
        :param index:	The index of the value in this timeseries
        :rtype: string
        :return: the string value at a particular index
        """
        return _fesapi.TimeSeriesData_getStringValue(self, index)

    def getValueTimestamp(self, index: "unsigned int") -> "time_t":
        r"""
        Get the timestamp associated to a value at a particular index.

        :type index: int
        :param index:	The index of the value in this timeseries
        :rtype: int
        :return: the timestamp associated to a value at a particular index. -1 if no timesteamp is provided for this value.
        """
        return _fesapi.TimeSeriesData_getValueTimestamp(self, index)

    def hasValueStatus(self, index: "unsigned int") -> "bool":
        r"""
        Check if a value at a particular index has a status.

        :type index: int
        :param index:	The index of the value in this timeseries
        :rtype: boolean
        :return: true if the value at this index has a status
        """
        return _fesapi.TimeSeriesData_hasValueStatus(self, index)

    def getValueStatus(self, index: "unsigned int") -> "gsoap_eml2_3::prodml22__ValueStatus":
        r"""
        Get the status associated to a value at a particular index.

        :type index: int
        :param index:	The index of the value in this timeseries
        :rtype: int
        :return: the status associated to a value at a particular index.
        """
        return _fesapi.TimeSeriesData_getValueStatus(self, index)

    def getKeywordCount(self) -> "unsigned int":
        r"""Get the count of keywords in this time series"""
        return _fesapi.TimeSeriesData_getKeywordCount(self)

    def getKeyword(self, index: "unsigned int") -> "gsoap_eml2_3::prodml22__TimeSeriesKeyword":
        r"""
        Get a keyword at a particular index.

        :type index: int
        :param index:	The index of the keyword in this timeseries
        :rtype: int
        :return: the keyword at a particular index
        """
        return _fesapi.TimeSeriesData_getKeyword(self, index)

    def getKeywordValue(self, index: "unsigned int") -> "std::string":
        r"""
        Get the value of a keyword at a particular index.

        :type index: int
        :param index:	The index of the value in this timeseries
        :rtype: string
        :return: the value of a keyword at a particular index.
        """
        return _fesapi.TimeSeriesData_getKeywordValue(self, index)
    __swig_destroy__ = _fesapi.delete_TimeSeriesData

# Register TimeSeriesData in _fesapi:
_fesapi.TimeSeriesData_swigregister(TimeSeriesData)
class DataObjectRepository(object):
    r"""
    A DataObjectRepository stores in memory all dataObjects.
    			This is the in-memory container which holds deserialized (EPC) files and fetched ETP dataobjects.
    			On the other direction, it is also used to store dataobjets which you want either to serialize in (EPC) files or pushed to an ETP store.
    			It is not a database (it is much more a simple container). For instance, in most cases, you are not supposed to delete anything neither update relationships.
    			It also controls the creation and the deletion of all contained dataobjects meaning that when you delete it, it also deletes all contained dataobjects.
    			It does not store numerical values of the dataobjects but only their XML definitions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    openingMode_READ_ONLY = _fesapi.DataObjectRepository_openingMode_READ_ONLY
    openingMode_READ_WRITE = _fesapi.DataObjectRepository_openingMode_READ_WRITE
    openingMode_READ_WRITE_DO_NOT_CREATE = _fesapi.DataObjectRepository_openingMode_READ_WRITE_DO_NOT_CREATE
    openingMode_OVERWRITE = _fesapi.DataObjectRepository_openingMode_OVERWRITE
    EnergisticsStandard_RESQML2_0_1 = _fesapi.DataObjectRepository_EnergisticsStandard_RESQML2_0_1
    EnergisticsStandard_EML2_0 = _fesapi.DataObjectRepository_EnergisticsStandard_EML2_0
    EnergisticsStandard_EML2_3 = _fesapi.DataObjectRepository_EnergisticsStandard_EML2_3
    EnergisticsStandard_PRODML2_2 = _fesapi.DataObjectRepository_EnergisticsStandard_PRODML2_2
    EnergisticsStandard_RESQML2_2 = _fesapi.DataObjectRepository_EnergisticsStandard_RESQML2_2
    EnergisticsStandard_WITSML2_1 = _fesapi.DataObjectRepository_EnergisticsStandard_WITSML2_1

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor

        |

        *Overload 2:*

        Constructor initializing the datobject repository based on a resource directory.

        :type resourceDirectory: string
        :param resourceDirectory:	Pathname of the resource directory.
            								For now it supports reading Energistics UOM 1.0 XML file
            								and a proprietary PropertyKindMapping.xml file waiting for PWLS support.
        """
        _fesapi.DataObjectRepository_swiginit(self, _fesapi.new_DataObjectRepository(*args))

    def setDefaultStandard(self, version: "common::DataObjectRepository::EnergisticsStandard") -> "void":
        r"""Set the used standard when creating a new dataobject"""
        return _fesapi.DataObjectRepository_setDefaultStandard(self, version)

    def getDefaultEmlVersion(self) -> "common::DataObjectRepository::EnergisticsStandard":
        r"""
        Gets the default EML version used when creating a EML data object.

        :rtype: int
        :return: The default EML version.
        """
        return _fesapi.DataObjectRepository_getDefaultEmlVersion(self)

    def getDefaultProdmlVersion(self) -> "common::DataObjectRepository::EnergisticsStandard":
        r"""
        Gets the default PRODML version used when creating a PRODML data object.

        :rtype: int
        :return: The default PRODML version.
        """
        return _fesapi.DataObjectRepository_getDefaultProdmlVersion(self)

    def getDefaultResqmlVersion(self) -> "common::DataObjectRepository::EnergisticsStandard":
        r"""
        Gets the default RESQML version used when creating a RESQML data object.

        :rtype: int
        :return: The default RESQML version.
        """
        return _fesapi.DataObjectRepository_getDefaultResqmlVersion(self)

    def getDefaultWitsmlVersion(self) -> "common::DataObjectRepository::EnergisticsStandard":
        r"""
        Gets the default WITSML version used when creating a WITSML data object.

        :rtype: int
        :return: The default WITSML version.
        """
        return _fesapi.DataObjectRepository_getDefaultWitsmlVersion(self)

    def clear(self) -> "void":
        r""" Removes and cleans all data objects from this repository"""
        return _fesapi.DataObjectRepository_clear(self)

    def getDefaultCrs(self) -> "eml2::AbstractLocal3dCrs *":
        r"""
        Gets the default CRS for writing. It is used in all writing methods if no explicit CRS is
        provided.

        :rtype: :py:class:`AbstractLocal3dCrs`
        :return: A pointer to the default CRS if it is defined, else null.
        """
        return _fesapi.DataObjectRepository_getDefaultCrs(self)

    def setDefaultCrs(self, crs: "Eml2_AbstractLocal3dCrs") -> "void":
        r"""
        Sets a default CRS for writing. It will be used in all writing methods if no explicit CRS is
        provided

        :param [in]:	crs	If non-null, the default CRS.
        """
        return _fesapi.DataObjectRepository_setDefaultCrs(self, crs)

    def getDefaultHdfProxy(self) -> "eml2::AbstractHdfProxy *":
        r"""
        Gets the default HDF5 file proxy for writing. It is used in all writing methods if no
        explicit HDF5 file proxy is provided.

        :rtype: :py:class:`AbstractHdfProxy`
        :return: ``nullptr`` if no default HDF5 file proxy is defined, else a pointer to the default HDF5 file proxy.
        """
        return _fesapi.DataObjectRepository_getDefaultHdfProxy(self)

    def setDefaultHdfProxy(self, hdfProxy: "Eml2_AbstractHdfProxy") -> "void":
        r"""
        Sets a default HDF5 file proxy for writing. It will be used in all writing methods if no
        explicit HDF5 file proxy is provided.

        :param [in]:	hdfProxy	If non-null, the HDF5 file proxy.
        """
        return _fesapi.DataObjectRepository_setDefaultHdfProxy(self, hdfProxy)

    def setHdfProxyFactory(self, factory: "HdfProxyFactory") -> "void":
        r"""
        Set the factory used to create HDF proxy and takes ownership of this HDF Proxy factory (don't delete it!)

        :param [in]:	factory	If non-null, the factory.
        """
        return _fesapi.DataObjectRepository_setHdfProxyFactory(self, factory)

    def addOrReplaceGsoapProxy(self, xml: "std::string const &", contentType: "std::string const &", uriSource: "std::string const &") -> "common::AbstractObject *":
        r"""
        Adds or replaces (based on Energistics XML definition) a data object in the repository. It
        does not update the relationships of the added or replaced data object

        :raises: std::invalid_argument	If, during a replacement, the content type of the data
            										object has changed.

        :type xml: string
        :param xml:		   	The XML which is the serialization of the Energistics data object to add
            						or to replace.
        :param contentOrDataType:	The content or qualified data type of the Energistics dataobject to add or to replace.
        :type uriSource: string
        :param uriSource:			The EPC document absolute path or the ETP dataspace URI where this dataobject comes from

        :rtype: :py:class:`AbstractObject`
        :return: Null if the content type of the data object cannot be wrapped by fesapi, else a
            			pointer the added or replaced data object.
        """
        return _fesapi.DataObjectRepository_addOrReplaceGsoapProxy(self, xml, contentType, uriSource)

    def setUriSource(self, uriSource: "std::string const &") -> "void":
        r"""
        Sets the URI Source of all dataobjects of this repository.
        It is particularly useful to map a repository to an ETP dataspace.

        :type uriSource: string
        :param uriSource:			The EPC document absolute path or the ETP dataspace URI associated to all dataobjects of this repository
        """
        return _fesapi.DataObjectRepository_setUriSource(self, uriSource)

    def cascadeDeleteDataObject(self, proxy: "AbstractObject") -> "uint64_t":
        r"""
        Delete a dataobject wich has not got any backward relationships. Throw an exception if the dataobejct ot delte has got backward relationships.
        It also goes on every forward related dataobject and delete them if they have no more backward relationships.
        It does that recursively.
        Remark : it is mainly used to delete properties because usually no dataobject points to them.
        For now, this method only deletes the XML part of the dataobject, not the HDF5 part.

        :param [in]:	proxy	The data object to delete.
        :rtype: int
        :return: The count of deleted objects
        """
        return _fesapi.DataObjectRepository_cascadeDeleteDataObject(self, proxy)

    def getHdfProxyCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getHdfProxyCount(self)

    def getHdfProxy(self, index: "unsigned int") -> "eml2::AbstractHdfProxy *":
        return _fesapi.DataObjectRepository_getHdfProxy(self, index)

    def getLocal3dCrsCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getLocal3dCrsCount(self)

    def getLocal3dCrs(self, index: "unsigned int") -> "eml2::AbstractLocal3dCrs *":
        return _fesapi.DataObjectRepository_getLocal3dCrs(self, index)

    def getActivityCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getActivityCount(self)

    def getActivity(self, index: "unsigned int") -> "eml2::Activity *":
        return _fesapi.DataObjectRepository_getActivity(self, index)

    def getActivityTemplateCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getActivityTemplateCount(self)

    def getActivityTemplate(self, index: "unsigned int") -> "eml2::ActivityTemplate *":
        return _fesapi.DataObjectRepository_getActivityTemplate(self, index)

    def getGraphicalInformationSetCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getGraphicalInformationSetCount(self)

    def getGraphicalInformationSet(self, index: "unsigned int") -> "eml2::GraphicalInformationSet *":
        return _fesapi.DataObjectRepository_getGraphicalInformationSet(self, index)

    def getPropertyKindCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getPropertyKindCount(self)

    def getPropertyKind(self, index: "unsigned int") -> "eml2::PropertyKind *":
        return _fesapi.DataObjectRepository_getPropertyKind(self, index)

    def getTimeSeriesCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getTimeSeriesCount(self)

    def getTimeSeries(self, index: "unsigned int") -> "eml2::TimeSeries *":
        return _fesapi.DataObjectRepository_getTimeSeries(self, index)

    def getDeviationSurveyRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getDeviationSurveyRepresentationCount(self)

    def getDeviationSurveyRepresentation(self, index: "unsigned int") -> "resqml2_0_1::DeviationSurveyRepresentation *":
        return _fesapi.DataObjectRepository_getDeviationSurveyRepresentation(self, index)

    def getSeismicLineCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getSeismicLineCount(self)

    def getSeismicLine(self, index: "unsigned int") -> "resqml2::AbstractSeismicLineFeature *":
        return _fesapi.DataObjectRepository_getSeismicLine(self, index)

    def getIjkGridRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getIjkGridRepresentationCount(self)

    def getIjkGridRepresentation(self, index: "unsigned int") -> "resqml2::AbstractIjkGridRepresentation *":
        return _fesapi.DataObjectRepository_getIjkGridRepresentation(self, index)

    def getBlockedWellboreRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getBlockedWellboreRepresentationCount(self)

    def getBlockedWellboreRepresentation(self, index: "unsigned int") -> "resqml2::BlockedWellboreRepresentation *":
        return _fesapi.DataObjectRepository_getBlockedWellboreRepresentation(self, index)

    def getFaultCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getFaultCount(self)

    def getFault(self, index: "unsigned int") -> "resqml2::BoundaryFeature *":
        return _fesapi.DataObjectRepository_getFault(self, index)

    def getFractureCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getFractureCount(self)

    def getFracture(self, index: "unsigned int") -> "resqml2::BoundaryFeature *":
        return _fesapi.DataObjectRepository_getFracture(self, index)

    def getGeobodyBoundaryCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getGeobodyBoundaryCount(self)

    def getGeobodyBoundary(self, index: "unsigned int") -> "resqml2::BoundaryFeature *":
        return _fesapi.DataObjectRepository_getGeobodyBoundary(self, index)

    def getHorizonCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getHorizonCount(self)

    def getHorizon(self, index: "unsigned int") -> "resqml2::BoundaryFeature *":
        return _fesapi.DataObjectRepository_getHorizon(self, index)

    def getCmpLineCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getCmpLineCount(self)

    def getCmpLine(self, index: "unsigned int") -> "resqml2::CmpLineFeature *":
        return _fesapi.DataObjectRepository_getCmpLine(self, index)

    def getContinuousColorMapCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getContinuousColorMapCount(self)

    def getContinuousColorMap(self, index: "unsigned int") -> "resqml2::ContinuousColorMap *":
        return _fesapi.DataObjectRepository_getContinuousColorMap(self, index)

    def getCulturalCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getCulturalCount(self)

    def getCultural(self, index: "unsigned int") -> "resqml2::CulturalFeature *":
        return _fesapi.DataObjectRepository_getCultural(self, index)

    def getDiscreteColorMapCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getDiscreteColorMapCount(self)

    def getDiscreteColorMap(self, index: "unsigned int") -> "resqml2::DiscreteColorMap *":
        return _fesapi.DataObjectRepository_getDiscreteColorMap(self, index)

    def getDoubleTableLookupCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getDoubleTableLookupCount(self)

    def getDoubleTableLookup(self, index: "unsigned int") -> "resqml2::DoubleTableLookup *":
        return _fesapi.DataObjectRepository_getDoubleTableLookup(self, index)

    def getAllGrid2dRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getAllGrid2dRepresentationCount(self)

    def getAllGrid2dRepresentation(self, index: "unsigned int") -> "resqml2::Grid2dRepresentation *":
        return _fesapi.DataObjectRepository_getAllGrid2dRepresentation(self, index)

    def getHorizonGrid2dRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getHorizonGrid2dRepresentationCount(self)

    def getHorizonGrid2dRepresentation(self, index: "unsigned int") -> "resqml2::Grid2dRepresentation *":
        return _fesapi.DataObjectRepository_getHorizonGrid2dRepresentation(self, index)

    def getIjkGridParametricRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getIjkGridParametricRepresentationCount(self)

    def getIjkGridParametricRepresentation(self, index: "unsigned int") -> "resqml2::IjkGridParametricRepresentation *":
        return _fesapi.DataObjectRepository_getIjkGridParametricRepresentation(self, index)

    def getIjkGridExplicitRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getIjkGridExplicitRepresentationCount(self)

    def getIjkGridExplicitRepresentation(self, index: "unsigned int") -> "resqml2::IjkGridExplicitRepresentation *":
        return _fesapi.DataObjectRepository_getIjkGridExplicitRepresentation(self, index)

    def getIjkSeismicCubeGridRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getIjkSeismicCubeGridRepresentationCount(self)

    def getIjkSeismicCubeGridRepresentation(self, index: "unsigned int") -> "resqml2::IjkGridLatticeRepresentation *":
        return _fesapi.DataObjectRepository_getIjkSeismicCubeGridRepresentation(self, index)

    def getModelCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getModelCount(self)

    def getModel(self, index: "unsigned int") -> "resqml2::Model *":
        return _fesapi.DataObjectRepository_getModel(self, index)

    def getPointSetRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getPointSetRepresentationCount(self)

    def getPointSetRepresentation(self, index: "unsigned int") -> "resqml2::PointSetRepresentation *":
        return _fesapi.DataObjectRepository_getPointSetRepresentation(self, index)

    def getAllPolylineRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getAllPolylineRepresentationCount(self)

    def getAllPolylineRepresentation(self, index: "unsigned int") -> "resqml2::PolylineRepresentation *":
        return _fesapi.DataObjectRepository_getAllPolylineRepresentation(self, index)

    def getHorizonPolylineRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getHorizonPolylineRepresentationCount(self)

    def getHorizonPolylineRepresentation(self, index: "unsigned int") -> "resqml2::PolylineRepresentation *":
        return _fesapi.DataObjectRepository_getHorizonPolylineRepresentation(self, index)

    def getSeismicLinePolylineRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getSeismicLinePolylineRepresentationCount(self)

    def getSeismicLinePolylineRepresentation(self, index: "unsigned int") -> "resqml2::PolylineRepresentation *":
        return _fesapi.DataObjectRepository_getSeismicLinePolylineRepresentation(self, index)

    def getAllPolylineSetRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getAllPolylineSetRepresentationCount(self)

    def getAllPolylineSetRepresentation(self, index: "unsigned int") -> "resqml2::PolylineSetRepresentation *":
        return _fesapi.DataObjectRepository_getAllPolylineSetRepresentation(self, index)

    def getHorizonPolylineSetRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getHorizonPolylineSetRepresentationCount(self)

    def getHorizonPolylineSetRepresentation(self, index: "unsigned int") -> "resqml2::PolylineSetRepresentation *":
        return _fesapi.DataObjectRepository_getHorizonPolylineSetRepresentation(self, index)

    def getFaultPolylineSetRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getFaultPolylineSetRepresentationCount(self)

    def getFaultPolylineSetRepresentation(self, index: "unsigned int") -> "resqml2::PolylineSetRepresentation *":
        return _fesapi.DataObjectRepository_getFaultPolylineSetRepresentation(self, index)

    def getFracturePolylineSetRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getFracturePolylineSetRepresentationCount(self)

    def getFracturePolylineSetRepresentation(self, index: "unsigned int") -> "resqml2::PolylineSetRepresentation *":
        return _fesapi.DataObjectRepository_getFracturePolylineSetRepresentation(self, index)

    def getCulturalPolylineSetRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getCulturalPolylineSetRepresentationCount(self)

    def getCulturalPolylineSetRepresentation(self, index: "unsigned int") -> "resqml2::PolylineSetRepresentation *":
        return _fesapi.DataObjectRepository_getCulturalPolylineSetRepresentation(self, index)

    def getRepresentationSetRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getRepresentationSetRepresentationCount(self)

    def getRepresentationSetRepresentation(self, index: "unsigned int") -> "resqml2::RepresentationSetRepresentation *":
        return _fesapi.DataObjectRepository_getRepresentationSetRepresentation(self, index)

    def getRockVolumeCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getRockVolumeCount(self)

    def getRockVolume(self, index: "unsigned int") -> "resqml2::RockVolumeFeature *":
        return _fesapi.DataObjectRepository_getRockVolume(self, index)

    def getGeobodyCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getGeobodyCount(self)

    def getGeobody(self, index: "unsigned int") -> "resqml2::RockVolumeFeature *":
        return _fesapi.DataObjectRepository_getGeobody(self, index)

    def getSeismicLatticeCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getSeismicLatticeCount(self)

    def getSeismicLattice(self, index: "unsigned int") -> "resqml2::SeismicLatticeFeature *":
        return _fesapi.DataObjectRepository_getSeismicLattice(self, index)

    def getSeismicLineSetCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getSeismicLineSetCount(self)

    def getSeismicLineSet(self, index: "unsigned int") -> "resqml2::SeismicLineSetFeature *":
        return _fesapi.DataObjectRepository_getSeismicLineSet(self, index)

    def getShotPointLineCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getShotPointLineCount(self)

    def getShotPointLine(self, index: "unsigned int") -> "resqml2::ShotPointLineFeature *":
        return _fesapi.DataObjectRepository_getShotPointLine(self, index)

    def getStratigraphicColumnCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getStratigraphicColumnCount(self)

    def getStratigraphicColumn(self, index: "unsigned int") -> "resqml2::StratigraphicColumn *":
        return _fesapi.DataObjectRepository_getStratigraphicColumn(self, index)

    def getStreamlinesFeatureCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getStreamlinesFeatureCount(self)

    def getStreamlinesFeature(self, index: "unsigned int") -> "resqml2::StreamlinesFeature *":
        return _fesapi.DataObjectRepository_getStreamlinesFeature(self, index)

    def getStreamlinesRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getStreamlinesRepresentationCount(self)

    def getStreamlinesRepresentation(self, index: "unsigned int") -> "resqml2::StreamlinesRepresentation *":
        return _fesapi.DataObjectRepository_getStreamlinesRepresentation(self, index)

    def getSubRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getSubRepresentationCount(self)

    def getSubRepresentation(self, index: "unsigned int") -> "resqml2::SubRepresentation *":
        return _fesapi.DataObjectRepository_getSubRepresentation(self, index)

    def getAllTriangulatedSetRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getAllTriangulatedSetRepresentationCount(self)

    def getAllTriangulatedSetRepresentation(self, index: "unsigned int") -> "resqml2::TriangulatedSetRepresentation *":
        return _fesapi.DataObjectRepository_getAllTriangulatedSetRepresentation(self, index)

    def getUnclassifiedTriangulatedSetRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getUnclassifiedTriangulatedSetRepresentationCount(self)

    def getUnclassifiedTriangulatedSetRepresentation(self, index: "unsigned int") -> "resqml2::TriangulatedSetRepresentation *":
        return _fesapi.DataObjectRepository_getUnclassifiedTriangulatedSetRepresentation(self, index)

    def getFaultTriangulatedSetRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getFaultTriangulatedSetRepresentationCount(self)

    def getFaultTriangulatedSetRepresentation(self, index: "unsigned int") -> "resqml2::TriangulatedSetRepresentation *":
        return _fesapi.DataObjectRepository_getFaultTriangulatedSetRepresentation(self, index)

    def getFractureTriangulatedSetRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getFractureTriangulatedSetRepresentationCount(self)

    def getFractureTriangulatedSetRepresentation(self, index: "unsigned int") -> "resqml2::TriangulatedSetRepresentation *":
        return _fesapi.DataObjectRepository_getFractureTriangulatedSetRepresentation(self, index)

    def getHorizonTriangulatedSetRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getHorizonTriangulatedSetRepresentationCount(self)

    def getHorizonTriangulatedSetRepresentation(self, index: "unsigned int") -> "resqml2::TriangulatedSetRepresentation *":
        return _fesapi.DataObjectRepository_getHorizonTriangulatedSetRepresentation(self, index)

    def getUnstructuredGridRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getUnstructuredGridRepresentationCount(self)

    def getUnstructuredGridRepresentation(self, index: "unsigned int") -> "resqml2::UnstructuredGridRepresentation *":
        return _fesapi.DataObjectRepository_getUnstructuredGridRepresentation(self, index)

    def getWellboreCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getWellboreCount(self)

    def getWellbore(self, index: "unsigned int") -> "resqml2::WellboreFeature *":
        return _fesapi.DataObjectRepository_getWellbore(self, index)

    def getWellboreTrajectoryRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getWellboreTrajectoryRepresentationCount(self)

    def getWellboreTrajectoryRepresentation(self, index: "unsigned int") -> "resqml2::WellboreTrajectoryRepresentation *":
        return _fesapi.DataObjectRepository_getWellboreTrajectoryRepresentation(self, index)

    def getWellboreFrameRepresentationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getWellboreFrameRepresentationCount(self)

    def getWellboreFrameRepresentation(self, index: "unsigned int") -> "resqml2::WellboreFrameRepresentation *":
        return _fesapi.DataObjectRepository_getWellboreFrameRepresentation(self, index)

    def getPropertySetCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getPropertySetCount(self)

    def getPropertySet(self, index: "unsigned int") -> "resqml2_0_1::PropertySet *":
        return _fesapi.DataObjectRepository_getPropertySet(self, index)

    def getWitsmlWellCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getWitsmlWellCount(self)

    def getWitsmlWell(self, index: "unsigned int") -> "witsml2::Well *":
        return _fesapi.DataObjectRepository_getWitsmlWell(self, index)

    def getWitsmlWellboreCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getWitsmlWellboreCount(self)

    def getWitsmlWellbore(self, index: "unsigned int") -> "witsml2::Wellbore *":
        return _fesapi.DataObjectRepository_getWitsmlWellbore(self, index)

    def getWitsmlTrajectoryCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getWitsmlTrajectoryCount(self)

    def getWitsmlTrajectory(self, index: "unsigned int") -> "witsml2::Trajectory *":
        return _fesapi.DataObjectRepository_getWitsmlTrajectory(self, index)

    def getWellCompletionCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getWellCompletionCount(self)

    def getWellCompletion(self, index: "unsigned int") -> "witsml2_1::WellCompletion *":
        return _fesapi.DataObjectRepository_getWellCompletion(self, index)

    def getWellboreCompletionCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getWellboreCompletionCount(self)

    def getWellboreCompletion(self, index: "unsigned int") -> "witsml2_1::WellboreCompletion *":
        return _fesapi.DataObjectRepository_getWellboreCompletion(self, index)

    def getWellboreGeometryCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getWellboreGeometryCount(self)

    def getWellboreGeometry(self, index: "unsigned int") -> "witsml2_1::WellboreGeometry *":
        return _fesapi.DataObjectRepository_getWellboreGeometry(self, index)

    def getLogCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getLogCount(self)

    def getLog(self, index: "unsigned int") -> "witsml2_1::Log *":
        return _fesapi.DataObjectRepository_getLog(self, index)

    def getChannelSetCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getChannelSetCount(self)

    def getChannelSet(self, index: "unsigned int") -> "witsml2_1::ChannelSet *":
        return _fesapi.DataObjectRepository_getChannelSet(self, index)

    def getChannelCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getChannelCount(self)

    def getChannel(self, index: "unsigned int") -> "witsml2_1::Channel *":
        return _fesapi.DataObjectRepository_getChannel(self, index)

    def getFluidSystemCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getFluidSystemCount(self)

    def getFluidSystem(self, index: "unsigned int") -> "prodml2_2::FluidSystem *":
        return _fesapi.DataObjectRepository_getFluidSystem(self, index)

    def getFluidCharacterizationCount(self) -> "unsigned int":
        return _fesapi.DataObjectRepository_getFluidCharacterizationCount(self)

    def getFluidCharacterization(self, index: "unsigned int") -> "prodml2_2::FluidCharacterization *":
        return _fesapi.DataObjectRepository_getFluidCharacterization(self, index)

    def getDataObjectByUuid(self, uuid: "std::string const &") -> "common::AbstractObject *":
        r"""
        Gets a data object from the repository by means of its uuid. If several data object
        correspond to this uuid in the repository, the first one in memory will be arbitrarily
        returned.

        :type uuid: string
        :param uuid:	The uuid of the requested data object.

        :rtype: :py:class:`AbstractObject`
        :return: A pointer to the data object which corresponds to the uuid, ``nullptr`` if there exists no
            			such data object.
        """
        return _fesapi.DataObjectRepository_getDataObjectByUuid(self, uuid)

    def getDataObjectByUuidAndVersion(self, uuid: "std::string const &", version: "std::string const &") -> "common::AbstractObject *":
        r"""
        Gets a data object from the repository by means of both its uuid and version.

        :type uuid: string
        :param uuid:   	The uuid of the requested data object.
        :type version: string
        :param version:	The version of the requested data object.

        :rtype: :py:class:`AbstractObject`
        :return: A pointer to the data object which corresponds to both uuid and version, ``nullptr`` if there
            			exists no such data object.
        """
        return _fesapi.DataObjectRepository_getDataObjectByUuidAndVersion(self, uuid, version)

    def getUuids(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Gets all the data object uuids which are part of this repository

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of uuids.
        """
        return _fesapi.DataObjectRepository_getUuids(self)

    def createHdfProxy(self, guid: "std::string const &", title: "std::string const &", packageDirAbsolutePath: "std::string const &", filePath: "std::string const &", hdfPermissionAccess: "common::DataObjectRepository::openingMode") -> "eml2::AbstractHdfProxy *":
        r"""
        Creates a non parallel access to an HDF5 file for writing to it. Resulting HDF5 file
        			proxy is stored into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:				  	The guid to set to the HDF5 file proxy. If empty then a new
            									guid will be generated.
        :type title: string
        :param title:				  	The title to set to the HDF5 file proxy. If empty then
            									"unknown" title will be set.
        :type packageDirAbsolutePath: string
        :param packageDirAbsolutePath:	Path of the directory where the HDF5 file must be created.
        :type filePath: string
        :param filePath:	  			Path of the HDF5 file relative to packageDirAbsolutePath.
        :type hdfPermissionAccess: int
        :param hdfPermissionAccess:   	The HDF5 file permission access. It is read
            										only by default.

        :rtype: :py:class:`AbstractHdfProxy`
        :return: A pointer to an instantiated HDF5 file proxy.
        """
        return _fesapi.DataObjectRepository_createHdfProxy(self, guid, title, packageDirAbsolutePath, filePath, hdfPermissionAccess)

    def createLocalDepth3dCrs(self, *args) -> "eml2::AbstractLocal3dCrs *":
        r"""
        *Overload 1:*

        Creates a local depth 3d CRS which is fully identified by means of an EPSG code.
        			Resulting local depth 3d CRS is stored into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If projectedEpsgCode == 0 || verticalEpsgCode ==
            										0.

        :type guid: string
        :param guid:			 	The guid to set to the local 3d CRS. If empty then a new guid
            								will be generated.
        :type title: string
        :param title:			 	The title to set to the local 3d CRS. If empty then "unknown"
            								title will be set.
        :type originOrdinal1: float
        :param originOrdinal1:   	The offset of the global 2d CRS on its first axis.
        :type originOrdinal2: float
        :param originOrdinal2:   	The offset of the global 2d CRS on its second axis.
        :type originOrdinal3: float
        :param originOrdinal3:   	The offset in depth of the local CRS regarding the depth origin
            								of the vertical CRS.
        :type arealRotation: float
        :param arealRotation:	 	The areal rotation in radians regarding the projected CRS.
        :type projectedUom: int
        :param projectedUom:	 	The unit of measure of the projected axis of this instance.
        :type projectedEpsgCode: int
        :param projectedEpsgCode:	The EPSG code of the associated projected CRS.
        :type verticalUom: int
        :param verticalUom:		 	The unit of measure of the vertical axis of this instance.
        :type verticalEpsgCode: int
        :param verticalEpsgCode: 	The EPSG code of the associated vertical CRS.
        :type isUpOriented: boolean
        :param isUpOriented:	 	If true, indicates that this depth CRS is actually an elevation
            								CRS.

        :rtype: :py:class:`AbstractLocal3dCrs`
        :return: A pointer to the new local depth 3d CRS.

        |

        *Overload 2:*

        Creates a local depth 3d CRS which is fully defined by a string representation.
        			Resulting local depth 3d CRS is	stored into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:				  	The guid to set to the local 3d CRS. If empty then a new guid
            									will be generated.
        :type title: string
        :param title:				  	The title to set to the local 3d CRS. If empty then
            									"unknown" title will be set.
        :type originOrdinal1: float
        :param originOrdinal1:		  	The offset of the global 2d CRS on its first axis.
        :type originOrdinal2: float
        :param originOrdinal2:		  	The offset of the global 2d CRS on its second axis.
        :type originOrdinal3: float
        :param originOrdinal3:		  	The offset in depth of the local CRS regarding the depth
            									origin of the vertical CRS.
        :type arealRotation: float
        :param arealRotation:		  	The areal rotation in radians regarding the projected CRS.
        :type projectedUom: int
        :param projectedUom:		  	The unit of measure of the projected axis of this instance.
        :type projectedDefinition: string
        :param projectedDefinition:		If starting with "PROJCRS" or "PROJCS" then it gives the WKT definition of the projected CRS.
            									Otherwise, it defines why this projected CRS should be considered as unknown.
        :type verticalUom: int
        :param verticalUom:			  	The unit of measure of the vertical axis of this instance.
        :type verticalDefinition: string
        :param verticalDefinition:	 	If starting with "VERT" then it gives the WKT definition of the vertical CRS.
            									Otherwise, it defines why this vertical CRS should be considered as unknown.
        :type isUpOriented: boolean
        :param isUpOriented:		  	If true, indicates that this depth CRS is actually an
            									elevation CRS.

        :rtype: :py:class:`AbstractLocal3dCrs`
        :return: A pointer to the new local depth 3d CRS.

        |

        *Overload 3:*

        Creates a local depth 3d CRS which is identified by an EPSG code for its projected
        			part and which is defined by a string representation for its vertical part.
        			Resulting local depth 3d CRS is	stored into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If projectedEpsgCode == 0.

        :type guid: string
        :param guid:				 	The guid to set to the local 3d CRS. If empty then a new guid
            									will be generated.
        :type title: string
        :param title:				 	The title to set to the local 3d CRS. If empty then
            									"unknown" title will be set.
        :type originOrdinal1: float
        :param originOrdinal1:		 	The offset of the global 2d CRS on its first axis.
        :type originOrdinal2: float
        :param originOrdinal2:		 	The offset of the global 2d CRS on its second axis.
        :type originOrdinal3: float
        :param originOrdinal3:		 	The offset in depth of the local CRS regarding the depth
            									origin of the vertical CRS.
        :type arealRotation: float
        :param arealRotation:		 	The areal rotation in radians regarding the projected CRS.
        :type projectedUom: int
        :param projectedUom:		 	The unit of measure of the projected axis of this instance.
        :type projectedEpsgCode: int
        :param projectedEpsgCode:	 	The EPSG code of the associated projected CRS.
        :type verticalUom: int
        :param verticalUom:			 	The unit of measure of the vertical axis of this instance.
        :type verticalDefinition: string
        :param verticalDefinition:	 	If starting with "VERT" then it gives the WKT definition of the vertical CRS.
            									Otherwise, it defines why this vertical CRS should be considered as unknown.
        :type isUpOriented: boolean
        :param isUpOriented:		 	If true, indicates that this depth CRS is actually an
            									elevation CRS.

        :rtype: :py:class:`AbstractLocal3dCrs`
        :return: A pointer to the new local depth 3d CRS.

        |

        *Overload 4:*

        Creates a local depth 3d CRS which is defined by a string representation for its projected part
        			and which is identified by an EPSG code for its vertical part.
        			Resulting local depth 3d CRS is	stored into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If verticalEpsgCode == 0.

        :type guid: string
        :param guid:				  	The guid to set to the local 3d CRS. If empty then a new guid
            									will be generated.
        :type title: string
        :param title:				  	The title to set to the local 3d CRS. If empty then
            									"unknown" title will be set.
        :type originOrdinal1: float
        :param originOrdinal1:		  	The offset of the global 2d CRS on its first axis.
        :type originOrdinal2: float
        :param originOrdinal2:		  	The offset of the global 2d CRS on its second axis.
        :type originOrdinal3: float
        :param originOrdinal3:		  	The offset in depth of the local CRS regarding the depth
            									origin of the vertical CRS.
        :type arealRotation: float
        :param arealRotation:		  	The areal rotation in radians regarding the projected CRS.
        :type projectedUom: int
        :param projectedUom:		  	The unit of measure of the projected axis of this instance.
        :type projectedDefinition: string
        :param projectedDefinition:		If starting with "PROJCRS" or "PROJCS" then it gives the WKT definition of the projected CRS.
            									Otherwise, it defines why this projected CRS should be considered as unknown.
        :type verticalUom: int
        :param verticalUom:			  	The unit of measure of the vertical axis of this instance.
        :type verticalEpsgCode: int
        :param verticalEpsgCode:	  	The EPSG code of the associated vertical CRS.
        :type isUpOriented: boolean
        :param isUpOriented:		  	If true, indicates that this depth CRS is actually an
            									elevation CRS.

        :rtype: :py:class:`AbstractLocal3dCrs`
        :return: A pointer to the new local depth 3d CRS.
        """
        return _fesapi.DataObjectRepository_createLocalDepth3dCrs(self, *args)

    def createLocalTime3dCrs(self, *args) -> "eml2::AbstractLocal3dCrs *":
        r"""
        *Overload 1:*

        Creates a local time 3d CRS which is fully identified by means of EPSG code.
        			Resulting local time 3d CRS is stored into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If projectedEpsgCode == 0 || verticalEpsgCode ==
            										0.

        :type guid: string
        :param guid:			 	The guid to set to the local 3d CRS. If empty then a new guid
            								will be generated.
        :type title: string
        :param title:			 	The title to set to the local 3d CRS. If empty then "unknown"
            								title will be set.
        :type originOrdinal1: float
        :param originOrdinal1:   	The offset of the global 2d CRS on its first axis.
        :type originOrdinal2: float
        :param originOrdinal2:   	The offset of the global 2d CRS on its second axis.
        :type originOrdinal3: float
        :param originOrdinal3:   	The offset in depth of the local CRS regarding the depth origin
            								of the vertical CRS.
        :type arealRotation: float
        :param arealRotation:	 	The areal rotation in radians regarding the projected CRS.
        :type projectedUom: int
        :param projectedUom:	 	The unit of measure of the projected axis of this instance.
        :type projectedEpsgCode: int
        :param projectedEpsgCode:	The EPSG code of the associated projected CRS.
        :type timeUom: int
        :param timeUom:			 	The unit of measure of the Z offset of this instance.
        :type verticalUom: int
        :param verticalUom:		 	The unit of measure of the vertical axis of this instance.
        :type verticalEpsgCode: int
        :param verticalEpsgCode: 	The EPSG code of the associated vertical CRS.
        :type isUpOriented: boolean
        :param isUpOriented:	 	If true, indicates that the Z offset if an elevation when
            								positive. If false, the Z offset if a depth when positive.

        :rtype: :py:class:`AbstractLocal3dCrs`
        :return: A pointer to the new local time 3d CRS.

        |

        *Overload 2:*

        Creates a local time 3d CRS which is fully defined by a string representation.
        			Resulting local time 3d CRS is stored into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:				  	The guid to set to the local 3d CRS. If empty then a new guid
            									will be generated.
        :type title: string
        :param title:				  	The title to set to the local 3d CRS. If empty then
            									"unknown" title will be set.
        :type originOrdinal1: float
        :param originOrdinal1:		  	The offset of the global 2d CRS on its first axis.
        :type originOrdinal2: float
        :param originOrdinal2:		  	The offset of the global 2d CRS on its second axis.
        :type originOrdinal3: float
        :param originOrdinal3:		  	The offset in depth of the local CRS regarding the depth
            									origin of the vertical CRS.
        :type arealRotation: float
        :param arealRotation:		  	The areal rotation in radians regarding the projected CRS.
        :type projectedUom: int
        :param projectedUom:		  	The unit of measure of the projected axis of this instance.
        :type projectedDefinition: string
        :param projectedDefinition:		If starting with "PROJCRS" or "PROJCS" then it gives the WKT definition of the projected CRS.
            									Otherwise, it defines why this projected CRS should be considered as unknown.
        :type timeUom: int
        :param timeUom:				  	The unit of measure of the Z offset of this instance.
        :type verticalUom: int
        :param verticalUom:			  	The unit of measure of the vertical axis of this instance.
        :type verticalDefinition: string
        :param verticalDefinition:	 	If starting with "VERT" then it gives the WKT definition of the vertical CRS.
            									Otherwise, it defines why this vertical CRS should be considered as unknown.
        :type isUpOriented: boolean
        :param isUpOriented:		  	If true, indicates that the Z offset if an elevation when
            									positive. If false, the Z offset if a depth when positive.

        :rtype: :py:class:`AbstractLocal3dCrs`
        :return: A pointer to the new local time 3d CRS.

        |

        *Overload 3:*

        Creates a local time 3d CRS which is identified by an EPSG code for its projected
        			part and which is defined by a string representation for its vertical part.
        			Resulting local time 3d CRS is stored into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If projectedEpsgCode == 0.

        :type guid: string
        :param guid:				 	The guid to set to the local 3d CRS. If empty then a new guid
            									will be generated.
        :type title: string
        :param title:				 	The title to set to the local 3d CRS. If empty then
            									"unknown" title will be set.
        :type originOrdinal1: float
        :param originOrdinal1:		 	The offset of the global 2d CRS on its first axis.
        :type originOrdinal2: float
        :param originOrdinal2:		 	The offset of the global 2d CRS on its second axis.
        :type originOrdinal3: float
        :param originOrdinal3:		 	The offset in depth of the local CRS regarding the depth
            									origin of the vertical CRS.
        :type arealRotation: float
        :param arealRotation:		 	The areal rotation in radians regarding the projected CRS.
        :type projectedUom: int
        :param projectedUom:		 	The unit of measure of the projected axis of this instance.
        :type projectedEpsgCode: int
        :param projectedEpsgCode:	 	The EPSG code of the associated projected CRS.
        :type timeUom: int
        :param timeUom:				 	The unit of measure of the Z offset of this instance.
        :type verticalUom: int
        :param verticalUom:			 	The unit of measure of the vertical axis of this instance.
        :type verticalDefinition: string
        :param verticalDefinition:	 	If starting with "VERT" then it gives the WKT definition of the vertical CRS.
            									Otherwise, it defines why this vertical CRS should be considered as unknown.
        :type isUpOriented: boolean
        :param isUpOriented:		 	If true, indicates that the Z offset if an elevation when
            									positive. If false, the Z offset if a depth when positive.

        :rtype: :py:class:`AbstractLocal3dCrs`
        :return: A pointer to the new local time 3d CRS.

        |

        *Overload 4:*

        Creates a local time 3d CRS which is defined by a string representation for its projected part
        			and which is identified by an EPSG code for its vertical part.
        			Resulting local time 3d CRS is stored into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If verticalEpsgCode == 0.

        :type guid: string
        :param guid:				  	The guid to set to the local 3d CRS. If empty then a new guid
            									will be generated.
        :type title: string
        :param title:				  	The title to set to the local 3d CRS. If empty then
            									"unknown" title will be set.
        :type originOrdinal1: float
        :param originOrdinal1:		  	The offset of the global 2d CRS on its first axis.
        :type originOrdinal2: float
        :param originOrdinal2:		  	The offset of the global 2d CRS on its second axis.
        :type originOrdinal3: float
        :param originOrdinal3:		  	The offset in depth of the local CRS regarding the depth
            									origin of the vertical CRS.
        :type arealRotation: float
        :param arealRotation:		  	The areal rotation in radians regarding the projected CRS.
        :type projectedUom: int
        :param projectedUom:		  	The unit of measure of the projected axis of this instance.
        :type projectedDefinition: string
        :param projectedDefinition:		If starting with "PROJCRS" or "PROJCS" then it gives the WKT definition of the projected CRS.
            									Otherwise, it defines why this projected CRS should be considered as unknown.
        :type timeUom: int
        :param timeUom:				  	The unit of measure of the Z offset of this instance.
        :type verticalUom: int
        :param verticalUom:			  	The unit of measure of the vertical axis of this instance.
        :type verticalEpsgCode: int
        :param verticalEpsgCode:	  	The EPSG code of the associated vertical CRS.
        :type isUpOriented: boolean
        :param isUpOriented:		  	If true, indicates that the Z offset if an elevation when
            									positive. If false, the Z offset if a depth when positive.

        :rtype: :py:class:`AbstractLocal3dCrs`
        :return: A pointer to the new local time 3d CRS.
        """
        return _fesapi.DataObjectRepository_createLocalTime3dCrs(self, *args)

    def createMdDatum(self, guid: "std::string const &", title: "std::string const &", locCrs: "Eml2_AbstractLocal3dCrs", originKind: "gsoap_eml2_3::eml23__ReferencePointKind", referenceLocationOrdinal1: "double", referenceLocationOrdinal2: "double", referenceLocationOrdinal3: "double") -> "resqml2::MdDatum *":
        r"""
        Creates a reference point (such as a MD datum) into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:					 	The guid to set to the reference point. If empty then a new
            											guid will be generated.
        :type title: string
        :param title:					 	The title to set to the reference point. If empty then
            											"unknown" title will be set.
        :param [in]:	locCrs					 	The local 3d CRS associated to this reference point if non-null,
            											else the default local 3d CRS.
        :type originKind: int
        :param originKind:				 	The reference location of the reference point.
        :type referenceLocationOrdinal1: float
        :param referenceLocationOrdinal1:	The first reference location ordinal relative to the
            											local 3d CRS.
        :type referenceLocationOrdinal2: float
        :param referenceLocationOrdinal2:	The second reference location ordinal relative to the
            											local 3d CRS.
        :type referenceLocationOrdinal3: float
        :param referenceLocationOrdinal3:	The third reference location ordinal relative to the
            											local 3d CRS.

        :rtype: :py:class:`MdDatum`
        :return: A pointer to the new reference point.
        """
        return _fesapi.DataObjectRepository_createMdDatum(self, guid, title, locCrs, originKind, referenceLocationOrdinal1, referenceLocationOrdinal2, referenceLocationOrdinal3)

    def createBoundaryFeature(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::BoundaryFeature *":
        r"""
        Creates a boundary feature into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the boundary feature. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the boundary feature. If empty then "unknown" title
            					will be set.

        :rtype: :py:class:`BoundaryFeature`
        :return: A pointer to the new boundary feature.
        """
        return _fesapi.DataObjectRepository_createBoundaryFeature(self, guid, title)

    def createHorizon(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::BoundaryFeature *":
        r"""
        Deprecated: Use {createBoundaryFeature()} method for RESQML post v2.0.1 Creates
        			a horizon into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the horizon. If empty then a new guid will be generated.
        :type title: string
        :param title:	The title to set to the horizon. If empty then "unknown" title will be set.

        :rtype: :py:class:`BoundaryFeature`
        :return: A pointer to the new horizon.
        """
        return _fesapi.DataObjectRepository_createHorizon(self, guid, title)

    def createGeobodyBoundaryFeature(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::BoundaryFeature *":
        r"""
        Deprecated: Use {createBoundaryFeature()} method for RESQML post v2.0.1 Creates
        			a geobody boundary feature into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the geobody boundary feature. If empty then a new guid
            					will be generated.
        :type title: string
        :param title:	The title to set to the geobody boundary feature. If empty then "unknown"
            					title will be set.

        :rtype: :py:class:`BoundaryFeature`
        :return: A pointer to the new geobody boundary feature.
        """
        return _fesapi.DataObjectRepository_createGeobodyBoundaryFeature(self, guid, title)

    def createGeobodyFeature(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::RockVolumeFeature *":
        r"""
        Creates a geobody feature into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the geobody feature. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the geobody feature. If empty then "unknown" title will
            					be set.

        :rtype: :py:class:`RockVolumeFeature`
        :return: A pointer to the new geobody feature.
        """
        return _fesapi.DataObjectRepository_createGeobodyFeature(self, guid, title)

    def createFault(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::BoundaryFeature *":
        r"""
        Deprecated: Use {createBoundaryFeature()} method for RESQML post v2.0.1 Creates
        			a fault into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the fault. If empty then a new guid will be generated.
        :type title: string
        :param title:	The title to set to the fault. If empty then "unknown" title will be set.

        :rtype: :py:class:`BoundaryFeature`
        :return: A pointer to the new fault.
        """
        return _fesapi.DataObjectRepository_createFault(self, guid, title)

    def createFracture(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::BoundaryFeature *":
        r"""
        Deprecated: Use {createBoundaryFeature()} method for RESQML post v2.0.1 Creates
        			a fracture into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the fracture. If empty then a new guid will be generated.
        :type title: string
        :param title:	The title to set to the fracture. If empty then "unknown" title will be set.

        :rtype: :py:class:`BoundaryFeature`
        :return: A pointer to the new fracture.
        """
        return _fesapi.DataObjectRepository_createFracture(self, guid, title)

    def createWellboreFeature(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::WellboreFeature *":
        r"""
        Creates a wellbore feature into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the wellbore feature. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the wellbore feature. If empty then "unknown" title
            					will be set.

        :rtype: :py:class:`WellboreFeature`
        :return: A pointer to the new wellbore feature.
        """
        return _fesapi.DataObjectRepository_createWellboreFeature(self, guid, title)

    def createSeismicLattice(self, guid: "std::string const &", title: "std::string const &", inlineIncrement: "int", crosslineIncrement: "int", originInline: "unsigned int", originCrossline: "unsigned int", inlineCount: "unsigned int", crosslineCount: "unsigned int") -> "resqml2::SeismicLatticeFeature *":
        r"""
        Creates a seismic lattice into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:			  	The guid to set to the seismic lattice. If empty then a new guid
            								will be generated.
        :type title: string
        :param title:			  	The title to set to the seismic lattice. If empty then
            								"unknown" title will be set.
        :type inlineIncrement: int
        :param inlineIncrement:   	The constant index increment between two consecutive inlines of
            								the seismic lattice.
        :type crosslineIncrement: int
        :param crosslineIncrement:	The constant index increment between two consecutive crosslines
            								of the seismic lattice.
        :type originInline: int
        :param originInline:	  	The index of the first inline of the seismic lattice.
        :type originCrossline: int
        :param originCrossline:   	The index of the first crossline of the seismic lattice.
        :type inlineCount: int
        :param inlineCount:		  	Number of inlines.
        :type crosslineCount: int
        :param crosslineCount:	  	Number of crosslines.

        :rtype: :py:class:`SeismicLatticeFeature`
        :return: A pointer to the new seismic lattice.
        """
        return _fesapi.DataObjectRepository_createSeismicLattice(self, guid, title, inlineIncrement, crosslineIncrement, originInline, originCrossline, inlineCount, crosslineCount)

    def createSeismicLine(self, guid: "std::string const &", title: "std::string const &", traceIndexIncrement: "int", firstTraceIndex: "unsigned int", traceCount: "unsigned int") -> "resqml2_0_1::SeismicLineFeature *":
        r"""
        Creates a seismic line into this repository

        :type guid: string
        :param guid:			   	The guid to set to the seismic line. If empty then a new guid
            								will be generated.
        :type title: string
        :param title:			   	The title to set to the seismic line. If empty then "unknown"
            								title will be set.
        :type traceIndexIncrement: int
        :param traceIndexIncrement:	The constant index increment between two consecutive traces.
        :type firstTraceIndex: int
        :param firstTraceIndex:	   	The index of the first trace of the seismic line.
        :type traceCount: int
        :param traceCount:		   	Number of traces.

        :rtype: :py:class:`SeismicLineFeature`
        :return: A pointer to the new seismic line.
        """
        return _fesapi.DataObjectRepository_createSeismicLine(self, guid, title, traceIndexIncrement, firstTraceIndex, traceCount)

    def createSeismicLineSet(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::SeismicLineSetFeature *":
        r"""
        Creates a seismic line set into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the seismic line set. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the seismic line set. If empty then "unknown".

        :rtype: :py:class:`SeismicLineSetFeature`
        :return: A pointer to the new seismic line set.
        """
        return _fesapi.DataObjectRepository_createSeismicLineSet(self, guid, title)

    def createCultural(self, *args) -> "resqml2::CulturalFeature *":
        r"""
        Creates a cultural into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the cultural. If empty then a new guid will be generated.
        :type title: string
        :param title:	The title to set to the cultural. If empty then "unknown" title will be set.
        :type kind: gsoap_eml2_3::resqml22__CulturalFeatureKind, optional
        :param kind: 	(Optional) The kind to set to the cultural. It is defaulted to
            					gsoap_eml2_3::resqml22__CulturalFeatureKind::project_x0020boundaries for
            					easing 2.0.1 compatibility.

        :rtype: :py:class:`CulturalFeature`
        :return: A pointer to the new cultural.
        """
        return _fesapi.DataObjectRepository_createCultural(self, *args)

    def createStratigraphicUnitFeature(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::RockVolumeFeature *":
        r"""
        Deprecated: Use {createRockVolumeFeature()} method for RESQML post v2.0.1
        			Creates a stratigraphic unit into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the stratigraphic unit. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the stratigraphic unit. If empty then "unknown" title
            					will be set.

        :rtype: :py:class:`RockVolumeFeature`
        :return: A pointer to the new stratigraphic unit.
        """
        return _fesapi.DataObjectRepository_createStratigraphicUnitFeature(self, guid, title)

    def createStructuralModel(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::Model *":
        r"""
        Deprecated: Use {createModel()} method for RESQML post v2.0.1 Creates a
        			structural model into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the structural model. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the structural model. If empty then "unknown" title
            					will be set.

        :rtype: :py:class:`Model`
        :return: A pointer to the new structural model.
        """
        return _fesapi.DataObjectRepository_createStructuralModel(self, guid, title)

    def createStratigraphicModel(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::Model *":
        r"""
        Deprecated: Use {createModel()} method for RESQML post v2.0.1 Creates a
        			stratigraphic model into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the stratigraphic model. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the stratigraphic model. If empty then "unknown" title
            					will be set.

        :rtype: :py:class:`Model`
        :return: A pointer to the new stratigraphic model.
        """
        return _fesapi.DataObjectRepository_createStratigraphicModel(self, guid, title)

    def createRockFluidModel(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::Model *":
        r"""
        Deprecated: Use {createModel()} method for RESQML post v2.0.1 Creates a rock
        			fluid model into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the rock fluid model. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the rock fluid model. If empty then "unknown" title
            					will be set.

        :rtype: :py:class:`Model`
        :return: A pointer to the new rock fluid model.
        """
        return _fesapi.DataObjectRepository_createRockFluidModel(self, guid, title)

    def createEarthModel(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::Model *":
        r"""
        Deprecated: Use {createModel()} method for RESQML post v2.0.1 Creates an earth
        			model into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the earth model. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the earth model. If empty then "unknown" title will be
            					set.

        :rtype: :py:class:`Model`
        :return: A pointer to the new earth model.
        """
        return _fesapi.DataObjectRepository_createEarthModel(self, guid, title)

    def createFluidBoundaryFeature(self, guid: "std::string const &", title: "std::string const &", fluidContact: "gsoap_resqml2_0_1::resqml20__FluidContact") -> "resqml2_0_1::FluidBoundaryFeature *":
        r"""
        Creates a fluid boundary feature into this repository

        :type guid: string
        :param guid:			The guid to set to the fluid boundary feature. If empty then a new
            							guid will be generated.
        :type title: string
        :param title:			The title to set to the fluid boundary feature. If empty then
            							"unknown" title will be set.
        :type fluidContact: int
        :param fluidContact:	The fluid contact.

        :rtype: :py:class:`FluidBoundaryFeature`
        :return: A pointer to the new fluid boundary feature.
        """
        return _fesapi.DataObjectRepository_createFluidBoundaryFeature(self, guid, title, fluidContact)

    def createRockFluidUnit(self, guid: "std::string const &", title: "std::string const &", phase: "gsoap_resqml2_0_1::resqml20__Phase", fluidBoundaryTop: "Resqml20_FluidBoundaryFeature", fluidBoundaryBottom: "Resqml20_FluidBoundaryFeature") -> "resqml2_0_1::RockFluidUnitFeature *":
        r"""
        Creates rock fluid unit into this repository

        :type guid: string
        :param guid:			   	The guid to set to the rock fluid unit. If empty then a
            										new guid will be generated.
        :type title: string
        :param title:			   	The title to set to the rock fluid unit. If empty then
            										"unknown" title will be set.
        :type phase: int
        :param phase:			   	The phase to set to the rock fluid unit.
        :param [in]:		fluidBoundaryTop   	The rock fluid unit top boundary. It cannot be null.
        :param [in]:		fluidBoundaryBottom	The rock fluid unit bottom boundary. It cannot be null.

        :rtype: :py:class:`RockFluidUnitFeature`
        :return: A pointer to the new rock fluid unit.
        """
        return _fesapi.DataObjectRepository_createRockFluidUnit(self, guid, title, phase, fluidBoundaryTop, fluidBoundaryBottom)

    def createGenericFeatureInterpretation(self, feature: "Resqml2_AbstractFeature", guid: "std::string const &", title: "std::string const &") -> "resqml2::GenericFeatureInterpretation *":
        r"""
        Creates a generic feature interpretation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If feature == nullptr.

        :param [in]:	feature	The interpreted feature. It cannot be null.
        :type guid: string
        :param guid:   	The guid to set to the generic feature interpretation. If empty then a
            						new guid will be generated.
        :type title: string
        :param title:  	The title to set to the generic feature interpretation. If empty then
            						"unknown" title will be set.

        :rtype: :py:class:`GenericFeatureInterpretation`
        :return: A pointer to the new generic feature interpretation.
        """
        return _fesapi.DataObjectRepository_createGenericFeatureInterpretation(self, feature, guid, title)

    def createBoundaryFeatureInterpretation(self, feature: "Resqml2_BoundaryFeature", guid: "std::string const &", title: "std::string const &") -> "resqml2::BoundaryFeatureInterpretation *":
        r"""
        Creates a boundary feature interpretation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If ``feature`` is ``nullptr``.

        :param [in]:	feature	The interpreted boundary feature. It cannot be null.
        :type guid: string
        :param guid:   	The guid to set to the boundary feature interpretation. If empty then a
            						new guid will be generated.
        :type title: string
        :param title:  	The title to set to the boundary feature interpretation. If empty then
            						"unknown" title will be set.

        :rtype: :py:class:`BoundaryFeatureInterpretation`
        :return: A pointer to the new boundary feature interpretation.
        """
        return _fesapi.DataObjectRepository_createBoundaryFeatureInterpretation(self, feature, guid, title)

    def createHorizonInterpretation(self, horizon: "Resqml2_BoundaryFeature", guid: "std::string const &", title: "std::string const &") -> "resqml2::HorizonInterpretation *":
        r"""
        Creates a horizon interpretation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If horizon == nullptr.

        :param [in]:	horizon	The interpreted horizon. It cannot be null.
        :type guid: string
        :param guid:   	The guid to set to the horizon interpretation. If empty then a new guid
            						will be generated.
        :type title: string
        :param title:  	The title to set to the horizon interpretation. If empty then "unknown"
            						title will be set.

        :rtype: :py:class:`HorizonInterpretation`
        :return: A pointer to the new horizon interpretation.
        """
        return _fesapi.DataObjectRepository_createHorizonInterpretation(self, horizon, guid, title)

    def createGeobodyBoundaryInterpretation(self, geobodyBoundary: "Resqml2_BoundaryFeature", guid: "std::string const &", title: "std::string const &") -> "resqml2::GeobodyBoundaryInterpretation *":
        r"""
        Creates a geobody boundary interpretation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If geobodyBoundary == nullptr.

        :param [in]:	geobodyBoundary	The interpreted geobody boundary. It cannot be null.
        :type guid: string
        :param guid:		   	The guid to set to the geobody boundary interpretation. If empty
            								then a new guid will be generated.
        :type title: string
        :param title:		   	The title to set to the geobody boundary interpretation. If empty
            								then "unknown" title will be set.

        :rtype: :py:class:`GeobodyBoundaryInterpretation`
        :return: A pointer to the new geobody boundary interpretation.
        """
        return _fesapi.DataObjectRepository_createGeobodyBoundaryInterpretation(self, geobodyBoundary, guid, title)

    def createFaultInterpretation(self, fault: "Resqml2_BoundaryFeature", guid: "std::string const &", title: "std::string const &") -> "resqml2::FaultInterpretation *":
        r"""
        Creates a fault interpretation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If fault == nullptr.

        :param [in]:	fault	The interpreted fault. It cannot be null.
        :type guid: string
        :param guid: 	The guid to set to the fault interpretation. If empty then a new guid
            						will be generated.
        :type title: string
        :param title:	The title to set to the fault interpretation. If empty then "unknown"
            						title will be set.

        :rtype: :py:class:`FaultInterpretation`
        :return: A pointer to the new fault interpretation.
        """
        return _fesapi.DataObjectRepository_createFaultInterpretation(self, fault, guid, title)

    def createFluidBoundaryInterpretation(self, boundary: "Resqml2_BoundaryFeature", guid: "std::string const &", title: "std::string const &", fluidContact: "gsoap_eml2_3::resqml22__FluidContact") -> "resqml2::FluidBoundaryInterpretation *":
        r"""
        Creates a fluid Boundary interpretation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If fault == nullptr.

        :param [in]:	boundary		The interpreted boundary. It cannot be null.
        :type guid: string
        :param guid: 			The guid to set to the interpretation. If empty then a new guid
            								will be generated.
        :type title: string
        :param title:			The title to set to the interpretation. If empty then "unknown"
            								title will be set.
        :type fluidContact: gsoap_eml2_3::resqml22__FluidContact
        :param fluidContact:	The fluid contact this boundary is.

        :rtype: :py:class:`FluidBoundaryInterpretation`
        :return: A pointer to the new interpretation.
        """
        return _fesapi.DataObjectRepository_createFluidBoundaryInterpretation(self, boundary, guid, title, fluidContact)

    def createWellboreInterpretation(self, wellbore: "Resqml2_WellboreFeature", guid: "std::string const &", title: "std::string const &", isDrilled: "bool") -> "resqml2::WellboreInterpretation *":
        r"""
        Creates a wellbore interpretation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If ``wellbore`` is ``nullptr``.

        :param [in]:	wellbore 	The interpreted wellbore feature. It cannot be null.
        :type guid: string
        :param guid:	 	The guid to set to the wellbore interpretation. If empty then a new
            							guid will be generated.
        :type title: string
        :param title:	 	The title to set to the wellbore interpretation. If empty then
            							"unknown" title will be set.
        :type isDrilled: boolean
        :param isDrilled:	Indicate if the wellbore is interpreted wether as drilled (true) or
            									not (false).

        :rtype: :py:class:`WellboreInterpretation`
        :return: A pointer to the new wellbore interpretation.
        """
        return _fesapi.DataObjectRepository_createWellboreInterpretation(self, wellbore, guid, title, isDrilled)

    def createEarthModelInterpretation(self, orgFeat: "Resqml2_Model", guid: "std::string const &", title: "std::string const &") -> "resqml2::EarthModelInterpretation *":
        r"""
        Creates an earth model interpretation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If orgFeat == nullptr.

        :param [in]:	orgFeat	The interpreted organization. It cannot be null.
        :type guid: string
        :param guid:   	The guid to set to the earth model interpretation. If empty then a new
            						guid will be generated.
        :type title: string
        :param title:  	The title to set to the earth model interpretation. If empty then
            						"unknown" title will be set.

        :rtype: :py:class:`EarthModelInterpretation`
        :return: A pointer to the new earth model interpretation.
        """
        return _fesapi.DataObjectRepository_createEarthModelInterpretation(self, orgFeat, guid, title)

    def createStructuralOrganizationInterpretationInAge(self, orgFeat: "Resqml2_Model", guid: "std::string const &", title: "std::string const &") -> "resqml2::StructuralOrganizationInterpretation *":
        r"""
        Creates a structural organization interpretation ordered by age into this repository.

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If orgFeat == nullptr or if in a RESQML v2.0
            										context, ``orgFeat`` is not a structural organization.

        :param [in]:	orgFeat	The interpreted organization. It cannot be null.
        :type guid: string
        :param guid:   	The guid to set to the structural organization interpretation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title:  	The title to set to the structural organization interpretation. If empty
            						then "unknown" title will be set.

        :rtype: :py:class:`StructuralOrganizationInterpretation`
        :return: A pointer to the new structural organization interpretation.
        """
        return _fesapi.DataObjectRepository_createStructuralOrganizationInterpretationInAge(self, orgFeat, guid, title)

    def createStructuralOrganizationInterpretationInApparentDepth(self, orgFeat: "Resqml2_Model", guid: "std::string const &", title: "std::string const &") -> "resqml2::StructuralOrganizationInterpretation *":
        r"""
        Creates a structural organization interpretation ordered by apparent depth into this
        			repository.

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If orgFeat == nullptr or if in a RESQML v2.0
            										context, ``orgFeat`` is not a structural organization.

        :param [in]:	orgFeat	The interpreted organization. It cannot be null.
        :type guid: string
        :param guid:   	The guid to set to the structural organization interpretation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title:  	The title to set to the structural organization interpretation. If empty
            						then "unknown" title will be set.

        :rtype: :py:class:`StructuralOrganizationInterpretation`
        :return: A pointer to the new structural organization interpretation.
        """
        return _fesapi.DataObjectRepository_createStructuralOrganizationInterpretationInApparentDepth(self, orgFeat, guid, title)

    def createStructuralOrganizationInterpretationInMeasuredDepth(self, orgFeat: "Resqml2_Model", guid: "std::string const &", title: "std::string const &") -> "resqml2::StructuralOrganizationInterpretation *":
        r"""
        Creates a structural organization interpretation ordered by measured depth into this
        			repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If orgFeat == nullptr or if in a RESQML v2.0
            										context, ``orgFeat`` is not a structural organization.

        :param [in]:	orgFeat	The interpreted organization. It cannot be null.
        :type guid: string
        :param guid:   	The guid to set to the structural organization interpretation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title:  	The title to set to the structural organization interpretation. If empty
            						then "unknown" title will be set.

        :rtype: :py:class:`StructuralOrganizationInterpretation`
        :return: A pointer to the new structural organization interpretation.
        """
        return _fesapi.DataObjectRepository_createStructuralOrganizationInterpretationInMeasuredDepth(self, orgFeat, guid, title)

    def createRockFluidOrganizationInterpretation(self, orgFeat: "Resqml2_Model", guid: "std::string const &", title: "std::string const &") -> "resqml2::RockFluidOrganizationInterpretation *":
        r"""
        Creates a rock fluid organization interpretation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If orgFeat == nullptr or if in a RESQML v2.0
            										context, ``orgFeat`` is not a fluid organization.

        :param [in]:	orgFeat	The interpreted organization. It cannot be null.
        :type guid: string
        :param guid:   	The guid to set to the rock fluid organization interpretation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title:  	The title to set to the rock fluid organization interpretation. If empty
            						then "unknown" title will be set.

        :rtype: :py:class:`RockFluidOrganizationInterpretation`
        :return: A pointer to the new rock fluid organization interpretation.
        """
        return _fesapi.DataObjectRepository_createRockFluidOrganizationInterpretation(self, orgFeat, guid, title)

    def createRockFluidUnitInterpretation(self, rockFluidUnitFeature: "Resqml2_RockVolumeFeature", guid: "std::string const &", title: "std::string const &") -> "resqml2::RockFluidUnitInterpretation *":
        r"""
        Creates a rock fluid unit interpretation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If feature == nullptr.

        :param [in]:	rockFluidUnitFeature	The interpreted rock fluid unit. It cannot be null.
        :type guid: string
        :param guid:					The guid to set to the rock fluid unit interpretation. If
            										empty then a new guid will be generated.
        :type title: string
        :param title:					The title to set to the rock fluid unit interpretation.
            										If empty then "unknown" title will be set.

        :rtype: :py:class:`RockFluidUnitInterpretation`
        :return: A pointer to the new rock fluid unit interpretation.
        """
        return _fesapi.DataObjectRepository_createRockFluidUnitInterpretation(self, rockFluidUnitFeature, guid, title)

    def createGeobodyInterpretation(self, geobody: "Resqml2_RockVolumeFeature", guid: "std::string const &", title: "std::string const &") -> "resqml2::GeobodyInterpretation *":
        r"""
        Creates a geobody interpretation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If geobody == nullptr or if in a RESQML v2.0
            										context, ``geobody`` is not an actual geobody feature.

        :param [in]:	geobody	The interpreted geobody. It cannot be null.
        :type guid: string
        :param guid:   	The guid to set to the geobody interpretation. If empty then a new guid
            						will be generated.
        :type title: string
        :param title:  	The title to set to the geobody interpretation. If empty then "unknown"
            						title will be set.

        :rtype: :py:class:`GeobodyInterpretation`
        :return: A pointer to the new geobody interpretation.
        """
        return _fesapi.DataObjectRepository_createGeobodyInterpretation(self, geobody, guid, title)

    def createStratigraphicUnitInterpretation(self, stratiUnitFeature: "Resqml2_RockVolumeFeature", guid: "std::string const &", title: "std::string const &") -> "resqml2::StratigraphicUnitInterpretation *":
        r"""
        Creates a stratigraphic unit interpretation into this repository.

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If stratiUnitFeature == nullptr.

        :param [in]:	stratiUnitFeature	The interpreted stratigraphic unit. It cannot be null.
        :type guid: string
        :param guid:			 	The guid to set to the stratigraphic unit interpretation. If
            									empty then a new guid will be generated.
        :type title: string
        :param title:			 	The title to set to the stratigraphic unit interpretation. If
            									empty then "unknown" title will be set.

        :rtype: :py:class:`StratigraphicUnitInterpretation`
        :return: A pointer to the new stratigraphic unit interpretation.
        """
        return _fesapi.DataObjectRepository_createStratigraphicUnitInterpretation(self, stratiUnitFeature, guid, title)

    def createStratigraphicColumn(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::StratigraphicColumn *":
        r"""
        Creates stratigraphic column into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the stratigraphic column. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the stratigraphic column. If empty then "unknown" title
            					will be set.

        :rtype: :py:class:`StratigraphicColumn`
        :return: A pointer to the new stratigraphic column.
        """
        return _fesapi.DataObjectRepository_createStratigraphicColumn(self, guid, title)

    def createStratigraphicColumnRankInterpretationInAge(self, orgFeat: "Resqml2_Model", guid: "std::string const &", title: "std::string const &", rank: "uint64_t") -> "resqml2::StratigraphicColumnRankInterpretation *":
        r"""
        Creates a stratigraphic column rank interpretation ordered by age into this
        			repository.

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If orgFeat == nullptr or if in a RESQML v2.0
            										context, ``orgFeat`` is not a stratigraphic organization.

        :param [in]:	orgFeat	The interpreted organization. It cannot be null.
        :type guid: string
        :param guid:   	The guid to set to the stratigraphic column rank interpretation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title:  	The title to set to the stratigraphic column rank interpretation. If
            						empty then "unknown" title will be set.
        :type rank: int
        :param rank:   	The rank of the stratigraphic column rank interpretation.

        :rtype: :py:class:`StratigraphicColumnRankInterpretation`
        :return: A pointer to the new stratigraphic column rank interpretation.
        """
        return _fesapi.DataObjectRepository_createStratigraphicColumnRankInterpretationInAge(self, orgFeat, guid, title, rank)

    def createStratigraphicColumnRankInterpretationInApparentDepth(self, orgFeat: "Resqml2_Model", guid: "std::string const &", title: "std::string const &", rank: "uint64_t") -> "resqml2::StratigraphicColumnRankInterpretation *":
        r"""
        Creates a stratigraphic column rank interpretation ordered by apparent depth into
        			this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If orgFeat == nullptr or if in a RESQML v2.0
            										context, ``orgFeat`` is not a stratigraphic organization.

        :param [in]:	orgFeat	The interpreted organization. It cannot be null.
        :type guid: string
        :param guid:   	The guid to set to the stratigraphic column rank interpretation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title:  	The title to set to the stratigraphic column rank interpretation. If
            						empty then "unknown" title will be set.
        :type rank: int
        :param rank:   	The rank of the stratigraphic column rank interpretation.

        :rtype: :py:class:`StratigraphicColumnRankInterpretation`
        :return: A pointer to the new stratigraphic column rank interpretation.
        """
        return _fesapi.DataObjectRepository_createStratigraphicColumnRankInterpretationInApparentDepth(self, orgFeat, guid, title, rank)

    def createStratigraphicOccurrenceInterpretationInAge(self, orgFeat: "Resqml2_Model", guid: "std::string const &", title: "std::string const &") -> "resqml2::StratigraphicOccurrenceInterpretation *":
        r"""
        Creates a stratigraphic occurrence interpretation ordered by age into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If orgFeat == nullptr or if in a RESQML v2.0
            										context, ``orgFeat`` is not a stratigraphic organization.

        :param [in]:	orgFeat	The interpreted organization. It cannot be null.
        :type guid: string
        :param guid:   	The guid to set to the stratigraphic occurrence interpretation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title:  	The title to set to the stratigraphic occurrence interpretation. If empty
            						then "unknown" title will be set.

        :rtype: :py:class:`StratigraphicOccurrenceInterpretation`
        :return: A pointer to the new stratigraphic occurrence interpretation.
        """
        return _fesapi.DataObjectRepository_createStratigraphicOccurrenceInterpretationInAge(self, orgFeat, guid, title)

    def createStratigraphicOccurrenceInterpretationInApparentDepth(self, orgFeat: "Resqml2_Model", guid: "std::string const &", title: "std::string const &") -> "resqml2::StratigraphicOccurrenceInterpretation *":
        r"""
        Creates a stratigraphic occurrence interpretation ordered by apparent depth into this
        			repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If orgFeat == nullptr or if in a RESQML v2.0
            										context, ``orgFeat`` is not a stratigraphic organization.

        :param [in]:	orgFeat	The interpreted organization. It cannot be null.
        :type guid: string
        :param guid:   	The guid to set to the stratigraphic occurrence interpretation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title:  	The title to set to the stratigraphic occurrence interpretation. If empty
            						then "unknown" title will be set.

        :rtype: :py:class:`StratigraphicOccurrenceInterpretation`
        :return: A pointer to the new stratigraphic occurrence interpretation.
        """
        return _fesapi.DataObjectRepository_createStratigraphicOccurrenceInterpretationInApparentDepth(self, orgFeat, guid, title)

    def createTriangulatedSetRepresentation(self, *args) -> "resqml2::TriangulatedSetRepresentation *":
        r"""
        *Overload 1:*

        Creates a triangulated set representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the triangulated set representation. If empty then a new
            					guid will be generated.
        :type title: string
        :param title:	The title to set to the triangulated set representation. If empty then
            					"unknown" title will be set.

        :rtype: :py:class:`TriangulatedSetRepresentation`
        :return: A pointer to the new triangulated set representation.

        |

        *Overload 2:*

        Creates a triangulated set representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null. You can alternatively
            						use {createTriangulatedSetRepresentation} if no interpretation is
            						associated to this representation.
        :type guid: string
        :param guid:  	The guid to set to the triangulated set representation. If empty then a
            						new guid will be generated.
        :type title: string
        :param title: 	The title to set to the triangulated set representation. If empty then
            						"unknown" title will be set.

        :rtype: :py:class:`TriangulatedSetRepresentation`
        :return: A pointer to the new triangulated set representation.
        """
        return _fesapi.DataObjectRepository_createTriangulatedSetRepresentation(self, *args)

    def createPolylineSetRepresentation(self, *args) -> "resqml2::PolylineSetRepresentation *":
        r"""
        *Overload 1:*

        Creates a polyline set representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the polyline set representation. If empty then a new guid
            					will be generated.
        :type title: string
        :param title:	The title to set to the polyline set representation. If empty then
            					"unknown" title will be set.

        :rtype: :py:class:`PolylineSetRepresentation`
        :return: A pointer to the new polyline set representation.

        |

        *Overload 2:*

        Creates a polyline set representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null. You can alternatively
            						use {createPolylineSetRepresentation} if no interpretation is
            						associated to this representation.
        :type guid: string
        :param guid:  	The guid to set to the polyline set representation. If empty then a new
            						guid will be generated.
        :type title: string
        :param title: 	The title to set to the polyline set representation. If empty then
            						"unknown" title will be set.

        :rtype: :py:class:`PolylineSetRepresentation`
        :return: A pointer to the new polyline set representation.

        |

        *Overload 3:*

        Creates a polyline set representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.
        :raises: std::invalid_argument	If in a RESQML v2.0 context, ``roleKind`` is a break line
            										role.

        :param [in]:	interp  	The represented interpretation. It cannot be null. You can
            							alternatively use {createPolylineSetRepresentation} if no
            							interpretation is associated to this representation.
        :type guid: string
        :param guid:		The guid to set to the polyline set representation. If empty then a
            							new guid will be generated.
        :type title: string
        :param title:   	The title to set to the polyline set representation. If empty then
            							"unknown" title will be set.
        :type roleKind: int
        :param roleKind:	The polyline set role kind.

        :rtype: :py:class:`PolylineSetRepresentation`
        :return: A pointer to the new polyline set representation.
        """
        return _fesapi.DataObjectRepository_createPolylineSetRepresentation(self, *args)

    def createPointSetRepresentation(self, *args) -> "resqml2::PointSetRepresentation *":
        r"""
        *Overload 1:*

        Creates a point set representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the point set representation. If empty then a new guid
            					will be generated.
        :type title: string
        :param title:	The title to set to the point set representation. If empty then "unknown"
            					title will be set.

        :rtype: :py:class:`PointSetRepresentation`
        :return: A pointer to the new point set representation.

        |

        *Overload 2:*

        Creates a point set representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the point set representation. If empty then a new guid
            						will be generated.
        :type title: string
        :param title: 	The title to set to the point set representation. If empty then
            						"unknown" title will be set.

        :rtype: :py:class:`PointSetRepresentation`
        :return: A pointer to the new point set representation.
        """
        return _fesapi.DataObjectRepository_createPointSetRepresentation(self, *args)

    def createPlaneSetRepresentation(self, interp: "AbstractFeatureInterpretation", guid: "std::string const &", title: "std::string const &") -> "resqml2::PlaneSetRepresentation *":
        r"""
        Creates a plane set representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the plane set representation. If empty then a new guid
            						will be generated.
        :type title: string
        :param title: 	The title to set to the plane set representation. If empty then
            						"unknown" title will be set.

        :rtype: :py:class:`PlaneSetRepresentation`
        :return: A pointer to the new plane set representation.
        """
        return _fesapi.DataObjectRepository_createPlaneSetRepresentation(self, interp, guid, title)

    def createPolylineRepresentation(self, *args) -> "resqml2::PolylineRepresentation *":
        r"""
        *Overload 1:*

        Creates a polyline representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:		The guid to set to the polyline representation. If empty then a new guid
            						will be generated.
        :type title: string
        :param title:   	The title to set to the polyline representation. If empty then
            						"unknown" title will be set.
        :type isClosed: boolean, optional
        :param isClosed:	(Optional) True if the polyline is closed, false (default) if it is not.

        :rtype: :py:class:`PolylineRepresentation`
        :return: A pointer to the new polyline representation.

        |

        *Overload 2:*

        Creates a polyline representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp  	The represented interpretation. It cannot be null. You can
            							alternatively use {createPolylineRepresentation} if no
            							interpretation is associated to this representation.
        :type guid: string
        :param guid:		The guid to set to the polyline representation. If empty then a new
            							guid will be generated.
        :type title: string
        :param title:   	The title to set to the polyline representation. If empty then
            							"unknown" title will be set.
        :type isClosed: boolean, optional
        :param isClosed:	(Optional) True if the polyline is closed, false (default) if it is
            							not.

        :rtype: :py:class:`PolylineRepresentation`
        :return: A pointer to the new polyline representation.

        |

        *Overload 3:*

        Creates a polyline representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp  	The represented interpretation. It cannot be null. You can
            							alternatively use {createPolylineRepresentation} if no
            							interpretation is associated to this representation.
        :type guid: string
        :param guid:		The guid to set to the polyline representation. If empty then a new
            							guid will be generated.
        :type title: string
        :param title:   	The title to set to the polyline representation. If empty then
            							"unknown" title will be set.
        :param isClosed:	(Optional) True if the polyline is closed, false (default) if it is
            							not.

        :rtype: :py:class:`PolylineRepresentation`
        :return: A pointer to the new polyline representation.

        |

        *Overload 4:*

        Creates a polyline representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp  	The represented interpretation. It cannot be null. You can
            									alternatively use {createPolylineRepresentation} if no
            									interpretation is associated to this representation.
        :type guid: string
        :param guid:		The guid to set to the polyline representation. If empty then a new
            							guid will be generated.
        :type title: string
        :param title:   	The title to set to the polyline representation. If empty then
            							"unknown" title will be set.
        :type roleKind: int
        :param roleKind:	The polyline role kind.
        :type isClosed: boolean, optional
        :param isClosed:	(Optional) True if the polyline is closed, false (default) if it is
            							not.

        :rtype: :py:class:`PolylineRepresentation`
        :return: A pointer to the new polyline representation.

        |

        *Overload 5:*

        Creates a polyline representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp  	The represented interpretation. It cannot be null. You can
            									alternatively use {createPolylineRepresentation} if no
            									interpretation is associated to this representation.
        :type guid: string
        :param guid:		The guid to set to the polyline representation. If empty then a new
            							guid will be generated.
        :type title: string
        :param title:   	The title to set to the polyline representation. If empty then
            							"unknown" title will be set.
        :type roleKind: int
        :param roleKind:	The polyline role kind.
        :param isClosed:	(Optional) True if the polyline is closed, false (default) if it is
            							not.

        :rtype: :py:class:`PolylineRepresentation`
        :return: A pointer to the new polyline representation.
        """
        return _fesapi.DataObjectRepository_createPolylineRepresentation(self, *args)

    def createGrid2dRepresentation(self, interp: "AbstractFeatureInterpretation", guid: "std::string const &", title: "std::string const &") -> "resqml2::Grid2dRepresentation *":
        r"""
        Creates a 2d grid representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the 2d grid representation. If empty then a new guid
            						will be generated.
        :type title: string
        :param title: 	The title to set to the 2d grid representation. If empty then "unknown"
            						title will be set.

        :rtype: :py:class:`Grid2dRepresentation`
        :return: A pointer to the new 2d grid representation.
        """
        return _fesapi.DataObjectRepository_createGrid2dRepresentation(self, interp, guid, title)

    def createWellboreTrajectoryRepresentation(self, *args) -> "resqml2_0_1::WellboreTrajectoryRepresentation *":
        r"""
        *Overload 1:*

        Creates a wellbore trajectory representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If ``interp`` or ``mdInfo`` is ``nullptr``.

        :param [in]:	interp		The represented wellbore interpretation. It cannot be null.
        :type guid: string
        :param guid:  		The guid to set to the wellbore trajectory representation. If empty then
            							a new guid will be generated.
        :type title: string
        :param title: 		The title to set to the wellbore trajectory representation. If empty then
            							"unknown" title will be set.
        :param [in]:	mdDatum		The MD datum of the trajectory, mainly the well reference point. It cannot be null.

        :rtype: :py:class:`WellboreTrajectoryRepresentation`
        :return: A pointer to the new wellbore trajectory representation.

        |

        *Overload 2:*

        Creates a wellbore trajectory representation (with an existing deviation survey as its
        origin) into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If ``interp`` or ``deviationSurvey`` is ``nullptr``.

        :param [in]:	interp		   	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:		   	The guid to set to the wellbore trajectory representation. If
            								empty then a new guid will be generated.
        :type title: string
        :param title:		   	The title to set to the wellbore trajectory representation. If
            								empty then "unknown" title will be set.
        :param [in]:	deviationSurvey	The deviation survey on which this wellbore trajectory relies on.
            								MD data will be retrieve from it. It cannot be null.

        :rtype: :py:class:`WellboreTrajectoryRepresentation`
        :return: A pointer to the new wellbore trajectory representation.
        """
        return _fesapi.DataObjectRepository_createWellboreTrajectoryRepresentation(self, *args)

    def createDeviationSurveyRepresentation(self, interp: "Resqml2_WellboreInterpretation", guid: "std::string const &", title: "std::string const &", isFinal: "bool", mdInfo: "Resqml2_MdDatum") -> "resqml2_0_1::DeviationSurveyRepresentation *":
        r"""
        Creates a deviation survey representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr or mdInfo ==
            												nullptr.

        :param [in]:	interp 		The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:   		The guid to set to the deviation survey representation. If empty then a
            							new guid will be generated.
        :type title: string
        :param title:  		The title to set to the deviation survey representation. If empty then
            							"unknown" title will be set.
        :type isFinal: boolean
        :param isFinal:		Used to indicate that this is a final version of the deviation survey
            							(true), as distinct from the interim interpretations (false).
        :param [in]:	refPoint 	The reference point which acts as a datum for this deviation survey representation.
            							It canot be null.

        :rtype: :py:class:`DeviationSurveyRepresentation`
        :return: A pointer to the new deviation survey representation.
        """
        return _fesapi.DataObjectRepository_createDeviationSurveyRepresentation(self, interp, guid, title, isFinal, mdInfo)

    def createWellboreFrameRepresentation(self, interp: "Resqml2_WellboreInterpretation", guid: "std::string const &", title: "std::string const &", traj: "Resqml2_WellboreTrajectoryRepresentation") -> "resqml2::WellboreFrameRepresentation *":
        r"""
        Creates a wellbore frame representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If ``interp`` or ``traj`` is ``nullptr``.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the wellbore frame representation. If empty then a new
            						guid will be generated.
        :type title: string
        :param title: 	The title to set to the wellbore frame representation. If empty then
            						"unknown" title will be set.
        :param [in]:	traj  	The wellbore trajectory that refers this wellbore frame. It cannot be
            						null.

        :rtype: :py:class:`WellboreFrameRepresentation`
        :return: A pointer to the new wellbore frame representation.
        """
        return _fesapi.DataObjectRepository_createWellboreFrameRepresentation(self, interp, guid, title, traj)

    def createWellboreMarkerFrameRepresentation(self, interp: "Resqml2_WellboreInterpretation", guid: "std::string const &", title: "std::string const &", traj: "Resqml2_WellboreTrajectoryRepresentation") -> "resqml2::WellboreMarkerFrameRepresentation *":
        r"""
        Creates a wellbore marker frame representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If ``interp`` of ``traj`` is ``nullptr``.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the wellbore marker frame representation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title: 	The title to set to the wellbore marker frame representation. If empty
            						then "unknown" title will be set.
        :param [in]:	traj  	The wellbore trajectory that refers this wellbore marker frame. It cannot
            						be null.

        :rtype: :py:class:`WellboreMarkerFrameRepresentation`
        :return: A pointer to the new wellbore marker frame representation.
        """
        return _fesapi.DataObjectRepository_createWellboreMarkerFrameRepresentation(self, interp, guid, title, traj)

    def createBlockedWellboreRepresentation(self, interp: "Resqml2_WellboreInterpretation", guid: "std::string const &", title: "std::string const &", traj: "Resqml2_WellboreTrajectoryRepresentation") -> "resqml2::BlockedWellboreRepresentation *":
        r"""
        Creates a blocked wellbore representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If traj == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the blocked wellbore representation. If empty then a
            						new guid will be generated.
        :type title: string
        :param title: 	The title to set to the blocked wellbore representation. If empty then
            						"unknown" title will be set.
        :param [in]:	traj  	The wellbore trajectory that refers this blocked wellbore representation.
            						It cannot be null.

        :rtype: :py:class:`BlockedWellboreRepresentation`
        :return: A pointer to the new blocked wellbore representation.
        """
        return _fesapi.DataObjectRepository_createBlockedWellboreRepresentation(self, interp, guid, title, traj)

    def createRepresentationSetRepresentation(self, *args) -> "resqml2::RepresentationSetRepresentation *":
        r"""
        *Overload 1:*

        Creates a representation set representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null. You can alternatively
            						use {createRepresentationSetRepresentation} if no interpretation
            						is associated to this representation.
        :type guid: string
        :param guid:  	The guid to set to the representation set representation. If empty then a
            						new guid will be generated.
        :type title: string
        :param title: 	The title to set to the representation set representation. If empty then
            						"unknown" title will be set.

        :rtype: :py:class:`RepresentationSetRepresentation`
        :return: A pointer to the new representation set representation.

        |

        *Overload 2:*

        Creates a representation set representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the representation set representation. If empty then a new
            					guid will be generated.
        :type title: string
        :param title:	The title to set to the representation set representation. If empty then
            					"unknown" title will be set.

        :rtype: :py:class:`RepresentationSetRepresentation`
        :return: A pointer to the new representation set representation.
        """
        return _fesapi.DataObjectRepository_createRepresentationSetRepresentation(self, *args)

    def createNonSealedSurfaceFrameworkRepresentation(self, interp: "Resqml2_StructuralOrganizationInterpretation", guid: "std::string const &", title: "std::string const &") -> "resqml2::NonSealedSurfaceFrameworkRepresentation *":
        r"""
        Creates a non sealed surface framework representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the non sealed surface framework representation. If
            						empty then a new guid will be generated.
        :type title: string
        :param title: 	The title to set to the non sealed surface framework representation. If
            						empty then "unknown" title will be set.

        :rtype: :py:class:`NonSealedSurfaceFrameworkRepresentation`
        :return: A pointer to the new non sealed surface framework representation.
        """
        return _fesapi.DataObjectRepository_createNonSealedSurfaceFrameworkRepresentation(self, interp, guid, title)

    def createSealedSurfaceFrameworkRepresentation(self, interp: "Resqml2_StructuralOrganizationInterpretation", guid: "std::string const &", title: "std::string const &") -> "resqml2::SealedSurfaceFrameworkRepresentation *":
        r"""
        Creates a sealed surface framework representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the sealed surface framework representation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title: 	The title to set to the sealed surface framework representation. If empty
            						then "unknown" title will be set.

        :rtype: :py:class:`SealedSurfaceFrameworkRepresentation`
        :return: A pointer to the new sealed surface framework representation.
        """
        return _fesapi.DataObjectRepository_createSealedSurfaceFrameworkRepresentation(self, interp, guid, title)

    def createSealedVolumeFrameworkRepresentation(self, interp: "Resqml2_StratigraphicColumnRankInterpretation", guid: "std::string const &", title: "std::string const &", ssf: "Resqml2_SealedSurfaceFrameworkRepresentation") -> "resqml2::SealedVolumeFrameworkRepresentation *":
        r"""
        Creates a sealed volume framework representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr or ssf == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the sealed volume framework representation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title: 	The title to set to the sealed volume framework representation. If empty
            						then "unknown" title will be set.
        :param [in]:	ssf   	The sealed surface framework that refers this sealed volume framework. It
            						cannot be null.

        :rtype: :py:class:`SealedVolumeFrameworkRepresentation`
        :return: A pointer to the new sealed volume framework representation.
        """
        return _fesapi.DataObjectRepository_createSealedVolumeFrameworkRepresentation(self, interp, guid, title, ssf)

    def createPartialIjkGridRepresentation(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::AbstractIjkGridRepresentation *":
        r"""
        Creates a partial ijk grid representation into this repository

        :type guid: string
        :param guid: 	The guid to set to the sealed volume framework representation. If empty
            					then a new guid will be generated.
        :type title: string
        :param title:	The title to set to the sealed volume framework representation.

        :rtype: :py:class:`AbstractIjkGridRepresentation`
        :return: A pointer to the new partial ijk grid representation.
        """
        return _fesapi.DataObjectRepository_createPartialIjkGridRepresentation(self, guid, title)

    def createPartialTruncatedIjkGridRepresentation(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::AbstractIjkGridRepresentation *":
        r"""
        Creates a partial truncated ijk grid representation into this repository

        :type guid: string
        :param guid: 	The guid to set to the sealed volume framework representation.
        :type title: string
        :param title:	The title to set to the sealed volume framework representation.

        :rtype: :py:class:`AbstractIjkGridRepresentation`
        :return: A pointer to the new partial truncated ijk grid representation.
        """
        return _fesapi.DataObjectRepository_createPartialTruncatedIjkGridRepresentation(self, guid, title)

    def createIjkGridExplicitRepresentation(self, *args) -> "resqml2::IjkGridExplicitRepresentation *":
        r"""
        *Overload 1:*

        Creates an ijk grid explicit representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:  	The guid to set to the ijk grid explicit representation. If empty then a new
            						guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid explicit representation. If empty then
            						"unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.
        :type kGaps: boolean, optional
        :param kGaps:	(Optional) Boolean array of length KCellCount-1.
            						TRUE if there is a gap after the corresponding layer.
            						Won't be freed by FESAPI.
        :param [in]:	proxy	(Optional) The HDF proxy for writing the ``enabledCells``
            						values. If ``nullptr`` (default), then the default HDF proxy will be
            						used.

        :rtype: :py:class:`IjkGridExplicitRepresentation`
        :return: A pointer to the new ijk grid explicit representation.

        |

        *Overload 2:*

        Creates an ijk grid explicit representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the ijk grid explicit representation. If empty then a
            						new guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid explicit representation. If empty then
            						"unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.
        :type kGaps: boolean, optional
        :param kGaps:	(Optional) Boolean array of length KCellCount-1.
            						TRUE if there is a gap after the corresponding layer.
            						Won't be freed by FESAPI.
        :param [in]:	proxy	(Optional) The HDF proxy for writing the ``enabledCells``
            						values. If ``nullptr`` (default), then the default HDF proxy will be
            						used.

        :rtype: :py:class:`IjkGridExplicitRepresentation`
        :return: A pointer to the new ijk grid explicit representation.

        |

        *Overload 3:*

        Creates an ijk grid explicit representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the ijk grid explicit representation. If empty then a
            						new guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid explicit representation. If empty then
            						"unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.
        :type kGaps: boolean, optional
        :param kGaps:	(Optional) Boolean array of length KCellCount-1.
            						TRUE if there is a gap after the corresponding layer.
            						Won't be freed by FESAPI.
        :param [in]:	proxy	(Optional) The HDF proxy for writing the ``enabledCells``
            						values. If ``nullptr`` (default), then the default HDF proxy will be
            						used.

        :rtype: :py:class:`IjkGridExplicitRepresentation`
        :return: A pointer to the new ijk grid explicit representation.

        |

        *Overload 4:*

        Creates an ijk grid explicit representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the ijk grid explicit representation. If empty then a
            						new guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid explicit representation. If empty then
            						"unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.
        :param kGaps:	(Optional) Boolean array of length KCellCount-1.
            						TRUE if there is a gap after the corresponding layer.
            						Won't be freed by FESAPI.
        :param [in]:	proxy	(Optional) The HDF proxy for writing the ``enabledCells``
            						values. If ``nullptr`` (default), then the default HDF proxy will be
            						used.

        :rtype: :py:class:`IjkGridExplicitRepresentation`
        :return: A pointer to the new ijk grid explicit representation.
        """
        return _fesapi.DataObjectRepository_createIjkGridExplicitRepresentation(self, *args)

    def createIjkGridParametricRepresentation(self, *args) -> "resqml2::IjkGridParametricRepresentation *":
        r"""
        *Overload 1:*

        Creates an ijk grid parametric representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:  	The guid to set to the ijk grid parametric representation. If empty then a
            						new guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid parametric representation. If empty then
            						"unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.
        :type kGaps: boolean, optional
        :param kGaps:	(Optional) Boolean array of length KCellCount-1.
            						TRUE if there is a gap after the corresponding layer.
            						Won't be freed by FESAPI.
        :param [in]:	proxy	(Optional) The HDF proxy for writing the ``enabledCells``
            						values. If ``nullptr`` (default), then the default HDF proxy will be
            						used.

        :rtype: :py:class:`IjkGridParametricRepresentation`
        :return: A pointer to the new ijk grid parametric representation.

        |

        *Overload 2:*

        Creates an ijk grid parametric representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the ijk grid parametric representation. If empty then
            						a new guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid parametric representation. If empty then
            						"unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.
        :type kGaps: boolean, optional
        :param kGaps:	(Optional) Boolean array of length KCellCount-1.
            						TRUE if there is a gap after the corresponding layer.
            						Won't be freed by FESAPI.
        :param [in]:	proxy	(Optional) The HDF proxy for writing the ``enabledCells``
            						values. If ``nullptr`` (default), then the default HDF proxy will be
            						used.

        :rtype: :py:class:`IjkGridParametricRepresentation`
        :return: A pointer to the new ijk grid parametric representation.

        |

        *Overload 3:*

        Creates an ijk grid parametric representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the ijk grid parametric representation. If empty then
            						a new guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid parametric representation. If empty then
            						"unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.
        :type kGaps: boolean, optional
        :param kGaps:	(Optional) Boolean array of length KCellCount-1.
            						TRUE if there is a gap after the corresponding layer.
            						Won't be freed by FESAPI.
        :param [in]:	proxy	(Optional) The HDF proxy for writing the ``enabledCells``
            						values. If ``nullptr`` (default), then the default HDF proxy will be
            						used.

        :rtype: :py:class:`IjkGridParametricRepresentation`
        :return: A pointer to the new ijk grid parametric representation.

        |

        *Overload 4:*

        Creates an ijk grid parametric representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the ijk grid parametric representation. If empty then
            						a new guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid parametric representation. If empty then
            						"unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.
        :param kGaps:	(Optional) Boolean array of length KCellCount-1.
            						TRUE if there is a gap after the corresponding layer.
            						Won't be freed by FESAPI.
        :param [in]:	proxy	(Optional) The HDF proxy for writing the ``enabledCells``
            						values. If ``nullptr`` (default), then the default HDF proxy will be
            						used.

        :rtype: :py:class:`IjkGridParametricRepresentation`
        :return: A pointer to the new ijk grid parametric representation.
        """
        return _fesapi.DataObjectRepository_createIjkGridParametricRepresentation(self, *args)

    def createIjkGridLatticeRepresentation(self, *args) -> "resqml2::IjkGridLatticeRepresentation *":
        r"""
        *Overload 1:*

        Creates an ijk grid lattice representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:  	The guid to set to the ijk grid lattice representation. If empty then a new
            					guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid lattice representation. If empty then
            					"unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.

        :rtype: :py:class:`IjkGridLatticeRepresentation`
        :return: A pointer to the new ijk grid lattice representation.

        |

        *Overload 2:*

        Creates an ijk grid lattice representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the ijk grid lattice representation. If empty then a
            						new guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid lattice representation. If empty then
            						"unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.

        :rtype: :py:class:`IjkGridLatticeRepresentation`
        :return: A pointer to the new ijk grid lattice representation.
        """
        return _fesapi.DataObjectRepository_createIjkGridLatticeRepresentation(self, *args)

    def createIjkGridNoGeometryRepresentation(self, *args) -> "resqml2::IjkGridNoGeometryRepresentation *":
        r"""
        *Overload 1:*

        Creates an ijk grid with no geometry representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:  	The guid to set to the ijk grid with no geometry representation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid with no geometry representation. If empty
            						then "unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.
        :type kGaps: boolean, optional
        :param kGaps:	(Optional) Boolean array of length KCellCount-1.
            						TRUE if there is a gap after the corresponding layer.
            						Won't be freed by FESAPI.
        :param [in]:	proxy	(Optional) The HDF proxy for writing the ``enabledCells``
            						values. If ``nullptr`` (default), then the default HDF proxy will be
            						used.

        :rtype: :py:class:`IjkGridNoGeometryRepresentation`
        :return: A pointer to the new ijk grid with no geometry representation.

        |

        *Overload 2:*

        Creates an ijk grid with no geometry representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the ijk grid with no geometry representation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid with no geometry representation. If
            						empty then "unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.
        :type kGaps: boolean, optional
        :param kGaps:	(Optional) Boolean array of length KCellCount-1.
            						TRUE if there is a gap after the corresponding layer.
            						Won't be freed by FESAPI.
        :param [in]:	proxy	(Optional) The HDF proxy for writing the ``enabledCells``
            						values. If ``nullptr`` (default), then the default HDF proxy will be
            						used.

        :rtype: :py:class:`IjkGridNoGeometryRepresentation`
        :return: A pointer to the new ijk grid with no geometry representation.

        |

        *Overload 3:*

        Creates an ijk grid with no geometry representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the ijk grid with no geometry representation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid with no geometry representation. If
            						empty then "unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.
        :type kGaps: boolean, optional
        :param kGaps:	(Optional) Boolean array of length KCellCount-1.
            						TRUE if there is a gap after the corresponding layer.
            						Won't be freed by FESAPI.
        :param [in]:	proxy	(Optional) The HDF proxy for writing the ``enabledCells``
            						values. If ``nullptr`` (default), then the default HDF proxy will be
            						used.

        :rtype: :py:class:`IjkGridNoGeometryRepresentation`
        :return: A pointer to the new ijk grid with no geometry representation.

        |

        *Overload 4:*

        Creates an ijk grid with no geometry representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:  	The guid to set to the ijk grid with no geometry representation. If empty
            						then a new guid will be generated.
        :type title: string
        :param title: 	The title to set to the ijk grid with no geometry representation. If
            						empty then "unknown" title will be set.
        :type iCount: int
        :param iCount:	Count of cells in the I direction in the grid.
        :type jCount: int
        :param jCount:	Count of cells in the J direction in the grid.
        :type kCount: int
        :param kCount:	Number of layers in the grid.
        :param kGaps:	(Optional) Boolean array of length KCellCount-1.
            						TRUE if there is a gap after the corresponding layer.
            						Won't be freed by FESAPI.
        :param [in]:	proxy	(Optional) The HDF proxy for writing the ``enabledCells``
            						values. If ``nullptr`` (default), then the default HDF proxy will be
            						used.

        :rtype: :py:class:`IjkGridNoGeometryRepresentation`
        :return: A pointer to the new ijk grid with no geometry representation.
        """
        return _fesapi.DataObjectRepository_createIjkGridNoGeometryRepresentation(self, *args)

    def createUnstructuredGridRepresentation(self, *args) -> "resqml2::UnstructuredGridRepresentation *":
        r"""
        *Overload 1:*

        Creates an unstructured grid representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:	 	The guid to set to the unstructured grid representation. If empty then a
            						new guid will be generated.
        :type title: string
        :param title:	 	The title to set to the unstructured grid representation. If empty then
            						"unknown" title will be set.
        :type cellCount: int
        :param cellCount:	Number of cells in the grid.

        :rtype: :py:class:`UnstructuredGridRepresentation`
        :return: A pointer to the new unstructured grid representation.

        |

        *Overload 2:*

        Creates an unstructured grid representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :param [in]:	interp	The represented interpretation. It cannot be null.
        :type guid: string
        :param guid:	 	The guid to set to the unstructured grid representation. If empty then a
            						new guid will be generated.
        :type title: string
        :param title:	 	The title to set to the unstructured grid representation. If empty then
            						"unknown" title will be set.
        :type cellCount: int
        :param cellCount:	Number of cells in the grid.

        :rtype: :py:class:`UnstructuredGridRepresentation`
        :return: A pointer to the new unstructured grid representation.
        """
        return _fesapi.DataObjectRepository_createUnstructuredGridRepresentation(self, *args)

    def createSubRepresentation(self, *args) -> "resqml2::SubRepresentation *":
        r"""
        *Overload 1:*

        Creates a sub-representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the sub-representation. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the sub-representation. If empty then "unknown" title
            					will be set.

        :rtype: :py:class:`SubRepresentation`
        :return: A pointer to the new sub-representation.

        |

        *Overload 2:*

        Creates a sub-representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null. You can alternatively
            						use {createSubRepresentation} if no interpretation is associated
            						to this representation.
        :type guid: string
        :param guid:  	The guid to set to the sub-representation. If empty then a new guid will
            						be generated.
        :type title: string
        :param title: 	The title to set to the sub-representation. If empty then "unknown"
            						title will be set.

        :rtype: :py:class:`SubRepresentation`
        :return: A pointer to the new sub-representation.
        """
        return _fesapi.DataObjectRepository_createSubRepresentation(self, *args)

    def createGridConnectionSetRepresentation(self, *args) -> "resqml2::GridConnectionSetRepresentation *":
        r"""
        *Overload 1:*

        Creates a grid connection set representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the grid connection set representation. If empty then a
            					new guid will be generated.
        :type title: string
        :param title:	The title to set to the grid connection set representation. If empty then
            					"unknown" title will be set.

        :rtype: :py:class:`GridConnectionSetRepresentation`
        :return: A pointer to the new grid connection set representation.

        |

        *Overload 2:*

        Creates a grid connection set representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If interp == nullptr.

        :param [in]:	interp	The represented interpretation. It cannot be null. You can alternatively
            						use {createGridConnectionSetRepresentation} if no interpretation
            						is associated to this representation.
        :type guid: string
        :param guid:  	The guid to set to the grid connection set representation. If empty then
            						a new guid will be generated.
        :type title: string
        :param title: 	The title to set to the grid connection set representation. If empty then
            						"unknown" title will be set.

        :rtype: :py:class:`GridConnectionSetRepresentation`
        :return: A pointer to the new grid connection set representation.
        """
        return _fesapi.DataObjectRepository_createGridConnectionSetRepresentation(self, *args)

    def createStreamlinesFeature(self, guid: "std::string const &", title: "std::string const &", timeIndex: "uint64_t", timeSeries: "TimeSeries") -> "resqml2::StreamlinesFeature *":
        r"""
        Creates a streamlines feature into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 		The guid to set to the streamlines feature. If empty then a new guid will be
            						generated.
        :type title: string
        :param title:		The title to set to the streamlines feature. If empty then "unknown" title
            						will be set.
        :type timeIndex: int
        :param timeIndex:	The time index in the time series of the this streamlines feature.
        :type timeSeries: :py:class:`TimeSeries`
        :param timeSeries:	The time series where the time index of this streamlines feature is given.

        :rtype: :py:class:`StreamlinesFeature`
        :return: A pointer to the new wellbore feature.
        """
        return _fesapi.DataObjectRepository_createStreamlinesFeature(self, guid, title, timeIndex, timeSeries)

    def createStreamlinesRepresentation(self, interp: "Resqml2_GenericFeatureInterpretation", guid: "std::string const &", title: "std::string const &", lineCount: "uint64_t") -> "resqml2::StreamlinesRepresentation *":
        r"""
        Creates a streamlines representation into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :param [in]:	interp		The represented interpretation. It cannot be null.
        :param [in]:	guid 		The guid to set to the streamlines representation. If empty then a new guid will be
            							generated.
        :param [in]:	title		The title to set to the streamlines representation. If empty then "unknown" title
            							will be set.
        :param [in]:	lineCount	The count of line in this representation

        :rtype: :py:class:`StreamlinesRepresentation`
        :return: A pointer to the new wellbore feature.
        """
        return _fesapi.DataObjectRepository_createStreamlinesRepresentation(self, interp, guid, title, lineCount)

    def createTimeSeries(self, guid: "std::string const &", title: "std::string const &") -> "eml2::TimeSeries *":
        r"""
        Creates a time series into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the time series. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the time series. If empty then "unknown" title will be
            					set.

        :rtype: :py:class:`TimeSeries`
        :return: A pointer to the new time series.
        """
        return _fesapi.DataObjectRepository_createTimeSeries(self, guid, title)

    def createDoubleTableLookup(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::DoubleTableLookup *":
        r"""
        Creates a double table lookup into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the double table lookup. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the double table lookup. If empty then "unknown" title
            					will be set.

        :rtype: :py:class:`DoubleTableLookup`
        :return: A pointer to the new double table lookup.
        """
        return _fesapi.DataObjectRepository_createDoubleTableLookup(self, guid, title)

    def createStringTableLookup(self, guid: "std::string const &", title: "std::string const &") -> "resqml2::StringTableLookup *":
        r"""
        Creates a string table lookup into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the string table lookup. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the string table lookup. If empty then "unknown" title
            					will be set.

        :rtype: :py:class:`StringTableLookup`
        :return: A pointer to the new string table lookup.
        """
        return _fesapi.DataObjectRepository_createStringTableLookup(self, guid, title)

    def createPropertyKind(self, *args) -> "eml2::PropertyKind *":
        r"""
        *Overload 1:*

        Creates a property kind into this repository

        :type guid: string
        :param guid:						 	The guid to set to the property kind. If empty then a
            											new guid will be generated.
        :type title: string
        :param title:						 	The title to set to the property kind. If empty then
            											"unknown" title will be set.
        :type namingSystem: string
        :param namingSystem:				 	The name of the dictionary within which the property
            											is unique. This also defines the name of the
            											controlling authority. Use a URN of the form urn:x-
            											resqml:domainOrEmail:dictionaryName.
        :type uom: int
        :param uom:							 	The property kind unit of measure taken from the
            											standard RESQML units of measure catalog.
        :type isAbstract: boolean
        :param isAbstract:						Indicates whether the property kind should be used
            											as a real (default) property or not.
        :type parentEnergisticsPropertyKind: int
        :param parentEnergisticsPropertyKind:	The parent property kind taken from the standard set
            											of RESQML property kinds.

        :rtype: :py:class:`PropertyKind`
        :return: A pointer to the new property kind.

        |

        *Overload 2:*

        Creates a property kind into this repository

        :raises: std::invalid_argument	If parentPropType == nullptr.

        :type guid: string
        :param guid:		  	The guid to set to the property kind. If empty then a new guid
            								will be generated.
        :type title: string
        :param title:		  	The title to set to the property kind. If empty then "unknown"
            								title will be set.
        :type namingSystem: string
        :param namingSystem:  	The name of the dictionary within which the property is unique.
            								This also defines the name of the controlling authority. Use a
            								URN of the form "urn:x- resqml:domainOrEmail:dictionaryName".
        :type uom: int
        :param uom:			  	The property kind unit of measure taken from the standard RESQML
            								units of measure catalog.
        :type isAbstract: boolean
        :param isAbstract:		Indicates whether the property kind should be used
            								as a real (default) property or not.
        :param [in]:	parentPropType	The parent property kind. It cannot be null.

        :rtype: :py:class:`PropertyKind`
        :return: A pointer to the new property kind.

        |

        *Overload 3:*

        Creates a property kind into this repository.

        :type guid: string
        :param guid:						 	The guid to set to the property kind. If empty then a
            											new guid will be generated.
        :type title: string
        :param title:						 	The title to set to the property kind. If empty then
            											"unknown" title will be set.
        :type namingSystem: string
        :param namingSystem:				 	The name of the dictionary within which the property
            											is unique. This also defines the name of the
            											controlling authority. Use a URN of the form "urn:x-
            											resqml:domainOrEmail:dictionaryName".
        :type nonStandardUom: string
        :param nonStandardUom:				 	The property kind unit of measure.
        :type isAbstract: boolean
        :param isAbstract:						Indicates whether the property kind should be used
            											as a real (default) property or not.
        :type parentEnergisticsPropertyKind: int
        :param parentEnergisticsPropertyKind:	The parent property kind taken from the standard set
            											of RESQML property kinds.

        :rtype: :py:class:`PropertyKind`
        :return: A pointer to the new property kind.

        |

        *Overload 4:*

        Creates a property kind into this repository

        :type guid: string
        :param guid:		  	The guid to set to the property kind. If empty then a new guid
            								will be generated.
        :type title: string
        :param title:		  	The title to set to the property kind. If empty then "unknown"
            								title will be set.
        :type namingSystem: string
        :param namingSystem:  	The name of the dictionary within which the property is unique.
            								This also defines the name of the controlling authority. Use a
            								URN of the form "urn:x- resqml:domainOrEmail:dictionaryName".
        :type nonStandardUom: string
        :param nonStandardUom:	The property kind unit of measure.
        :type isAbstract: boolean
        :param isAbstract:		Indicates whether the property kind should be used
            								as a real (default) property or not.
        :param [in]:	parentPropType	The parent property kind. It cannot be null.

        :rtype: :py:class:`PropertyKind`
        :return: A pointer to the new property kind.

        |

        *Overload 5:*

        Creates a property kind starting with EML2.1 version into this repository.
        			Don't use it at all if you want a full RESQML2.0.1 EPC!!! Use other same name methods instead please.

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:			  	The guid to set to the property kind. If empty then a new
            									guid will be generated.
        :type title: string
        :param title:			  	The title to set to the property kind. If empty then
            									"unknown" title will be set.
        :type quantityClass: int
        :param quantityClass:	  	A reference to the name of a quantity class in the
            									Energistics units of measure dictionary.
        :type isAbstract: boolean, optional
        :param isAbstract:		  	(Optional) Indicates whether the property kind should be used
            									as a real (default) property or not. False by default.
        :param [in]:	parentPropertyKind	(Optional) If non-null, the parent property kind. If null, a
            									default partial parent property kind will be created.

        :rtype: :py:class:`PropertyKind`
        :return: A pointer to the new property kind.

        |

        *Overload 6:*

        Creates a property kind starting with EML2.1 version into this repository.
        			Don't use it at all if you want a full RESQML2.0.1 EPC!!! Use other same name methods instead please.

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:			  	The guid to set to the property kind. If empty then a new
            									guid will be generated.
        :type title: string
        :param title:			  	The title to set to the property kind. If empty then
            									"unknown" title will be set.
        :type quantityClass: int
        :param quantityClass:	  	A reference to the name of a quantity class in the
            									Energistics units of measure dictionary.
        :type isAbstract: boolean, optional
        :param isAbstract:		  	(Optional) Indicates whether the property kind should be used
            									as a real (default) property or not. False by default.
        :param [in]:	parentPropertyKind	(Optional) If non-null, the parent property kind. If null, a
            									default partial parent property kind will be created.

        :rtype: :py:class:`PropertyKind`
        :return: A pointer to the new property kind.

        |

        *Overload 7:*

        Creates a property kind starting with EML2.1 version into this repository.
        			Don't use it at all if you want a full RESQML2.0.1 EPC!!! Use other same name methods instead please.

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:			  	The guid to set to the property kind. If empty then a new
            									guid will be generated.
        :type title: string
        :param title:			  	The title to set to the property kind. If empty then
            									"unknown" title will be set.
        :type quantityClass: int
        :param quantityClass:	  	A reference to the name of a quantity class in the
            									Energistics units of measure dictionary.
        :param isAbstract:		  	(Optional) Indicates whether the property kind should be used
            									as a real (default) property or not. False by default.
        :param [in]:	parentPropertyKind	(Optional) If non-null, the parent property kind. If null, a
            									default partial parent property kind will be created.

        :rtype: :py:class:`PropertyKind`
        :return: A pointer to the new property kind.

        |

        *Overload 8:*

        Creates a property kind starting with EML2.1 version into this repository.
        			Don't use it at all if you want a full RESQML2.0.1 EPC!!! Use other same name methods instead please.

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:			  	The guid to set to the property kind. If empty then a new
            									guid will be generated.
        :type title: string
        :param title:			  	The title to set to the property kind. If empty then
            									"unknown" title will be set.
        :type quantityClass: string
        :param quantityClass:	  	A reference to the name of a quantity class in the
            									Energistics units of measure dictionary or in another dictionary.
        :type isAbstract: boolean, optional
        :param isAbstract:		  	(Optional) Indicates whether the property kind should be used
            									as a real (default) property or not. False by default.
        :param [in]:	parentPropertyKind	(Optional) If non-null, the parent property kind. If null, a
            									default partial parent property kind will be created.

        :rtype: :py:class:`PropertyKind`
        :return: A pointer to the new property kind.

        |

        *Overload 9:*

        Creates a property kind starting with EML2.1 version into this repository.
        			Don't use it at all if you want a full RESQML2.0.1 EPC!!! Use other same name methods instead please.

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:			  	The guid to set to the property kind. If empty then a new
            									guid will be generated.
        :type title: string
        :param title:			  	The title to set to the property kind. If empty then
            									"unknown" title will be set.
        :type quantityClass: string
        :param quantityClass:	  	A reference to the name of a quantity class in the
            									Energistics units of measure dictionary or in another dictionary.
        :type isAbstract: boolean, optional
        :param isAbstract:		  	(Optional) Indicates whether the property kind should be used
            									as a real (default) property or not. False by default.
        :param [in]:	parentPropertyKind	(Optional) If non-null, the parent property kind. If null, a
            									default partial parent property kind will be created.

        :rtype: :py:class:`PropertyKind`
        :return: A pointer to the new property kind.

        |

        *Overload 10:*

        Creates a property kind starting with EML2.1 version into this repository.
        			Don't use it at all if you want a full RESQML2.0.1 EPC!!! Use other same name methods instead please.

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.

        :type guid: string
        :param guid:			  	The guid to set to the property kind. If empty then a new
            									guid will be generated.
        :type title: string
        :param title:			  	The title to set to the property kind. If empty then
            									"unknown" title will be set.
        :type quantityClass: string
        :param quantityClass:	  	A reference to the name of a quantity class in the
            									Energistics units of measure dictionary or in another dictionary.
        :param isAbstract:		  	(Optional) Indicates whether the property kind should be used
            									as a real (default) property or not. False by default.
        :param [in]:	parentPropertyKind	(Optional) If non-null, the parent property kind. If null, a
            									default partial parent property kind will be created.

        :rtype: :py:class:`PropertyKind`
        :return: A pointer to the new property kind.
        """
        return _fesapi.DataObjectRepository_createPropertyKind(self, *args)

    def createPropertySet(self, guid: "std::string const &", title: "std::string const &", hasMultipleRealizations: "bool", hasSinglePropertyKind: "bool", timeSetKind: "gsoap_resqml2_0_1::resqml20__TimeSetKind") -> "resqml2_0_1::PropertySet *":
        r"""
        Creates a property set into this repository.

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If, in a RESQML v2.0 context, ``timeSetKind`` is single
            										time series.

        :type guid: string
        :param guid:				   	The guid to set to the property set. If empty then a new guid
            									will be generated.
        :type title: string
        :param title:				   	The title to set to the property set. If empty then
            									"unknown" title will be set.
        :type hasMultipleRealizations: boolean
        :param hasMultipleRealizations:	True if the set contains properties with defined realization
            									indices, false if not.
        :type hasSinglePropertyKind: boolean
        :param hasSinglePropertyKind:  	True if the set contains only property values associated with
            									a single property kind, false if not.
        :type timeSetKind: int
        :param timeSetKind:			   	The time relationship that share the properties of this set,
            									if any.

        :rtype: :py:class:`PropertySet`
        :return: A pointer to the new property set.
        """
        return _fesapi.DataObjectRepository_createPropertySet(self, guid, title, hasMultipleRealizations, hasSinglePropertyKind, timeSetKind)

    def createCommentProperty(self, *args) -> "resqml2::CommentProperty *":
        r"""
        *Overload 1:*

        Creates a comment property (which is of a well known Energistics property kind) into this
        repository.

        :raises: std::invalid_argument	If ``rep`` is null.

        :param [in]:	rep					   	The representation on which this property is attached to.
            										It cannot be null.
        :type guid: string
        :param guid:				   	The guid to set to the property. If empty then a new guid
            										will be generated.
        :type title: string
        :param title:				   	The title to set to the property. If empty then
            										"unknown" title will be set.
        :type attachmentKind: int
        :param attachmentKind:		   	The topological element on which the property values are
            										attached to.
        :type energisticsPropertyKind: int
        :param energisticsPropertyKind:	The property kind of these property values which must be
            										defined in the standard Energistics property type
            										dictionary.

        :rtype: :py:class:`CommentProperty`
        :return: A pointer to the new comment property.

        |

        *Overload 2:*

        Creates a comment property (which is of a local property kind) into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If ``rep`` or ``localPropKind`` is null.

        :param [in]:	rep			  	The representation on which this property is attached to. It
            								cannot be null.
        :type guid: string
        :param guid:		  	The guid to set to the property. If empty then a new guid will be
            								generated.
        :type title: string
        :param title:		  	The title to set to the property. If empty then "unknown" title
            								will be set.
        :type attachmentKind: int
        :param attachmentKind:	The topological element on which the property values are attached
            								to.
        :param [in]:	localPropType 	The property kind of these property values which must be defined
            								in the EPC document as a local property kind. It cannot be null.

        :rtype: :py:class:`CommentProperty`
        :return: A pointer to the new comment property.
        """
        return _fesapi.DataObjectRepository_createCommentProperty(self, *args)

    def createContinuousProperty(self, *args) -> "resqml2::ContinuousProperty *":
        r"""
        *Overload 1:*

        Creates a continuous property (which is of well known Energistics unit of measure and
        property kind) into this repository

        :raises: std::invalid_argument	If ``rep`` is null.

        :param [in]:	rep					   	The representation on which this property is attached to.
            										It cannot be null.
        :type guid: string
        :param guid:				   	The guid to set to the property. If empty then a new guid
            										will be generated.
        :type title: string
        :param title:				   	The title to set to the property. If empty then
            										"unknown" title will be set.
        :type attachmentKind: int
        :param attachmentKind:		   	The topological element on which the property values are
            										attached to.
        :type uom: int
        :param uom:					   	The property unit of measure taken from the standard
            										Energistics units of measure catalog. Please check
            										COMMON_NS::EnumStringMapper::getEnergisticsUnitOfMeasure
            										in order to minimize the use of non standard unit of
            										measure.
        :type energisticsPropertyKind: int
        :param energisticsPropertyKind:	The property kind of these property values which must be
            										defined in the standard Energistics property type
            										dictionary.
        :param dimensions:			   	The dimensions of each value of this property. If this parameter
            										is empty, then it is assumed this property is a scalar one.

        :rtype: :py:class:`ContinuousProperty`
        :return: A pointer to the new continuous property.

        |

        *Overload 2:*

        Creates a continuous property (which is of a well known unit of measure and a local property
        kind) into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If ``rep`` or ``localPropType`` is null.

        :param [in]:	rep			  	The representation on which this property is attached to. It
            								cannot be null.
        :type guid: string
        :param guid:		  	The guid to set to the property. If empty then a new guid will be
            								generated.
        :type title: string
        :param title:		  	The title to set to the property. If empty then "unknown" title
            								will be set.
        :type attachmentKind: int
        :param attachmentKind:	The topological element on which the property values are attached
            								to.
        :type uom: int
        :param uom:			  	The property unit of measure taken from the standard Energistics
            								units of measure catalog. Please check
            								COMMON_NS::EnumStringMapper::getEnergisticsUnitOfMeasure in order
            								to minimize the use of non standard unit of measure.
        :param [in]:	localPropType 	The property kind of these property values which must be defined
            								in the EPC document as a local property kind. It cannot be null.
        :param dimensions:	   	The dimensions of each value of this property. If this parameter
            								is empty, then it is assumed this property is a scalar one.

        :rtype: :py:class:`ContinuousProperty`
        :return: A pointer to the new continuous property.

        |

        *Overload 3:*

        Creates a continuous property (which is of a local unit of measure and a well known property
        kind) into this repository

        :raises: std::invalid_argument	If ``rep`` is null.

        :param [in]:	rep					   	The representation on which this property is attached to.
            										It cannot be null.
        :type guid: string
        :param guid:				   	The guid to set to the property. If empty then a new guid
            										will be generated.
        :type title: string
        :param title:				   	The title to set to the property. If empty then
            										"unknown" title will be set.


        :type attachmentKind: int
        :param attachmentKind:		   	The topological element on which the property values are
            										attached to.
        :type nonStandardUom: string
        :param nonStandardUom:		   	The property unit of measure. Please check
            										COMMON_NS::EnumStringMapper::getEnergisticsUnitOfMeasure
            										in order to minimize the use of non standard unit of
            										measure.
        :type energisticsPropertyKind: int
        :param energisticsPropertyKind:	The property kind of these property values which must be
            										defined in the standard Energistics property type
            										dictionary.
        :param dimensions:	   			The dimensions of each value of this property. If this parameter
            										is empty, then it is assumed this property is a scalar one.

        :rtype: :py:class:`ContinuousProperty`
        :return: A pointer to the new continuous property.

        |

        *Overload 4:*

        Creates a continuous property (which is of local unit of measure and property kind) into this
        repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If ``rep`` or ``localPropType`` is null.

        :param [in]:	rep			  	The representation on which this property is attached to. It
            								cannot be null.
        :type guid: string
        :param guid:		  	The guid to set to the property. If empty then a new guid will be
            								generated.
        :type title: string
        :param title:		  	The title to set to the property. If empty then "unknown" title
            								will be set.
        :type attachmentKind: int
        :param attachmentKind:	The topological element on which the property values are attached
            								to.
        :type nonStandardUom: string
        :param nonStandardUom:	The property unit of measure. Please check
            								COMMON_NS::EnumStringMapper::getEnergisticsUnitOfMeasure in order
            								to minimize the use of non standard unit of measure.
        :param [in]:	localPropType 	The property kind of these property values which must be defined
            								in the EPC document as a local property kind. It cannot be null.
        :param dimensions:	   			The dimensions of each value of this property. If this parameter
            										is empty, then it is assumed this property is a scalar one.

        :rtype: :py:class:`ContinuousProperty`
        :return: A pointer to the new continuous property.
        """
        return _fesapi.DataObjectRepository_createContinuousProperty(self, *args)

    def createDiscreteProperty(self, *args) -> "resqml2::DiscreteProperty *":
        r"""
        *Overload 1:*

        Creates a discrete property (which is of a well known Energistics property kind) into this
        repository

        :raises: std::invalid_argument	If ``rep`` is null.

        :param [in]:	rep					   	The representation on which this property is attached to.
            										It cannot be null.
        :type guid: string
        :param guid:				   	The guid to set to the property. If empty then a new guid
            										will be generated.
        :type title: string
        :param title:				   	The title to set to the property. If empty then
            										"unknown" title will be set.


        :type attachmentKind: int
        :param attachmentKind:		   	The topological element on which the property values are
            										attached to.


        :type energisticsPropertyKind: int
        :param energisticsPropertyKind:	The property kind of these property values which must be
            										defined in the standard Energistics property type
            										dictionary.
        :param dimensions:	   			The dimensions of each value of this property. If this parameter
            										is empty, then it is assumed this property is a scalar one.

        :rtype: :py:class:`DiscreteProperty`
        :return: A pointer to the new discrete property.

        |

        *Overload 2:*

        Creates a discrete property (which is of a local property kind) into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If ``or`` ``localPropKind`` is null.

        :param [in]:	rep			  	The representation on which this property is attached to. It
            								cannot be null.
        :type guid: string
        :param guid:		  	The guid to set to the property. If empty then a new guid will be
            								generated.
        :type title: string
        :param title:		  	The title to set to the property. If empty then "unknown" title
            								will be set.
        :type attachmentKind: int
        :param attachmentKind:	The topological element on which the property values are attached
            								to.
        :param [in]:	localPropType 	The property kind of these property values which must be defined
            								in the EPC document as a local property kind. It cannot be null.
        :param dimensions:	   	The dimensions of each value of this property. If this parameter
            								is empty, then it is assumed this property is a scalar one.

        :rtype: :py:class:`DiscreteProperty`
        :return: A pointer to the new discrete property.
        """
        return _fesapi.DataObjectRepository_createDiscreteProperty(self, *args)

    def createCategoricalProperty(self, *args) -> "resqml2::CategoricalProperty *":
        r"""
        *Overload 1:*

        Creates a categorical property (which is of a standard Energistics property kind) into this
        repository

        :raises: std::invalid_argument	If ``rep`` or ``strLookup`` is null.

        :param [in]:	rep					   	The representation on which this property is attached to.
            										It cannot be null.
        :type guid: string
        :param guid:				   	The guid to set to the property. If empty then a new guid
            										will be generated.
        :type title: string
        :param title:				   	The title to set to the property. If empty then
            										"unknown" title will be set.
        :type dimension: int
        :param dimension:			   	The dimension of each value of this property. Dimension
            										is 1 for a scalar property.
        :type attachmentKind: int
        :param attachmentKind:		   	The topological element on which the property values are
            										attached to.
        :param [in]:	strLookup			   	The string lookup which defines the possible string
            										values and their keys.
        :type energisticsPropertyKind: int
        :param energisticsPropertyKind:	The property kind of these property values which must be
            										defined in the standard Energistics property type
            										dictionary.

        :rtype: :py:class:`CategoricalProperty`
        :return: A pointer to new categorical property.

        |

        *Overload 2:*

        Creates a categorical property (which is of a standard Energistics property kind) into this
        repository

        :raises: std::invalid_argument	If ``rep`` or ``strLookup`` is null.

        :param [in]:	rep					   	The representation on which this property is attached to.
            										It cannot be null.
        :type guid: string
        :param guid:				   	The guid to set to the property. If empty then a new guid
            										will be generated.
        :type title: string
        :param title:				   	The title to set to the property. If empty then
            										"unknown" title will be set.
        :type dimension: int
        :param dimension:			   	The dimension of each value of this property. Dimension
            										is 1 for a scalar property.
        :type attachmentKind: int
        :param attachmentKind:		   	The topological element on which the property values are
            										attached to.
        :param [in]:	dblLookup			   	The double lookup which defines a discrete function associated with the property values.
        :type energisticsPropertyKind: int
        :param energisticsPropertyKind:	The property kind of these property values which must be
            										defined in the standard Energistics property type
            										dictionary.

        :rtype: :py:class:`CategoricalProperty`
        :return: A pointer to new categorical property.

        |

        *Overload 3:*

        Creates a categorical property (which is of a local property kind) into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If ``rep``, ``strLookup`` or ``localPropKind`` is null.

        :param [in]:	rep			  	The representation on which this property is attached to. It
            								cannot be null.
        :type guid: string
        :param guid:		  	The guid to set to the property. If empty then a new guid will be
            								generated.
        :type title: string
        :param title:		  	The title to set to the property. If empty then "unknown" title
            								will be set.
        :type dimension: int
        :param dimension:	  	The dimension of each value of this property. Dimension is 1 for
            								a scalar property.
        :type attachmentKind: int
        :param attachmentKind:	The topological element on which the property values are attached
            								to.
        :param [in]:	strLookup	  	The string lookup which defines the possible string values and
            								their keys. It cannot be null.
        :param [in]:	localPropType 	The property kind of these property values which must be defined
            								in the EPC document as a local property kind. It cannot be null.

        :rtype: :py:class:`CategoricalProperty`
        :return: A pointer to the new categorical property.

        |

        *Overload 4:*

        Creates a categorical property (which is of a local property kind) into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If ``rep``, ``strLookup`` or ``localPropKind`` is null.

        :param [in]:	rep			  	The representation on which this property is attached to. It
            								cannot be null.
        :type guid: string
        :param guid:		  	The guid to set to the property. If empty then a new guid will be
            								generated.
        :type title: string
        :param title:		  	The title to set to the property. If empty then "unknown" title
            								will be set.
        :type dimension: int
        :param dimension:	  	The dimension of each value of this property. Dimension is 1 for
            								a scalar property.
        :type attachmentKind: int
        :param attachmentKind:	The topological element on which the property values are attached
            								to.
        :param [in]:	dblLookup		The double lookup which defines a discrete function associated with the property values.
        :param [in]:	localPropType 	The property kind of these property values which must be defined
            								in the EPC document as a local property kind. It cannot be null.

        :rtype: :py:class:`CategoricalProperty`
        :return: A pointer to the new categorical property.
        """
        return _fesapi.DataObjectRepository_createCategoricalProperty(self, *args)

    def createPointsProperty(self, *args) -> "resqml2::PointsProperty *":
        r"""
        *Overload 1:*

        Creates a points property (which is of a well known Energistics property kind) into this
        repository

        :raises: std::invalid_argument	If ``rep`` is null.

        :param [in]:	rep					   	The representation on which this property is attached to.
            										It cannot be null.
        :type guid: string
        :param guid:				   	The guid to set to the property. If empty then a new guid
            										will be generated.
        :type title: string
        :param title:				   	The title to set to the property. If empty then
            										"unknown" title will be set.
        :type dimension: int
        :param dimension:			   	The dimension of each value of this property. Dimension
            										is 1 for a scalar property.
        :type attachmentKind: int
        :param attachmentKind:		   	The topological element on which the property values are
            										attached to.
        :type energisticsPropertyKind: int, optional
        :param energisticsPropertyKind:	The property kind of these property values which must be
            										defined in the standard Energistics property type
            										dictionary. Defautl is length

        :rtype: :py:class:`PointsProperty`
        :return: A pointer to the new points property.

        |

        *Overload 2:*

        Creates a points property (which is of a local property kind) into this repository

        :raises: std::invalid_argument	If the default RESQML version is unrecognized.
        :raises: std::invalid_argument	If ``or`` ``localPropKind`` is null.

        :param [in]:	rep			  	The representation on which this property is attached to. It
            								cannot be null.
        :type guid: string
        :param guid:		  	The guid to set to the property. If empty then a new guid will be
            								generated.
        :type title: string
        :param title:		  	The title to set to the property. If empty then "unknown" title
            								will be set.
        :type dimension: int
        :param dimension:	  	The dimension of each value of this property. Dimension is 1 for
            								a scalar property.
        :type attachmentKind: int
        :param attachmentKind:	The topological element on which the property values are attached
            								to.
        :param [in]:	localPropType 	The property kind of these property values which must be defined
            								in the EPC document as a local property kind. It cannot be null.

        :rtype: :py:class:`PointsProperty`
        :return: A pointer to the new points property.
        """
        return _fesapi.DataObjectRepository_createPointsProperty(self, *args)

    def createActivityTemplate(self, guid: "std::string const &", title: "std::string const &") -> "eml2::ActivityTemplate *":
        r"""
        Creates an activity template into this repository

        :raises: std::invalid_argument	If the default EML version is unrecognized.

        :type guid: string
        :param guid: 	The guid to set to the activity template. If empty then a new guid will be
            					generated.
        :type title: string
        :param title:	The title to set to the activity template. If empty then "unknown" title
            					will be set.

        :rtype: :py:class:`ActivityTemplate`
        :return: A pointer to the new activity template.
        """
        return _fesapi.DataObjectRepository_createActivityTemplate(self, guid, title)

    def createActivity(self, activityTemplate: "ActivityTemplate", guid: "std::string const &", title: "std::string const &") -> "eml2::Activity *":
        r"""
        Creates an activity into this repository

        :raises: std::invalid_argument	If the default EML version is unrecognized.
        :raises: std::invalid_argument	If activityTemplate == nullptr.

        :param [in]:	activityTemplate	The activity template on which this activity is based on.
        :type guid: string
        :param guid:				The guid to set to the activity. If empty then a new guid
            									will be generated.
        :type title: string
        :param title:				The title to set to the activity. If empty then "unknown"
            									title will be set.

        :rtype: :py:class:`Activity`
        :return: A pointer to the new activity.
        """
        return _fesapi.DataObjectRepository_createActivity(self, activityTemplate, guid, title)

    def createWell(self, *args) -> "witsml2::Well *":
        r"""
        *Overload 1:*

        Creates a well into this repository

        :type guid: string
        :param guid: 	The guid to set to the well. If empty then a new guid will be generated.
        :type title: string
        :param title:	The title to set to the well. If empty then "unknown" title will be set.
        :type isActive: boolean
        :param isActive:	True if is active, false if not.

        :rtype: :py:class:`Well`
        :return: A pointer to the new well.

        |

        *Overload 2:*

        Creates a well into this repository

        :type guid: string
        :param guid:		 	The guid to set to the well. If empty then a new guid will be
            							generated.
        :type title: string
        :param title:		 	The title to set to the well. If empty then "unknown" title will be
            							set.
        :type isActive: boolean
        :param isActive:		True if is active, false if not.
        :type statusWell: int
        :param statusWell:   	POSC well status.
        :type directionWell: int
        :param directionWell:	POSC well direction. The direction of the flow of the fluids in a
            							well facility (generally, injected or produced, or some combination).

        :rtype: :py:class:`Well`
        :return: A pointer to the new well.
        """
        return _fesapi.DataObjectRepository_createWell(self, *args)

    def createWellbore(self, *args) -> "witsml2::Wellbore *":
        r"""
        *Overload 1:*

        Creates a wellbore into this repository.

        :raises: std::invalid_argument	If witsmlWell == nullptr.

        :param [in]:	witsmlWell	The well associated to this wellbore. It cannot be null.
        :type guid: string
        :param guid:	  	The guid to set to the wellbore. If empty then a new guid will be
            							generated.
        :type title: string
        :param title:	  	The title to set to the wellbore. If empty then "unknown" title
            							will be set.
        :type isActive: boolean
        :param isActive:	  	True if is active, false if not.

        :rtype: :py:class:`Wellbore`
        :return: A pointer to the new wellbore.

        |

        *Overload 2:*

        Creates a wellbore into this repository.

        :raises: std::invalid_argument	If witsmlWell == nullptr.

        :param [in]:	witsmlWell	  	The well associated to this wellbore. It cannot be null.
        :type guid: string
        :param guid:		  	The guid to set to the wellbore. If empty then a new guid will be
            								generated.
        :type title: string
        :param title:		  	The title to set to the wellbore. If empty then "unknown" title
            								will be set.
        :type statusWellbore: int
        :param statusWellbore:	POSC wellbore status.
        :type isActive: boolean
        :param isActive:	  	True if is active, false if not.
        :type achievedTD: boolean
        :param achievedTD:	  	True indicates that the wellbore has achieved total depth. That
            								is, drilling has completed. False indicates otherwise.

        :rtype: :py:class:`Wellbore`
        :return: A pointer to the new wellbore.
        """
        return _fesapi.DataObjectRepository_createWellbore(self, *args)

    def createWellCompletion(self, witsmlWell: "Witsml2_Well", guid: "std::string const &", title: "std::string const &") -> "witsml2_1::WellCompletion *":
        r"""
        Creates a well completion into this repository

        :raises: std::invalid_argument	If witsmlWell == nullptr.

        :param [in]:	witsmlWell	The well associated to this well completion. It cannot be null.
        :type guid: string
        :param guid:	  	The guid to set to the well completion. If empty then a new guid will
            							be generated.
        :type title: string
        :param title:	  	The title to set to the well completion. If empty then "unknown"
            							title will be set.

        :rtype: :py:class:`WellCompletion`
        :return: A pointer to the new well completion.
        """
        return _fesapi.DataObjectRepository_createWellCompletion(self, witsmlWell, guid, title)

    def createWellboreCompletion(self, witsmlWellbore: "Witsml2_Wellbore", guid: "std::string const &", title: "std::string const &") -> "witsml2_1::WellboreCompletion *":
        r"""
        Creates a wellbore completion into this repository

        :param [in]:	witsmlWellbore	  	The wellbore associated to this wellbore completion. It
            									cannot be null.
        :type guid: string
        :param guid:			  	The guid to set to the wellbore completion. If empty then a new guid will be
            									generated.
        :type title: string
        :param title:			  	The title to set to the wellbore completion. If empty then "unknown" title
            									will be set.

        :rtype: :py:class:`WellboreCompletion`
        :return: A pointer to the new wellbore completion.
        """
        return _fesapi.DataObjectRepository_createWellboreCompletion(self, witsmlWellbore, guid, title)

    def createWellboreGeometry(self, witsmlWellbore: "Witsml2_Wellbore", guid: "std::string const &", title: "std::string const &", isActive: "bool") -> "witsml2_1::WellboreGeometry *":
        r"""
        Creates a wellbore geometry into this repository. It is used to capture information
        			about the configuration of the permanently installed components in a wellbore

        :raises: std::invalid_argument	If witsmlWellbore == nullptr.

        :param [in]:	witsmlWellbore	The wellbore associated to this wellbore geometry. It cannot be
            								null.
        :type guid: string
        :param guid:		  	The guid to set to the geometry. If empty then a new guid will be
            								generated.
        :type title: string
        :param title:		  	The title to set to the geometry. If empty then "unknown" title
            								will be set.
        :type isActive: boolean
        :param isActive:	  	True if is active, false if not.

        :rtype: :py:class:`WellboreGeometry`
        :return: A pointer to the new wellbore geometry.
        """
        return _fesapi.DataObjectRepository_createWellboreGeometry(self, witsmlWellbore, guid, title, isActive)

    def createTrajectory(self, witsmlWellbore: "Witsml2_Wellbore", guid: "std::string const &", title: "std::string const &", isActive: "bool") -> "witsml2_1::Trajectory *":
        r"""
        Creates a wellbore trajectory into this repository

        :raises: std::invalid_argument	If witsmlWellbore == nullptr.

        :param [in]:	witsmlWellbore	The wellbore associated to this wellbore trajectory. It cannot be
            								null.
        :type guid: string
        :param guid:		  	The guid to set to the trajectory. If empty then a new guid will
            								be generated.
        :type title: string
        :param title:		  	The title to set to the trajectory. If empty then "unknown"
            								title will be set.
        :type isActive: boolean
        :param isActive:	  	True if is active, false if not.

        :rtype: :py:class:`Trajectory`
        :return: A pointer to the new trajectory.
        """
        return _fesapi.DataObjectRepository_createTrajectory(self, witsmlWellbore, guid, title, isActive)

    def createLog(self, witsmlWellbore: "Witsml2_Wellbore", guid: "std::string const &", title: "std::string const &", isActive: "bool") -> "witsml2_1::Log *":
        r"""
        Creates a wellbore log into this repository

        :raises: std::invalid_argument	If witsmlWellbore == nullptr.

        :param [in]:	witsmlWellbore	The wellbore associated to this log. It cannot be null.
        :type guid: string
        :param guid:			The guid to set to the log. If empty then a new guid will be
            								generated.
        :type title: string
        :param title:			The title to set to the log. If empty then "unknown" title will
            								be set.
        :type isActive: boolean
        :param isActive:		True if is active, false if not.

        :rtype: :py:class:`Log`
        :return: A pointer to the new log.
        """
        return _fesapi.DataObjectRepository_createLog(self, witsmlWellbore, guid, title, isActive)

    def createChannelSet(self, guid: "std::string const &", title: "std::string const &", isActive: "bool") -> "witsml2_1::ChannelSet *":
        r"""
        Creates a channel set into this repository

        :type guid: string
        :param guid: 	The guid to set to the channel set. If empty then a new guid will be generated.
        :type title: string
        :param title:	The title to set to the channel set. If empty then "unknown" title will be set.
        :type isActive: boolean
        :param isActive:	True if is active, false if not.

        :rtype: :py:class:`ChannelSet`
        :return: A pointer to the new channel set.
        """
        return _fesapi.DataObjectRepository_createChannelSet(self, guid, title, isActive)

    def createChannel(self, propertyKind: "PropertyKind", guid: "std::string const &", title: "std::string const &", mnemonic: "std::string const &", uom: "gsoap_eml2_3::eml23__UnitOfMeasure", dataKind: "gsoap_eml2_3::witsml21__ChannelDataKind", isActive: "bool") -> "witsml2_1::Channel *":
        r"""
        Creates a channel into this repository

        :raises: std::invalid_argument	If propertyKind == nullptr.

        :param [in]:	propertyKind	  	The property kind associated to this channel. It cannot be
            									null.
        :type guid: string
        :param guid:			  	The guid to set to the channel. If empty then a new guid will
            									be generated.
        :type title: string
        :param title:			  	The title to set to the channel. If empty then "unknown"
            									title will be set.
        :type mnemonic: string
        :param mnemonic:		  	The mnemonic name to set to this channel.
        :type uom: int
        :param uom:				  	The underlying unit of measure of the value.
        :type dataKind: int
        :param dataKind:		  	The underlying data kind of the value.
        :type isActive: boolean
        :param isActive:	  	True if is active, false if not.

        :rtype: :py:class:`Channel`
        :return: A pointer to the new channel.
        """
        return _fesapi.DataObjectRepository_createChannel(self, propertyKind, guid, title, mnemonic, uom, dataKind, isActive)

    def createWellboreMarker(self, *args) -> "witsml2_1::WellboreMarker *":
        r"""
        *Overload 1:*

        Creates a wellbore marker within a given wellbore marker frame representation.

        :raises: std::invalid_argument	If wellboreMarkerFrame == nullptr.

        :param [in]:	wellboreMarkerFrame	The wellbore marker frame representation where to push back
            									the wellbore marker.
        :type guid: string
        :param guid:			   	The guid to set to the wellbore marker. If empty then a new
            									guid will be generated.
        :type title: string
        :param title:			   	The title to set to the wellbore marker. If empty then
            									"unknown" title will be set.

        :rtype: :py:class:`WellboreMarker`
        :return: A pointer to the new wellbore marker.

        |

        *Overload 2:*

        Creates a wellbore marker within a given wellbore marker frame representation.

        :raises: std::invalid_argument	If wellboreMarkerFrame == nullptr.

        :param [in]:	wellboreMarkerFrame 	The wellbore marker frame representation where to push
            										back the wellbore marker.
        :type guid: string
        :param guid:					The guid to set to the wellbore marker. If empty then a
            										new guid will be generated.
        :type title: string
        :param title:					The title to set to the wellbore marker. If empty then
            										"unknown" title will be set.
        :type geologicBoundaryKind: int
        :param geologicBoundaryKind:	The geologic boundary kind.

        :rtype: :py:class:`WellboreMarker`
        :return: A pointer to the new wellbore marker.

        |

        *Overload 3:*

        Creates a WITSML2.0 Wellbore Marker into this repository

        :type guid: string
        :param guid:		  	The guid to set to the marker. If empty then a new guid will be
            								generated.
        :type title: string
        :param title:		  	The title to set to the marker. If empty then "unknown" title will
            								be set.
        :type md: float
        :param md:		  		The Measured Depth to set to this marker.
        :type mdUom: int
        :param mdUom:			The underlying unit of measure of the MD value.

        :rtype: :py:class:`WellboreMarker`
        :return: A pointer to the new Wellbore Marker.

        |

        *Overload 4:*

        Creates a WITSML2.0 Wellbore Marker into this repository

        :raises: std::invalid_argument	If witsmlWellbore == nullptr.

        :param [in]:	witsmlWellbore	The wellbore associated to this marker. It cannot be null.
        :type guid: string
        :param guid:		  	The guid to set to the marker. If empty then a new guid will be
            								generated.
        :type title: string
        :param title:		  	The title to set to the marker. If empty then "unknown" title will
            								be set.
        :type md: float
        :param md:		  		The Measured Depth to set to this marker.
        :type mdUom: int
        :param mdUom:			The underlying unit of measure of the MD value.

        :rtype: :py:class:`WellboreMarker`
        :return: A pointer to the new Wellbore Marker.
        """
        return _fesapi.DataObjectRepository_createWellboreMarker(self, *args)

    def createFluidSystem(self, guid: "std::string const &", title: "std::string const &", temperatureValue: "double", temperatureUom: "gsoap_eml2_3::eml23__ThermodynamicTemperatureUom", pressureValue: "double", pressureUom: "gsoap_eml2_3::eml23__PressureUom", reservoirFluidKind: "gsoap_eml2_3::prodml22__ReservoirFluidKind", gasOilRatio: "double", gasOilRatioUom: "gsoap_eml2_3::eml23__VolumePerVolumeUom") -> "prodml2_2::FluidSystem *":
        r"""
        Creates a fluid system into this repository

        :type guid: string
        :param guid:			  	The guid to set to the fluid system. If empty then a new guid
            								will be generated.
        :type title: string
        :param title:			  	The title to set to the fluid system. If empty then "unknown"
            								title will be set.
        :type temperatureValue: float
        :param temperatureValue:  	The temperature value.
        :type temperatureUom: int
        :param temperatureUom:	  	The temperature unit of measure.
        :type pressureValue: float
        :param pressureValue:	  	The pressure value.
        :type pressureUom: int
        :param pressureUom:		  	The pressure unit of measure.
        :type reservoirFluidKind: int
        :param reservoirFluidKind:	The kind of the reservoir fluid.
        :type gasOilRatio: float
        :param gasOilRatio:		  	The gas oil ratio.
        :type gasOilRatioUom: int
        :param gasOilRatioUom:	  	The gas oil ratio unit of measure.

        :rtype: :py:class:`FluidSystem`
        :return: A pointer to the new fluid system.
        """
        return _fesapi.DataObjectRepository_createFluidSystem(self, guid, title, temperatureValue, temperatureUom, pressureValue, pressureUom, reservoirFluidKind, gasOilRatio, gasOilRatioUom)

    def createFluidCharacterization(self, guid: "std::string const &", title: "std::string const &") -> "prodml2_2::FluidCharacterization *":
        r"""
        Creates a fluid characterization into this repository

        :type guid: string
        :param guid: 	The guid to set to the fluid characterization. If empty then a new guid will
            					be generated.
        :type title: string
        :param title:	The title to set to the fluid characterization. If empty then "unknown"
            					title will be set.

        :rtype: :py:class:`FluidCharacterization`
        :return: A pointer to the new fluid characterization.
        """
        return _fesapi.DataObjectRepository_createFluidCharacterization(self, guid, title)

    def createTimeSeriesData(self, guid: "std::string const &", title: "std::string const &") -> "prodml2_2::TimeSeriesData *":
        r"""
        Creates a time series data into this repository

        :type guid: string
        :param guid: 	The guid to set to the time series data. If empty then a new guid will
            					be generated.
        :type title: string
        :param title:	The title to set to the time series data. If empty then "unknown"
            					title will be set.

        :rtype: :py:class:`TimeSeriesData`
        :return: A pointer to the new time series data.
        """
        return _fesapi.DataObjectRepository_createTimeSeriesData(self, guid, title)

    def getPropertyKindMapper(self) -> "resqml2_0_1::PropertyKindMapper *":
        r"""
        Gets the property kind mapper if it was given at repository construction time

        :rtype: :py:class:`PropertyKindMapper`
        :return: The property kind mapper, or ``nullptr`` if no property kind mapper was given at
            			repository construction time.
        """
        return _fesapi.DataObjectRepository_getPropertyKindMapper(self)

    def clearWarnings(self) -> "void":
        r""" Clears the warnings from the repository"""
        return _fesapi.DataObjectRepository_clearWarnings(self)

    def getWarnings(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        return _fesapi.DataObjectRepository_getWarnings(self)

    def createPartialLocalDepth3dCrs(self, *args) -> "resqml2_0_1::LocalDepth3dCrs *":
        return _fesapi.DataObjectRepository_createPartialLocalDepth3dCrs(self, *args)

    def createPartialLocalTime3dCrs(self, *args) -> "resqml2_0_1::LocalTime3dCrs *":
        return _fesapi.DataObjectRepository_createPartialLocalTime3dCrs(self, *args)

    def createPartialMdDatum(self, *args) -> "resqml2_0_1::MdDatum *":
        return _fesapi.DataObjectRepository_createPartialMdDatum(self, *args)

    def createPartialHorizon(self, *args) -> "resqml2_0_1::Horizon *":
        return _fesapi.DataObjectRepository_createPartialHorizon(self, *args)

    def createPartialTectonicBoundaryFeature(self, *args) -> "resqml2_0_1::TectonicBoundaryFeature *":
        return _fesapi.DataObjectRepository_createPartialTectonicBoundaryFeature(self, *args)

    def createPartialFrontierFeature(self, *args) -> "resqml2_0_1::FrontierFeature *":
        return _fesapi.DataObjectRepository_createPartialFrontierFeature(self, *args)

    def createPartialWellboreFeature(self, *args) -> "resqml2_0_1::WellboreFeature *":
        return _fesapi.DataObjectRepository_createPartialWellboreFeature(self, *args)

    def createPartialSeismicLineFeature(self, *args) -> "resqml2_0_1::SeismicLineFeature *":
        return _fesapi.DataObjectRepository_createPartialSeismicLineFeature(self, *args)

    def createPartialSeismicLineSetFeature(self, *args) -> "resqml2_0_1::SeismicLineSetFeature *":
        return _fesapi.DataObjectRepository_createPartialSeismicLineSetFeature(self, *args)

    def createPartialSeismicLatticeFeature(self, *args) -> "resqml2_0_1::SeismicLatticeFeature *":
        return _fesapi.DataObjectRepository_createPartialSeismicLatticeFeature(self, *args)

    def createPartialOrganizationFeature(self, *args) -> "resqml2_0_1::OrganizationFeature *":
        return _fesapi.DataObjectRepository_createPartialOrganizationFeature(self, *args)

    def createPartialStratigraphicUnitFeature(self, *args) -> "resqml2_0_1::StratigraphicUnitFeature *":
        return _fesapi.DataObjectRepository_createPartialStratigraphicUnitFeature(self, *args)

    def createPartialGeobodyFeature(self, *args) -> "resqml2_0_1::GeobodyFeature *":
        return _fesapi.DataObjectRepository_createPartialGeobodyFeature(self, *args)

    def createPartialFluidBoundaryFeature(self, *args) -> "resqml2_0_1::FluidBoundaryFeature *":
        return _fesapi.DataObjectRepository_createPartialFluidBoundaryFeature(self, *args)

    def createPartialGenericFeatureInterpretation(self, *args) -> "resqml2_0_1::GenericFeatureInterpretation *":
        return _fesapi.DataObjectRepository_createPartialGenericFeatureInterpretation(self, *args)

    def createPartialHorizonInterpretation(self, *args) -> "resqml2_0_1::HorizonInterpretation *":
        return _fesapi.DataObjectRepository_createPartialHorizonInterpretation(self, *args)

    def createPartialFaultInterpretation(self, *args) -> "resqml2_0_1::FaultInterpretation *":
        return _fesapi.DataObjectRepository_createPartialFaultInterpretation(self, *args)

    def createPartialWellboreInterpretation(self, *args) -> "resqml2_0_1::WellboreInterpretation *":
        return _fesapi.DataObjectRepository_createPartialWellboreInterpretation(self, *args)

    def createPartialStratigraphicUnitInterpretation(self, *args) -> "resqml2_0_1::StratigraphicUnitInterpretation *":
        return _fesapi.DataObjectRepository_createPartialStratigraphicUnitInterpretation(self, *args)

    def createPartialStructuralOrganizationInterpretation(self, *args) -> "resqml2_0_1::StructuralOrganizationInterpretation *":
        return _fesapi.DataObjectRepository_createPartialStructuralOrganizationInterpretation(self, *args)

    def createPartialStratigraphicColumnRankInterpretation(self, *args) -> "resqml2_0_1::StratigraphicColumnRankInterpretation *":
        return _fesapi.DataObjectRepository_createPartialStratigraphicColumnRankInterpretation(self, *args)

    def createPartialStratigraphicOccurrenceInterpretation(self, *args) -> "resqml2_0_1::StratigraphicOccurrenceInterpretation *":
        return _fesapi.DataObjectRepository_createPartialStratigraphicOccurrenceInterpretation(self, *args)

    def createPartialEarthModelInterpretation(self, *args) -> "resqml2_0_1::EarthModelInterpretation *":
        return _fesapi.DataObjectRepository_createPartialEarthModelInterpretation(self, *args)

    def createPartialGeobodyBoundaryInterpretation(self, *args) -> "resqml2_0_1::GeobodyBoundaryInterpretation *":
        return _fesapi.DataObjectRepository_createPartialGeobodyBoundaryInterpretation(self, *args)

    def createPartialGeobodyInterpretation(self, *args) -> "resqml2_0_1::GeobodyInterpretation *":
        return _fesapi.DataObjectRepository_createPartialGeobodyInterpretation(self, *args)

    def createPartialPolylineSetRepresentation(self, *args) -> "resqml2_0_1::PolylineSetRepresentation *":
        return _fesapi.DataObjectRepository_createPartialPolylineSetRepresentation(self, *args)

    def createPartialPointSetRepresentation(self, *args) -> "resqml2_0_1::PointSetRepresentation *":
        return _fesapi.DataObjectRepository_createPartialPointSetRepresentation(self, *args)

    def createPartialPlaneSetRepresentation(self, *args) -> "resqml2_0_1::PlaneSetRepresentation *":
        return _fesapi.DataObjectRepository_createPartialPlaneSetRepresentation(self, *args)

    def createPartialPolylineRepresentation(self, *args) -> "resqml2_0_1::PolylineRepresentation *":
        return _fesapi.DataObjectRepository_createPartialPolylineRepresentation(self, *args)

    def createPartialGrid2dRepresentation(self, *args) -> "resqml2_0_1::Grid2dRepresentation *":
        return _fesapi.DataObjectRepository_createPartialGrid2dRepresentation(self, *args)

    def createPartialTriangulatedSetRepresentation(self, *args) -> "resqml2_0_1::TriangulatedSetRepresentation *":
        return _fesapi.DataObjectRepository_createPartialTriangulatedSetRepresentation(self, *args)

    def createPartialWellboreTrajectoryRepresentation(self, *args) -> "resqml2_0_1::WellboreTrajectoryRepresentation *":
        return _fesapi.DataObjectRepository_createPartialWellboreTrajectoryRepresentation(self, *args)

    def createPartialDeviationSurveyRepresentation(self, *args) -> "resqml2_0_1::DeviationSurveyRepresentation *":
        return _fesapi.DataObjectRepository_createPartialDeviationSurveyRepresentation(self, *args)

    def createPartialRepresentationSetRepresentation(self, *args) -> "resqml2_0_1::RepresentationSetRepresentation *":
        return _fesapi.DataObjectRepository_createPartialRepresentationSetRepresentation(self, *args)

    def createPartialNonSealedSurfaceFrameworkRepresentation(self, *args) -> "resqml2_0_1::NonSealedSurfaceFrameworkRepresentation *":
        return _fesapi.DataObjectRepository_createPartialNonSealedSurfaceFrameworkRepresentation(self, *args)

    def createPartialSealedSurfaceFrameworkRepresentation(self, *args) -> "resqml2_0_1::SealedSurfaceFrameworkRepresentation *":
        return _fesapi.DataObjectRepository_createPartialSealedSurfaceFrameworkRepresentation(self, *args)

    def createPartialUnstructuredGridRepresentation(self, *args) -> "resqml2_0_1::UnstructuredGridRepresentation *":
        return _fesapi.DataObjectRepository_createPartialUnstructuredGridRepresentation(self, *args)

    def createPartialSubRepresentation(self, *args) -> "resqml2_0_1::SubRepresentation *":
        return _fesapi.DataObjectRepository_createPartialSubRepresentation(self, *args)

    def createPartialGridConnectionSetRepresentation(self, *args) -> "resqml2_0_1::GridConnectionSetRepresentation *":
        return _fesapi.DataObjectRepository_createPartialGridConnectionSetRepresentation(self, *args)

    def createPartialTimeSeries(self, *args) -> "resqml2_0_1::TimeSeries *":
        return _fesapi.DataObjectRepository_createPartialTimeSeries(self, *args)

    def createPartialPropertyKind(self, *args) -> "resqml2_0_1::PropertyKind *":
        return _fesapi.DataObjectRepository_createPartialPropertyKind(self, *args)

    def createPartialPropertySet(self, *args) -> "resqml2_0_1::PropertySet *":
        return _fesapi.DataObjectRepository_createPartialPropertySet(self, *args)

    def createPartialDoubleTableLookup(self, *args) -> "resqml2_0_1::DoubleTableLookup *":
        return _fesapi.DataObjectRepository_createPartialDoubleTableLookup(self, *args)

    def createPartialStringTableLookup(self, *args) -> "resqml2_0_1::StringTableLookup *":
        return _fesapi.DataObjectRepository_createPartialStringTableLookup(self, *args)

    def createPartialDiscreteProperty(self, *args) -> "resqml2_0_1::DiscreteProperty *":
        return _fesapi.DataObjectRepository_createPartialDiscreteProperty(self, *args)

    def createPartialCategoricalProperty(self, *args) -> "resqml2_0_1::CategoricalProperty *":
        return _fesapi.DataObjectRepository_createPartialCategoricalProperty(self, *args)

    def createPartialCommentProperty(self, *args) -> "resqml2_0_1::CommentProperty *":
        return _fesapi.DataObjectRepository_createPartialCommentProperty(self, *args)

    def createPartialContinuousProperty(self, *args) -> "resqml2_0_1::ContinuousProperty *":
        return _fesapi.DataObjectRepository_createPartialContinuousProperty(self, *args)

    def createPartialActivity(self, *args) -> "resqml2_0_1::Activity *":
        return _fesapi.DataObjectRepository_createPartialActivity(self, *args)

    def createPartialActivityTemplate(self, *args) -> "resqml2_0_1::ActivityTemplate *":
        return _fesapi.DataObjectRepository_createPartialActivityTemplate(self, *args)

    def createPartialWell(self, *args) -> "witsml2_1::Well *":
        return _fesapi.DataObjectRepository_createPartialWell(self, *args)

    def createPartialWellCompletion(self, *args) -> "witsml2_1::WellCompletion *":
        return _fesapi.DataObjectRepository_createPartialWellCompletion(self, *args)

    def createPartialWellbore(self, *args) -> "witsml2_1::Wellbore *":
        return _fesapi.DataObjectRepository_createPartialWellbore(self, *args)

    def createPartialWellboreCompletion(self, *args) -> "witsml2_1::WellboreCompletion *":
        return _fesapi.DataObjectRepository_createPartialWellboreCompletion(self, *args)

    def createPartialWellboreGeometry(self, *args) -> "witsml2_1::WellboreGeometry *":
        return _fesapi.DataObjectRepository_createPartialWellboreGeometry(self, *args)

    def createPartialTrajectory(self, *args) -> "witsml2_1::Trajectory *":
        return _fesapi.DataObjectRepository_createPartialTrajectory(self, *args)

    def createPartialLog(self, *args) -> "witsml2_1::Log *":
        return _fesapi.DataObjectRepository_createPartialLog(self, *args)

    def createPartialChannelSet(self, *args) -> "witsml2_1::ChannelSet *":
        return _fesapi.DataObjectRepository_createPartialChannelSet(self, *args)

    def createPartialChannel(self, *args) -> "witsml2_1::Channel *":
        return _fesapi.DataObjectRepository_createPartialChannel(self, *args)
    __swig_destroy__ = _fesapi.delete_DataObjectRepository

# Register DataObjectRepository in _fesapi:
_fesapi.DataObjectRepository_swigregister(DataObjectRepository)
class EpcDocument(object):
    r"""
     EPC is an implementation of the Open Packaging Conventions (OPC), a widely used container-file technology
    that allows multiple types of files to be bundled together into a single package.
    Built on the widely used ZIP file structure and originally created by Microsoft, OPC is now an open standard supported by these standards organizations:
     - Ecma International (http://www.ecma-international.org/publications/standards/Ecma-376.htm )
     - ISO/IEC 29500-2:2012, which has 4 parts, which are all freely available at this link (http://standards.iso.org/ittf/PubliclyAvailableStandards/index.html ).
    An EPC file (or package) is a ZIP file, which may be "unzipped" to view its components.
    When implemented as part of an Energistics standard, the zipping/unzipping is done using the OPC libraries (per the EPC Specification).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fileName: "std::string const &"):
        r"""
        Constructor

        :type fileName: string
        :param fileName:	Full pathname of the EPC document in UTF-8 encoding.
        """
        _fesapi.EpcDocument_swiginit(self, _fesapi.new_EpcDocument(fileName))

    def open(self, fileName: "std::string const &") -> "void":
        r"""
        Opens an EPC document.

        :type fileName: string
        :param fileName:	Full pathname of the EPC document in UTF-8 encoding.
        """
        return _fesapi.EpcDocument_open(self, fileName)

    def serializeFrom(self, repo: "DataObjectRepository") -> "void":
        r"""
        Serializes the content of a data object repository into this EPC document.

        :type repo: :py:class:`DataObjectRepository`
        :param repo:		A data object repository.
        """
        return _fesapi.EpcDocument_serializeFrom(self, repo)

    def deserializeInto(self, *args) -> "std::string":
        r"""
        Deserializes this package (data objects and relationships) into a data object repository

        :param [in,out]:	repo			   	A data object repository.
        :type hdfPermissionAccess: int, optional
        :param hdfPermissionAccess:	(Optional) The HDF5 file permission access. It is read
            										only by default.

        :rtype: string
        :return: An empty string if success otherwise the warning string.
        """
        return _fesapi.EpcDocument_deserializeInto(self, *args)

    def getStorageDirectory(self) -> "std::string":
        r"""
        Gets the absolute path of the directory where the EPC document is stored.

        :rtype: string
        :return: The EPC document storage directory.
        """
        return _fesapi.EpcDocument_getStorageDirectory(self)

    def getName(self) -> "std::string":
        r"""
        Gets the name of the EPC document

        :rtype: string
        :return: The name of the EPC document without the ``.epc`` extension.
        """
        return _fesapi.EpcDocument_getName(self)

    def setExtendedCoreProperty(self, key: "std::string const &", value: "std::string const &") -> "void":
        r"""
        Sets or adds an extended core property

        :type key: string
        :param key:  	The key of the property.
        :type value: string
        :param value:	The value of the property.
        """
        return _fesapi.EpcDocument_setExtendedCoreProperty(self, key, value)

    def getExtendedCorePropertyCount(self) -> "uint64_t":
        r"""
        Gets extended core property count.
        The EpcDocument must have been deserialized at least once to get the extended core proeprties information.

        :rtype: int
        :return: The count of extended core properties in this EPC document
        """
        return _fesapi.EpcDocument_getExtendedCorePropertyCount(self)

    def getExtendedCoreProperty(self, key: "std::string const &") -> "std::string":
        r"""
        Gets an extended core property value according to its key.
        The EpcDocument must have been deserialized at least once to get the extended core proeprties information.

        :type key: string
        :param key:	The key of the property.

        :rtype: string
        :return: An empty string if the extended core property does not exist. Or the extended core
            			property value if it exists.
        """
        return _fesapi.EpcDocument_getExtendedCoreProperty(self, key)
    __swig_destroy__ = _fesapi.delete_EpcDocument

# Register EpcDocument in _fesapi:
_fesapi.EpcDocument_swigregister(EpcDocument)
class EnumStringMapper(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _fesapi.EnumStringMapper_swiginit(self, _fesapi.new_EnumStringMapper())

    def getEnergisticsPropertyKindName(self, energisticsPropertyKind: "gsoap_resqml2_0_1::resqml20__ResqmlPropertyKind") -> "std::string":
        r"""
        Get the name of a RESQML2.0 property kind as a string based on the property kind enumerated
        value

        :type energisticsPropertyKind: int
        :param energisticsPropertyKind:	A RESQML2.0 property kind.

        :rtype: string
        :return: A string corresponding to ``energisticsPropertyKind`` if successful. The empty string
            			if no correspondence is found.
        """
        return _fesapi.EnumStringMapper_getEnergisticsPropertyKindName(self, energisticsPropertyKind)

    def getEnergisticsPropertyKind(self, energisticsPropertyKindName: "std::string const &") -> "gsoap_resqml2_0_1::resqml20__ResqmlPropertyKind":
        r"""
        Get the RESQML2.0 property kind enumerated value from the name of a property kind

        :type energisticsPropertyKindName: string
        :param energisticsPropertyKindName:	The name of a RESQML2.0 property kind.

        :rtype: int
        :return: The RESQML2.0 property kind enumerated value corresponding to
            ``energisticsPropertyKindName`` if successful. The most abstract RESQML2.0 property kind
            			enumerated value if no correspondence is found.
        """
        return _fesapi.EnumStringMapper_getEnergisticsPropertyKind(self, energisticsPropertyKindName)

    def getEnergisticsUnitOfMeasureName(self, energisticsUom: "gsoap_resqml2_0_1::resqml20__ResqmlUom") -> "std::string":
        r"""
        Get the name of a RESQML2.0 unit of measure as a string based on the unit of measure
        enumerated value

        :type energisticsUom: int
        :param energisticsUom:	A RESQML2.0 unit of measure.

        :rtype: string
        :return: A string corresponding to ``energisticsUom`` if successful. The empty string if no
            			correspondence is found.
        """
        return _fesapi.EnumStringMapper_getEnergisticsUnitOfMeasureName(self, energisticsUom)

    def getEnergisticsUnitOfMeasure(self, energisticsUomName: "std::string const &") -> "gsoap_resqml2_0_1::resqml20__ResqmlUom":
        r"""
        Get the RESQML2.0 unit of measure enumerated value from the name of a unit of measure

        :type energisticsUomName: string
        :param energisticsUomName:	The name of a RESQML2.0 unit of measure.

        :rtype: int
        :return: The RESQML2.0 unit of measure enumerated value corresponding to ``energisticsUomName``
            			if successful. The Euclidian (no unit of measure) RESQML2.0 unit of measure if no
            			correspondence is found.
        """
        return _fesapi.EnumStringMapper_getEnergisticsUnitOfMeasure(self, energisticsUomName)

    def getFacet(self, *args) -> "gsoap_eml2_3::eml23__FacetKind":
        r"""
        *Overload 1:*

        Get the name of a facet as a string based on the enumerated facet enumerated value

        :type facet: int
        :param facet:	An enumerated facet.

        :rtype: string
        :return: A string corresponding to ``facet`` if successful. The empty string if no
            			correspondence is found.

        |

        *Overload 2:*

        Get the enumerated value from the name of a facet.

        :type facet: string
        :param facet:	The name of a facet.

        :rtype: int
        :return: The facet enumerated value corresponding to ``facet`` if successful. The
            ``what`` facet enumerated value if no correspendance is found.
        """
        return _fesapi.EnumStringMapper_getFacet(self, *args)

    def lengthUomToString(self, witsmlUom: "gsoap_eml2_3::eml23__LengthUom") -> "std::string":
        r"""
        Get the name of an EML2.1 length unit of measure as a string based on the unit of measure
        enumerated value

        :type witsmlUom: int
        :param witsmlUom:	An EML2.1 length unit of measure.

        :rtype: string
        :return: A string corresponding to ``witsmlUom`` if successful. The empty string if no
            			correspondence is found.
        """
        return _fesapi.EnumStringMapper_lengthUomToString(self, witsmlUom)

    def verticalCoordinateUomToString(self, witsmlUom: "gsoap_eml2_3::eml23__VerticalCoordinateUom") -> "std::string":
        r"""
        Get the name of an EML2.1 vertical coordinate unit of measure as a string based on the unit
        of measure enumerated value

        :type witsmlUom: int
        :param witsmlUom:	An EML2.1 vertical coordinate unit of measure.

        :rtype: string
        :return: A string corresponding to ``witsmlUom`` if successful. The empty string if no
            			correspondence is found.
        """
        return _fesapi.EnumStringMapper_verticalCoordinateUomToString(self, witsmlUom)

    def planeAngleUomToString(self, witsmlUom: "gsoap_eml2_3::eml23__PlaneAngleUom") -> "std::string":
        r"""
        Get the name of an EML2.1 plane angle unit of measure as a string based on the unit of
        measure enumerated value

        :type witsmlUom: int
        :param witsmlUom:	An EML2.1 plane angle unit of measure.

        :rtype: string
        :return: A string corresponding to ``witsmlUom`` if successful. The empty string if no
            			correspondence is found.
        """
        return _fesapi.EnumStringMapper_planeAngleUomToString(self, witsmlUom)
    __swig_destroy__ = _fesapi.delete_EnumStringMapper

# Register EnumStringMapper in _fesapi:
_fesapi.EnumStringMapper_swigregister(EnumStringMapper)

