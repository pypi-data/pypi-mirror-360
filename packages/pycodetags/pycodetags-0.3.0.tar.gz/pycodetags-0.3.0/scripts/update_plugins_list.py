from __future__ import annotations

import datetime
import pathlib
import re
from collections.abc import Iterable, Iterator
from textwrap import dedent
from typing import Any, TypedDict

import packaging.version
import platformdirs
import tabulate
from requests_cache import CachedResponse, CachedSession, OriginalResponse, SQLiteCache
from tqdm import tqdm

HOST_APP = "pycodetags"

FILE_HEAD = f"""
<!-- Note this file is autogenerated by scripts/update_plugins_list.py' - usually weekly via github action -->

# {HOST_APP} Plugin List

Below is an automated compilation of `{HOST_APP}` plugins available on [PyPI](https://pypi.org).
It includes PyPI projects whose names begin with `{HOST_APP}-` or `{HOST_APP.replace("-","_")}_` and a handful of manually selected projects.
Packages classified as inactive are excluded.

For detailed insights into how this list is generated,
please refer to [the update script](https://github.com/matthewdeanmartin/code_tags/blob/main/scripts/update_plugins_list.py').

> **Warning**
>
> Please be aware that this list is not a curated collection of projects
> and does not undergo a systematic review process.
> It serves purely as an informational resource to aid in the discovery of `{HOST_APP}` plugins.
>
> Do not presume any endorsement from the `{HOST_APP}` project or its developers,
> and always conduct your own quality assessment before incorporating any of these plugins into your own projects.
"""

DEVELOPMENT_STATUS_CLASSIFIERS = (
    "Development Status :: 1 - Planning",
    "Development Status :: 2 - Pre-Alpha",
    "Development Status :: 3 - Alpha",
    "Development Status :: 4 - Beta",
    "Development Status :: 5 - Production/Stable",
    "Development Status :: 6 - Mature",
    "Development Status :: 7 - Inactive",
)

ADDITIONAL_PROJECTS = {}


def escape_md(text: str) -> str:
    """Escape special Markdown characters."""
    return text.replace("*", "\\*").replace("_", "\\_").replace("`", "\\`")


def project_response_with_refresh(
    session: CachedSession, name: str, last_serial: int
) -> OriginalResponse | CachedResponse:
    response = session.get(f"https://pypi.org/pypi/{name}/json")
    if int(response.headers.get("X-PyPI-Last-Serial", -1)) != last_serial:
        response = session.get(f"https://pypi.org/pypi/{name}/json", refresh=True)
    return response


def get_session() -> CachedSession:
    cache_path = platformdirs.user_cache_path("pytest-plugin-list")
    cache_path.mkdir(exist_ok=True, parents=True)
    cache_file = cache_path.joinpath("http_cache.sqlite3")
    return CachedSession(backend=SQLiteCache(cache_file))


def pytest_plugin_projects_from_pypi(session: CachedSession) -> dict[str, int]:
    response = session.get(
        "https://pypi.org/simple",
        headers={"Accept": "application/vnd.pypi.simple.v1+json"},
        refresh=True,
    )
    return {
        name: p["_last-serial"]
        for p in response.json()["projects"]
        if ((name := p["name"]).startswith(("pycodetags-", "pycodetags_")) or name in ADDITIONAL_PROJECTS)
    }


class PluginInfo(TypedDict):
    name: str
    summary: str
    last_release: str
    status: str
    requires: str


def iter_plugins() -> Iterator[PluginInfo]:
    session = get_session()
    name_2_serial = pytest_plugin_projects_from_pypi(session)

    for name, last_serial in tqdm(name_2_serial.items(), smoothing=0):
        response = project_response_with_refresh(session, name, last_serial)
        if response.status_code == 404:
            continue
        response.raise_for_status()
        info = response.json()["info"]
        if "Development Status :: 7 - Inactive" in info["classifiers"]:
            continue
        for classifier in DEVELOPMENT_STATUS_CLASSIFIERS:
            if classifier in info["classifiers"]:
                status = classifier[22:]
                break
        else:
            status = "N/A"

        requires = "N/A"
        if info["requires_dist"]:
            for requirement in info["requires_dist"]:
                if re.match(r"pytest(?![-.\\w])", requirement):
                    requires = requirement
                    break

        def version_sort_key(version_string: str) -> Any:
            try:
                return packaging.version.parse(version_string)
            except packaging.version.InvalidVersion:
                return packaging.version.Version("0.0.0alpha")

        releases = response.json()["releases"]
        for release in sorted(releases, key=version_sort_key, reverse=True):
            if releases[release]:
                release_date = datetime.date.fromisoformat(releases[release][-1]["upload_time_iso_8601"].split("T")[0])
                last_release = release_date.strftime("%b %d, %Y")
                break

        summary = escape_md(info["summary"].replace("\n", "")) if info["summary"] else ""

        yield {
            "name": info["name"],
            "summary": summary.strip(),
            "last_release": last_release,
            "status": status,
            "requires": requires,
        }


def plugin_definitions(plugins: Iterable[PluginInfo]) -> Iterator[str]:
    for plugin in plugins:
        yield dedent(
            f"""
            ## {plugin['name']}

            - **Last release**: {plugin['last_release']}
            - **Status**: {plugin['status']}
            - **Requires**: {plugin['requires']}

            {plugin['summary']}
            """
        )


def main() -> None:
    plugins = [*iter_plugins()]
    reference_dir = pathlib.Path("docs")
    plugin_list = reference_dir / "plugin_list.md"

    with plugin_list.open("w", encoding="UTF-8") as f:
        f.write(FILE_HEAD)
        f.write(f"\nThis list contains {len(plugins)} plugins.\n\n")

        plugin_table = tabulate.tabulate(plugins, headers="keys", tablefmt="github")
        f.write(plugin_table)
        f.write("\n\n")

        for definition in plugin_definitions(plugins):
            f.write(definition)
            f.write("\n")


if __name__ == "__main__":
    main()
