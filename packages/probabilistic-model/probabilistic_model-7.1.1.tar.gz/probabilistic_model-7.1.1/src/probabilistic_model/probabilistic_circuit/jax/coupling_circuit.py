from abc import abstractmethod
from functools import cached_property

import jax
from jax.tree_util import tree_flatten, tree_unflatten

import equinox as eqx
from typing_extensions import Tuple, List
import jax.numpy as jnp
from .probabilistic_circuit import Layer


class Conditioner:
    """
    Interface for a conditioner that generates parameters for a circuit.
    """

    @abstractmethod
    def generate_parameters(self, x: jax.Array) -> jax.Array:
        """
        Generate parameters for a circuit given an input.

        :param x: The input to the conditioner.
        :return: The parameters for the circuit.
        """
        raise NotImplementedError

    @property
    @abstractmethod
    def output_length(self):
        """
        :return: The length number of parameters that the model outputs.
        """
        raise NotImplementedError


class CouplingCircuit(eqx.Module):
    """
    A probabilistic circuit that uses a function to generate parameters for a circuit.
    Simply speaking, this represents P(y, theta=f(x)).
    """

    conditioner: Conditioner
    """
    The conditioner that generates the parameters for the circuit.
    """

    circuit: Layer = eqx.field(static=True)
    """
    The circuit to generate the parameters for.
    """

    conditioner_columns: jax.Array = eqx.field(static=True)
    """
    The columns in a matrix that the conditioner takes as input for producing circuit parameters.
    """

    circuit_columns: jax.Array = eqx.field(static=True)
    """
    The columns in a matrix that the circuit takes as input for calculating likelihoods.
    """

    def __init__(self, conditioner: Conditioner, conditioner_columns: jax.Array,
                 circuit: Layer, circuit_columns):
        self.conditioner = conditioner
        self.conditioner_columns = conditioner_columns
        self.circuit = circuit
        self.circuit_columns = circuit_columns

    def partition_circuit(self):
        """
        Partition the circuit into the parameters and the static structure.
        :return:
        """
        return self.circuit.partition()

    @cached_property
    def slices_of_parameters_for_flat_model(self) -> List[Tuple[int, int]]:
        """
        :return: The slices that can be used to partition the parameters that are generated by the conditioner
            into the structure of the circuit.
        """
        # get the parameters and circuit definition
        tree_def, static = self.circuit.partition()

        # flatten the parameters
        flat_model, flat_tree_def = jax.tree_util.tree_flatten(tree_def)

        slices = [None] * len(flat_model)
        offset = 0
        for index, leaf in enumerate(flat_model):
            leaf_length = len(leaf)
            slices[index] = (offset, offset + leaf_length)
            offset += leaf_length

        return slices


    def create_circuit_from_parameters(self, params: jax.Array) -> Layer:
        """
        Generate a circuit with the structure from self.circuit and the parameters from params.
        :param params: The parameters to be used in the circuit.
        :return: The circuit
        """

        # get the parameters and circuit definition
        tree_def, static = self.partition_circuit()

        # flatten the parameters
        flat_model, flat_tree_def = jax.tree_util.tree_flatten(tree_def)

        # slice the parameters such that they match the pytree
        slices_parameters = [params[start:end] for start, end in self.slices_of_parameters_for_flat_model]

        # update the parameters
        params = tree_unflatten(flat_tree_def, slices_parameters)

        # assemble the parameterized model
        circuit = eqx.combine(params, static)
        return circuit

    def conditional_log_likelihood_single(self, x):
        """
        Calculate the truncated log likelihood of a single data point.

        :param x: The datapoint
        :return: The truncated log likelihood of the data point
        """
        params = self.conditioner.generate_parameters(x[self.conditioner_columns])
        circuit = self.create_circuit_from_parameters(params)
        return circuit.log_likelihood_of_nodes_single(x[self.circuit_columns])

    def conditional_log_likelihood(self, x):
        return jax.vmap(self.conditional_log_likelihood_single)(x)

    def validate(self):
        """
        Check if the output of the conditioner matches the parametrization of the circuit.
        """
        self.circuit.validate()
        assert self.circuit.number_of_trainable_parameters == self.conditioner.output_length


class LinearConditioner(eqx.Module, Conditioner):
    """
    A simple linear conditioner that generates parameters for a circuit.
    """

    linear: eqx.nn.Linear

    def __init__(self, in_features: int, out_features: int):
        self.linear = eqx.nn.Linear(in_features, out_features, key=jax.random.PRNGKey(69))

    def generate_parameters(self, x: jax.Array) -> jax.Array:
        return self.linear(x)

    @property
    def output_length(self):
        return self.linear.out_features
