"use strict";

//-------------------------
// utility functions to generate header file
//-------------------------
const MapCont = "map<string, tuple<int, string>>";
const MapLabel = "const "+MapCont+" ";

function FormatCSVString(strobj, crnum, is4enum)
{
    let nitems = 0, nquat = 0;
    let ist = 0, bef, aft;
    let ex = /"/g;

    while(true){
        ist = strobj.indexOf(", ", ist);
        if(ist == -1){
            break;
        }
        ist++;

        let target = strobj.substring(0, ist-1);
        let nquat = target.match(ex);
        if(nquat != null){
            if(nquat.length%2 > 0){
                continue;
            };
        }

        nitems++;
        if(nitems%crnum == 0){
            bef = strobj.slice(0, ist-1);
            aft = strobj.slice(ist-1);
            if(is4enum){
                strobj = bef+aft.replace(", ", ",\n\t\t");
                ist +=2 ;    
            }
            else{
                strobj = bef+aft.replace(", ", ",\n\t");
                ist++;    
            }
        }
    }
    return is4enum ? "\t"+strobj : "{\n\t"+strobj+"\n};\n";
}

function FormatCppVector(type)
{
    return "const vector<"+type+"> ";
}

function FormatCppVectorDouble(type)
{
    return "const vector<vector<"+type+">> ";
}

function FormatTuple(label, index, fmt)
{
    return '{"'+label+'", '+"tuple<int, string> ("+index+', "'+fmt+'")}';
}

function FormatConst(labelobj, prefix = "")
{
    let data = "";
    for(let i = 0; i < labelobj.length; i++){
        let keys = Object.keys(labelobj[i]);
        data += prefix+"const string "+keys[0]+" = "+'"'+labelobj[i][keys[0]]+'"'+";\n"
    }
    return data;
}

function FormatMapobjs(mapobjs)
{
    let data = "";
    Object.keys(mapobjs).forEach((el) => {
        data += "const map<string, vector<double>> "+el+" {\n";
        let labels = Object.keys(mapobjs[el]);
        for(let n = 0; n < labels.length; n++){
            data += "\t{\""+labels[n]+"\", vector<double> {"
            for(let k = 0; k < mapobjs[el][labels[n]].length; k++){
                if(k > 0){
                    data += ", "
                }
                data += mapobjs[el][labels[n]][k].toString();                
            }
            if(n == labels.length-1){
                data += "}}\n"
            }
            else{
                data+= "}},\n"
            }
        }
        data += "};\n"
    });
    return data;
}

function GenerateHeaderFile()
{
    let data = "";
    data += "// ---------------------------------------------------\n";
    data += "// automatically generated by SIMPLEX GUI, do not edit\n";
    data += "// ---------------------------------------------------\n\n";
    data += "#ifndef simplex_input_h\n#define simplex_input_h\n\n";
    data += "#include <string>\n";
    data += "#include <map>\n";
    data += "#include <tuple>\n";
    data += "#include <vector>\n";
    data += "using namespace std;\n\n";

    let scanprms = 4;
    // ScanPrmsLabel.initial, ScanPrmsLabel.final, ScanPrmsLabel.points/ScanPrmsLabel.interv, ScanPrmsLabel.iniser

    let constlabels = [
        {EBLabel:EBLabel}, 
        {SeedLabel:SeedLabel}, 
        {SPXOutLabel:SPXOutLabel}, 
        {UndLabel:UndLabel},
        {WakeLabel:WakeLabel},
        {LatticeLabel:LatticeLabel},
        {ChicaneLabel:ChicaneLabel},
        {DispersionLabel:DispersionLabel},
        {AlignmentLabel:AlignmentLabel},
        {SimCondLabel:SimCondLabel},
        {DataDumpLabel:DataDumpLabel},
        {OutFileLabel:OutFileLabel},
        {PostPLabel:PostPLabel},
        {ScanLabel:ScanLabel},
        {Fin1ScanLabel:Fin1ScanLabel},
        {ScanOutLabel:ScanOutLabel},
        {ErrorLabel:ErrorLabel},
        {WarningLabel:WarningLabel},
        {InputLabel:InputLabel},
        {GainCurveLabel:GainCurveLabel},
        {RadCharactLabel:RadCharactLabel},
        {TempProfileLabel:TempProfileLabel},
        {SpecProfileLabel:SpecProfileLabel},
        {SpatProfileLabel:SpatProfileLabel},
        {AnglProfileLabel:AnglProfileLabel},
        {KValueTrendLabel:KValueTrendLabel},
        {CoordinateLabel:CoordinateLabel},
        {StepCoordLabel:StepCoordLabel},
        {StepIndexLabel:StepIndexLabel},
        {SliceCoordLabel:SliceCoordLabel},
        {XYCoordLabel:XYCoordLabel},
        {AvgEnergyLabel:AvgEnergyLabel},
        {SliceEmittanceLabel:SliceEmittanceLabel},
        {SliceEspreadLabel:SliceEspreadLabel},
        {PeakCurrLabel:PeakCurrLabel},
        {SimulatedChargeLabel:SimulatedChargeLabel},
        {TotalStepsLabel:TotalStepsLabel},
        {CentralEnergyLabel:CentralEnergyLabel},
        {XYPointsLabel:XYPointsLabel},
        {BeamletsLabel:BeamletsLabel},
        {ParticlesLabel:ParticlesLabel},
        {DataDimLabel:DataDimLabel},
        {DataTitlesLabel:DataTitlesLabel},
        {UnitsLabel:UnitsLabel},
        {VariablesLabel:VariablesLabel},
        {RetInfLabel:RetInfLabel},
        {DataNameLabel:DataNameLabel},
        {EtDistLabel:EtDistLabel},
        {CurrentProfLabel:CurrentProfLabel},
        {EtProfLabel:EtProfLabel},       
        {PostPResultLabel:PostPResultLabel},
        {PlotScatterLabel:PlotScatterLabel},
        {PPMicroBunchLabel:PPMicroBunchLabel},
        {PPFDlabel:PPFDlabel},
        {PP1stIntLabel:PP1stIntLabel},
        {PP2ndIntLabel:PP2ndIntLabel},
        {PPPhaseErrLabel:PPPhaseErrLabel},
        {PPKValue:PPKValue},
        {PPDetune:PPDetune},
        {PPWakeBunch:PPWakeBunch},
        {PPWakeEvar:PPWakeEvar},
        {PPBetaLabel:PPBetaLabel},
        {PPOptBetaLabel:PPOptBetaLabel},
        {PPFocusStrength:PPFocusStrength},
        {PPDispersion:PPDispersion},
        {PPMonoSpectrum:PPMonoSpectrum},
        {IntegerLabel:IntegerLabel},
        {IncrementalLabel:IncrementalLabel},
        {NumberLabel:NumberLabel},
        {DataLabel:DataLabel},
        {GridLabel:GridLabel},
        {BoolLabel:BoolLabel},
        {StringLabel:StringLabel},
        {SelectionLabel:SelectionLabel},
        {ArrayLabel:ArrayLabel},
        {ArrayIntegerLabel:ArrayIntegerLabel},
        {ArrayIncrementalLabel:ArrayIncrementalLabel}
    ];

    data += "// labels for parameters and data import\n"
            +FormatConst(constlabels)+"\n";

    let selections = [
        {NotAvaliable:NotAvaliable}, 
        {CustomLabel:CustomLabel},

        {GaussianBunch:GaussianBunch}, 
        {BoxcarBunch:BoxcarBunch},
        {SimplexOutput:SimplexOutput}, 
        {CustomSlice:CustomSlice}, 
        {CustomCurrent:CustomCurrent}, 
        {CustomEt:CustomEt}, 
        {CustomParticle:CustomParticle},

        {ProjectedPrm:ProjectedPrm},
        {SlicedPrmOptimize:SlicedPrmOptimize},
        {SlicedPrmCustom:SlicedPrmCustom},

        {UndDataLabel:UndDataLabel},
        {WakeDataLabel:WakeDataLabel}, 
        {MonoDataLabel:MonoDataLabel}, 

        {UnitMeter:UnitMeter}, 
        {UnitMiliMeter:UnitMiliMeter}, 
        {UnitRad:UnitRad}, 
        {UnitMiliRad:UnitMiliRad}, 
        {UnitSec:UnitSec}, 
        {UnitpSec:UnitpSec}, 
        {UnitfSec:UnitfSec}, 
        {UnitGeV:UnitGeV}, 
        {UnitMeV:UnitMeV}, 
        {UnitGamma:UnitGamma}, 

        {GaussianPulse:GaussianPulse}, 
        {ChirpedPulse:ChirpedPulse}, 

        {LinearUndLabel:LinearUndLabel}, 
        {HelicalUndLabel:HelicalUndLabel}, 
        {EllipticUndLabel:EllipticUndLabel}, 
        {MultiHarmUndLabel:MultiHarmUndLabel}, 
        {MultiHarmContLabel:MultiHarmContLabel},
        {TaperCustomLabel:TaperCustomLabel},
        {DataAllocLabel:DataAllocLabel},

        {TaperStair:TaperStair}, 
        {TaperContinuous:TaperContinuous}, 
        {TaperCustom:TaperCustom}, 
        {TaperOptWhole:TaperOptWhole}, 
        {TaperOptSlice:TaperOptSlice}, 
        {TaperOptWake:TaperOptWake},

        {IdealLabel:IdealLabel}, 
        {SpecifyErrLabel:SpecifyErrLabel}, 
        {ImportDataLabel:ImportDataLabel}, 

        {FUFULabel:FUFULabel}, 
        {FUDULabel:FUDULabel}, 
        {DUFULabel:DUFULabel},
        {DoubletLabel:DoubletLabel}, 
        {TripletLabel:TripletLabel}, 
        {CombinedLabel:CombinedLabel}, 

        {XtalTransLabel:XtalTransLabel}, 
        {XtalReflecLabel:XtalReflecLabel}, 

        {C400Label:C400Label}, 
        {C220Label:C220Label}, 
        {Si111Label:Si111Label}, 

        {TargetOffsetLabel:TargetOffsetLabel},
        {TargetErrorLabel:TargetErrorLabel},
        {OffsetEachLabel:OffsetEachLabel},

        {TimeDepLabel:TimeDepLabel},
        {SSLabel:SSLabel},
        {CyclicLabel:CyclicLabel},
        {SmoothingGauss:SmoothingGauss},
        {KillQuiteLoad:KillQuiteLoad},
        {KillShotNoize:KillShotNoize},
        {RealElectronNumber:RealElectronNumber},
        
        {DumpSegExitLabel:DumpSegExitLabel},
        {DumpSpecifyLabel:DumpSpecifyLabel},
        {DumpUndExitLabel:DumpUndExitLabel},
        {RegularIntSteps:RegularIntSteps},

        {WholeSliceLabel:WholeSliceLabel},
        {SpecificSliceLabel:SpecificSliceLabel},
        
        {SliceLabel:SliceLabel},
        {CurrentLabel:CurrentLabel},
        {EnergyLabel:EnergyLabel},
        {EspLabel:EspLabel},
        {EmittxLabel:EmittxLabel},
        {EmittyLabel:EmittyLabel},
        {BetaxLabel:BetaxLabel},
        {BetayLabel:BetayLabel},
        {AlphaxLabel:AlphaxLabel},
        {AlphayLabel:AlphayLabel},
        {XavLabel:XavLabel},
        {YavLabel:YavLabel},
        {XpavLabel:XpavLabel},
        {YpavLabel:YpavLabel},
        {CalcStatusLabel:CalcStatusLabel},
        {InitStatusLabel:InitStatusLabel},
        {ScanPrmItems:scanprms.toString()},

        {PPBetaOptQgrad:PPBetaOptQgrad},
        {PPBetaOptInitial:PPBetaOptInitial},

        {PostPPowerLabel:PostPPowerLabel},
        {PostPFluxLabel:PostPFluxLabel},
        {PostPCampLabel:PostPCampLabel},
        {PostPBunchFLabel:PostPBunchFLabel},
        {PostPEnergyLabel:PostPEnergyLabel},
        {PostPPartDistLabel:PostPPartDistLabel},
        {PostPFarLabel:PostPFarLabel},
        {PostPNearLabel:PostPNearLabel},
        {PostPtXLabel:PostPtXLabel},
        {PostPtYLabel:PostPtYLabel},
        {PostPtetaLabel:PostPtetaLabel},
        {PostPIntegFullLabel:PostPIntegFullLabel},
        {PostPIntegPartialLabel:PostPIntegPartialLabel},
        {PostPWignerLabel:PostPWignerLabel},

        {PostPRealLabel:PostPRealLabel},
        {PostPImagLabel:PostPImagLabel},
        {PostPExLabel:PostPExLabel},
        {PostPEyLabel:PostPEyLabel},
        {PostPBothLabel:PostPBothLabel},
        {PostPTimeDomainLabel:PostPTimeDomainLabel},
        {PostPSpatDomainLabel:PostPSpatDomainLabel},
        {PostPXAxisLabel:PostPXAxisLabel},
        {PostPYAxisLabel:PostPYAxisLabel},

        {PulseEnergyLabel:PulseEnergyLabel},
        {RadPowerLabel:RadPowerLabel},
        {SpatEnergyDensLabel:SpatEnergyDensLabel},
        {AngEnergyDensLabel:AngEnergyDensLabel},
        {SpatPowerDensLabel:SpatPowerDensLabel},
        {AngPowerDensLabel:AngPowerDensLabel},
        {BunchFactorLabel:BunchFactorLabel},
        {ELossLabel:ELossLabel},
        {PLossLabel:PLossLabel},
        {EspreadLabel:EspreadLabel},

        {PulselengthLabel:PulselengthLabel},
        {BandwidthLabel:BandwidthLabel},
        {DivergenceX:DivergenceX},
        {DivergenceY:DivergenceY},
        {BeamSizeX:BeamSizeX},
        {BeamSizeY:BeamSizeY},
        {CurvatureLabel:CurvatureLabel},
        {ElapsedTimeLabel:ElapsedTimeLabel}
    ];
    data += "// labels for selections\n"
            +FormatConst(selections)+"\n";

    let crnumv = 8, crnums = 4;
    let update = [];
    for(let j = 0; j < UpdateScans.length; j++){
        update.push("\""+UpdateScans[j]+"\"");
    }
    data += "// labels to force update for scan option\n";
    data += FormatCppVector("string")+" UpdateScans "+FormatCSVString(update.join(", "), crnumv, false)+"\n"

    let mapobjs = {BuiltinXtals:BuiltinXtals};
    data += FormatMapobjs(mapobjs)+"\n";

    let hdrorg = [
        {enum:[], str:[], strsimp:[], def:[]}, // 0: number
        {enum:[], str:[], strsimp:[], def:[]}, // 1: vector
        {enum:[], str:[], strsimp:[], def:[]}, // 2: boolean
        {enum:[], str:[], strsimp:[], def:[], select:[]}, // 3: selection
        {enum:[], str:[], strsimp:[], def:[]}, // 4: string
        {enum:[], str:[], strsimp:[]} // 5: plottable data
    ];

    let categsufs = {
        [EBLabel]: ["EBeam", EBeamPrmsOrder, EBeamPrmsLabel],
        [SeedLabel]: ["Seed", SeedPrmsOrder, SeedPrmsLabel],
        [MBunchEvalLabel]: ["Mbunch", EvalMBunchOrder, EvalMBunchLabel],
        [SPXOutLabel]: ["SPXOut", ImportSPXOutOrder, ImportSPXOutLabel],
        [UndLabel]: ["Und", UndPrmsOrder, UndPrmsLabel],
        [WakeLabel]: ["Wake", WakePrmsOrder, WakePrmsLabel],
        [LatticeLabel]: ["Lattice", LatticePrmsOrder, LatticePrmsLabel],
        [ChicaneLabel]: ["Chicane", ChicanePrmsOrder, ChicanePrmsLabel],
        [AlignmentLabel]: ["Alignment", AlignErrorPrmsOrder, AlignErrorUPrmsLabel],
        [DispersionLabel]: ["Dispersion", DispersionPrmsOrder, DispersionPrmsLabel],
        [SimCondLabel]: ["SimCtrl", SimCtrlsPrmsOrder, SimCtrlsPrmsLabel],
        [DataDumpLabel]: ["DataDump", DataOutPrmsOrder, DataOutPrmsLabel],
        [OutFileLabel]: ["Outfile", OutputOptionsOrder, OutputOptionsLabel],
        [PartConfLabel]: ["PartFmt", ParticleConfigOrder, ParticleConfigLabel],
        [PrePLabel]: ["PreP", PreProcessPrmOrder, PreProcessPrmLabel],
        [PostPLabel]: ["PostP", PostProcessPrmOrder, PostProcessPrmLabel],
    };
    let keys = Object.keys(categsufs);

    let suf = ["Prm", "Vec", "Bool", "Sel", "Str", "Data"];
    let ctypes = ["double", "vector<double>", "bool", "string", "string", ""];
    // length of suf & ctypes should be the same

    let simplel = "Simple"
    let headers;
    let defvalues = {};
    let maplabels = [], mapsimples = [];
    for(let n = 0; n < keys.length; n++){
        headers =  CopyJSON(hdrorg);

        let prmobjs = {};

        DumpObjHeaderOption(categsufs[keys[n]][1], categsufs[keys[n]][2], prmobjs, GUIConf.defref[keys[n]], headers);
        headers = ConcatHeaderObjs(suf, ctypes, categsufs[keys[n]][0], simplel, headers, crnumv, crnums, defvalues);
        data += "// "+keys[n]+"\n";
        data += headers+"\n";

        maplabels.push(categsufs[keys[n]][0]);
        mapsimples.push(categsufs[keys[n]][0]+simplel);
    }

    data = data.replaceAll("null", "0");

    data += "// import data format\n";
    data += ExportAsciiFormat();

    data += "const map<string, int> SliceIndex {\n"
    for(let j = 0; j < SliceTitles.length; j++){
        if(j > 0){
            data += ",\n"
        }
        data += "\t{\""+SliceTitles[j]+"\", "+j.toString()+"}";
    }
    data += "\n};\n\n"

    let enumkeys = [], keystrs = [];
    for(let j = 0; j < keys.length; j++){
        enumkeys.push(categsufs[keys[j]][0]+"_");
        keystrs.push("\""+keys[j]+"\"");
    }
    enumkeys[0] += " = 0";
    enumkeys.push("Categories");

    data += "// parameter categories\n";
    data += "enum CategoryOrder "+FormatCSVString(enumkeys.join(", "), crnumv, false)+"\n"

    data += FormatCppVector("string")+" CategoryNames "+FormatCSVString(keystrs.join(", "), crnumv, false)+"\n"

    data += FormatCppVector(MapCont)+" ParameterFullNames "+FormatCSVString(maplabels.join(", "), crnumv, false)+"\n";
    data += FormatCppVector(MapCont)+" ParameterSimples "+FormatCSVString(mapsimples.join(", "), crnumv, false)+"\n";

    let defaults = new Array(suf.length);
    for(let n = 0; n < suf.length; n++){
        if(ctypes[n] == ""){
            continue;
        }
        defaults[n] = FormatCppVectorDouble(ctypes[n])+" Default"+suf[n]+" "+FormatCSVString(defvalues[suf[n]].join(", "), crnumv, false);
    } 

    data += defaults.join("\n");

    data += "const double GainPerStep = "+GainPerStep.toString()+";\n\n";
    data += "const int MinimumParticles = "+MinimumParticles.toString()+";\n\n";
    data += "const int JSONIndent = "+JSONIndent+";\n\n";
    data += "#endif"

    let blob = new Blob([data], {type:"text/plain"});
    let link = document.createElement("a");
    link.href = window.URL.createObjectURL(blob);
    link.download = "simplex_input.h";
    link.click();
    link.remove();
}

function ExportAsciiFormat()
{
    let labels = [
        [CustomSlice, "slicefile"],
        [CustomCurrent, "currfile"],
        [CustomEt, "etfile"],
        [CustomParticle, "partfile"],
        [UndDataLabel],
        [WakeDataLabel, "wakecustomdata"],
        [MonoDataLabel, "monodata"],
    ];
    let objs = [[], []];
    for(let i = 0; i < labels.length; i++){
        for(let j = 0; j < labels[i].length; j++){
            let tplc = '{"'+labels[i][j]+'"'+", tuple<int, vector<string>> ("+AsciiFormats[labels[i][0]].dim;
            let strbr = JSON.stringify(AsciiFormats[labels[i][0]].titles);
            let tmp = strbr.replace("[", "").replace("]", "");
            tplc += ", {"+tmp+"})}";
            objs[j].push(tplc);    
        }
    }
    let data = "const map<string, tuple<int, vector<string>>> DataFormat {\n\t"+objs[0].join(",\n\t")+"\n};\n\n";
    data += "const map<string, tuple<int, vector<string>>> DataFormatSimple {\n\t"+objs[1].join(",\n\t")+"\n};\n\n";
    return data;
}

function DumpObjHeaderOption(orders, labels, prmobjs, obj, hdrdata)
{
    let hdridx, isstr, fmt;
    for(let i = 0; i < orders.length; i++){
        isstr = false;
        if(orders[i] == SeparatorLabel){
            continue;
        }
        else if(labels[orders[i]][1] == SimpleLabel){
            continue;
        }
        else if(labels[orders[i]][1] == PlotObjLabel){
            hdridx = 5; // data
            fmt = DataLabel;
        }
        else if(labels[orders[i]][1] == GridLabel){
            hdridx = 5; // data
            fmt = GridLabel;
        }
        else if(Array.isArray(labels[orders[i]][1])){
            if(labels[orders[i]].length > 2 && labels[orders[i]][2] == SelectionLabel){
                hdridx = 3; // selection
                let brac = [];
                for(let j = 0; j < labels[orders[i]][1].length; j++){
                    brac.push('"'+labels[orders[i]][1][j]+'"');
                }
                hdrdata[hdridx].select.push(brac);
                isstr = true;
                fmt = SelectionLabel;    
            }
            else{
                hdridx = 1; // vertor
                fmt = ArrayLabel;
            }
        }
        else if(typeof labels[orders[i]][1] == "boolean"){
            hdridx = 2; // boolean
            fmt = BoolLabel;
        }
        else{
            if(typeof obj[labels[orders[i]][1]] == "object"){
                console.log("Invalid format for "+labels[orders[i]][0]);
                continue;
            }
            if(typeof labels[orders[i]][1] == "number"){
                hdridx = 0; // number
                fmt = NumberLabel;
            }
            else{
                hdridx = 4; // string
                fmt = StringLabel;
                isstr = true;
            }
        }
        hdrdata[hdridx].enum.push(orders[i]+"_");
        hdrdata[hdridx].str.push(FormatTuple(labels[orders[i]][0], orders[i]+"_", fmt));
        hdrdata[hdridx].strsimp.push(FormatTuple(orders[i], orders[i]+"_", fmt));

        if(labels[orders[i]][1] == FileLabel 
                || labels[orders[i]][1] == FolderLabel){
            hdrdata[hdridx].def.push('""');
        }
        else if(hdridx != 5){
            if(isstr){
                hdrdata[hdridx].def.push('"'+obj[labels[orders[i]][0]].toString()+'"');
            }
            else if(fmt == ArrayLabel){
                hdrdata[hdridx].def.push(obj[labels[orders[i]][0]]);
            }
            else{
                hdrdata[hdridx].def.push(obj[labels[orders[i]][0]].toString());
            }
        }
    }
}

function ConcatHeaderObjs(suf, ctypes, categ, simplel, hdrdata, crnumv, crnums, defvalues)
{
    let enumcont = [];
    let strcont = [];
    let strsimcont = [];
    let defconts = [];
    let defcont;
    let tmp;

    let label = MapLabel+categ;
    let nlabel = "Num"+categ;
    let deflabel = "Def"+categ;
    let types = [];
    for(let n = 0; n < ctypes.length; n++){
        types.push(FormatCppVector(ctypes[n]));

    }
    let numlabels = [];
    let defs = [];
    for(let i = 0; i < suf.length; i++){
        numlabels.push(nlabel+suf[i]);
        defs.push(types[i]+deflabel+suf[i]+" ");
        if(!defvalues.hasOwnProperty(suf[i])){
            defvalues[suf[i]] = [];
        }
        defvalues[suf[i]].push(deflabel+suf[i]);
    }

    for(let n = 0; n < hdrdata.length; n++){
        if(hdrdata[n].enum.length == 0){
            if(n < 5){
                defconts.push(defs[n]+"{};\n");
            }
            continue;
        }
        hdrdata[n].enum[0] += " = 0";
        hdrdata[n].enum.push(numlabels[n]);

        tmp = hdrdata[n].enum.join(", ");
        enumcont.push(FormatCSVString(tmp, crnumv, true));

        strcont.push(hdrdata[n].str.join(",\n\t"));
        strsimcont.push(hdrdata[n].strsimp.join(",\n\t"));

        if(hdrdata[n].hasOwnProperty("def")){
            let crnum = n == 0 || n == 1 || n == 2 ? crnumv : crnums;
            if(n == 1){
                let tmpbra = [];
                for(let i = 0; i < hdrdata[n].def.length; i++){
                    tmpbra.push("{"+hdrdata[n].def[i][0]+", "+hdrdata[n].def[i][1]+"}");
                }
                tmp = tmpbra.join(", ");
                defcont = defs[n]+FormatCSVString(tmp, crnum*2, false);
            }
            else{
                tmp = hdrdata[n].def.join(", ");
                defcont = defs[n]+FormatCSVString(tmp, crnum, false);
            }
            defconts.push(defcont);
        }
    }

    enumcont = "enum "+categ+"Index"+" {\n"+enumcont.join(",\n")+"\n};\n";

    let strf = label+" {\n\t"+strcont.join(",\n\t")+"\n};\n";
    let strsimf = label+simplel+" {\n\t"+strsimcont.join(",\n\t")+"\n};\n";

    let data = [enumcont, strf, strsimf, defconts.join("\n")];
    return data.join("\n");
}
