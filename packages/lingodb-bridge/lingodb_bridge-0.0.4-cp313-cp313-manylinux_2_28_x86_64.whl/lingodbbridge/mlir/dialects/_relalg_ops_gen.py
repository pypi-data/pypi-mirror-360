
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "relalg"

@_ods_cext.register_operation(_Dialect)
class AggrFuncOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.aggrfn"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, fn, rel, attr, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fn"] = (fn if (
    isinstance(fn, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RelAlg_AggrFunc')) else
      _ods_ir.AttrBuilder.get('RelAlg_AggrFunc')(fn, context=_ods_context))
    attributes["attr"] = (attr if (
    isinstance(attr, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnRefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnRefAttr')(attr, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def fn(self):
    return self.operation.attributes["fn"]

  @fn.setter
  def fn(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fn"] = value

  @builtins.property
  def attr(self):
    return self.operation.attributes["attr"]

  @attr.setter
  def attr(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["attr"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def aggrfn(result, fn, rel, attr, *, loc=None, ip=None) -> _ods_ir.Value:
  return AggrFuncOp(result=result, fn=fn, rel=rel, attr=attr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AggregationOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.aggregation"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, rel, group_by_cols, computed_cols, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["group_by_cols"] = (group_by_cols if (
    isinstance(group_by_cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(group_by_cols, context=_ods_context))
    attributes["computed_cols"] = (computed_cols if (
    isinstance(computed_cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(computed_cols, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def group_by_cols(self):
    return self.operation.attributes["group_by_cols"]

  @group_by_cols.setter
  def group_by_cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_by_cols"] = value

  @builtins.property
  def computed_cols(self):
    return self.operation.attributes["computed_cols"]

  @computed_cols.setter
  def computed_cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["computed_cols"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def aggr_func(self):
    return self.regions[0]

def aggregation(result, rel, group_by_cols, computed_cols, *, loc=None, ip=None) -> _ods_ir.Value:
  return AggregationOp(result=result, rel=rel, group_by_cols=group_by_cols, computed_cols=computed_cols, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AntiSemiJoinOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.antisemijoin"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, left, right, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(left)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def left(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def predicate(self):
    return self.regions[0]

def antisemijoin(result, left, right, *, loc=None, ip=None) -> _ods_ir.Value:
  return AntiSemiJoinOp(result=result, left=left, right=right, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BaseTableOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.basetable"

  _ODS_REGIONS = (0, True)

  def __init__(self, table_identifier, columns, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["table_identifier"] = (table_identifier if (
    isinstance(table_identifier, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(table_identifier, context=_ods_context))
    attributes["columns"] = (columns if (
    isinstance(columns, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
      _ods_ir.AttrBuilder.get('DictionaryAttr')(columns, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def table_identifier(self):
    return self.operation.attributes["table_identifier"]

  @table_identifier.setter
  def table_identifier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["table_identifier"] = value

  @builtins.property
  def columns(self):
    return self.operation.attributes["columns"]

  @columns.setter
  def columns(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["columns"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def basetable(table_identifier, columns, *, loc=None, ip=None) -> _ods_ir.Value:
  return BaseTableOp(table_identifier=table_identifier, columns=columns, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectionJoinOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.collectionjoin"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, cols, collAttr, left, right, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(left)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cols"] = (cols if (
    isinstance(cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(cols, context=_ods_context))
    attributes["collAttr"] = (collAttr if (
    isinstance(collAttr, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnDefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnDefAttr')(collAttr, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def left(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def cols(self):
    return self.operation.attributes["cols"]

  @cols.setter
  def cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cols"] = value

  @builtins.property
  def collAttr(self):
    return self.operation.attributes["collAttr"]

  @collAttr.setter
  def collAttr(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["collAttr"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def predicate(self):
    return self.regions[0]

def collectionjoin(result, cols, coll_attr, left, right, *, loc=None, ip=None) -> _ods_ir.Value:
  return CollectionJoinOp(result=result, cols=cols, collAttr=coll_attr, left=left, right=right, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstRelationOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.const_relation"

  _ODS_REGIONS = (0, True)

  def __init__(self, columns, values, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["columns"] = (columns if (
    isinstance(columns, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(columns, context=_ods_context))
    attributes["values"] = (values if (
    isinstance(values, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(values, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def columns(self):
    return self.operation.attributes["columns"]

  @columns.setter
  def columns(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["columns"] = value

  @builtins.property
  def values(self):
    return self.operation.attributes["values"]

  @values.setter
  def values(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["values"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def const_relation(columns, values, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConstRelationOp(columns=columns, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CountRowsOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, rel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def res(self):
    return self.operation.results[0]

def count(rel, *, loc=None, ip=None) -> _ods_ir.Value:
  return CountRowsOp(rel=rel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CrossProductOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.crossproduct"

  _ODS_REGIONS = (0, True)

  def __init__(self, left, right, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(left)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def left(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def crossproduct(left, right, *, loc=None, ip=None) -> _ods_ir.Value:
  return CrossProductOp(left=left, right=right, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExceptOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.except"

  _ODS_REGIONS = (0, True)

  def __init__(self, set_semantic, left, right, mapping, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(left)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["set_semantic"] = (set_semantic if (
    isinstance(set_semantic, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RelAlg_SetSemantic')) else
      _ods_ir.AttrBuilder.get('RelAlg_SetSemantic')(set_semantic, context=_ods_context))
    attributes["mapping"] = (mapping if (
    isinstance(mapping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(mapping, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def left(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def set_semantic(self):
    return self.operation.attributes["set_semantic"]

  @set_semantic.setter
  def set_semantic(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["set_semantic"] = value

  @builtins.property
  def mapping(self):
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mapping"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def except_(set_semantic, left, right, mapping, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExceptOp(set_semantic=set_semantic, left=left, right=right, mapping=mapping, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExistsOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.exists"

  _ODS_REGIONS = (0, True)

  def __init__(self, rel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def exists(rel, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExistsOp(rel=rel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FullOuterJoinOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.fullouterjoin"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, left, right, mapping, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(left)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mapping"] = (mapping if (
    isinstance(mapping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(mapping, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def left(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def mapping(self):
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mapping"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def predicate(self):
    return self.regions[0]

def fullouterjoin(result, left, right, mapping, *, loc=None, ip=None) -> _ods_ir.Value:
  return FullOuterJoinOp(result=result, left=left, right=right, mapping=mapping, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetListOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.getlist"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, rel, cols, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cols"] = (cols if (
    isinstance(cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(cols, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def cols(self):
    return self.operation.attributes["cols"]

  @cols.setter
  def cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cols"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def getlist(res, rel, cols, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetListOp(res=res, rel=rel, cols=cols, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.getscalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, attr, rel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["attr"] = (attr if (
    isinstance(attr, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnRefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnRefAttr')(attr, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def attr(self):
    return self.operation.attributes["attr"]

  @attr.setter
  def attr(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["attr"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def getscalar(res, attr, rel, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetScalarOp(res=res, attr=attr, rel=rel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupJoinOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.groupjoin"

  _ODS_REGIONS = (3, True)

  def __init__(self, result, left, right, behavior, leftCols, rightCols, mapped_cols, computed_cols, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(left)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["behavior"] = (behavior if (
    isinstance(behavior, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RelAlg_GroupJoinBehavior')) else
      _ods_ir.AttrBuilder.get('RelAlg_GroupJoinBehavior')(behavior, context=_ods_context))
    attributes["leftCols"] = (leftCols if (
    isinstance(leftCols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(leftCols, context=_ods_context))
    attributes["rightCols"] = (rightCols if (
    isinstance(rightCols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(rightCols, context=_ods_context))
    attributes["mapped_cols"] = (mapped_cols if (
    isinstance(mapped_cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(mapped_cols, context=_ods_context))
    attributes["computed_cols"] = (computed_cols if (
    isinstance(computed_cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(computed_cols, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def left(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def behavior(self):
    return self.operation.attributes["behavior"]

  @behavior.setter
  def behavior(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["behavior"] = value

  @builtins.property
  def leftCols(self):
    return self.operation.attributes["leftCols"]

  @leftCols.setter
  def leftCols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["leftCols"] = value

  @builtins.property
  def rightCols(self):
    return self.operation.attributes["rightCols"]

  @rightCols.setter
  def rightCols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rightCols"] = value

  @builtins.property
  def mapped_cols(self):
    return self.operation.attributes["mapped_cols"]

  @mapped_cols.setter
  def mapped_cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mapped_cols"] = value

  @builtins.property
  def computed_cols(self):
    return self.operation.attributes["computed_cols"]

  @computed_cols.setter
  def computed_cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["computed_cols"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def predicate(self):
    return self.regions[0]

  @builtins.property
  def map_func(self):
    return self.regions[1]

  @builtins.property
  def aggr_func(self):
    return self.regions[2]

def groupjoin(result, left, right, behavior, left_cols, right_cols, mapped_cols, computed_cols, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupJoinOp(result=result, left=left, right=right, behavior=behavior, leftCols=left_cols, rightCols=right_cols, mapped_cols=mapped_cols, computed_cols=computed_cols, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.in"

  _ODS_REGIONS = (0, True)

  def __init__(self, val, rel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(val)
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def val(self):
    return self.operation.operands[0]

  @builtins.property
  def rel(self):
    return self.operation.operands[1]

  @builtins.property
  def res(self):
    return self.operation.results[0]

def in_(val, rel, *, loc=None, ip=None) -> _ods_ir.Value:
  return InOp(val=val, rel=rel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InnerJoinOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.join"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, left, right, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(left)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def left(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def predicate(self):
    return self.regions[0]

def join(result, left, right, *, loc=None, ip=None) -> _ods_ir.Value:
  return InnerJoinOp(result=result, left=left, right=right, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntersectOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.intersect"

  _ODS_REGIONS = (0, True)

  def __init__(self, set_semantic, left, right, mapping, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(left)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["set_semantic"] = (set_semantic if (
    isinstance(set_semantic, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RelAlg_SetSemantic')) else
      _ods_ir.AttrBuilder.get('RelAlg_SetSemantic')(set_semantic, context=_ods_context))
    attributes["mapping"] = (mapping if (
    isinstance(mapping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(mapping, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def left(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def set_semantic(self):
    return self.operation.attributes["set_semantic"]

  @set_semantic.setter
  def set_semantic(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["set_semantic"] = value

  @builtins.property
  def mapping(self):
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mapping"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def intersect(set_semantic, left, right, mapping, *, loc=None, ip=None) -> _ods_ir.Value:
  return IntersectOp(set_semantic=set_semantic, left=left, right=right, mapping=mapping, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LimitOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.limit"

  _ODS_REGIONS = (0, True)

  def __init__(self, max_rows, rel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["max_rows"] = (max_rows if (
    isinstance(max_rows, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(max_rows, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def max_rows(self):
    return self.operation.attributes["max_rows"]

  @max_rows.setter
  def max_rows(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_rows"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def limit(max_rows, rel, *, loc=None, ip=None) -> _ods_ir.Value:
  return LimitOp(max_rows=max_rows, rel=rel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MapOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.map"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, rel, computed_cols, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["computed_cols"] = (computed_cols if (
    isinstance(computed_cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(computed_cols, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def computed_cols(self):
    return self.operation.attributes["computed_cols"]

  @computed_cols.setter
  def computed_cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["computed_cols"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def predicate(self):
    return self.regions[0]

def map(result, rel, computed_cols, *, loc=None, ip=None) -> _ods_ir.Value:
  return MapOp(result=result, rel=rel, computed_cols=computed_cols, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MarkJoinOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.markjoin"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, markattr, left, right, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(left)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["markattr"] = (markattr if (
    isinstance(markattr, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnDefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnDefAttr')(markattr, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def left(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def markattr(self):
    return self.operation.attributes["markattr"]

  @markattr.setter
  def markattr(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["markattr"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def predicate(self):
    return self.regions[0]

def markjoin(result, markattr, left, right, *, loc=None, ip=None) -> _ods_ir.Value:
  return MarkJoinOp(result=result, markattr=markattr, left=left, right=right, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaterializeOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.materialize"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, rel, cols, columns, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cols"] = (cols if (
    isinstance(cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(cols, context=_ods_context))
    attributes["columns"] = (columns if (
    isinstance(columns, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(columns, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def cols(self):
    return self.operation.attributes["cols"]

  @cols.setter
  def cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cols"] = value

  @builtins.property
  def columns(self):
    return self.operation.attributes["columns"]

  @columns.setter
  def columns(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["columns"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def materialize(result, rel, cols, columns, *, loc=None, ip=None) -> _ods_ir.Value:
  return MaterializeOp(result=result, rel=rel, cols=cols, columns=columns, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NestedOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.nested"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, inputs, used_cols, available_cols, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["used_cols"] = (used_cols if (
    isinstance(used_cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(used_cols, context=_ods_context))
    attributes["available_cols"] = (available_cols if (
    isinstance(available_cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(available_cols, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def used_cols(self):
    return self.operation.attributes["used_cols"]

  @used_cols.setter
  def used_cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["used_cols"] = value

  @builtins.property
  def available_cols(self):
    return self.operation.attributes["available_cols"]

  @available_cols.setter
  def available_cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["available_cols"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def nested_fn(self):
    return self.regions[0]

def nested(result, inputs, used_cols, available_cols, *, loc=None, ip=None) -> _ods_ir.Value:
  return NestedOp(result=result, inputs=inputs, used_cols=used_cols, available_cols=available_cols, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OuterJoinOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.outerjoin"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, left, right, mapping, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(left)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mapping"] = (mapping if (
    isinstance(mapping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(mapping, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def left(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def mapping(self):
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mapping"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def predicate(self):
    return self.regions[0]

def outerjoin(result, left, right, mapping, *, loc=None, ip=None) -> _ods_ir.Value:
  return OuterJoinOp(result=result, left=left, right=right, mapping=mapping, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ProjectionOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.projection"

  _ODS_REGIONS = (0, True)

  def __init__(self, set_semantic, rel, cols, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["set_semantic"] = (set_semantic if (
    isinstance(set_semantic, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RelAlg_SetSemantic')) else
      _ods_ir.AttrBuilder.get('RelAlg_SetSemantic')(set_semantic, context=_ods_context))
    attributes["cols"] = (cols if (
    isinstance(cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(cols, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def set_semantic(self):
    return self.operation.attributes["set_semantic"]

  @set_semantic.setter
  def set_semantic(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["set_semantic"] = value

  @builtins.property
  def cols(self):
    return self.operation.attributes["cols"]

  @cols.setter
  def cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cols"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def projection(set_semantic, rel, cols, *, loc=None, ip=None) -> _ods_ir.Value:
  return ProjectionOp(set_semantic=set_semantic, rel=rel, cols=cols, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class QueryOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.query"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def query_ops(self):
    return self.regions[0]

def query(results_, inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(QueryOp(results_=results_, inputs=inputs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class QueryReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.query_return"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def query_return(inputs, *, loc=None, ip=None) -> _ods_ir.Operation:
  return QueryReturnOp(inputs=inputs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RankOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.rank"

  _ODS_REGIONS = (0, True)

  def __init__(self, rel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def res(self):
    return self.operation.results[0]

def rank(rel, *, loc=None, ip=None) -> _ods_ir.Value:
  return RankOp(rel=rel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RenamingOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.renaming"

  _ODS_REGIONS = (0, True)

  def __init__(self, rel, columns, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["columns"] = (columns if (
    isinstance(columns, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(columns, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def columns(self):
    return self.operation.attributes["columns"]

  @columns.setter
  def columns(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["columns"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def renaming(rel, columns, *, loc=None, ip=None) -> _ods_ir.Value:
  return RenamingOp(rel=rel, columns=columns, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectionOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.selection"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, rel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def predicate(self):
    return self.regions[0]

def selection(result, rel, *, loc=None, ip=None) -> _ods_ir.Value:
  return SelectionOp(result=result, rel=rel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SemiJoinOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.semijoin"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, left, right, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(left)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def left(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def predicate(self):
    return self.regions[0]

def semijoin(result, left, right, *, loc=None, ip=None) -> _ods_ir.Value:
  return SemiJoinOp(result=result, left=left, right=right, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SingleJoinOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.singlejoin"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, left, right, mapping, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(left)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mapping"] = (mapping if (
    isinstance(mapping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(mapping, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def left(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def mapping(self):
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mapping"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def predicate(self):
    return self.regions[0]

def singlejoin(result, left, right, mapping, *, loc=None, ip=None) -> _ods_ir.Value:
  return SingleJoinOp(result=result, left=left, right=right, mapping=mapping, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SortOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.sort"

  _ODS_REGIONS = (0, True)

  def __init__(self, rel, sortspecs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sortspecs"] = (sortspecs if (
    isinstance(sortspecs, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(sortspecs, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def sortspecs(self):
    return self.operation.attributes["sortspecs"]

  @sortspecs.setter
  def sortspecs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sortspecs"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def sort(rel, sortspecs, *, loc=None, ip=None) -> _ods_ir.Value:
  return SortOp(rel=rel, sortspecs=sortspecs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TmpOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.tmp"

  _ODS_REGIONS = (0, True)

  def __init__(self, resulting, rel, cols, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cols"] = (cols if (
    isinstance(cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(cols, context=_ods_context))
    results.extend(resulting)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def cols(self):
    return self.operation.attributes["cols"]

  @cols.setter
  def cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cols"] = value

  @builtins.property
  def resulting(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def tmp(resulting, rel, cols, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TmpOp(resulting=resulting, rel=rel, cols=cols, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TopKOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.topk"

  _ODS_REGIONS = (0, True)

  def __init__(self, max_rows, rel, sortspecs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["max_rows"] = (max_rows if (
    isinstance(max_rows, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(max_rows, context=_ods_context))
    attributes["sortspecs"] = (sortspecs if (
    isinstance(sortspecs, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(sortspecs, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def max_rows(self):
    return self.operation.attributes["max_rows"]

  @max_rows.setter
  def max_rows(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_rows"] = value

  @builtins.property
  def sortspecs(self):
    return self.operation.attributes["sortspecs"]

  @sortspecs.setter
  def sortspecs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sortspecs"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def topk(max_rows, rel, sortspecs, *, loc=None, ip=None) -> _ods_ir.Value:
  return TopKOp(max_rows=max_rows, rel=rel, sortspecs=sortspecs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TrackTuplesOP(_ods_ir.OpView):
  OPERATION_NAME = "relalg.track_tuples"

  _ODS_REGIONS = (0, True)

  def __init__(self, rel, resultId, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["resultId"] = (resultId if (
    isinstance(resultId, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(resultId, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def resultId(self):
    return self.operation.attributes["resultId"]

  @resultId.setter
  def resultId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resultId"] = value

def track_tuples(rel, result_id, *, loc=None, ip=None) -> _ods_ir.Operation:
  return TrackTuplesOP(rel=rel, resultId=result_id, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class UnionOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.union"

  _ODS_REGIONS = (0, True)

  def __init__(self, set_semantic, left, right, mapping, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(left)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["set_semantic"] = (set_semantic if (
    isinstance(set_semantic, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RelAlg_SetSemantic')) else
      _ods_ir.AttrBuilder.get('RelAlg_SetSemantic')(set_semantic, context=_ods_context))
    attributes["mapping"] = (mapping if (
    isinstance(mapping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(mapping, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def left(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def set_semantic(self):
    return self.operation.attributes["set_semantic"]

  @set_semantic.setter
  def set_semantic(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["set_semantic"] = value

  @builtins.property
  def mapping(self):
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mapping"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def union(set_semantic, left, right, mapping, *, loc=None, ip=None) -> _ods_ir.Value:
  return UnionOp(set_semantic=set_semantic, left=left, right=right, mapping=mapping, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WindowOp(_ods_ir.OpView):
  OPERATION_NAME = "relalg.window"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, rel, partition_by, order_by, computed_cols, from_, to, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["partition_by"] = (partition_by if (
    isinstance(partition_by, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(partition_by, context=_ods_context))
    attributes["order_by"] = (order_by if (
    isinstance(order_by, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(order_by, context=_ods_context))
    attributes["computed_cols"] = (computed_cols if (
    isinstance(computed_cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(computed_cols, context=_ods_context))
    attributes["from"] = (from_ if (
    isinstance(from_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(from_, context=_ods_context))
    attributes["to"] = (to if (
    isinstance(to, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(to, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rel(self):
    return self.operation.operands[0]

  @builtins.property
  def partition_by(self):
    return self.operation.attributes["partition_by"]

  @partition_by.setter
  def partition_by(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["partition_by"] = value

  @builtins.property
  def order_by(self):
    return self.operation.attributes["order_by"]

  @order_by.setter
  def order_by(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["order_by"] = value

  @builtins.property
  def computed_cols(self):
    return self.operation.attributes["computed_cols"]

  @computed_cols.setter
  def computed_cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["computed_cols"] = value

  @builtins.property
  def from_(self):
    return self.operation.attributes["from"]

  @from_.setter
  def from_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["from"] = value

  @builtins.property
  def to(self):
    return self.operation.attributes["to"]

  @to.setter
  def to(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["to"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def aggr_func(self):
    return self.regions[0]

def window(result, rel, partition_by, order_by, computed_cols, from_, to, *, loc=None, ip=None) -> _ods_ir.Value:
  return WindowOp(result=result, rel=rel, partition_by=partition_by, order_by=order_by, computed_cols=computed_cols, from_=from_, to=to, loc=loc, ip=ip).result
