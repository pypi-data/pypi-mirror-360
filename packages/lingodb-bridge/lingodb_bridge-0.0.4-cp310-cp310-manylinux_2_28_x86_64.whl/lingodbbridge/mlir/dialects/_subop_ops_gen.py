
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "subop"

@_ods_cext.register_operation(_Dialect)
class CombineTupleOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.combine_tuple"

  _ODS_REGIONS = (0, True)

  def __init__(self, stream, right, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    operands.append(right)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def res(self):
    return self.operation.results[0]

def combine_tuple(stream, right, *, loc=None, ip=None) -> _ods_ir.Value:
  return CombineTupleOp(stream=stream, right=right, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CreateArrayOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.create_array"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, numElements, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(numElements)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def numElements(self):
    return self.operation.operands[0]

  @builtins.property
  def res(self):
    return self.operation.results[0]

def create_array(res, num_elements, *, loc=None, ip=None) -> _ods_ir.Value:
  return CreateArrayOp(res=res, numElements=num_elements, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CreateContinuousView(_ods_ir.OpView):
  OPERATION_NAME = "subop.create_continuous_view"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def create_continuous_view(result, source, *, loc=None, ip=None) -> _ods_ir.Value:
  return CreateContinuousView(result=result, source=source, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CreateFrom(_ods_ir.OpView):
  OPERATION_NAME = "subop.create_from"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, columns, state, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(state)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["columns"] = (columns if (
    isinstance(columns, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(columns, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def state(self):
    return self.operation.operands[0]

  @builtins.property
  def columns(self):
    return self.operation.attributes["columns"]

  @columns.setter
  def columns(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["columns"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def create_from(result, columns, state, *, loc=None, ip=None) -> _ods_ir.Value:
  return CreateFrom(result=result, columns=columns, state=state, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CreateHashIndexedView(_ods_ir.OpView):
  OPERATION_NAME = "subop.create_hash_indexed_view"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, hash_member, link_member, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["hash_member"] = (hash_member if (
    isinstance(hash_member, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(hash_member, context=_ods_context))
    attributes["link_member"] = (link_member if (
    isinstance(link_member, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(link_member, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def hash_member(self):
    return self.operation.attributes["hash_member"]

  @hash_member.setter
  def hash_member(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hash_member"] = value

  @builtins.property
  def link_member(self):
    return self.operation.attributes["link_member"]

  @link_member.setter
  def link_member(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["link_member"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def create_hash_indexed_view(result, source, hash_member, link_member, *, loc=None, ip=None) -> _ods_ir.Value:
  return CreateHashIndexedView(result=result, source=source, hash_member=hash_member, link_member=link_member, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CreateHeapOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.create_heap"

  _ODS_REGIONS = (1, True)

  def __init__(self, res, sortBy, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sortBy"] = (sortBy if (
    isinstance(sortBy, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(sortBy, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sortBy(self):
    return self.operation.attributes["sortBy"]

  @sortBy.setter
  def sortBy(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sortBy"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

  @builtins.property
  def region(self):
    return self.regions[0]

def create_heap(res, sort_by, *, loc=None, ip=None) -> _ods_ir.Value:
  return CreateHeapOp(res=res, sortBy=sort_by, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CreateSegmentTreeView(_ods_ir.OpView):
  OPERATION_NAME = "subop.create_segment_tree_view"

  _ODS_REGIONS = (2, True)

  def __init__(self, result, source, relevant_members, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["relevant_members"] = (relevant_members if (
    isinstance(relevant_members, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(relevant_members, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def relevant_members(self):
    return self.operation.attributes["relevant_members"]

  @relevant_members.setter
  def relevant_members(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relevant_members"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def initial_fn(self):
    return self.regions[0]

  @builtins.property
  def combine_fn(self):
    return self.regions[1]

def create_segment_tree_view(result, source, relevant_members, *, loc=None, ip=None) -> _ods_ir.Value:
  return CreateSegmentTreeView(result=result, source=source, relevant_members=relevant_members, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CreateSimpleStateOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.create_simple_state"

  _ODS_REGIONS = (1, True)

  def __init__(self, res, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def res(self):
    return self.operation.results[0]

  @builtins.property
  def initFn(self):
    return self.regions[0]

def create_simple_state(res, *, loc=None, ip=None) -> _ods_ir.Value:
  return CreateSimpleStateOp(res=res, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CreateSortedViewOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.create_sorted_view"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, toSort, sortBy, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(toSort)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sortBy"] = (sortBy if (
    isinstance(sortBy, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(sortBy, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def toSort(self):
    return self.operation.operands[0]

  @builtins.property
  def sortBy(self):
    return self.operation.attributes["sortBy"]

  @sortBy.setter
  def sortBy(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sortBy"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def region(self):
    return self.regions[0]

def create_sorted_view(result, to_sort, sort_by, *, loc=None, ip=None) -> _ods_ir.Value:
  return CreateSortedViewOp(result=result, toSort=to_sort, sortBy=sort_by, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CreateThreadLocalOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.create_thread_local"

  _ODS_REGIONS = (1, True)

  def __init__(self, res, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def res(self):
    return self.operation.results[0]

  @builtins.property
  def initFn(self):
    return self.regions[0]

def create_thread_local(res, *, loc=None, ip=None) -> _ods_ir.Value:
  return CreateThreadLocalOp(res=res, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EntriesBetweenOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.entries_between"

  _ODS_REGIONS = (0, True)

  def __init__(self, stream, left_ref, right_ref, between, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["left_ref"] = (left_ref if (
    isinstance(left_ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnRefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnRefAttr')(left_ref, context=_ods_context))
    attributes["right_ref"] = (right_ref if (
    isinstance(right_ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnRefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnRefAttr')(right_ref, context=_ods_context))
    attributes["between"] = (between if (
    isinstance(between, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnDefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnDefAttr')(between, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def left_ref(self):
    return self.operation.attributes["left_ref"]

  @left_ref.setter
  def left_ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["left_ref"] = value

  @builtins.property
  def right_ref(self):
    return self.operation.attributes["right_ref"]

  @right_ref.setter
  def right_ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["right_ref"] = value

  @builtins.property
  def between(self):
    return self.operation.attributes["between"]

  @between.setter
  def between(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["between"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def entries_between(stream, left_ref, right_ref, between, *, loc=None, ip=None) -> _ods_ir.Value:
  return EntriesBetweenOp(stream=stream, left_ref=left_ref, right_ref=right_ref, between=between, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutionGroupOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.execution_group"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def sub_ops(self):
    return self.regions[0]

def execution_group(results_, inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ExecutionGroupOp(results_=results_, inputs=inputs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ExecutionGroupReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.execution_group_return"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def execution_group_return(inputs, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutionGroupReturnOp(inputs=inputs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutionStepOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.execution_step"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, inputs, is_thread_local, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["is_thread_local"] = (is_thread_local if (
    isinstance(is_thread_local, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolArrayAttr')) else
      _ods_ir.AttrBuilder.get('BoolArrayAttr')(is_thread_local, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def is_thread_local(self):
    return self.operation.attributes["is_thread_local"]

  @is_thread_local.setter
  def is_thread_local(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_thread_local"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def sub_ops(self):
    return self.regions[0]

def execution_step(results_, inputs, is_thread_local, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ExecutionStepOp(results_=results_, inputs=inputs, is_thread_local=is_thread_local, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ExecutionStepReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.execution_step_return"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def execution_step_return(inputs, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutionStepReturnOp(inputs=inputs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FilterOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.filter"

  _ODS_REGIONS = (0, True)

  def __init__(self, stream, filterSemantic, conditions, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["filterSemantic"] = (filterSemantic if (
    isinstance(filterSemantic, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FilterSemantic')) else
      _ods_ir.AttrBuilder.get('FilterSemantic')(filterSemantic, context=_ods_context))
    attributes["conditions"] = (conditions if (
    isinstance(conditions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(conditions, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def filterSemantic(self):
    return self.operation.attributes["filterSemantic"]

  @filterSemantic.setter
  def filterSemantic(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filterSemantic"] = value

  @builtins.property
  def conditions(self):
    return self.operation.attributes["conditions"]

  @conditions.setter
  def conditions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["conditions"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def filter(stream, filter_semantic, conditions, *, loc=None, ip=None) -> _ods_ir.Value:
  return FilterOp(stream=stream, filterSemantic=filter_semantic, conditions=conditions, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GatherOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, stream, ref, mapping, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ref"] = (ref if (
    isinstance(ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnRefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnRefAttr')(ref, context=_ods_context))
    attributes["mapping"] = (mapping if (
    isinstance(mapping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
      _ods_ir.AttrBuilder.get('DictionaryAttr')(mapping, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def ref(self):
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ref"] = value

  @builtins.property
  def mapping(self):
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mapping"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def gather(stream, ref, mapping, *, loc=None, ip=None) -> _ods_ir.Value:
  return GatherOp(stream=stream, ref=ref, mapping=mapping, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GenerateEmitOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.generate_emit"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def generate_emit(values, *, loc=None, ip=None) -> _ods_ir.Operation:
  return GenerateEmitOp(values=values, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GenerateOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.generate"

  _ODS_REGIONS = (1, True)

  def __init__(self, res, streams, generated_columns, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["generated_columns"] = (generated_columns if (
    isinstance(generated_columns, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(generated_columns, context=_ods_context))
    results.append(res)
    results.extend(streams)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def generated_columns(self):
    return self.operation.attributes["generated_columns"]

  @generated_columns.setter
  def generated_columns(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["generated_columns"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

  @builtins.property
  def streams(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

  @builtins.property
  def region(self):
    return self.regions[0]

def generate(res, streams, generated_columns, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(GenerateOp(res=res, streams=streams, generated_columns=generated_columns, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GenericCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def res(self):
    return self.operation.results[0]

def create_(res, *, loc=None, ip=None) -> _ods_ir.Value:
  return GenericCreateOp(res=res, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetBeginReferenceOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.get_begin_ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, stream, state, ref, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    operands.append(state)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ref"] = (ref if (
    isinstance(ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnDefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnDefAttr')(ref, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def state(self):
    return self.operation.operands[1]

  @builtins.property
  def ref(self):
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ref"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def get_begin_ref(stream, state, ref, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetBeginReferenceOp(stream=stream, state=state, ref=ref, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetEndReferenceOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.get_end_ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, stream, state, ref, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    operands.append(state)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ref"] = (ref if (
    isinstance(ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnDefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnDefAttr')(ref, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def state(self):
    return self.operation.operands[1]

  @builtins.property
  def ref(self):
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ref"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def get_end_ref(stream, state, ref, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetEndReferenceOp(stream=stream, state=state, ref=ref, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetExternalOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.get_external"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, descr, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["descr"] = (descr if (
    isinstance(descr, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(descr, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def descr(self):
    return self.operation.attributes["descr"]

  @descr.setter
  def descr(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["descr"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def get_external(res, descr, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetExternalOp(res=res, descr=descr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InFlightOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.in_flight"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, columns, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["columns"] = (columns if (
    isinstance(columns, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(columns, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def columns(self):
    return self.operation.attributes["columns"]

  @columns.setter
  def columns(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["columns"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def in_flight(values, columns, *, loc=None, ip=None) -> _ods_ir.Value:
  return InFlightOp(values=values, columns=columns, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InFlightTupleOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.in_flight_tuple"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, columns, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["columns"] = (columns if (
    isinstance(columns, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(columns, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def columns(self):
    return self.operation.attributes["columns"]

  @columns.setter
  def columns(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["columns"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def in_flight_tuple(values, columns, *, loc=None, ip=None) -> _ods_ir.Value:
  return InFlightTupleOp(values=values, columns=columns, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InsertOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.insert"

  _ODS_REGIONS = (1, True)

  def __init__(self, stream, state, mapping, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    operands.append(state)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mapping"] = (mapping if (
    isinstance(mapping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
      _ods_ir.AttrBuilder.get('DictionaryAttr')(mapping, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def state(self):
    return self.operation.operands[1]

  @builtins.property
  def mapping(self):
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mapping"] = value

  @builtins.property
  def eqFn(self):
    return self.regions[0]

def insert(stream, state, mapping, *, loc=None, ip=None) -> _ods_ir.Operation:
  return InsertOp(stream=stream, state=state, mapping=mapping, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LockOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.lock"

  _ODS_REGIONS = (1, True)

  def __init__(self, res, stream, ref, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ref"] = (ref if (
    isinstance(ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnRefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnRefAttr')(ref, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def ref(self):
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ref"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

  @builtins.property
  def nested(self):
    return self.regions[0]

def lock(res, stream, ref, *, loc=None, ip=None) -> _ods_ir.Value:
  return LockOp(res=res, stream=stream, ref=ref, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LookupOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.lookup"

  _ODS_REGIONS = (2, True)

  def __init__(self, res, stream, state, keys, ref, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    operands.append(state)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["keys"] = (keys if (
    isinstance(keys, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(keys, context=_ods_context))
    attributes["ref"] = (ref if (
    isinstance(ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnDefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnDefAttr')(ref, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def state(self):
    return self.operation.operands[1]

  @builtins.property
  def keys(self):
    return self.operation.attributes["keys"]

  @keys.setter
  def keys(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keys"] = value

  @builtins.property
  def ref(self):
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ref"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

  @builtins.property
  def eqFn(self):
    return self.regions[0]

  @builtins.property
  def initFn(self):
    return self.regions[1]

def lookup(res, stream, state, keys, ref, *, loc=None, ip=None) -> _ods_ir.Value:
  return LookupOp(res=res, stream=stream, state=state, keys=keys, ref=ref, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LookupOrInsertOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.lookup_or_insert"

  _ODS_REGIONS = (2, True)

  def __init__(self, res, stream, state, keys, ref, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    operands.append(state)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["keys"] = (keys if (
    isinstance(keys, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(keys, context=_ods_context))
    attributes["ref"] = (ref if (
    isinstance(ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnDefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnDefAttr')(ref, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def state(self):
    return self.operation.operands[1]

  @builtins.property
  def keys(self):
    return self.operation.attributes["keys"]

  @keys.setter
  def keys(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keys"] = value

  @builtins.property
  def ref(self):
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ref"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

  @builtins.property
  def eqFn(self):
    return self.regions[0]

  @builtins.property
  def initFn(self):
    return self.regions[1]

def lookup_or_insert(res, stream, state, keys, ref, *, loc=None, ip=None) -> _ods_ir.Value:
  return LookupOrInsertOp(res=res, stream=stream, state=state, keys=keys, ref=ref, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LoopContinueOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.loop_continue"

  _ODS_REGIONS = (0, True)

  def __init__(self, cond_state, cond_member, values, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(cond_state)
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cond_member"] = (cond_member if (
    isinstance(cond_member, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(cond_member, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond_state(self):
    return self.operation.operands[0]

  @builtins.property
  def values(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def cond_member(self):
    return self.operation.attributes["cond_member"]

  @cond_member.setter
  def cond_member(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cond_member"] = value

def loop_continue(cond_state, cond_member, values, *, loc=None, ip=None) -> _ods_ir.Operation:
  return LoopContinueOp(cond_state=cond_state, cond_member=cond_member, values=values, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LoopOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.loop"

  _ODS_REGIONS = (1, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def bodyRegion(self):
    return self.regions[0]

def loop(res, args, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LoopOp(res=res, args=args, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MapOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.map"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, stream, computed_cols, input_cols, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["computed_cols"] = (computed_cols if (
    isinstance(computed_cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(computed_cols, context=_ods_context))
    attributes["input_cols"] = (input_cols if (
    isinstance(input_cols, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(input_cols, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def computed_cols(self):
    return self.operation.attributes["computed_cols"]

  @computed_cols.setter
  def computed_cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["computed_cols"] = value

  @builtins.property
  def input_cols(self):
    return self.operation.attributes["input_cols"]

  @input_cols.setter
  def input_cols(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_cols"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def fn(self):
    return self.regions[0]

def map(result, stream, computed_cols, input_cols, *, loc=None, ip=None) -> _ods_ir.Value:
  return MapOp(result=result, stream=stream, computed_cols=computed_cols, input_cols=input_cols, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaterializeOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.materialize"

  _ODS_REGIONS = (0, True)

  def __init__(self, stream, state, mapping, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    operands.append(state)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mapping"] = (mapping if (
    isinstance(mapping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
      _ods_ir.AttrBuilder.get('DictionaryAttr')(mapping, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def state(self):
    return self.operation.operands[1]

  @builtins.property
  def mapping(self):
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mapping"] = value

def materialize(stream, state, mapping, *, loc=None, ip=None) -> _ods_ir.Operation:
  return MaterializeOp(stream=stream, state=state, mapping=mapping, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MergeOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.merge"

  _ODS_REGIONS = (2, True)

  def __init__(self, res, threadLocal, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(threadLocal)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def threadLocal(self):
    return self.operation.operands[0]

  @builtins.property
  def res(self):
    return self.operation.results[0]

  @builtins.property
  def combineFn(self):
    return self.regions[0]

  @builtins.property
  def eqFn(self):
    return self.regions[1]

def merge(res, thread_local, *, loc=None, ip=None) -> _ods_ir.Value:
  return MergeOp(res=res, threadLocal=thread_local, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NestedExecutionGroupOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.nested_execution_group"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def sub_ops(self):
    return self.regions[0]

def nested_execution_group(results_, inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(NestedExecutionGroupOp(results_=results_, inputs=inputs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class NestedExecutionGroupReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.nested_execution_group_return"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def nested_execution_group_return(inputs, *, loc=None, ip=None) -> _ods_ir.Operation:
  return NestedExecutionGroupReturnOp(inputs=inputs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class NestedMapOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.nested_map"

  _ODS_REGIONS = (1, True)

  def __init__(self, res, stream, parameters, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["parameters"] = (parameters if (
    isinstance(parameters, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(parameters, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def parameters(self):
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["parameters"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

  @builtins.property
  def region(self):
    return self.regions[0]

def nested_map(res, stream, parameters, *, loc=None, ip=None) -> _ods_ir.Value:
  return NestedMapOp(res=res, stream=stream, parameters=parameters, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OffsetReferenceBy(_ods_ir.OpView):
  OPERATION_NAME = "subop.offset_ref_by"

  _ODS_REGIONS = (0, True)

  def __init__(self, stream, ref, idx, newRef, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ref"] = (ref if (
    isinstance(ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnRefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnRefAttr')(ref, context=_ods_context))
    attributes["idx"] = (idx if (
    isinstance(idx, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnRefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnRefAttr')(idx, context=_ods_context))
    attributes["newRef"] = (newRef if (
    isinstance(newRef, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnDefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnDefAttr')(newRef, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def ref(self):
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ref"] = value

  @builtins.property
  def idx(self):
    return self.operation.attributes["idx"]

  @idx.setter
  def idx(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["idx"] = value

  @builtins.property
  def newRef(self):
    return self.operation.attributes["newRef"]

  @newRef.setter
  def newRef(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["newRef"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def offset_ref_by(stream, ref, idx, new_ref, *, loc=None, ip=None) -> _ods_ir.Value:
  return OffsetReferenceBy(stream=stream, ref=ref, idx=idx, newRef=new_ref, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.reduce"

  _ODS_REGIONS = (2, True)

  def __init__(self, stream, ref, columns, members, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ref"] = (ref if (
    isinstance(ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnRefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnRefAttr')(ref, context=_ods_context))
    attributes["columns"] = (columns if (
    isinstance(columns, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(columns, context=_ods_context))
    attributes["members"] = (members if (
    isinstance(members, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(members, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def ref(self):
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ref"] = value

  @builtins.property
  def columns(self):
    return self.operation.attributes["columns"]

  @columns.setter
  def columns(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["columns"] = value

  @builtins.property
  def members(self):
    return self.operation.attributes["members"]

  @members.setter
  def members(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["members"] = value

  @builtins.property
  def region(self):
    return self.regions[0]

  @builtins.property
  def combine(self):
    return self.regions[1]

def reduce(stream, ref, columns, members, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ReduceOp(stream=stream, ref=ref, columns=columns, members=members, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RenamingOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.rename"

  _ODS_REGIONS = (0, True)

  def __init__(self, stream, columns, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["columns"] = (columns if (
    isinstance(columns, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(columns, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def columns(self):
    return self.operation.attributes["columns"]

  @columns.setter
  def columns(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["columns"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def rename(stream, columns, *, loc=None, ip=None) -> _ods_ir.Value:
  return RenamingOp(stream=stream, columns=columns, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScanListOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.scan_list"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, elem, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(list)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["elem"] = (elem if (
    isinstance(elem, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnDefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnDefAttr')(elem, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self):
    return self.operation.operands[0]

  @builtins.property
  def elem(self):
    return self.operation.attributes["elem"]

  @elem.setter
  def elem(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["elem"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def scan_list(list, elem, *, loc=None, ip=None) -> _ods_ir.Value:
  return ScanListOp(list=list, elem=elem, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScanOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.scan"

  _ODS_REGIONS = (0, True)

  def __init__(self, state, mapping, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(state)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mapping"] = (mapping if (
    isinstance(mapping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
      _ods_ir.AttrBuilder.get('DictionaryAttr')(mapping, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def state(self):
    return self.operation.operands[0]

  @builtins.property
  def mapping(self):
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mapping"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def scan(state, mapping, *, loc=None, ip=None) -> _ods_ir.Value:
  return ScanOp(state=state, mapping=mapping, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScanRefsOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.scan_refs"

  _ODS_REGIONS = (0, True)

  def __init__(self, state, ref, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(state)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ref"] = (ref if (
    isinstance(ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnDefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnDefAttr')(ref, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def state(self):
    return self.operation.operands[0]

  @builtins.property
  def ref(self):
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ref"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def scan_refs(state, ref, *, loc=None, ip=None) -> _ods_ir.Value:
  return ScanRefsOp(state=state, ref=ref, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, stream, ref, mapping, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ref"] = (ref if (
    isinstance(ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnRefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnRefAttr')(ref, context=_ods_context))
    attributes["mapping"] = (mapping if (
    isinstance(mapping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
      _ods_ir.AttrBuilder.get('DictionaryAttr')(mapping, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def ref(self):
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ref"] = value

  @builtins.property
  def mapping(self):
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mapping"] = value

def scatter(stream, ref, mapping, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ScatterOp(stream=stream, ref=ref, mapping=mapping, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SetResultOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.set_result"

  _ODS_REGIONS = (0, True)

  def __init__(self, result_id, state, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(state)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["result_id"] = (result_id if (
    isinstance(result_id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(result_id, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def state(self):
    return self.operation.operands[0]

  @builtins.property
  def result_id(self):
    return self.operation.attributes["result_id"]

  @result_id.setter
  def result_id(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_id"] = value

def set_result(result_id, state, *, loc=None, ip=None) -> _ods_ir.Operation:
  return SetResultOp(result_id=result_id, state=state, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SetTrackedCountOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.set_tracked_count"

  _ODS_REGIONS = (0, True)

  def __init__(self, tupleCount, resultId, readState, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(tupleCount)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["resultId"] = (resultId if (
    isinstance(resultId, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(resultId, context=_ods_context))
    attributes["readState"] = (readState if (
    isinstance(readState, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(readState, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def tupleCount(self):
    return self.operation.operands[0]

  @builtins.property
  def resultId(self):
    return self.operation.attributes["resultId"]

  @resultId.setter
  def resultId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resultId"] = value

  @builtins.property
  def readState(self):
    return self.operation.attributes["readState"]

  @readState.setter
  def readState(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["readState"] = value

def set_tracked_count(tuple_count, result_id, read_state, *, loc=None, ip=None) -> _ods_ir.Operation:
  return SetTrackedCountOp(tupleCount=tuple_count, resultId=result_id, readState=read_state, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SimpleStateGetScalar(_ods_ir.OpView):
  OPERATION_NAME = "subop.simple_state_get_scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, state, member, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(state)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["member"] = (member if (
    isinstance(member, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(member, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def state(self):
    return self.operation.operands[0]

  @builtins.property
  def member(self):
    return self.operation.attributes["member"]

  @member.setter
  def member(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["member"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def simple_state_get_scalar(res, state, member, *, loc=None, ip=None) -> _ods_ir.Value:
  return SimpleStateGetScalar(res=res, state=state, member=member, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnionOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.union"

  _ODS_REGIONS = (0, True)

  def __init__(self, streams, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(streams))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def streams(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self):
    return self.operation.results[0]

def union(streams, *, loc=None, ip=None) -> _ods_ir.Value:
  return UnionOp(streams=streams, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnwrapOptionalRefOp(_ods_ir.OpView):
  OPERATION_NAME = "subop.unwrap_optional_ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, stream, optional_ref, ref, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(stream)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["optional_ref"] = (optional_ref if (
    isinstance(optional_ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnRefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnRefAttr')(optional_ref, context=_ods_context))
    attributes["ref"] = (ref if (
    isinstance(ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ColumnDefAttr')) else
      _ods_ir.AttrBuilder.get('ColumnDefAttr')(ref, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def stream(self):
    return self.operation.operands[0]

  @builtins.property
  def optional_ref(self):
    return self.operation.attributes["optional_ref"]

  @optional_ref.setter
  def optional_ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["optional_ref"] = value

  @builtins.property
  def ref(self):
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ref"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def unwrap_optional_ref(stream, optional_ref, ref, *, loc=None, ip=None) -> _ods_ir.Value:
  return UnwrapOptionalRefOp(stream=stream, optional_ref=optional_ref, ref=ref, loc=loc, ip=ip).result
