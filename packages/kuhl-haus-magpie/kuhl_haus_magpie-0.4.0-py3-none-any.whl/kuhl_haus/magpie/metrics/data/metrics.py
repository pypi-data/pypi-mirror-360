from __future__ import annotations

import json
import time
import traceback
from dataclasses import dataclass, field
from typing import Any, List, Dict, Optional
from logging import Logger
from kuhl_haus.magpie.metrics.clients.carbon_poster import CarbonPoster


@dataclass()
class Metrics:
    """
    Represents a Metrics object with attributes for tracking and managing various metrics
    such as counters, attributes, and metadata, as well as methods for processing and
    serializing these metrics. The object also facilitates posting and logging the metrics.

    This class is designed to work within a system that requires structured tracking and
    reporting of performance or operational data. It provides utilities for managing counters,
    attributes, and metadata, as well as methods for serializing and converting these
    metrics into various formats suitable for storage or transmission, such as JSON or
    Graphite-compatible formats. By organizing metrics based on namespaces, hostnames,
    and additional metadata, it enables comprehensive monitoring and diagnostic capabilities.

    Attributes
    ----------
    mnemonic : str
        A unique identifier or short description for the object.
    namespace : str
        A namespace under which metrics are grouped or classified.
    name: str
        A name or identifier for the object.
    hostname : Optional[str]
        The hostname associated with the object, default is an empty string.
    timestamp : Optional[int]
        The timestamp for the object in seconds, default is -1 (autogenerated current time).

    meta : Optional[Dict[str, Any]]
        Metadata dictionary containing additional descriptive attributes for tagging metrics.
    attributes : Optional[Dict[str, Any]]
        A dictionary of key-value pairs describing additional attributes of the object. Values may be any type.
        Values that can be converted to an integer or float will be included in the metrics list.
    counters : Optional[Dict[str, int]]
        A dictionary of counters, where the keys are counter names and
        values are integer counts. Counters are always included in the metrics list.

    Methods
    -------
    __post_init__
        Automatically triggered after the initialization of the dataclass. Assigns
        the current timestamp (seconds) if the default was left unchanged.
    declare_counters(counters: List[str])
        Initializes a dictionary of counters with default values of 0.
    set_counter(counter: str, increment: int)
        Updates or initializes a counter with a specified increment value.
    json
        Converts the object's attributes into a JSON-formatted string representation.
    carbon
        Generates a list of tuples representing Carbon-formatted metrics paths.
    __get_tags
        Constructs metadata tags in a formatted string, skipping empty metadata.
    __add_attributes(path: str, metrics: List[tuple])
        Appends formatted attribute metrics to the metrics list.
    __add_counters(path: str, metrics: List[tuple])
        Appends formatted counter metrics to the metrics list.
    post_metrics(logger: Logger, poster: CarbonPoster)
        Posts the object's metrics to Graphite and logs the operation details.
    log_metrics(logger: Logger)
        Logs the JSON-formatted string of metrics or logs an error if an issue arises.
    """
    mnemonic: str
    namespace: str
    name: str
    hostname: Optional[str] = ""
    timestamp: Optional[int] = -1
    meta: Optional[Dict[str, Any]] = field(default_factory=dict)
    attributes: Optional[Dict[str, Any]] = field(default_factory=dict)
    counters:  Optional[Dict[str, int]] = field(default_factory=dict)

    def __post_init__(self):
        """
        __post_init__

        Automatically called after the dataclass initialization to perform additional
        processing. This method checks if the `timestamp` attribute has been left with
        its default value (-1), and if so, assigns it the current time in seconds.

        Raises
        ------
        None
        """
        if self.timestamp == -1:
            self.timestamp = time.time_ns() // 1_000_000_000

    def declare_counters(self, counters: List[str]):
        """
        Declare counters by initializing them in the `self.counters` dictionary with
        a default value of 0. This method takes a list of counter names, processes
        them in reverse order, and sets their initial values to zero within the
        provided dictionary.

        Parameters:
        counters: List[str]
            A list of strings representing the counter names to be added to
            `self.counters` with an initial value of 0.
        """
        while counters:
            counter = counters.pop()
            self.counters[counter] = 0

    def set_counter(self, counter: str, increment: int):
        """
        Updates the value of a specific counter in the counters dictionary. If the counter
        does not exist, it initializes the counter with the provided increment value.

        Args:
            counter (str): The name of the counter to update or initialize.
            increment (int): The value to add to the counter. If the counter does not
                exist, this value is used to initialize it.
        """
        if counter in self.counters:
            self.counters[counter] += increment
        else:
            self.counters[counter] = increment

    @property
    def json(self) -> str:
        """
        Serialize object data to a JSON-formatted string.

        The `json` property converts the relevant attributes of the object into a
        JSON-formatted string. It includes the object's mnemonic, namespace, timestamp,
        metadata, attributes, and counters.

        Returns
        -------
        str
            A JSON-formatted string representation of the object.
        """
        serialized_result = json.dumps(
            {
                "mnemonic": self.mnemonic,
                "namespace": self.namespace,
                "name": self.name,
                "timestamp": self.timestamp,
                "meta": self.meta,
                "attributes": self.attributes,
                "counters": self.counters,
            }
        )
        return serialized_result

    @property
    def carbon(self) -> List[tuple]:
        """
        Provides a property accessor for generating a list of carbon metrics.

        This method dynamically constructs and collects metric paths based
        on the object's namespace, mnemonic, name, hostname, and associated
        tags. The paths are populated with attributes and counters using
        internal helper methods. The result is a comprehensive list of metrics
        that describe the state or activity related to this object under varying
        contexts.

        Returns:
            List[tuple]: A list of tuples representing metrics paths with
            corresponding data, constructed based on namespace, mnemonic,
            tags, and optionally a hostname (if defined).
        """
        metrics = []
        tags = self.__get_tags()
        tagged_path = f"{self.namespace}.{self.name}.mnemonic.{self.mnemonic}.%s{tags}"
        self.__add_attributes(path=tagged_path, metrics=metrics)
        self.__add_counters(path=tagged_path, metrics=metrics)

        mnemonic_path = f"{self.namespace}.{self.name}.mnemonic.{self.mnemonic}.%s"
        self.__add_attributes(path=mnemonic_path, metrics=metrics)
        self.__add_counters(path=mnemonic_path, metrics=metrics)
        if self.hostname:
            dotless_hostname = self.hostname.replace('.', '_')
            hostname_path = f"{self.namespace}.{self.name}.hostname.{dotless_hostname}.%s"
            self.__add_attributes(path=hostname_path, metrics=metrics)
            self.__add_counters(path=hostname_path, metrics=metrics)

        return metrics

    def __get_tags(self) -> str:
        """
        Generate and return tags constructed from metadata attributes.

        The method iterates over the passed metadata dictionary and constructs a formatted string of key-value
        pairs separated by semicolons. If a value is empty or unavailable, it is skipped in the final result.

        Returns:
            str: A string of metadata tags in key-value pair format, separated by semicolons.

        Raises:
            Catches and continues on ValueError if raised during the metadata processing.
        """
        # disk.used;datacenter=dc1;rack=a1;server=web01
        tags = ""
        for k, v in self.meta.items():
            try:
                if v:
                    tags += f";{k}={v}"
            except ValueError:
                continue
        return tags

    def __add_attributes(self, path: str, metrics: List[tuple]):
        """
        Adds attributes to the metrics list using provided path and timestamp.

        This private method iterates over the `attributes` dictionary of the instance
        and extends the passed `metrics` list with new metrics derived from the dictionary
        keys and values. If the value is numeric (int or float), it is added directly.
        If the value is a string representing a numeric value, it is converted to an
        integer before being added. Non-numeric string values are skipped.

        Parameters:
        path : str
            The string format to define the path where metrics are appended.
        metrics : List[tuple]
            A list of tuples where each tuple represents a path and its associated data
            to be extended with new entries.

        Raises:
            ValueError
                Raised internally when a string value cannot be converted into an integer.
                These cases are caught and handled within the method to continue processing.
        """
        for k, v in self.attributes.items():
            try:
                if isinstance(v, (int, float)):
                    metrics.extend([(path % k, (self.timestamp, v)),])
                elif isinstance(v, str):
                    whole, sep, _ = v.partition('.')
                    value = int(whole)
                    metrics.extend([(path % k, (self.timestamp, value)),])
            except ValueError:
                continue

    def __add_counters(self, path: str, metrics: List[tuple]):
        """
        Private method to add counter metrics.

        The method processes the existing counters in the `self.counters` dictionary
        and adds each counter to the provided `metrics` list. Each counter is formatted
        with the specified path, timestamp, and value. Invalid or mismatched formatting
        is skipped through exception handling.

        Args:
            path: A string pattern used to format the counter keys.
            metrics: A reference to a list where the formatted counters will be added.
        """
        for k, v in self.counters.items():
            try:
                metrics.extend([(path % k, (self.timestamp, int(v))),])
            except ValueError:
                continue

    def post_metrics(self, logger: Logger, poster: CarbonPoster):
        """
        Posts formatted metrics to Graphite and logs the operation.

        Logs the number of metrics posted and their details upon a successful operation.
        Catches and logs any exceptions encountered during the posting process, providing
        details about the error and the associated traceback.  Exceptions are not re-raised.

        Args:
            logger (Logger): The logger instance used for writing info, debug and error logs.
            poster (CarbonPoster): The poster object responsible for posting metrics
                to Graphite.

        Raises:
            Exception: Propagates any unexpected exceptions encountered while logging errors and tracebacks.
        """
        try:
            carbon_metrics = self.carbon
            poster.post_metrics(carbon_metrics)
            logger.info(f"Posted {len(carbon_metrics)} metrics to Graphite.")
            logger.debug(f"Metrics: {carbon_metrics}")
        except Exception as e:
            logger.error(
                f"Unhandled exception raised while posting metrics for {self.mnemonic} ({repr(e)})\r\n"
                f"{traceback.format_exc()}"
            )

    def log_metrics(self, logger: Logger):
        """
        Logs metrics using the provided logger. The method attempts to log the JSON representation
        of metrics with an info-level log. In case of an exception during logging, it logs the
        exception details with an error-level log. Exceptions are not re-raised.

        Args:
            logger (Logger): The logger instance used to log the metric information.

        Raises:
            Exception: Propagates any unexpected exceptions encountered while logging errors and tracebacks.
        """
        try:
            logger.info(self.json)
        except Exception as e:
            logger.error(
                f"Unhandled exception raised while logging for {self.mnemonic} ({repr(e)})\r\n"
                f"{traceback.format_exc()}"
            )

    @staticmethod
    def version_to_float(version_string: str) -> float:
        """
            Converts a version string to a float representation.

            The function processes a version string to extract its major, minor, and
            build components, ensuring the minor component does not exceed 99. The
            extracted components are combined into a float for easy comparison.

            Examples:
            Input         Output
            --------------------
            0.0.1     ->     0.1
            0.0.100   ->   0.100
            0.1.0     ->       1
            0.1.1     ->     1.1
            0.99.1    ->    99.1
            0.100.1   ->    99.1
            1.0.0     ->     100
            1.1.0     ->     110
            1.0.1     ->   100.1
            1.1.1     ->   101.1

            Args:
                version_string: The version string to be converted. It can include
                    major, minor, and build numbers, along with additional suffixes,
                    which will be ignored.

            Returns:
                A float representing the version with the structure MajorMinor.Build (where minor is padded to 2 digits)

            Raises:
                ValueError: If the version string does not contain a valid major number
                    or contains invalid numeric components.
        """

        base_version = version_string.split('-')[0].split('+')[0]
        parts = base_version.split('.')

        major = int(parts[0])
        minor = int(parts[1]) if len(parts) > 1 else 0
        build = int(parts[2]) if len(parts) > 2 else 0

        minor = min(minor, 99)
        minor_str = f"{minor:02d}"
        build = min(build, 65535)
        build_str = f"{build:05d}"

        # Combine as a float
        return float(f"{major}{minor_str}.{build_str}")

    @staticmethod
    def simple_version_to_float(version_string: str) -> float:
        """
            Converts a version string in the format 'major.minor' to a float.

            This function parses a version string which may contain optional suffixes (denoted
            by '-' or '+'), strips these suffixes, and combines the major and minor parts into
            a float. The minor part is padded to three digits for consistent results. If the
            minor value exceeds 999, it is clamped to 999.

            Examples:
            Input         Output
            --------------------
            0.0.1          ->   0.0
            0.0.100        ->   0.0
            0.1.0          ->   0.001
            0.1.1          ->   0.001
            0.99.1         ->   0.099
            0.100.1        ->   0.100
            0.999.1        ->   0.999
            0.1000.1       ->   0.999
            1.0.0          ->   1.0
            1.1.0          ->   1.001
            1.0.1          ->   1.0
            1.1.1          ->   1.001
            1.2.3-alpha    ->   1.002
            2.0.0+build.1  ->   2.0

            Args:
                version_string: A string representing the version, consisting of major and
                                optional minor segments separated by '.'.

            Returns:
                A float representation of the version with the format major.minor.
        """

        base_version = version_string.split('-')[0].split('+')[0]
        parts = base_version.split('.')

        major = int(parts[0])
        minor = int(parts[1]) if len(parts) > 1 else 0

        minor = min(minor, 999)
        minor_str = f"{minor:03d}"

        # Combine as a float
        return float(f"{major}.{minor_str}")

    @staticmethod
    def version_to_int(version_string: str) -> int:
        """
            Convert a version string into an integer representation for easier comparison purposes. The
            version string is expected to follow a format like "major.minor.build[-suffix][+metadata]".
            Only the major, minor, and build components are considered in the conversion. Minor and build
            numbers are clamped to a maximum of 99.

            Examples:
            Input         Output
            --------------------
            0.0.1    ->         1
            0.0.9    ->         9
            0.0.10   ->        10
            0.0.99   ->        99
            0.0.100  ->        99
            0.1.0    ->       100
            0.1.1    ->       101
            0.9.0    ->       900
            0.10.0   ->      1000
            0.99.0   ->      9900
            0.100.0  ->      9900
            1.0.0    ->    10,000

            Parameters:
            version_string: str
                A version string to be converted.

            Returns:
            int
                An integer representation of the version string.
        """
        base_version = version_string.split('-')[0].split('+')[0]
        parts = base_version.split('.')

        major = int(parts[0])
        minor = int(parts[1]) if len(parts) > 1 else 0
        build = int(parts[2]) if len(parts) > 2 else 0

        minor = min(minor, 99)
        minor_str = f"{minor:02d}"
        build = min(build, 99)
        build_str = f"{build:02d}"

        return int(f"{major}{minor_str}{build_str}")
