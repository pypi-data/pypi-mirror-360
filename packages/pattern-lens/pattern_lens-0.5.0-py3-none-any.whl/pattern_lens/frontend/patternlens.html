<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    <title>Attention Pattern Analysis</title>
    <link rel="icon" type="image/svg+xml" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23000" stroke="%23333" stroke-width="1"/><path d="M0,0 L100,100 L0,100 Z" fill="rgba(0,255,255,0.2)"/><path d="M0,0 L15,15 L0,15 Z" fill="rgba(255,255,255,0.3)"/><path d="M15,15 L35,35 L15,35 Z" fill="rgba(255,255,255,0.3)"/><path d="M35,35 L60,60 L35,60 Z" fill="rgba(255,255,255,0.3)"/><path d="M60,60 L100,100 L60,100 Z" fill="rgba(255,255,255,0.3)"/></svg>'>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.2.31/vue.global.min.js"></script>
    <!-- Include lodash library for utility functions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <!-- Include pako library for decompressing SVGZ files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>
    <!-- For decompressing SVGZ files -->
    <!-- Include ag-Grid library for prompts table -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/32.1.0/ag-grid-community.min.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/ag-grid-community@32.2.0/dist/ag-grid-community.min.js"></script>
    <!-- stylesheet -->
        <!-- begin 'style.css' -->
    <style>
    /* CSS Variables */
    :root {
    	/* Colors */
    	--primary: #007bff;
    	--primary-hover: #0056b3;
    	--secondary: #6c757d;
    	--secondary-hover: #545b62;
    	--success: #28a745;
    	--border: #ccc;
    	--text-muted: #666;
    	--bg-light: #f0f0f0;
    	--bg-white: #fff;
    	--shadow: rgba(0, 0, 0, 0.1);
    	--text-color: #000;
    
    	/* Dark mode colors */
    	--dark-bg: #1a1a1a;
    	--dark-text: #ffffff;
    	--dark-border: #444;
    	--dark-bg-light: #2d2d2d;
    	--dark-shadow: rgba(0, 0, 0, 0.3);
    
    	/* Spacing */
    	--space-xs: 3px;
    	--space-sm: 5px;
    	--space-md: 10px;
    	--space-lg: 20px;
    
    	/* Layout */
    	--border-radius: 4px;
    	--container-max-width: 1200px;
    	--checkbox-size: 12px;
    }
    
    /* Base Styles */
    body {
    	font-family: Arial, sans-serif;
    	line-height: 1.4;
    	margin: 0;
    	padding: var(--space-md);
    }
    
    .container {
    	max-width: var(--container-max-width);
    	margin: 0 auto;
    }
    
    /* Header Styles */
    .header-container {
    	display: flex;
    	justify-content: space-between;
    	align-items: center;
    	margin-bottom: 1rem;
    }
    
    .header-title {
    	margin: 0;
    }
    
    .header-controls {
    	display: flex;
    	gap: 1rem;
    	align-items: center;
    }
    
    /* Layout Components */
    .main-selection-content {
    	display: flex;
    	flex-direction: column;
    	border: 2px solid var(--border);
    	height: 800px;
    	min-height: 400px;
    	resize: vertical;
    	overflow: hidden;
    }
    
    .top-filters {
    	display: flex;
    	gap: var(--space-md);
    	height: 350px;
    	border-bottom: 1px solid var(--border);
    	min-height: 100px;
    	max-height: 80vh;
    	padding: var(--space-md);
    	resize: vertical;
    	position: relative;
    	overflow: auto;
    }
    
    /* Functions Filter */
    .functions-filter {
    	width: 200px;
    	min-width: 100px;
    	max-width: 500px;
    	display: flex;
    	flex-direction: column;
    	border: 1px solid var(--border);
    	padding: var(--space-md);
    	border-radius: var(--border-radius);
    	flex-shrink: 0;
    }
    
    /* Filter Components */
    .filter-item {
    	margin-bottom: var(--space-sm);
    	border: 1px solid var(--border);
    	padding: var(--space-sm);
    	border-radius: var(--border-radius);
    }
    
    .filter-label {
    	display: flex;
    	align-items: center;
    	justify-content: space-between;
    	margin-bottom: var(--space-xs);
    }
    
    /* Checkbox Lists */
    .checkbox-list {
    	border: 1px solid var(--border);
    	padding: var(--space-xs);
    	flex: 1;
    	overflow-y: auto;
    	overflow-x: visible;
    }
    
    .checkbox-item {
    	position: relative;
    	display: flex;
    	align-items: center;
    	margin-bottom: 1px;
    	line-height: 1;
    	width: 100%;
    }
    
    .checkbox-item label {
    	display: flex;
    	align-items: center;
    	justify-content: space-between;
    	width: 100%;
    	margin-left: 4px;
    }
    
    .function-name {
    	flex-grow: 1;
    	margin-right: 8px;
    }
    
    input[type="checkbox"] {
    	margin: 0 0.2em 0 0;
    	width: var(--checkbox-size);
    	height: var(--checkbox-size);
    	vertical-align: middle;
    }
    
    /* Head Grid */
    .head-grid {
    	display: flex;
    	gap: 1px;
    	margin: 0 8px;
    	height: 100%;
    	align-items: center;
    }
    
    .headsGrid-col {
    	display: flex;
    	flex-direction: column;
    	gap: 1px;
    	height: 100%;
    	justify-content: center;
    }
    
    .headsGrid-cell {
    	width: 5px;
    	height: 5px;
    	margin: 0.5px;
    	transition: background-color 0.2s ease;
    }
    
    .headsGrid-cell-selected {
    	background-color: #2a1fee;
    }
    
    .headsGrid-cell-empty {
    	background-color: #ac9a9a;
    }
    
    /* Model Grid */
    #modelGrid {
    	flex: 1;
    	min-width: 200px;
    	overflow: auto;
    }
    
    /* Prompt Table */
    .prompt-table {
    	flex: 1;
    	min-height: 200px;
    	display: flex;
    	flex-direction: column;
    	overflow: hidden;
    	position: relative;
    }
    
    .prompts-info {
    	border: 1px solid var(--border);
    	padding: var(--space-sm);
    	border-radius: var(--border-radius);
    }
    
    .prompt-counter {
    	display: flex;
    	align-items: center;
    	justify-content: space-between;
    }
    
    .prompt-text-cell {
    	cursor: pointer;
    }
    
    /* ag-Grid Customization */
    .ag-theme-alpine {
    	height: calc(100% - 3em) !important;
    	width: 100% !important;
    }
    
    .ag-cell-edit-input {
    	height: 100% !important;
    	line-height: normal !important;
    	padding: 0 8px !important;
    }
    
    .ag-cell:not(.invalid-selection) {
    	background-color: transparent !important;
    }
    
    .ag-cell.invalid-selection {
    	background-color: #ffeaea !important;
    }
    
    /* Dataset List */
    .dataset-list-container {
    	position: absolute;
    	right: var(--space-md);
    	top: 0.5em;
    }
    
    .dataset-list {
    	position: relative;
    	cursor: pointer;
    	border: 1px solid var(--border);
    	padding: 1px;
    	border-radius: var(--border-radius);
    	background-color: #f9f9f9;
    }
    
    .dataset-list-content {
    	display: none;
    	position: absolute;
    	right: 0;
    	top: 100%;
    	background-color: var(--bg-white);
    	border: 1px solid var(--border);
    	padding: var(--space-xs) var(--space-lg) var(--space-xs) var(--space-xs);
    	font-family: monospace;
    	box-shadow: 0 4px 8px var(--shadow);
    	z-index: 1000;
    }
    
    .dataset-list:hover .dataset-list-content {
    	display: block;
    }
    
    /* Image Controls and Display */
    .image-controls-container {
    	margin: var(--space-lg) 0;
    }
    
    .image-controls {
    	display: flex;
    	align-items: center;
    	justify-content: space-between;
    	padding: var(--space-md);
    	background-color: var(--bg-light);
    	border-radius: 8px;
    	box-shadow: 0 2px 4px var(--shadow);
    }
    
    .image-controls-display,
    .image-controls-size {
    	display: flex;
    	align-items: center;
    	width: 50%;
    }
    
    .image-controls-size {
    	justify-content: flex-end;
    }
    
    .resize-slider {
    	width: 250px;
    	margin: 0 var(--space-md);
    }
    
    .resize-input {
    	width: 75px;
    	padding: 2px var(--space-sm);
    }
    
    /* Image Grid */
    .images {
    	display: grid;
    	gap: var(--space-sm);
    	margin-top: var(--space-md);
    }
    
    .image-container {
    	text-align: center;
    }
    
    .image-info {
    	font-size: 0.8em;
    	margin: 2em 0 -1em;
    }
    
    .img-container svg,
    .img-container img {
    	width: 100%;
    	height: 100%;
    	object-fit: contain;
    	image-rendering: pixelated;
    	-ms-interpolation-mode: nearest-neighbor;
    }
    
    /* Buttons */
    .btn {
    	margin: 5px;
    	padding: 8px 16px;
    	font-size: 14px;
    	font-weight: bold;
    	border: none;
    	border-radius: var(--border-radius);
    	cursor: pointer;
    	transition: background-color 0.3s ease;
    }
    
    .btn-primary {
    	background-color: var(--primary);
    	color: white;
    }
    
    .btn-primary:hover {
    	background-color: var(--primary-hover);
    }
    
    .btn-secondary,
    .btn-header,
    .btn-dark-mode {
    	background-color: var(--secondary);
    	color: white;
    }
    
    .btn-secondary:hover,
    .btn-header:hover,
    .btn-dark-mode:hover {
    	background-color: var(--secondary-hover);
    }
    
    /* Progress Bar */
    .progress-bar {
    	height: 12px;
    	width: 200px;
    	background: #ddd;
    	border-radius: 6px;
    	overflow: hidden;
    }
    
    .progress-bar-fill {
    	height: 100%;
    	transition: width 0.3s ease;
    }
    
    .progress-bar-fill.loading {
    	background-color: var(--primary);
    }
    
    .progress-bar-fill.complete {
    	background-color: var(--success);
    }
    
    .progress-wrapper {
    	padding-left: 1rem;
    }
    
    /* Function Info Tooltip */
    .function-info {
    	position: relative;
    	cursor: help;
    	display: flex;
    	align-items: center;
    	margin-left: auto;
    }
    
    .function-tooltip {
    	display: none;
    	position: fixed;
    	background-color: #eee;
    	border: 1px solid #ccc;
    	padding: 8px;
    	width: 250px;
    	z-index: 9999999;
    	border-radius: 4px;
    	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .function-info:hover .function-tooltip {
    	display: block;
    }
    
    /* Dark Mode Styles */
    .dark-mode {
    	background-color: var(--dark-bg);
    	color: var(--dark-text);
    }
    
    .dark-mode .container {
    	background-color: var(--dark-bg);
    }
    
    .dark-mode .functions-filter,
    .dark-mode .filter-item,
    .dark-mode .checkbox-list {
    	background-color: var(--dark-bg-light);
    	border-color: var(--dark-border);
    }
    
    .dark-mode .ag-theme-alpine {
    	--ag-background-color: var(--dark-bg-light);
    	--ag-header-background-color: var(--dark-bg);
    	--ag-odd-row-background-color: var(--dark-bg);
    	--ag-header-foreground-color: var(--dark-text);
    	--ag-foreground-color: var(--dark-text);
    	--ag-border-color: var(--dark-border);
    }
    
    .dark-mode .top-controls {
    	background-color: var(--dark-bg-light);
    }
    
    .dark-mode .dataset-list,
    .dark-mode .dataset-list-content {
    	background-color: var(--dark-bg-light);
    	border-color: var(--dark-border);
    	color: var(--dark-text);
    }
    
    .dark-mode .dataset-list-content ul {
    	margin: 0;
    	padding: 0.5em 1em;
    	list-style-type: none;
    }
    
    .dark-mode .dataset-list-content li {
    	color: var(--dark-text);
    	padding: 0.2em 0;
    }
    
    .dark-mode .image-controls-container {
    	background-color: transparent;
    }
    
    .dark-mode .image-controls {
    	background-color: var(--dark-bg-light);
    	border-color: var(--dark-border);
    	box-shadow: 0 2px 4px var(--dark-shadow);
    }
    
    .dark-mode .resize-slider,
    .dark-mode .resize-input {
    	background-color: var(--dark-bg);
    	border-color: var(--dark-border);
    }
    
    .dark-mode .resize-input {
    	color: var(--dark-text);
    }
    
    .dark-mode .image-controls label {
    	color: var(--dark-text);
    }
    
    .dark-mode .progress-bar {
    	background-color: var(--dark-bg);
    	border: 1px solid var(--dark-border);
    }
    
    .dark-mode .progress-status {
    	color: var(--dark-text);
    }
    
    .dark-mode .function-tooltip {
    	background-color: var(--dark-bg-light);
    	border-color: var(--dark-border);
    	color: var(--dark-text);
    }
    
    /* Utility Classes */
    .loading,
    .error {
    	text-align: center;
    	padding: var(--space-md);
    }
    
    .counter {
    	font-size: 0.8em;
    	color: var(--text-muted);
    	margin-left: auto;
    }
    
    /* Dark Mode Toggle */
    .dark-mode-toggle {
    	position: relative;
    	width: 60px;
    	height: 30px;
    	border-radius: 15px;
    	background-color: #e2e8f0;
    	cursor: pointer;
    	transition: background-color 0.3s ease;
    	border: none;
    	padding: 0;
    	overflow: hidden;
    }
    
    .dark-mode-toggle::before {
    	content: "";
    	position: absolute;
    	top: 3px;
    	left: 3px;
    	width: 24px;
    	height: 24px;
    	border-radius: 50%;
    	background-color: white;
    	transition: transform 0.3s ease;
    	z-index: 1;
    }
    
    .dark-mode .dark-mode-toggle {
    	background-color: #4a5568;
    }
    
    .dark-mode .dark-mode-toggle::before {
    	transform: translateX(30px);
    }
    
    .dark-mode-icon {
    	position: absolute;
    	top: 50%;
    	transform: translateY(-50%);
    	font-size: 14px;
    	pointer-events: none;
    	line-height: 1;
    	display: flex;
    	align-items: center;
    	justify-content: center;
    	width: 24px;
    	height: 24px;
    }
    
    .sun-icon {
    	left: 8px;
    	opacity: 1;
    }
    
    .moon-icon {
    	right: 8px;
    	opacity: 1;
    }
    
    .dark-mode-button {
    	display: flex;
    	align-items: center;
    	gap: 8px;
    	cursor: pointer;
    	color: inherit;
    }
    
    /* Visualization Controls Styles */
    .visualization-controls {
    	display: flex;
    	align-items: center;
    	gap: 20px;
    	margin-top: 10px;
    	padding: 5px 0;
    	border-top: 1px solid var(--border);
    }
    
    .color-controls,
    .sort-controls {
    	display: flex;
    	align-items: center;
    	gap: 8px;
    }
    
    .image-container {
    	position: relative;
    	border: 3px solid transparent;
    	border-radius: 6px;
    	padding: 4px;
    	transition: border-color 0.2s ease;
    }
    
    .dark-mode .visualization-controls {
    	border-color: var(--dark-border);
    }
    
    .color-legend {
    	display: flex;
    	flex-wrap: wrap;
    	gap: 10px;
    	margin-top: 10px;
    	padding: 10px;
    	background-color: var(--bg-light);
    	border-radius: 6px;
    }
    
    .legend-item {
    	display: flex;
    	align-items: center;
    	gap: 5px;
    	font-size: 0.85em;
    }
    
    .legend-color {
    	width: 16px;
    	height: 16px;
    	border-radius: 3px;
    	border: 3px solid #000;
    }
    
    .dark-mode .color-legend {
    	background-color: var(--dark-bg-light);
    }
    
    .dark-mode .legend-color {
    	border-color: #fff;
    }
    </style>
    <!-- end 'style.css' -->
    <!-- js imports -->
        <!-- begin 'config.js' -->
    <script>
    /**
     * Configuration Handler
     * 
     * Provides a flexible configuration system with multiple override levels:
     * 1. Default configuration (lowest priority)
     * 2. Inline configuration override (INLINE_CONFIG)
     * 3. External config.json file
     * 4. URL parameters (highest priority)
     * 
     * Features:
     * - Deep merging of configuration objects
     * - URL parameter parsing with dot notation support
     * - Automatic URL synchronization with debouncing
     * - Configuration export functionality
     * - Reset to loaded state capability
     */
    
    // Configuration constants
    const CONFIG_FILE_PATH = "pl_cfg.json";
    const URL_UPDATE_DEBOUNCE_DELAY = 500; // ms
    const FLOAT_COMPARISON_EPSILON = 0.001;
    
    // Keys to skip during URL serialization
    const URL_SKIP_PATHS = [];
    
    // Keys to skip during config comparison
    const COMPARISON_SKIP_KEYS = [];
    
    // For inline config overrides - replace this with external script if needed
    var INLINE_CONFIG = null;
    
    // the line below might be replaced by an external build script to inject a config
    /*$$$INLINE_CONFIG$$$*/
    
    // Global variables for configuration management
    let CONFIG = null;
    let LOADED_CONFIG = null; // Store the config as loaded from file for comparison
    let URL_UPDATE_TIMEOUT = null;
    
    /**
     * Get default configuration object
     * @returns {object} Default configuration
     */
    function getDefaultConfig() {
    	let default_cfg = {
    		// Data configuration
    		data: {
    			basePath: "./",  // Base path for data directory
    			singleViewerPath: "single.html",  // Path to single pattern viewer
    			modelsFile: "models.jsonl",
    			figuresFile: "figures.jsonl",
    			promptsFile: "prompts.jsonl",
    			figureFormats: ['svg', 'svgz', 'png'],  // Supported figure formats
    			urlHeadPrefix: 'heads-'  // Prefix for URL head parameters
    		},
    
    		// UI configuration
    		ui: {
    			imagesPerRow: 4,  // Number of images to display per row
    			darkModeDefault: false
    		},
    
    		// Visualization configuration
    		visualization: {
    			// Add any visualization-specific settings here
    		}
    	};
    
    	if (INLINE_CONFIG) {
    		// If INLINE_CONFIG is set, merge it into the default config
    		deepMerge(default_cfg, INLINE_CONFIG);
    		console.log("Merged inline config overrides");
    	}
    
    	return default_cfg;
    }
    
    /**
     * Load config.json (if present) and merge into CONFIG.
     * Also parse URL parameters and apply them to CONFIG.
     * Priority: URL params > config.json > inline config > defaults
     * @returns {Promise<object>} resolved CONFIG object
     */
    async function getConfig() {
    	// Initialize with defaults
    	CONFIG = getDefaultConfig();
    
    	try {
    		// First, try to load config.json
    		const r = await fetch(CONFIG_FILE_PATH);
    		if (r.ok) {
    			const loaded = await r.json();
    			// Deep merge loaded config into CONFIG
    			deepMerge(CONFIG, loaded);
    			// Store a deep copy of the loaded config for URL comparison
    			LOADED_CONFIG = JSON.parse(JSON.stringify(CONFIG));
    			console.log("Loaded config.json");
    		} else {
    			console.warn("config.json not found, using defaults");
    			// If no config.json, use defaults for comparison
    			LOADED_CONFIG = JSON.parse(JSON.stringify(CONFIG));
    		}
    	} catch (e) {
    		// if the inline config is null, then failing to find config.json is fine
    		if (!INLINE_CONFIG) {
    			console.error("Config load error:", e);
    		} else {
    			console.warn("Failed to load config.json, but it's fine because an inline config was provided");
    		}
    		// On error, use defaults for comparison
    		LOADED_CONFIG = JSON.parse(JSON.stringify(CONFIG));
    	}
    
    	// Parse URL parameters and override CONFIG values (highest priority)
    	parseURLParams();
    
    	return CONFIG;
    }
    
    /**
     * Deep merge source object into target object
     * @param {object} target - Target object to merge into
     * @param {object} source - Source object to merge from
     */
    function deepMerge(target, source) {
    	for (const key in source) {
    		if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
    			if (!target[key]) target[key] = {};
    			deepMerge(target[key], source[key]);
    		} else {
    			target[key] = source[key];
    		}
    	}
    }
    
    /**
     * Parse URL parameters and update CONFIG
     * Supports nested paths like: ?theme=light&ui.showToolbar=false&performance.maxItems=2000
     * Also supports arrays like: ?data.sources=file1.json,file2.json,file3.json
     * @param {URLSearchParams} [params] - Optional URLSearchParams object, defaults to current URL
     */
    function parseURLParams(params = null) {
    	if (!params) {
    		params = new URLSearchParams(window.location.search);
    	}
    
    	for (const [key, value] of params) {
    		setNestedConfigValue(CONFIG, key, parseConfigValue(value));
    	}
    }
    
    /**
     * Set a nested configuration value using dot notation
     * Example: setNestedConfigValue(CONFIG, "ui.showToolbar", false)
     * @param {object} obj - Object to modify
     * @param {string} path - Dot-separated path
     * @param {any} value - Value to set
     */
    function setNestedConfigValue(obj, path, value) {
    	const keys = path.split('.');
    	let current = obj;
    
    	for (let i = 0; i < keys.length - 1; i++) {
    		const key = keys[i];
    		if (!(key in current) || typeof current[key] !== 'object') {
    			current[key] = {};
    		}
    		current = current[key];
    	}
    
    	const finalKey = keys[keys.length - 1];
    	current[finalKey] = value;
    	console.log(`URL param override: ${path} = ${value}`);
    }
    
    /**
     * Parse a string value from URL params into appropriate type
     * Handles arrays (comma-separated values), booleans, numbers, and strings
     * @param {string} value - String value from URL parameter
     * @returns {any} Parsed value
     */
    function parseConfigValue(value) {
    	// Boolean
    	if (value === 'true') return true;
    	if (value === 'false') return false;
    
    	// Array (comma-separated) - but handle single values too
    	if (value.includes(',')) {
    		return value.split(',').map(v => v.trim()).filter(v => v.length > 0);
    	}
    
    	// Number
    	if (!isNaN(value) && !isNaN(parseFloat(value))) {
    		return parseFloat(value);
    	}
    
    	// String (including hex colors, URLs, etc.)
    	return value;
    }
    
    /**
     * Update the URL with current CONFIG state
     * Debounced to avoid excessive URL updates
     * @param {number} [delay] - Debounce delay in milliseconds (uses global constant if not provided)
     */
    function updateURL(delay = URL_UPDATE_DEBOUNCE_DELAY) {
    	if (URL_UPDATE_TIMEOUT) {
    		clearTimeout(URL_UPDATE_TIMEOUT);
    	}
    
    	URL_UPDATE_TIMEOUT = setTimeout(() => {
    		const params = generateURLParams();
    		const newURL = window.location.pathname + (params.toString() ? '?' + params.toString() : '');
    		window.history.replaceState({}, '', newURL);
    		URL_UPDATE_TIMEOUT = null;
    	}, delay);
    }
    
    /**
     * Generate URL search params from current CONFIG state
     * Only includes values that differ from the loaded config (not defaults)
     * @returns {URLSearchParams} URL parameters representing config differences
     */
    function generateURLParams() {
    	if (!LOADED_CONFIG) {
    		// Fallback to default config if loaded config not available
    		return new URLSearchParams();
    	}
    
    	const params = new URLSearchParams();
    	const differences = findConfigDifferences(CONFIG, LOADED_CONFIG);
    
    	for (const [path, value] of differences) {
    		// Skip certain fields that shouldn't be in URLs
    		if (shouldSkipInURL(path)) {
    			continue;
    		}
    
    		// Special handling for arrays
    		if (Array.isArray(value)) {
    			if (value.length > 0) {
    				params.set(path, value.join(','));
    			}
    		} else {
    			params.set(path, value.toString());
    		}
    	}
    
    	return params;
    }
    
    /**
     * Check if a config path should be skipped when generating URL parameters
     * @param {string} path - Config path (dot notation)
     * @returns {boolean} True if should be skipped
     */
    function shouldSkipInURL(path) {
    	return URL_SKIP_PATHS.some(skipPath => path.startsWith(skipPath));
    }
    
    /**
     * Find differences between current config and loaded config
     * Returns array of [path, value] tuples
     * Uses epsilon comparison for floats
     * @param {object} current - Current configuration
     * @param {object} base - Base configuration to compare against
     * @param {string} [prefix=''] - Current path prefix
     * @returns {Array<[string, any]>} Array of [path, value] differences
     */
    function findConfigDifferences(current, base, prefix = '') {
    	const differences = [];
    
    	for (const key in current) {
    		// Skip certain keys that shouldn't be compared
    		if (shouldSkipInComparison(key)) {
    			continue;
    		}
    
    		const currentPath = prefix ? `${prefix}.${key}` : key;
    		const currentValue = current[key];
    		const baseValue = base[key];
    
    		if (Array.isArray(currentValue)) {
    			// Special handling for arrays
    			if (!Array.isArray(baseValue) || !arraysEqual(currentValue, baseValue)) {
    				differences.push([currentPath, currentValue]);
    			}
    		} else if (typeof currentValue === 'object' && currentValue !== null) {
    			if (typeof baseValue === 'object' && !Array.isArray(baseValue) && baseValue !== null) {
    				differences.push(...findConfigDifferences(currentValue, baseValue, currentPath));
    			} else {
    				// Base doesn't have this object, include all of current
    				differences.push([currentPath, JSON.stringify(currentValue)]);
    			}
    		} else {
    			// Compare primitive values with epsilon for floats
    			let valuesEqual = false;
    
    			if (typeof currentValue === 'number' && typeof baseValue === 'number') {
    				// Use epsilon comparison for floats
    				valuesEqual = Math.abs(currentValue - baseValue) < FLOAT_COMPARISON_EPSILON;
    			} else {
    				// Direct comparison for other types
    				valuesEqual = currentValue === baseValue;
    			}
    
    			if (!valuesEqual) {
    				differences.push([currentPath, currentValue]);
    			}
    		}
    	}
    
    	return differences;
    }
    
    /**
     * Check if a config key should be skipped during comparison
     * @param {string} key - Configuration key
     * @returns {boolean} True if should be skipped
     */
    function shouldSkipInComparison(key) {
    	return COMPARISON_SKIP_KEYS.includes(key);
    }
    
    /**
     * Helper function to compare arrays for equality
     * @param {Array} arr1 - First array
     * @param {Array} arr2 - Second array
     * @returns {boolean} True if arrays are equal
     */
    function arraysEqual(arr1, arr2) {
    	if (arr1.length !== arr2.length) return false;
    	for (let i = 0; i < arr1.length; i++) {
    		if (arr1[i] !== arr2[i]) return false;
    	}
    	return true;
    }
    
    /**
     * Get the current configuration as a formatted JSON string
     * @param {number} [indent=2] - JSON indentation spaces
     * @returns {string} Formatted JSON configuration
     */
    function getConfigAsJSON(indent = 2) {
    	return JSON.stringify(CONFIG, null, indent);
    }
    
    /**
     * Export current configuration to a new browser tab
     * Creates a downloadable JSON file with current config
     */
    function exportConfigToNewTab() {
    	const configText = getConfigAsJSON();
    	const blob = new Blob([configText], { type: 'application/json' });
    	const url = URL.createObjectURL(blob);
    	window.open(url, '_blank');
    
    	// Clean up the object URL after a delay
    	setTimeout(() => {
    		URL.revokeObjectURL(url);
    	}, 1000);
    }
    
    /**
     * Reset CONFIG to the loaded config.json state and clear URL parameters
     * Useful for reverting all changes back to the original loaded state
     */
    function resetConfigToLoaded() {
    	if (!LOADED_CONFIG) {
    		console.warn("No loaded config available, resetting to defaults");
    		CONFIG = getDefaultConfig();
    	} else {
    		// Deep copy the loaded config back to CONFIG
    		CONFIG = JSON.parse(JSON.stringify(LOADED_CONFIG));
    	}
    
    	// Clear URL parameters by navigating to clean URL
    	const cleanURL = window.location.pathname;
    	window.history.replaceState({}, '', cleanURL);
    
    	// Clear the URL update timeout if it exists
    	if (URL_UPDATE_TIMEOUT) {
    		clearTimeout(URL_UPDATE_TIMEOUT);
    		URL_UPDATE_TIMEOUT = null;
    	}
    
    	console.log("Config reset to loaded state and URL cleared");
    }
    
    /**
     * Get a nested configuration value using dot notation
     * Example: getConfigValue("ui.showToolbar")
     * @param {string} path - Dot-separated path to config value
     * @param {any} [defaultValue] - Default value if path doesn't exist
     * @returns {any} Configuration value or default
     */
    function getConfigValue(path, defaultValue = undefined) {
    	const keys = path.split('.');
    	let current = CONFIG;
    
    	for (const key of keys) {
    		if (current && typeof current === 'object' && key in current) {
    			current = current[key];
    		} else {
    			return defaultValue;
    		}
    	}
    
    	return current;
    }
    
    /**
     * Set a nested configuration value and optionally update URL
     * Example: setConfigValue("theme", "light", true)
     * @param {string} path - Dot-separated path to config value
     * @param {any} value - Value to set
     * @param {boolean} [updateUrl=true] - Whether to update URL parameters
     */
    function setConfigValue(path, value, updateUrl = true) {
    	setNestedConfigValue(CONFIG, path, value);
    
    	if (updateUrl) {
    		updateURL();
    	}
    }
    
    /**
     * Initialize the configuration system
     * Call this once when your application starts
     * @returns {Promise<object>} Resolved configuration object
     */
    async function initConfig() {
    	try {
    		return await getConfig();
    	} catch (error) {
    		console.error("Failed to initialize configuration:", error);
    		// Fallback to defaults
    		CONFIG = getDefaultConfig();
    		LOADED_CONFIG = JSON.parse(JSON.stringify(CONFIG));
    		return CONFIG;
    	}
    }
    </script>
    <!-- end 'config.js' -->
        <!-- begin 'util.js' -->
    <script>
    const fileOps = {
    	async getDirectoryContents(path) {
    		const response = await fetch(`${path}/index.txt`);
    		const text = await response.text();
    		return text.trim().split('\n');
    	},
    	async fileExists(path) {
    		const response = await fetch(path, { method: 'HEAD' });
    		return response.ok;
    	},
    	async fetchJson(path) {
    		const response = await fetch(path);
    		return response.json();
    	},
    	async fetchJsonL(path) {
    		const response = await fetch(path);
    		const text = await response.text();
    		// allow for the last line being incomplete
    		const text_split = text.trim().split('\n');
    		let output = text_split.slice(0, -1).map(JSON.parse);
    		try {
    			output.push(JSON.parse(text_split[text_split.length - 1]));
    		} catch (error) {
    			console.error('Error parsing last line of JSONL:', error);
    		}
    		return output;
    	},
    	async fetchAndDecompressSvgz(path) {
    		// returns null if file does not exist
    		const response = await fetch(path);
    		if (!response.ok) {
    			return null;
    		} else {
    			const arrayBuffer = await response.arrayBuffer();
    			const uint8Array = new Uint8Array(arrayBuffer);
    			return pako.inflate(uint8Array, { to: 'string' });
    		}
    	},
    	async figureExists(path) {
    		for (const format of CONFIG.data.figureFormats) {
    			fig_path = `${path}.${format}`;
    			if (await this.fileExists(fig_path)) {
    				return format;
    			}
    		}
    		return null;
    	}
    };
    
    
    const colorUtils = {
    	getRandomColor() {
    		// Generate vibrant colors with good contrast
    		const hue = Math.floor(Math.random() * 360);
    		return `hsl(${hue}, 70%, 60%)`;
    	},
    };
    
    
    </script>
    <!-- end 'util.js' -->
        <!-- begin 'app.js' -->
    <script>
    const app = Vue.createApp({
    
    	// ########     ###    ########    ###
    	// ##     ##   ## ##      ##      ## ##
    	// ##     ##  ##   ##     ##     ##   ##
    	// ##     ## ##     ##    ##    ##     ##
    	// ##     ## #########    ##    #########
    	// ##     ## ##     ##    ##    ##     ##
    	// ########  ##     ##    ##    ##     ##
    
    	data() {
    		return {
    			isDarkMode: false,
    			prompts: {
    				all: {},        // hash -> prompt mapping
    				selected: [],   // selected from table
    				grid: {
    					api: null,
    					isReady: false
    				},
    			},
    			loading: false,
    			images: {
    				visible: [],
    				expected: 0,
    				requested: false,
    				upToDate: false,
    				perRow: 4,
    			},
    			models: {
    				configs: {},    // model -> config mapping
    				grid: {
    					api: null,
    				},
    			},
    			filters: {
    				available: {    // all available options
    					models: [],
    					functions: [],
    					layers: [],
    					heads: [],
    				},
    				selected: {     // currently selected options
    					models: [],
    					functions: [],
    					layers: [],
    					heads: [],
    				},
    			},
    			head_selections_str: {}, // model -> selection string mapping
    			visualization: {
    				colorBy: '',
    				sortBy: '',
    				sortOrder: 'asc',
    				colorMap: {},
    			},
    		};
    	},
    
    	methods: {
    
    		// ##     ## ########    ###    ########   ######
    		// ##     ## ##         ## ##   ##     ## ##    ##
    		// ##     ## ##        ##   ##  ##     ## ##
    		// ######### ######   ##     ## ##     ##  ######
    		// ##     ## ##       ######### ##     ##       ##
    		// ##     ## ##       ##     ## ##     ## ##    ##
    		// ##     ## ######## ##     ## ########   ######
    
    		// Parse head selection string and return a 2D array of booleans
    		parseHeadString(str, maxLayer, maxHead) {
    			try {
    				const result = Array(maxLayer).fill().map(() => Array(maxHead).fill(false));
    				if (!str || str.trim() === '') return result;
    
    				const selections = str.replaceAll("x", "*").split(',').map(s => s.trim());
    
    				for (const selection of selections) {
    					const match = selection.match(/^L(\d+|\d+-\d+|\*)(H\d+|H\*|Hx)?$/);
    					if (!match) return null;
    
    					const layerPart = match[1];
    					let headPart = match[2];
    
    					// If the user typed only "L8" (no head specification), default to H*
    					if (!headPart) {
    						headPart = 'H*';
    					}
    
    					let layers = [];
    					if (layerPart === '*') {
    						layers = Array.from({ length: maxLayer }, (_, i) => i);
    					} else if (layerPart.includes('-')) {
    						const [start, end] = layerPart.split('-').map(Number);
    						if (start > end || end >= maxLayer) return null;
    						layers = Array.from({ length: end - start + 1 }, (_, i) => start + i);
    					} else {
    						const layer = Number(layerPart);
    						if (layer >= maxLayer) return null;
    						layers = [layer];
    					}
    
    					const headStr = headPart.substring(1);
    					if (headStr === '*' || headStr === 'x') {
    						for (const layer of layers) {
    							result[layer].fill(true);
    						}
    					} else {
    						const head = Number(headStr);
    						if (head >= maxHead) return null;
    						for (const layer of layers) {
    							result[layer][head] = true;
    						}
    					}
    				}
    
    				return result;
    			} catch (e) {
    				console.error('Error parsing head string:', e);
    				return null;
    			}
    		},
    
    		isHeadSelected(model, layer, head) {
    			// First check if we have parsed selections for this model
    			if (!this.head_selections_arr[model]) {
    				console.warn(`No parsed head selections found for model: ${model}`);
    				return false;
    			}
    
    			try {
    				// Verify layer and head are within bounds
    				const parsedSelections = this.head_selections_arr[model];
    				if (!Array.isArray(parsedSelections) ||
    					!Array.isArray(parsedSelections[layer]) ||
    					typeof parsedSelections[layer][head] === 'undefined') {
    					console.warn(
    						`Invalid layer/head combination for ${model}: L${layer}H${head}`,
    						`Max bounds: L${parsedSelections.length - 1}H${parsedSelections[0]?.length - 1}`
    					);
    					return false;
    				}
    
    				return parsedSelections[layer][head];
    			} catch (e) {
    				console.error('Error checking head selection:', e);
    				console.log('Model:', model, 'Layer:', layer, 'Head:', head);
    				return false;
    			}
    		},
    
    		isValidHeadSelection(model) {
    			return this.head_selections_arr[model] !== null;
    		},
    		// ##     ## ########  ##
    		// ##     ## ##     ## ##
    		// ##     ## ##     ## ##
    		// ##     ## ########  ##
    		// ##     ## ##   ##   ##
    		// ##     ## ##    ##  ##
    		//  #######  ##     ## ########
    
    		// Modified URL handling
    		updateURL() {
    			const params = new URLSearchParams();
    
    			if (this.filters.selected.functions.length > 0) {
    				params.set('functions', this.filters.selected.functions.join('~'));
    			}
    
    			if (this.prompts.selected.length > 0) {
    				params.set('prompts', this.prompts.selected.join('~'));
    			}
    
    			if (this.filters.selected.models.length > 0) {
    				params.set('models', this.filters.selected.models.join('~'));
    			}
    
    			if (this.filters.selected.models.length > 0) {
    				for (const model of Object.keys(this.head_selections_str)) {
    					params.set(
    						`${CONFIG.data.urlHeadPrefix}${model}`,
    						this.head_selections_str[model].replaceAll("*", "x").replaceAll(" ", "").split(',').join('~')
    					);
    				}
    			}
    
    			const newURL = `${window.location.pathname}?${params.toString()}`;
    			history.replaceState(null, '', newURL);
    		},
    
    		readURL() {
    			const params = new URLSearchParams(window.location.search);
    
    			this.filters.selected.functions = params.get('functions')?.split('~') || [];
    
    			this.prompts.selected = params.get('prompts')?.split('~') || [];
    
    			this.filters.selected.models = params.get('models')?.split('~') || [];
    
    			try {
    				this.head_selections_str = {};
    				for (const [key, value] of params) {
    					if (key.startsWith(CONFIG.data.urlHeadPrefix)) {
    						const model = key.substring(CONFIG.data.urlHeadPrefix.length);
    						this.head_selections_str[model] = value.split('~').join(', ');
    					}
    				}
    			} catch (e) {
    				console.error('Error parsing head selections from URL:', e);
    			}
    		},
    		selectPromptsFromURL() {
    			if (!this.isGridReady || this.prompts.selected.length === 0) return;
    
    			const promptSet = new Set(this.prompts.selected);
    			this.prompts.grid.api.forEachNode((node) => {
    				if (promptSet.has(node.data.hash)) {
    					node.setSelected(true);
    				}
    			});
    		},
    		getImageUrl(image) {
    			return this.getFilterUrl('all', [image.model], [image.promptHash], [image.layer], [image.head], [image.function]);
    		},
    
    		openSingleView(promptHash, model, layer, head) {
    			const singlePath = CONFIG.data.singleViewerPath;
    			const params = new URLSearchParams({
    				prompt: promptHash,
    				head: `${model}.L${layer}.H${head}`
    			});
    			window.open(`${singlePath}?${params.toString()}`, '_blank');
    		},
    
    		getSinglePropertyFilterUrl(type, value) {
    			const params = new URLSearchParams(window.location.search);
    			params.set(type, value); // This preserves other params while updating just this one
    			return `${window.location.pathname}?${params.toString()}`;
    		},
    
    		getFilterUrl(type, ...values) {
    			const params = new URLSearchParams(window.location.search);
    
    			if (type === 'all') {
    				params.set('models', values[0].join('~'));
    				params.set('prompts', values[1].join('~'));
    				params.set('layers', values[2].join('~'));
    				params.set('heads', values[3].join('~'));
    				params.set('functions', values[4].join('~'));
    			} else {
    				params.set(type, values.flat().join('~'));
    			}
    
    			return `${window.location.pathname}?${params.toString()}`;
    		},
    
    		// ##     ## ######## ##       ########  ######## ########
    		// ##     ## ##       ##       ##     ## ##       ##     ##
    		// ##     ## ##       ##       ##     ## ##       ##     ##
    		// ######### ######   ##       ########  ######   ########
    		// ##     ## ##       ##       ##        ##       ##   ##
    		// ##     ## ##       ##       ##        ##       ##    ##
    		// ##     ## ######## ######## ##        ######## ##     ##
    
    		toggleDarkMode() {
    			console.log('Toggling dark mode');  // Add this debug line
    			this.isDarkMode = !this.isDarkMode;
    			localStorage.setItem('darkMode', this.isDarkMode);
    			// Force a DOM update
    			this.$nextTick(() => {
    				document.documentElement.classList.toggle('dark-mode', this.isDarkMode);
    			});
    		},
    		clearAllSelections() {
    			// Clear prompts selection
    			if (this.prompts.grid.api) {
    				this.prompts.grid.api.deselectAll();
    			}
    
    			// Clear models selection
    			if (this.models.grid.api) {
    				this.models.grid.api.deselectAll();
    			}
    
    			// Clear function selections
    			this.filters.selected.functions = [];
    
    			// Reset head selections
    			this.head_selections_str = {};
    
    			// Update URL to reflect cleared state
    			this.updateURL();
    		},
    		isIndeterminate(category) {
    			const items = this.filters.available[category];
    			const selectedItems = this.filters.selected[category];
    			return selectedItems.length > 0 && selectedItems.length < items.length;
    		},
    		isChecked(category) {
    			const items = this.filters.available[category];
    			const selectedItems = this.filters.selected[category];
    			return selectedItems.length === items.length && items.length > 0;
    		},
    		toggleSelectAll(category, event) {
    			const checked = event.target.checked;
    			this.filters.selected[category] = checked ? [...this.filters.available[category]] : [];
    		},
    		async loadData() {
    			try {
    				await this.loadModels();
    				await Promise.all([
    					this.loadAllPrompts(),
    					this.loadFunctions()
    				]);
    
    				this.updateLayersAndHeads();
    			} catch (error) {
    				console.error('Error loading data:', error);
    			}
    		},
    		async loadModels() {
    			this.loading = true;
    			console.log('Loading models...');
    			const models = await fileOps.fetchJsonL(`${CONFIG.data.basePath}/${CONFIG.data.modelsFile}`);
    			this.models.configs = {};
    			for (const model of models) {
    				this.models.configs[model["model_name"]] = model;
    			}
    			this.filters.available.models = Object.keys(this.models.configs);
    			console.log('Models:', this.filters.available.models);
    			this.loading = false;
    
    			// After loading models, initialize head selections
    			this.filters.selected.models.forEach(model => {
    				if (!this.head_selections_str[model]) {
    					this.head_selections_str[model] = 'L*H*';
    				}
    			});
    		},
    		async loadFunctions() {
    			const functions = await fileOps.fetchJsonL(`${CONFIG.data.basePath}/${CONFIG.data.figuresFile}`);
    			console.log('Functions:', functions);
    			this.filters.available.functions = functions.reduce(
    				(acc, item) => {
    					acc[item.name] = item;
    					return acc;
    				},
    				{},
    			);
    			console.log('this.filters.available.functions:', this.filters.available.functions);
    		},
    		onFirstDataRendered(params) {
    			this.selectPromptsFromURL();
    		},
    		// Handle selection change in ag-Grid
    		onSelectionChanged() {
    			const selectedNodes = this.prompts.grid.api.getSelectedRows();
    			this.prompts.selected = selectedNodes.map(node => node.hash);
    			this.updateURL();
    		},
    		// Update layers and heads based on selected models
    		updateLayersAndHeads() {
    			// get all layer and head counts
    			let mdl_n_layers = [];
    			let mdl_n_heads = [];
    			for (const model of this.filters.selected.models) {
    				const config = this.models.configs[model];
    				if (config) {
    					mdl_n_layers.push(config.n_layers);
    					mdl_n_heads.push(config.n_heads);
    				}
    			}
    			// get the max layer and head counts, generate lists
    			this.filters.available.layers = [];
    			this.filters.available.heads = [];
    
    			for (let i = 0; i < _.max(mdl_n_layers); i++) {
    				this.filters.available.layers.push(i.toString());
    			}
    			for (let i = 0; i < _.max(mdl_n_heads); i++) {
    				this.filters.available.heads.push(i.toString());
    			}
    		},
    
    		// ##     ##  #######  ########  ######## ##        ######
    		// ###   ### ##     ## ##     ## ##       ##       ##    ##
    		// #### #### ##     ## ##     ## ##       ##       ##
    		// ## ### ## ##     ## ##     ## ######   ##        ######
    		// ##     ## ##     ## ##     ## ##       ##             ##
    		// ##     ## ##     ## ##     ## ##       ##       ##    ##
    		// ##     ##  #######  ########  ######## ########  ######
    		getHeadSelectionCount(model) {
    			const parsed = this.head_selections_arr[model];
    			if (!parsed) return 0;
    			return parsed.reduce((acc, layer) =>
    				acc + layer.reduce((sum, isSelected) => sum + (isSelected ? 1 : 0), 0), 0);
    		},
    		getTotalHeads(model) {
    			const config = this.models.configs[model];
    			return config ? config.n_layers * config.n_heads : 0;
    		},
    		setupModelTable() {
    			const columnDefs = [
    				{
    					headerName: 'Model',
    					field: 'model_name',
    					sort: 'asc',
    					width: 150
    				},
    				{
    					headerName: 'd_model',
    					field: 'd_model',
    					width: 90,
    					filter: 'agNumberColumnFilter'
    				},
    				{
    					headerName: 'n_layers',
    					field: 'n_layers',
    					width: 90,
    					filter: 'agNumberColumnFilter'
    				},
    				{
    					headerName: 'n_heads',
    					field: 'n_heads',
    					width: 90,
    					filter: 'agNumberColumnFilter'
    				},
    				{
    					headerName: 'Selected',
    					valueGetter: (params) => {
    						return `${this.getHeadSelectionCount(params.data.model_name)} / ${this.getTotalHeads(params.data.model_name)}`;
    					},
    					width: 100
    				},
    				{
    					headerName: 'Head Grid',
    					field: 'head_grid',
    					width: 150,
    					cellRenderer: (params) => {
    						const model = params.data.model_name;
    						const div = document.createElement('div');
    						div.className = 'head-grid';
    						div.setAttribute('data-model', model); // Add data attribute for updates
    
    						const n_heads = params.data.n_heads;
    						const n_layers = params.data.n_layers;
    
    						for (let h = 0; h < n_heads; h++) {
    							const layerDiv = document.createElement('div');
    							layerDiv.className = 'headsGrid-col';
    
    							for (let l = 0; l < n_layers; l++) {
    								const cell = document.createElement('div');
    								cell.className = `headsGrid-cell ${this.isHeadSelected(model, l, h) ? 'headsGrid-cell-selected' : 'headsGrid-cell-empty'}`;
    								cell.setAttribute('data-layer', l);
    								cell.setAttribute('data-head', h);
    								layerDiv.appendChild(cell);
    							}
    
    							div.appendChild(layerDiv);
    						}
    
    						return div;
    					}
    				},
    				{
    					headerName: 'Head Selection',
    					field: 'head_selection',
    					editable: true,
    					width: 200,
    					cellEditor: 'agTextCellEditor',
    					cellEditorParams: {
    						maxLength: 50
    					},
    					valueSetter: params => {
    						const newValue = params.newValue;
    						const model = params.data.model_name;
    
    						// Update the head selection in Vue's data
    						params.context.componentParent.head_selections_str[model] = newValue;
    
    						// Update the cell class for validation styling
    						const isValid = params.context.componentParent.isValidHeadSelection(model);
    						const cell = params.api.getCellRendererInstances({
    							rowNodes: [params.node],
    							columns: [params.column]
    						})[0];
    
    						if (cell) {
    							const element = cell.getGui();
    							if (isValid) {
    								element.classList.remove('invalid-selection');
    							} else {
    								element.classList.add('invalid-selection');
    							}
    						}
    
    						// Force refresh of the head grid cell
    						const gridCol = params.api.getColumnDef('head_grid');
    						if (gridCol) {
    							params.api.refreshCells({
    								rowNodes: [params.node],
    								columns: ['head_grid'],
    								force: true
    							});
    						}
    
    						return true;
    					},
    					valueGetter: params => {
    						return params.context.componentParent.head_selections_str[params.data.model_name] || 'L*H*';
    					},
    					cellClass: params => {
    						const isValid = params.context.componentParent.isValidHeadSelection(params.data.model_name);
    						return isValid ? '' : 'invalid-selection';
    					}
    				},
    			];
    
    			const modelGrid_options = {
    				columnDefs: columnDefs,
    				rowData: Object.values(this.models.configs),
    				selection: {
    					headerCheckbox: true,
    					selectAll: 'filtered',
    					checkboxes: true,
    					mode: 'multiRow',
    					enableClickSelection: true,
    				},
    				defaultColDef: {
    					sortable: true,
    					filter: true,
    					resizable: true,
    					floatingFilter: true,
    					suppressKeyboardEvent: params => {
    						// Allow all keyboard events in edit mode
    						if (params.editing) {
    							return false;
    						}
    						// Prevent default grid behavior for typing when not in edit mode
    						if (params.event.key.length === 1 && !params.event.ctrlKey && !params.event.metaKey) {
    							return false;
    						}
    						return true;
    					},
    				},
    				context: {
    					componentParent: this
    				},
    				onSelectionChanged: (event) => {
    					const selectedRows = event.api.getSelectedRows();
    					this.filters.selected.models = selectedRows.map(row => row.model_name);
    				},
    				onGridReady: (params) => {
    					this.models.grid.api = params.api;
    					// Select models from URL
    					if (this.filters.selected.models.length > 0) {
    						params.api.forEachNode(node => {
    							if (this.filters.selected.models.includes(node.data.model_name)) {
    								node.setSelected(true);
    							}
    						});
    					}
    				},
    			};
    
    			const modelGrid_div = document.querySelector('#modelGrid');
    			this.models.grid.api = agGrid.createGrid(modelGrid_div, modelGrid_options);
    		},
    		refreshHeadGrids() {
    			if (this.models.grid.api) {
    				this.models.grid.api.refreshCells({
    					columns: ['head_grid'],
    					force: true
    				});
    			}
    		},
    		// ########  ########   #######  ##     ## ########  ########
    		// ##     ## ##     ## ##     ## ###   ### ##     ##    ##   
    		// ##     ## ##     ## ##     ## #### #### ##     ##    ##   
    		// ########  ########  ##     ## ## ### ## ########     ##   
    		// ##        ##   ##   ##     ## ##     ## ##           ##    
    		// ##        ##    ##  ##     ## ##     ## ##           ##    
    		// ##        ##     ##  #######  ##     ## ##           ##    
    
    		async loadAllPrompts() {
    			this.loading = true;
    			console.log('Loading prompts...');
    			this.prompts.all = {};
    
    			for (const model of this.filters.available.models) {
    				try {
    					const modelPrompts = await fileOps.fetchJsonL(`${CONFIG.data.basePath}/${model}/${CONFIG.data.promptsFile}`);
    					for (const prompt of modelPrompts) {
    						if (prompt.hash in this.prompts.all) {
    							this.prompts.all[prompt.hash].models.push(model);
    						} else {
    							this.prompts.all[prompt.hash] = { ...prompt, models: [model] };
    						}
    					}
    				} catch (error) {
    					console.error(`Error loading prompts for model ${model}:`, error);
    				}
    			}
    			console.log('loaded number of prompts:', Object.keys(this.prompts.all).length);
    			this.loading = false;
    		},
    		// Initialize the ag-Grid table
    		setupPromptTable() {
    			const columnDefs = [
    				{
    					headerName: 'Prompt Text',
    					field: 'text',
    					sortable: true,
    					filter: true,
    					flex: 2,
    					cellRenderer: (params) => {
    						const eGui = document.createElement('div');
    						// Replace tabs and newlines with spaces for display
    						eGui.innerText = params.value.replace(/\s+/g, ' ');
    						eGui.classList.add('prompt-text-cell');
    						eGui.addEventListener('click', () => {
    							navigator.clipboard.writeText(params.value);
    						});
    
    						eGui.addEventListener('contextmenu', (event) => {
    							event.preventDefault();
    							const newWindow = window.open();
    							newWindow.document.write(`<pre>${params.value}</pre>`);
    							newWindow.document.close();
    							newWindow.document.title = `Prompt '${params.data.hash}'`;
    						});
    
    						return eGui;
    					},
    				},
    				{
    					headerName: 'Models', field: 'models', sortable: true, filter: true, width: 150,
    					valueFormatter: (params) => params.value.join(', '),
    				},
    				{ headerName: 'Hash', field: 'hash', sortable: true, filter: true, width: 100 },
    				{ headerName: 'Tokens', field: 'n_tokens', sortable: true, filter: 'agNumberColumnFilter', width: 80 },
    				{ headerName: 'Dataset', field: 'meta.pile_set_name', sortable: true, filter: true, width: 150 },
    			];
    
    			// Grid options
    			const promptGrid_options = {
    				columnDefs: columnDefs,
    				rowData: Object.values(this.prompts.all),
    				pagination: true,
    				enableCellTextSelection: true,
    				paginationPageSize: 20,
    				paginationPageSizeSelector: [5, 10, 20, 50, 100, 500],
    				selection: {
    					headerCheckbox: true,
    					selectAll: 'filtered',
    					checkboxes: true,
    					mode: 'multiRow',
    					enableClickSelection: true,
    				},
    
    				defaultColDef: {
    					sortable: true,
    					filter: true,
    					resizable: true,
    					floatingFilter: true
    				},
    				onSelectionChanged: this.onSelectionChanged.bind(this),
    				onFirstDataRendered: this.onFirstDataRendered.bind(this),
    				onGridReady: (params) => {
    					this.prompts.grid.api = params.api;
    					this.isGridReady = true;
    					this.selectPromptsFromURL();
    				},
    			};
    
    			const promptGrid_div = document.querySelector('#promptGrid');
    			this.prompts.grid.api = agGrid.createGrid(promptGrid_div, promptGrid_options);
    		},
    
    		// ########  ####  ######  ########  ##          ###    ##    ##
    		// ##     ##  ##  ##    ## ##     ## ##         ## ##    ##  ##
    		// ##     ##  ##  ##       ##     ## ##        ##   ##    ####
    		// ##     ##  ##   ######  ########  ##       ##     ##    ##
    		// ##     ##  ##        ## ##        ##       #########    ##
    		// ##     ##  ##  ##    ## ##        ##       ##     ##    ##
    		// ########  ####  ######  ##        ######## ##     ##    ##
    
    		// Display images based on selected criteria
    		async displayImages() {
    			this.loading = true;
    			this.images.requested = true;
    			this.images.visible = [];
    
    			// Calculate total images based on parsed head selections
    			let totalImages = 0;
    			for (const model of this.filters.selected.models) {
    				totalImages += this.getHeadSelectionCount(model) * this.prompts.selected.length * this.filters.selected.functions.length;
    			}
    			this.images.expected = totalImages;
    
    			// Load images based on parsed head selections
    			for (const model of this.filters.selected.models) {
    				const config = this.models.configs[model];
    				const rawString = this.head_selections_str[model] || 'L*H*';
    				const parsedHeads = this.parseHeadString(rawString, config.n_layers, config.n_heads);
    				if (!parsedHeads) {
    					console.warn(`Invalid head selection for ${model}: "${rawString}"`);
    					continue;
    				}
    
    				// Iterate over all layers and heads
    				for (let layer = 0; layer < config.n_layers; layer++) {
    					for (let head = 0; head < config.n_heads; head++) {
    						if (!parsedHeads[layer][head]) {
    							continue;
    						}
    						// Now for each selected prompt and function:
    						for (const promptHash of this.prompts.selected) {
    							for (
    								const func_name of
    								this.filters.selected.functions
    							) {
    								let func = this.filters.available.functions[func_name];
    								if (!func) {
    									console.warn(`Function not found ${func_name}`, typeof func_name, JSON.stringify(func_name), func_name, this.filters.available.functions);
    								}
    								const basePath = `${CONFIG.data.basePath}/${model}/prompts/${promptHash}/L${layer}/H${head}`;
    
    								// get the figure format from metadata
    								let figure_format = func.figure_save_fmt;
    								if (!figure_format) {
    									// as a fallback, look for all valid formats
    									figure_format = await fileOps.figureExists(`${basePath}/${func_name}`);
    									console.log('could not find figure format for func name', func_name, 'found', figure_format);
    								}
    
    								if (figure_format) {
    									// Create figure entry
    									const figure_meta = {
    										name: `${model} - Prompt ${promptHash} - L${layer}H${head} - ${func_name}`,
    										model: model,
    										promptHash: promptHash,
    										layer: layer,
    										head: head,
    										function: func_name,
    										figure_format: figure_format,
    									};
    
    									if (figure_format === 'svgz') {
    										const svgText = await fileOps.fetchAndDecompressSvgz(`${basePath}/${func_name}.svgz`);
    										if (svgText) {
    											this.images.visible.push({
    												content: svgText,
    												...figure_meta,
    											});
    										}
    									} else {
    										const imglink = `<img src="${basePath}/${func_name}.${figure_format}" alt="${figure_meta.name}">`;
    										this.images.visible.push({
    											content: imglink,
    											...figure_meta,
    										});
    									}
    								}
    							}
    						}
    					}
    				}
    			}
    
    			this.images.upToDate = true;
    			this.loading = false;
    		},
    		openMetadata(func) {
    			const newWindow = window.open('', '_blank');
    			let content = `<div style="font-family: sans-serif; line-height:1.4;">`;
    			if (func.doc) {
    				content += `<p><strong>Description:</strong> ${func.doc}</p>`;
    			}
    			if (func.figure_save_fmt) {
    				content += `<p><strong>Format:</strong> ${func.figure_save_fmt}</p>`;
    			}
    			if (func.source) {
    				content += `<p><strong>Source:</strong> ${func.source}</p>`;
    			}
    			content += `</div>`;
    			newWindow.document.write(content);
    			newWindow.document.close();
    			newWindow.document.title = `Metadata for ${func.name}`;
    		},
    
    		regenerateColors() {
    			if (!this.visualization.colorBy) return;
    
    			// Get unique values for the selected property
    			const uniqueValues = [...new Set(this.images.visible.map(img => img[this.visualization.colorBy]))];
    
    			// Generate new random colors
    			this.visualization.colorMap = {};
    			uniqueValues.forEach(value => {
    				this.visualization.colorMap[value] = colorUtils.getRandomColor();
    			});
    		},
    
    
    		getBorderColor(image) {
    			if (!this.visualization.colorBy || !image) return 'transparent';
    			const value = image[this.visualization.colorBy];
    			return this.visualization.colorMap[value] || 'transparent';
    		},
    	},
    
    
    
    	//  ######   #######  ##     ## ########  ##     ## ######## ######## ########
    	// ##    ## ##     ## ###   ### ##     ## ##     ##    ##    ##       ##     ##
    	// ##       ##     ## #### #### ##     ## ##     ##    ##    ##       ##     ##
    	// ##       ##     ## ## ### ## ########  ##     ##    ##    ######   ##     ##
    	// ##       ##     ## ##     ## ##        ##     ##    ##    ##       ##     ##
    	// ##    ## ##     ## ##     ## ##        ##     ##    ##    ##       ##     ##
    	//  ######   #######  ##     ## ##         #######     ##    ######## ########
    
    	computed: {
    		uniqueDatasets() {
    			return [
    				...new Set(
    					Object.values(this.prompts.all).map(prompt => prompt.meta.pile_set_name).filter(Boolean)
    				)
    			];
    		},
    		head_selections_arr() {
    			// model -> boolean[][] mapping for efficient lookup
    			let parsed = {};
    
    			for (const model in this.head_selections_str) {
    				const config = this.models.configs[model];
    				if (!config) {
    					console.warn(`No config found for model: ${model}`);
    					parsed[model] = null;
    					continue;
    				}
    
    				const parsedHeads = this.parseHeadString(
    					this.head_selections_str[model] || 'L*H*',
    					config.n_layers,
    					config.n_heads
    				);
    
    				if (!parsedHeads) {
    					console.warn(
    						`Invalid head selection for ${model}: "${this.head_selections_str[model]}"`
    					);
    				}
    
    				parsed[model] = parsedHeads;
    			}
    
    			return parsed;
    		},
    		sortedImages() {
    			if (!this.visualization.sortBy) return this.images.visible;
    
    			return [...this.images.visible].sort((a, b) => {
    				const valueA = a[this.visualization.sortBy];
    				const valueB = b[this.visualization.sortBy];
    
    				// Handle numeric values for layer and head
    				if (['layer', 'head'].includes(this.visualization.sortBy)) {
    					const numA = Number(valueA);
    					const numB = Number(valueB);
    					return this.visualization.sortOrder === 'asc'
    						? numA - numB
    						: numB - numA;
    				}
    
    				// Handle string values
    				const comparison = String(valueA).localeCompare(String(valueB));
    				return this.visualization.sortOrder === 'asc' ? comparison : -comparison;
    			});
    		},
    	},
    
    
    	// ##      ##    ###    ########  ######  ##     ##
    	// ##  ##  ##   ## ##      ##    ##    ## ##     ##
    	// ##  ##  ##  ##   ##     ##    ##       ##     ##
    	// ##  ##  ## ##     ##    ##    ##       #########
    	// ##  ##  ## #########    ##    ##       ##     ##
    	// ##  ##  ## ##     ##    ##    ##    ## ##     ##
    	//  ###  ###  ##     ##    ##     ######  ##     ##
    
    	// Watch for changes in selected models to load prompts and update layers and heads
    	watch: {
    		'filters.selected': {
    			deep: true,
    			handler() {
    				this.images.upToDate = false;
    				this.updateURL();
    			}
    		},
    		'prompts.selected': {
    			handler() {
    				this.images.upToDate = false;
    			}
    		},
    		'head_selections_str': {
    			deep: true,
    			handler(newValue) {
    				Object.keys(newValue).forEach(model => {
    					if (!this.models.configs[model]) {
    						console.warn(`Attempting to update head selections for unknown model: ${model}`);
    						return;
    					}
    				});
    				this.images.upToDate = false;
    				this.updateURL();
    				this.refreshHeadGrids();
    			}
    		},
    		'filters.selected.models': {
    			deep: true,
    			handler(newModels) {
    				// Initialize head selections for new models
    				newModels.forEach(model => {
    					if (!this.head_selections_str[model]) {
    						this.head_selections_str[model] = 'L*H*';
    					}
    				});
    				this.updateURL();
    			}
    		},
    		'visualization.colorBy': {
    			handler(newValue) {
    				if (newValue) {
    					this.regenerateColors();
    				}
    			}
    		},
    	},
    
    	// Lifecycle hook when component is mounted
    	async mounted() {
    		console.log('Mounting app:', this);
    
    		// Apply config values to data (config is already initialized by main script)
    		this.images.perRow = CONFIG.ui.imagesPerRow;
    		this.isDarkMode = CONFIG.ui.darkModeDefault;
    
    		const savedDarkMode = localStorage.getItem('darkMode');
    		if (savedDarkMode !== null) {
    			this.isDarkMode = savedDarkMode === 'true';
    		}
    		if (this.isDarkMode) {
    			document.documentElement.classList.add('dark-mode');
    		}
    		this.readURL(); // Read filters from URL first
    		await this.loadData(); // Load models, prompts, and functions
    		this.setupModelTable(); // Initialize the model grid
    		this.setupPromptTable(); // Initialize the prompts grid
    		console.log('Mounted app:', this);
    	}
    });
    
    </script>
    <!-- end 'app.js' -->
    <!-- main script -->
    <script>
        // Mount the Vue app to the DOM element with id="app"
        window.addEventListener('DOMContentLoaded', async () => {
            // Initialize config first
            await initConfig();

            // Mount the app
            app.mount('#app');
        });
    </script>
</head>

<body>
    <!-- Root element for Vue app -->
    <div id="app" class="container" :class="{ 'dark-mode': isDarkMode }">
        <div class="header-container">
            <h1 class="header-title">Attention Pattern Analysis</h1>
            <a href="https://github.com/mivanit/pattern-lens/">built with pattern-lens v0.5.0 </a>
            <div class="header-controls">
                <button class="btn btn-header dark-mode-button" @click="toggleDarkMode">
                    <span>Dark Mode</span>
                    <div class="dark-mode-toggle">
                        <div class="dark-mode-icon" style="left: 4px">☀️</div>
                        <div class="dark-mode-icon" style="right: 4px">🌙</div>
                    </div>
                </button>
                <button class="btn btn-header" @click="clearAllSelections"> 🗑️ Clear All Selections </button>
            </div>
        </div>
        <div class="main-selection-content">
            <!-- Top section with functions and models side by side -->
            <div class="top-filters">
                <!-- Functions Filter -->
                <div class="functions-filter">
                    <div class="filter-label">
                        <input type="checkbox" id="select-all-functions" :indeterminate.prop="isIndeterminate('functions')" :checked="isChecked('functions')" @change="toggleSelectAll('functions', $event)">
                        <label for="select-all-functions">Functions:</label>
                        <span class="counter"> {{ filters.selected.functions.length }} / {{ Object.keys(filters.available.functions).length }} </span>
                    </div>
                    <div class="checkbox-list">
                        <div v-for="(func, name) in filters.available.functions" :key="name" class="checkbox-item">
                            <input type="checkbox" :id="'func-' + name" :value="name" v-model="filters.selected.functions">
                            <label :for="'func-' + name">
                                <span class="function-name">{{ name }}</span>
                                <span class="function-info">ℹ️ <div class="function-tooltip">
                                        <div v-if="func.figure_save_fmt"><strong>Format:</strong> {{ func.figure_save_fmt }}</div>
                                        <div v-if="func.source"><strong>Source:</strong> {{ func.source }}</div>
                                        <div v-if="func.doc"> {{ func.doc }} </div>
                                    </div>
                                </span>
                            </label>
                        </div>
                    </div>
                </div>
                <!-- Model Selection -->
                <div id="modelGrid" class="ag-theme-alpine" style="height: 300px; width: 100%;"></div>
            </div>
            <!-- Prompts Table (full width) -->
            <div class="prompt-table">
                <div class="prompts-info">
                    <div class="prompt-counter"> Selected Prompts: {{ prompts.selected.length }} / {{ Object.keys(prompts.all).length }} </div>
                    <div class="dataset-list-container">
                        <div class="dataset-list"> Hover here to see unique datasets <div class="dataset-list-content">
                                <ul>
                                    <li v-for="dataset in uniqueDatasets" :key="dataset">{{ dataset }}</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="promptGrid" class="ag-theme-alpine"></div>
            </div>
        </div>
        <!-- image display button and size controls -->
        <div class="image-controls-container">
            <div class="visualization-controls">
                <div class="color-controls">
                    <label for="colorBy">Color borders by:</label>
                    <select id="colorBy" v-model="visualization.colorBy">
                        <option value="">None</option>
                        <option value="model">Model</option>
                        <option value="function">Function</option>
                        <option value="layer">Layer</option>
                        <option value="head">Head</option>
                        <option value="promptHash">Prompt</option>
                    </select>
                    <button class="btn btn-secondary" @click="regenerateColors" :disabled="!visualization.colorBy" title="Generate new random colors"> 🔄 Regenerate Colors </button>
                </div>
                <div class="sort-controls">
                    <label for="sortBy">Sort by:</label>
                    <select id="sortBy" v-model="visualization.sortBy">
                        <option value="">Default Order</option>
                        <option value="model">Model</option>
                        <option value="function">Function</option>
                        <option value="layer">Layer</option>
                        <option value="head">Head</option>
                        <option value="promptHash">Prompt</option>
                    </select>
                    <select v-model="visualization.sortOrder">
                        <option value="asc">Ascending</option>
                        <option value="desc">Descending</option>
                    </select>
                </div>
            </div>
            <div class="image-controls">
                <div class="image-controls-display">
                    <button class="btn" :class="{ 'btn-primary': !images.upToDate, 'btn-secondary': images.upToDate }" @click="displayImages"> {{ images.upToDate ? 'Images Up to Date' : 'Display Images' }} </button>
                    <div class="progress-wrapper">
                        <span class="progress-status" v-if="images.expected > 0"> {{ images.visible.length || 'N/A' }} / {{ images.expected }} images</span>
                        <div class="progress-bar" v-if="loading || images.visible.length > 0">
                            <div class="progress-bar-fill" :class="{ 'loading': loading, 'complete': !loading }" :style="{ width: `${(images.visible.length / images.expected) * 100}%` }">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="image-controls-size" v-if="images.visible.length > 0">
                    <label for="resizeSlider">Images per row:</label>
                    <input type="range" id="resizeSlider" class="resize-slider" v-model.number="images.perRow" min="1" max="16" step="1">
                    <input type="number" class="resize-input" v-model.number="images.perRow" min="1" max="64">
                </div>
            </div>
        </div>
        <!-- images are loading -->
        <div v-if="loading" class="loading">Loading...</div>
        <!-- actual images display -->
        <!-- actual images display -->
        <div v-else-if="images.visible.length > 0" class="images" :style="{ 'grid-template-columns': `repeat(${images.perRow}, 1fr)` }">
            <div v-for="image in sortedImages" class="image-container" :style="{ borderColor: getBorderColor(image) }">
                <p v-if="images.perRow <= 4" class="image-info">
                    <a :href="getSinglePropertyFilterUrl('models', image.model)">{{ image.model }}</a> - <a :href="getSinglePropertyFilterUrl('functions', image.function)">{{ image.function }}</a> - <a :href="getSinglePropertyFilterUrl('layers', image.layer)">L{{ image.layer }}</a> - <a :href="getSinglePropertyFilterUrl('heads', image.head)">H{{ image.head }}</a> - <a :href="getSinglePropertyFilterUrl('prompts', image.promptHash)">{{ image.promptHash }}</a>
                </p>
                <a href="#" @click.prevent="openSingleView(image.promptHash, image.model, image.layer, image.head)" class="img-container" v-html="image.content" :title="images.perRow > 4 ? image.name : ''" style="cursor: pointer;">
                </a>
            </div>
        </div>
        <!-- no images found -->
        <div v-else-if="images.requested" class="error">No images found for the selected criteria.</div>
    </div>
</body>

</html>