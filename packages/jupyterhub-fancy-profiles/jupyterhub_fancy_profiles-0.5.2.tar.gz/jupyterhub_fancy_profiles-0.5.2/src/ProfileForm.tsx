import {
  ChangeEventHandler,
  MouseEventHandler,
  useContext,
  useEffect,
  useState,
} from "react";
import "../node_modules/xterm/css/xterm.css";

import "./form.css";
import { SpawnerFormContext } from "./state";
import { ProfileOptions } from "./ProfileOptions";
import useFormCache from "./hooks/useFormCache";
import { PermalinkContext } from "./context/Permalink";
import Permalink from "./components/Permalink";

/**
 * Generates the *contents* of the form shown in the profile selection page
 *
 * A <form> tag is generated by JupyterHub, and we don't have control over it. A <submit>
 * is also generated, but we hide it with CSS and use our own so we have better control over
 * validation.
 */
function Form() {
  const {
    profile: selectedProfile,
    setProfile,
    profileList
  } = useContext(SpawnerFormContext);
  const { permalinkValues, setPermalinkValue, permalinkParseError } = useContext(PermalinkContext);
  const [profileError, setProfileError] = useState("");
  const [formErrors, setFormErrors] = useState<Element[]>([]);
  const { cacheChoiceOption, cacheRepositorySelection } = useFormCache();

  const handleSubmit: MouseEventHandler<HTMLButtonElement> = (e) => {
    setProfileError("");
    setFormErrors([]);
    const form = (e.target as HTMLElement).closest("form");

    // validate the form
    const formIsValid = form.checkValidity();

    // prevent form submit
    if (!formIsValid) {
      setTimeout(() => {
        // Timeout here so we can collect the errors after the errors are rendered on the page
        const errors = form.getElementsByClassName("invalid-feedback");
        setFormErrors(Array.from(errors));
      }, 10);

      setTimeout(() => {
        // Need to wait for the error summary to render
        window.scrollTo(0, document.body.scrollHeight);
      }, 100);

      setProfileError(!selectedProfile ? "Select a container profile" : "");
      e.preventDefault();
      return;
    }

    // Cache active unlisted-choice values
    const cacheUnlistedChoices = form.getElementsByClassName("cache-unlisted-choice");
    Array.from(cacheUnlistedChoices).forEach((el) => {
      const { id, value } = el as HTMLInputElement;
      cacheChoiceOption(id, value);
    });

    // Cache active repository/ref values
    const cacheRepositories = form.getElementsByClassName("cache-repository");
    Array.from(cacheRepositories).forEach((el) => {
      const { id, value } = el as HTMLInputElement;
      if (id.endsWith("--repo")) {
        const fieldName = id.slice(0, -6);
        const refField = document.getElementById(`${fieldName}--ref`);
        cacheRepositorySelection(fieldName, value, (refField as HTMLInputElement).value);
      }
    });
  };

  const handleProfileSelect: ChangeEventHandler<HTMLInputElement> = (e) => {
    const slug = e.target.value;
    setProfile(slug);
    setPermalinkValue("profile", slug);
    setProfileError("");
  };

  useEffect(() => {
    // scroll the selected profile into view
    if (permalinkValues.profile) {
      const targetElement = document.getElementById(`profile-${permalinkValues.profile}`);
      const observer = new IntersectionObserver((e) => {
        if (e.length > 0 && !e[0].isIntersecting) {
          // scroll the element into if not fully visible
          targetElement.scrollIntoView();
        }
        // Disconnecting the oberserver, we only want to scroll once
        observer.disconnect();
      }, {
        root: null,
        rootMargin: "0px",
        threshold: 1, // we want the element to be fully visible
      });
      observer.observe(targetElement);
    }
  }, [permalinkValues.profile]);

  return (
    <fieldset
      aria-label="Select profile"
      aria-description="First, select the profile; second, configure the options for the selected profile."
    >
      {permalinkParseError && <div className="alert alert-warning">Unable to parse permalink configuration.</div>}
      <input
        type="radio"
        className="hidden"
        name="profile"
        value={selectedProfile?.slug}
        checked
        readOnly
      />
      {profileList.map((profile) => {
        const { display_name, description, profile_options, slug } = profile;

        return (
          <div
            id={`profile-${slug}`}
            key={slug}
            className={`profile-select ${
              selectedProfile?.slug === slug ? "selected-profile" : ""
            }`}
            onClick={() => {
              setProfile(slug);
              setPermalinkValue("profile", slug);
            }}
          >
            {profileList.length > 1 && (
              <input
                type="radio"
                name="select-profile"
                id={`profile-option-${slug}`}
                value={slug}
                onChange={handleProfileSelect}
                required
                checked={selectedProfile?.slug === slug}
                aria-labelledby={`profile-option-${slug}-label`}
              />
            )}
            <div className="profile-select-body">
              <div className="d-flex align-items-start">
                <div
                  id={`profile-option-${slug}-label`}
                  className="profile-select-label flex-grow-1"
                >
                  <h2>{display_name}</h2>
                  <p>{description}</p>
                </div>
                {selectedProfile?.slug === slug && <Permalink />}
              </div>

              {profile_options && (
                <ProfileOptions profile={slug} config={profile_options} />
              )}
            </div>
          </div>
        );
      })}

      {(formErrors.length > 0 || profileError) && (
        <div
          className={`form-errors ${formErrors.length > 0 || profileError ? "d-block" : "d-none"}`}
        >
          <p><b>Unable to start the server. The form is incomplete.</b></p>
          <ul>
            {profileError && <li>{profileError}</li>}
            {formErrors.map(err => (
              <li>
                <a
                  href="#"
                  onClick={(e) => {
                    e.preventDefault();
                    err.parentElement.scrollIntoView();
                  }}
                >
                  {err.textContent}
                </a>
              </li>
            ))}
          </ul>
        </div>
      )}

      <button
        className="btn btn-jupyter form-control"
        type="submit"
        onClick={handleSubmit}
      >
        Start
      </button>
    </fieldset>
  );
}

export default Form;
